{
 "0": [
  "s = input()\n\nopening_bracket_pos = s.find('[')\nclosing_bracket_pos = s.rfind(']')\n\nif opening_bracket_pos == -1 or closing_bracket_pos == -1 or opening_bracket_pos >= closing_bracket_pos:\n    print(-1)\n    exit()\n\ns = s[opening_bracket_pos+1:closing_bracket_pos]\n\nfirst_colon_pos = s.find(':')\nlast_colon_pos = s.rfind(':')\n\nif first_colon_pos == -1 or last_colon_pos == -1 or first_colon_pos >= last_colon_pos:\n    print(-1)\n    exit()\n\ninner_str = s[first_colon_pos+1:last_colon_pos]\n\nmax_len = len(inner_str.split('|'))\n\nprint(max_len+4)"
 ],
 "1": [
  "x = input()\ns = sum(int(i) for i in x) #calculate the sum of digits of integer x\nfor i in range(int(x)-1, 0, -1): #loop through all positive integers less than x in descending order\n    if sum(int(j) for j in str(i)) > s: #if sum of digits is greater than sum of x, print the number and break\n        print(i)\n        break\nelse: #if no such number is found, print x\n    print(x)"
 ],
 "2": [
  "n = input()\nlucky = False\nwhile not lucky:\n    n = str(int(n) + 1)\n    if len(set(n)) <= 2:\n        lucky = True\nprint(int(n) - int(n[0]) - 1)"
 ],
 "3": [
  "n, q = map(int, input().split())\npainters = []\nfor i in range(q):\n    painters.append(tuple(map(int, input().split())))\n    \nmax_painted = 0\nfor i in range(q):\n    for j in range(i+1, q):\n        painted = [0] * n\n        for k in range(i, j+1):\n            for x in range(painters[k][0]-1, painters[k][1]):\n                painted[x] = 1\n        max_painted = max(max_painted, sum(painted))\n        \nprint(max_painted)"
 ],
 "4": [
  "x = int(input())\nhh, mm = map(int, input().split())\n\ncount = 0\nwhile True:\n    if '7' in str(hh) or '7' in str(mm):\n        break\n    mm -= x\n    if mm < 0:\n        mm += 60\n        hh -= 1\n    if hh < 0:\n        hh += 24\n    count += 1\n\nprint(count)"
 ],
 "5": [
  "n, pos, l, r = map(int, input().split())\n\nif l == 1 and r == n:\n    print(0)\nelif l == 1:\n    print(abs(pos - r) + 1)\nelif r == n:\n    print(abs(l - pos) + 1)\nelse:\n    print(min(abs(pos-l), abs(pos-r)) + r-l + 2)"
 ],
 "6": [
  "for _ in range(int(input())):\n    n,x=map(int,input().split())\n    arr=[]\n    for i in range(n):\n        arr.append(list(map(int,input().split())))\n    arr.sort()\n    ans=0\n    flag=1\n    for i in arr:\n        while x-i[0]>=0:\n            ans+=1\n            x-=i[0]\n            x+=i[1]\n            if x<=0:\n                flag=0\n                break\n        if flag==0:\n            break\n    if flag==0:\n        print(ans)\n    elif x>0:\n        cnt=(x+(arr[0][0]-1))//arr[0][0]\n        x-=cnt*arr[0][0]\n        ans+=cnt\n        x+=arr[0][1]\n        if x>0:\n            print(-1)\n        else:\n            print(ans)\n    else:\n        print(ans)"
 ],
 "7": [
  "n, m = map(int, input().split())\nleft = 1\nright = int(2e9)\nwhile left < right:\n    mid = (left + right)//2\n    if n < mid*(mid+1)//2*m:\n        right = mid\n    else:\n        left = mid + 1\nprint(left)"
 ],
 "8": [
  "from collections import defaultdict\n\ntiles = input().split()\n\nsuit_dict = defaultdict(int)\nfor tile in tiles:\n    num = tile[0]\n    suit = tile[1]\n    suit_dict[suit] += 1\n    if suit_dict[suit] >= 2:\n        if suit_dict[suit] == 2:\n            pair_suit = suit\n        elif suit_dict[suit] == 3:\n            print(0)\n            exit()\n\nfor suit in ['m', 'p', 's']:\n    suit_tiles = [tile for tile in tiles if tile[1] == suit]\n    for i in range(1, 8):\n        if str(i) + suit not in suit_tiles:\n            if str(i + 1) + suit in suit_tiles and str(i + 2) + suit in suit_tiles:\n                print(0)\n                exit()\n\nfor suit in ['m', 'p', 's']:\n    if suit_dict[suit] == 1:\n        suit_tiles = [tile for tile in tiles if tile[1] == suit]\n        for i in range(1, 10):\n            if str(i) + suit not in tiles:\n                if (i == 1 and str(i + 1) + suit in tiles and str(i + 2) + suit in tiles) or \\\n                        (i == 2 and '1' + suit in tiles and str(i + 1) + suit in tiles and str(i + 2) + suit in tiles) or \\\n                        (i >= 3 and str(i - 2) + suit in tiles and str(i - 1) + suit in tiles and str(i + 1) + suit in tiles):\n                    print(1)\n                    exit()\n\nprint(2)"
 ],
 "9": [
  "d = int(input())\nn, m = map(int, input().split())\nsofas = []\nfor i in range(d):\n    x1, y1, x2, y2 = map(int, input().split())\n    x1 -= 1\n    y1 -= 1\n    x2 -= 1\n    y2 -= 1\n    if x1 == x2:\n        if y1 > y2:\n            y1, y2 = y2, y1\n        sofas.append((i, 'h', x1, y1, y2))\n    else:\n        if x1 > x2:\n            x1, x2 = x2, x1\n        sofas.append((i, 'v', y1, x1, x2))\n\ncntl, cntr, cntt, cntb = map(int, input().split()))\n\npossible_sofas = set(range(d))\n\nfor sofa in sofas:\n    if sofa[1] == 'h':\n        if sofa[2] == 0:\n            cntl -= 1\n        if sofa[2] == n-1:\n            cntr -= 1\n    else:\n        if sofa[2] == 0:\n            cntt -= 1\n        if sofa[2] == m-1:\n            cntb -= 1\n\n    if sofa[1] == 'h':\n        if cntl < 0 or cntr < 0:\n            possible_sofas.discard(sofa[0])\n            continue\n        cnt = 0\n        for i in sofas:\n            if i[1] == 'v' and i[2] <= sofa[3] and i[4] >= sofa[4]:\n                cnt += 1\n        if cnt != cntt + cntb:\n            possible_sofas.discard(sofa[0])\n            continue\n    else:\n        if cntt < 0 or cntb < 0:\n            possible_sofas.discard(sofa[0])\n            continue\n        cnt = 0\n        for i in sofas:\n            if i[1] == 'h' and i[2] <= sofa[3] and i[4] >= sofa[3]:\n                cnt += 1\n        if cnt != cntl + cntr:\n            possible_sofas.discard(sofa[0])\n\nif len(possible_sofas) == 0:\n    print('-1')\nelse:\n    print(possible_sofas.pop()+1)"
 ],
 "10": [
  "n = int(input())\nmin_days_off = n // 7 * 2\nmax_days_off = min_days_off\nif n % 7 == 6:\n    min_days_off += 1\nif n % 7 >= 1:\n    max_days_off += min(n % 7, 2)\nif n % 7 >= 6:\n    max_days_off += 1\nprint(min_days_off, max_days_off)"
 ],
 "11": [
  "n, a, b, p, q = map(int, input().split())\nlcm = a * b // math.gcd(a, b)\nans = p * (n // a - n // lcm) + q * (n // b - n // lcm)\nprint(ans)"
 ],
 "12": [
  "n = int(input())\ntrophies = input().strip()\nmax_length = trophies.count('G')\ncurr_length = 0\nfor i in range(n):\n    if trophies[i] == 'S':\n        j = i+1\n        while j < n and trophies[j] == 'S':\n            j += 1\n        if j == n:\n            break\n        curr_length = j - i - 1\n        if i > 0 and trophies[i-1] == 'G':\n            curr_length += 1\n        if j < n-1 and trophies[j+1] == 'G':\n            curr_length += 1\n        max_length = max(max_length, curr_length)\nprint(min(max_length+1, trophies.count('G')+1))"
 ],
 "13": [
  "from collections import deque\n\nn, k = map(int, input().split())\nk_main_courses = set(map(int, input().split()))\n\npre_courses = {i+1: [] for i in range(n)}\ndependants = [0]*n\nfor i in range(n):\n    pre_courses_list = list(map(int, input().split()))[1:]\n    dependants[i] = len(pre_courses_list)\n    if dependants[i] == 0:\n        pre_courses[i+1] = set()\n    else:\n        pre_courses[i+1] = set(pre_courses_list)\n\nq = deque()\nfor i in range(1, n+1):\n    if dependants[i-1] == 0:\n        q.append(i)\n\norder_of_completion = []\nwhile q:\n    curr_course = q.popleft()\n    order_of_completion.append(curr_course)\n    for course in pre_courses[curr_course]:\n        dependants[course-1] -= 1\n        if dependants[course-1] == 0:\n            q.append(course)\n\nif len(order_of_completion) < n:\n    print(-1)\nelse:\n    needed_main_courses = sorted(list(k_main_courses))\n    completed_main_courses = [course for course in order_of_completion \n                              if course in k_main_courses]\n    if completed_main_courses != needed_main_courses:\n        print(-1)\n    else:\n        print(len(order_of_completion))\n        print(*order_of_completion)"
 ],
 "14": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\ns = []\nmax_val = k\nans = []\nfor x in a:\n    while s and s[-1] == max_val:\n        max_val -= 1\n        ans.append(s.pop())\n    if x == max_val + 1:\n        max_val += 1\n    else:\n        s.append(x)\nwhile s:\n    ans.append(s.pop())\nif len(ans) != n:\n    print(-1)\nelse:\n    print(\" \".join(map(str, ans)))"
 ],
 "15": [
  "a, b, c = map(int, input().split())\nif c == 0:\n    print(\"YES\" if a == b else \"NO\")\nelse:\n    if ((b-a)/c >= 0) and ((b-a)%c==0):\n        print(\"YES\")\n    else:\n        print(\"NO\")"
 ],
 "16": [
  "cnt1 = int(input())\ncnt2 = int(input())\ncnt3 = int(input())\ncnt4 = int(input())\n\nif cnt3 == 0:\n    if cnt1 == cnt4:\n        print(1)\n    else:\n        print(0)\nelse:\n    if cnt1 == cnt4:\n        if cnt3 == 1:\n            print(1)\n        else:\n            print(0)\n    elif cnt1 - cnt4 == 1:\n        if cnt3 <= cnt1:\n            print(1)\n        else:\n            print(0)\n    elif cnt1 - cnt4 == -1:\n        if cnt3 <= cnt4:\n            print(1)\n        else:\n            print(0)\n    else:\n        print(0)"
 ],
 "17": [
  "n, k, t = map(int, input().split())\nif t <= k:\n  print(t)\nelif t <= n:\n  print(k)\nelse:\n  print(k - (t - n))"
 ],
 "18": [
  "s = input()\nt = ''\nu = ''\n\nwhile s:\n    if s[0] <= u[-1:]:\n        u += s[0]\n    else:\n        t += s[0]\n    s = s[1:]\n    if not s:\n        break\n  \n    if s[-1] <= u[-1:]:\n        u += s[-1]\n    else:\n        t = s[-1] + t\n    s = s[:-1]\n    \nprint(u)"
 ],
 "19": [
  "t = int(input())\n\nfor i in range(t):\n    n = int(input())\n    plays = 0\n    clears = 0\n    valid = True\n    for j in range(n):\n        p, c = map(int, input().split())\n        if p < plays or c < clears or c > p or c - clears > p - plays:\n            valid = False\n        plays, clears = p, c\n    print(\"YES\" if valid else \"NO\")"
 ],
 "20": [
  "time = input()\n\nwhile(True):\n    time = time.split(\":\")\n    hh = int(time[0])\n    mm = int(time[1])\n    mm += 1\n    if(mm == 60):\n        mm = 0\n        hh += 1\n    if(hh == 24):\n        hh = 0\n    time = str(hh).zfill(2) + \":\" + str(mm).zfill(2)\n    if(time == time[::-1]):\n        print(int(str(hh).zfill(2)+str(mm).zfill(2)) - int(str(time.split(\":\")[0]).zfill(2)+str(time.split(\":\")[1]).zfill(2)))\n        break"
 ],
 "21": [
  "n=int(input())\na=list(map(int,input().split()))\nmax_pos=a.index(max(a))\nmin_pos=a.index(min(a))\ndist=max(max_pos,min_pos)-min(max_pos,min_pos)\nif dist==n-1 and not(max_pos==n-1 or min_pos==0):\n    dist+=1\nelif dist==n-2 and ((max_pos==0 and min_pos==n-1) or (max_pos==n-1 and min_pos==0)):\n    dist+=1\nprint(dist)"
 ],
 "22": [
  "s = input()\nn = len(s)\nif n%2 == 0:\n    s1 = s[:n//2]\n    s2 = s[n//2:]\nelse:\n    s1 = s[:n//2]\n    s2 = s[n//2+1:]\nif s1 == s2[::-1]:\n    print(\"TAK\")\nelse:\n    print(\"NIE\")"
 ],
 "23": [
  "a = input().strip()\nb = input().strip()\na = sorted(a, reverse=True)\n\nfor i in range(len(a)):\n    if a[i] == '0':\n        continue\n    if a[i] <= b[0]:\n        j = 1\n        while j < len(b) and a[i] >= b[j]:\n            j += 1\n        if j == len(b) or a[i] < b[j]:\n            res = a[i]\n            b = b[:j] + res + ''.join(sorted(b[j:]+a[i+1:],reverse=True))\n            break\nprint(b)"
 ],
 "24": [
  "matrix = []\nfor i in range(10):\n    row = input()\n    matrix.append(row)\n\nfor i in range(10):\n    for j in range(10):\n        if matrix[i][j] == \".\":\n            if i+4 < 10 and matrix[i+1][j] == \"X\" and matrix[i+2][j] == \"X\" and matrix[i+3][j] == \"X\" and matrix[i+4][j] == \"X\":\n                print(\"YES\")\n                exit(0)\n            if i+4 < 10 and j+4 < 10 and matrix[i+1][j+1] == \"X\" and matrix[i+2][j+2] == \"X\" and matrix[i+3][j+3] == \"X\" and matrix[i+4][j+4] == \"X\":\n                print(\"YES\")\n                exit(0)\n            if j+4 < 10 and matrix[i][j+1] == \"X\" and matrix[i][j+2] == \"X\" and matrix[i][j+3] == \"X\" and matrix[i][j+4] == \"X\":\n                print(\"YES\")\n                exit(0)\n            if i-4 >= 0 and j+4 < 10 and matrix[i-1][j+1] == \"X\" and matrix[i-2][j+2] == \"X\" and matrix[i-3][j+3] == \"X\" and matrix[i-4][j+4] == \"X\":\n                print(\"YES\")\n                exit(0)\n            if i-4 >= 0 and matrix[i-1][j] == \"X\" and matrix[i-2][j] == \"X\" and matrix[i-3][j] == \"X\" and matrix[i-4][j] == \"X\":\n                print(\"YES\")\n                exit(0)\nprint(\"NO\")"
 ],
 "25": [
  "n, k = map(int, input().split())\nif k > n*n//2+n%2 or k < n//2*(n//2+(n+1)%2):\n    print(-1)\nelse:\n    a = [[0]*n for _ in range(n)]\n    for i in range(n//2):\n        j = n//2+i\n        for l in range(k // (n//2-(i+(n+1)%2)//2)):\n            a[i][l+i+(n+1)%2//2] = 1\n            a[j][l+j//2] = 1\n        k -= (n//2-(i+(n+1)%2)//2) * (j-(n+1)%2-i-(n+1)%2//2+1)\n    if k > 0:\n        i = n//2\n        for j in range(n//2, n):\n            if k <= j-(n+1)%2-i-(n+1)%2//2+1 or j == n-1:\n                a[i][j] = a[j][i] = 1\n                k -= 1\n                if k == 0:\n                    break\n    for row in a:\n        print(*row)"
 ],
 "26": [
  "x, y, z = sorted(map(float, input().split()))\n\nif x == y == z:\n    print('x^y^z')\n\nif x <= 1 and y <= 1:\n    if z == 200:\n        print('y^x^z')\n    else:\n        print('z^y^x')\n\nelif x <= 1:\n    print('x^y^z')\n\nelif x <= 1.44269504089 and y <= 2:\n    print('y^x^z')\n\nelif x <= 2 and y <= 3:\n    print('y^x^z')\n\nelif x <= 2.66514414269 and y <= 2.66514414269:\n    print('(y^x)^z')\n\nelse:\n    print('x^y^z')"
 ],
 "27": [
  "n = int(input())\ns = input()\n\nif s.count(s[0]) == n:\n    print(1)\nelif s == s[::-1]:\n    print(n)\nelse:\n    for i in range(1, n):\n        if s[:i] * 2 == s:\n            print(i + 1)\n            break\n    else:\n        print(n)"
 ],
 "28": [
  "n = int(input())\n\ntest_types = {\"0\": [], \"1\": []}\nfor i in range(n):\n    file_name, file_type = input().split()\n    test_types[file_type].append(file_name)\n\nexamples = test_types[\"1\"]\nnum_examples = len(examples)\nregular_tests = test_types[\"0\"]\n\n# set example tests as first tests\nscript = []\nfor i in range(num_examples):\n    script.append(f\"move {examples[i]} {i+1}\")\n\n# set remaining regular tests as n-(num_examples) tests\nif num_examples == 0:\n    test_num = 1\nelse:\n    test_num = num_examples+1\nfor i in range(len(regular_tests)):\n    script.append(f\"move {regular_tests[i]} {test_num}\")\n    test_num += 1\n\nprint(len(script))\nfor line in script:\n    print(line)"
 ],
 "29": [
  "ticket = input()\n\nsum1 = int(ticket[0]) + int(ticket[1]) + int(ticket[2])\nsum2 = int(ticket[3]) + int(ticket[4]) + int(ticket[5])\nresult = 0\n\nif sum1 == sum2:\n    print(0)\nelse:\n    for i in range(3):\n        if sum1 > sum2:\n            if int(ticket[i]) > 1:\n                sum1 -= int(ticket[i]) - 1\n                result += int(ticket[i]) - 1\n        else:\n            if int(ticket[i]) < 9:\n                sum1 += 9 - int(ticket[i])\n                result += 9 - int(ticket[i])\n\n    for i in range(3, 6):\n        if sum2 > sum1:\n            if int(ticket[i]) > 1:\n                sum2 -= int(ticket[i]) - 1\n                result += int(ticket[i]) - 1\n        else:\n            if int(ticket[i]) < 9:\n                sum2 += 9 - int(ticket[i])\n                result += 9 - int(ticket[i])\n\n    print(result)"
 ],
 "30": [
  "m, x = map(int, input().split())\ntraps = 1\nroom = x\nwhile room != 1:\n    traps += 1\n    room = (room * x) % m\nprint(traps)"
 ],
 "31": [
  "n, k = map(int, input().split())\nmod = 10 ** 6 + 3\n\ndef modinv(a, mod):\n    b = mod\n    x = 1\n    y = 0\n    while b:\n        t = a // b\n        a -= t * b\n        x -= t * y\n        a, b = b, a\n        x, y = y, x\n    return (x + mod) % mod\n\ndef solve(n, k, mod):\n    if k > mod:\n        return solve(n, k % mod, mod)\n    if k > (1 << n):\n        return 0\n    num = den = 1\n    for i in range((1 << k) - 1, (1 << n), 1):\n        num = (num * i) % mod\n    for i in range(2, 2 ** k): \n        den = (den * i) % mod\n    for i in range((1 << n) - (1 << k) + 1, (1 << n) + 1, 1):\n        den = (den * i) % mod\n    return (num * modinv(den, mod)) % mod\n\nprint(solve(n, k, mod), 1)"
 ],
 "32": [
  "n = int(input())\npos = 0\nfor i in range(n):\n    t, d = input().split()\n    t = int(t)\n    if pos == 0 and d != \"South\":\n        print(\"NO\")\n        exit()\n    elif pos == 20000 and d != \"North\":\n        print(\"NO\")\n        exit()\n    if d == \"North\":\n        pos -= t\n        if pos < 0:\n            print(\"NO\")\n            exit()\n    elif d == \"South\":\n        pos += t\n        if pos > 20000:\n            print(\"NO\")\n            exit()\nif pos != 0:\n    print(\"NO\")\nelse:\n    print(\"YES\")"
 ],
 "33": [
  "a1, b1, a2, b2, L, R = map(int, input().split())\ngcd = abs(a1 - a2)\n\nif (b2 - b1) % gcd != 0:\n    print(0)\nelse:\n    lc = abs(b2 - b1) // gcd\n    ans = 1 + (R - L) // lc\n    print(ans if b1 % gcd == b2 % gcd else 0)"
 ],
 "34": [
  "n, a, b = map(int, input().split())\n\nlo, hi = 1, min(a, b)\n\nwhile lo < hi:\n    mid = (lo + hi + 1) // 2\n    \n    if (a // mid) + (b // mid) >= n and a // (mid + 1) + b // (mid + 1) < n:\n        lo = mid\n    else:\n        hi = mid - 1\n\nprint(lo)"
 ],
 "35": [
  "n, m = map(int, input().split())\nfield = [input() for _ in range(n)]\n\nprint(\"YES\" if all(field[i][:] == field[0][:] for i in range(n//3)) and all(field[i][:] == field[n//3][:] for i in range(n//3, 2*n//3)) and all(field[i][:] == field[2*n//3][:] for i in range(2*n//3, n)) and field[0][:] != field[n//3][:] != field[2*n//3][:] and field[0][:m//3] != field[0][m//3:2*m//3] != field[0][2*m//3:] else \"NO\")"
 ],
 "36": [
  "n = int(input())\n\nring = int(((-3 + (9 + 12*n)**0.5)/6).real) + 1\nnum_in_ring = 3*ring*(ring-1) + 1\n\nx, y = 0, 0\nif ring > 1:\n    side_len = 2*ring - 1\n    start = num_in_ring - side_len + 1\n    if num_in_ring - n < side_len:\n        x, y = ring-1, n - (num_in_ring - side_len)\n    elif num_in_ring - n < 2*side_len - 1:\n        x, y = ring-1 - (num_in_ring - n - side_len + 1), ring-1\n    elif num_in_ring - n < 3*side_len - 2:\n        x, y = -ring+1, ring-1 - (num_in_ring - side_len*2 + 1 + side_len - n)\n    elif num_in_ring - n < 4*side_len - 2:\n        x, y = -ring+1 + (num_in_ring - n - side_len*3 + 2), -ring+1\n    elif num_in_ring - n < 5*side_len - 3:\n        x, y = n - (num_in_ring - side_len*4 + 2), -ring+1 + (num_in_ring - n - side_len*3 + 2 + side_len - 1)\n    else: # num_in_ring - n >= 5*side_len - 3\n        x, y = ring-1, ring-1 - (num_in_ring - side_len*5 + 3 + side_len - n)\n\nprint(x, y)"
 ],
 "37": [
  "a, b, c = map(int, input().split())\nfor i in range(c//a + 1):\n    if (c-a*i) % b == 0:\n        print(\"Yes\")\n        break\nelse:\n    print(\"No\")"
 ],
 "38": [
  "n, L = map(int, input().split())\nkefa = list(map(int, input().split()))\nsasha = list(map(int, input().split()))\n \nfor i in range(n):\n    if kefa == sasha:\n        print(\"YES\")\n        break\n    sasha = [(x - sasha[1] + L) % L for x in sasha]\n    sasha = sasha[1:] + [sasha[0]]\nelse:\n    print(\"NO\")"
 ],
 "39": [
  "s = input()\nn = len(s)\nans = 0\nfor i in range(n):\n    for j in range(i, n):\n        if s[i:j+1] == s[i:j+1][::-1]:\n            continue\n        ans = max(ans, j-i+1)\nprint(ans)"
 ],
 "40": [
  "n = int(input())\nratings = []\nfor i in range(n):\n    a, b = map(int, input().split())\n    ratings.append((a, b))\n\nif any(a != b for a, b in ratings):  # check if someone's rating has changed\n    print(\"rated\")\nelse:\n    sorted_ratings = sorted(ratings, reverse=True)  # sort the ratings in decreasing order\n    if ratings == sorted_ratings:  # check if the ratings are already in non-increasing order\n        print(\"unrated\")\n    else:\n        print(\"maybe\")"
 ],
 "41": [
  "n = int(input())\na = list(map(int,input().split()))\nz = -1\ndistances = [0] * n\nfor i in range(n):\n    if a[i] == 0:\n        z = i\n    if z == -1:\n        distances[i] = 10**9\n    else:\n        distances[i] = i - z\n    if z != -1 and i > z and distances[z-(i-z)] < i-z:\n            distances[i] = distances[z-(i-z)]\nfor i in range(n-1,-1,-1):\n    if a[i] == 0:\n        z = i\n    if z != -1 and i < z and distances[z+(z-i)] < z-i:\n            distances[i] = distances[z+(z-i)]\nprint(*distances)"
 ],
 "42": [
  "n = int(input())\ns = input().strip()\n\nm = len(s)\ns += '#' * (n-m)\n\nf = [0] * (m+1)\nk = 0\nfor i in range(1,m):\n    while k and s[k] != s[i]:\n        k = f[k-1]\n    if s[k] == s[i]:\n        k += 1\n    f[i] = k\n\ndp = [[0]*2 for i in range(n+1)]\ndp[0][0] = 1\nfor i in range(1, n+1):\n    for j in range(2):\n        for k in range(m, 0, -1):\n            nj = j\n            while nj and s[nj] != '0'+s[k-1]:\n                nj = f[nj-1]\n            if s[nj] == '0'+s[k-1]:\n                nj += 1\n            dp[i][j] += dp[i-1][j^1] * nj\n\nans = dp[n][0] - 1\n\nprint(ans)"
 ],
 "43": [
  "import math\n\nn = int(input())\nvectors = []\nfor i in range(1, n+1):\n    x, y = map(int, input().split())\n    vectors.append((i, x, y))\n\nmin_angle = math.inf\nmin_indices = None\n\nfor i in range(n-1):\n    for j in range(i+1, n):\n        angle = math.acos((vectors[i][1]*vectors[j][1] + vectors[i][2]*vectors[j][2]) / \n                          (math.sqrt(vectors[i][1]**2 + vectors[i][2]**2)*math.sqrt(vectors[j][1]**2 + vectors[j][2]**2)))\n        if angle < min_angle:\n            min_angle = angle\n            min_indices = (vectors[i][0], vectors[j][0])\n\nprint(min_indices[0], min_indices[1])"
 ],
 "44": [
  "d, k, a, b, t = map(int, input().split())\nif k >= d:\n    print(d * a)\nelse:\n    x = (d - k) // k\n    time = x * (k * a + t)\n    rem = d - (k * (x + 1))\n    if rem <= 0:\n        print(time + d * a)\n    else:\n        time += min(t + rem * a, rem * b)\n        print(time)"
 ],
 "45": [
  "n,k = map(int,input().split())\nif n < k or n > k * (k + 1) // 2:\n    print(\"-1\")\nelse:\n    ans = [0] * k\n    m = n // k\n    r = n % k\n    for i in range(k):\n        ans[i] = m * (i + 1)\n        if i + 1 <= r:\n            ans[i] += i + 1\n    print(\" \".join(map(str, ans)))"
 ],
 "46": [
  "n, m = map(int, input().split())\ncount = 0\nfor i in range(0, n+1, 5):\n    count += ((m+i)//5)*2 - ((m+i)%5 == 0)\nprint(count)"
 ],
 "47": [
  "n, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculate the initial beauty of the array without multiplying any subarray\nmax_sum = 0\ncurr_sum = 0\nfor num in a:\n    curr_sum = max(num, curr_sum+num)\n    max_sum = max(max_sum, curr_sum)\n    \n# Case 1: x = -1\nif x == -1:\n    # Check if multiplying any subarray with -1 gives a higher beauty\n    max_multiplication = a[0]*-1\n    curr_multiplication = a[0]*-1\n    for i in range(1, n):\n        curr_multiplication *= -1\n        curr_multiplication = max(a[i]*-1, curr_multiplication+a[i]*-1)\n        max_multiplication = max(max_multiplication, curr_multiplication)\n\n    max_sum = max(max_sum, max_multiplication)\n\n# Case 2: x = 1\nelif x == 1:\n    # There is no need to multiply any subarray\n    pass\n\n# Case 3: x is positive or negative (but not 1 or -1)\nelse:\n    # To solve this case, we will find the maximum beauty of\n    # the array where every element is multiplied with x. We will\n    # then find the maximum subarray sum of the array a when it is\n    # multiplied with x. Adding this maximum subarray sum to the\n    # original maximum beauty of array gives us the final answer.\n    max_sum_x = 0\n    curr_sum_x = 0\n    max_subarray_x = 0\n    curr_subarray_x = 0\n    for num in a:\n        curr_sum_x = max(num*x, curr_sum_x+num*x)\n        curr_subarray_x = max(curr_subarray_x+num*x, num*x)\n        max_sum_x = max(max_sum_x, curr_sum_x)\n        max_subarray_x = max(max_subarray_x, curr_subarray_x)\n\n    max_sum = max(max_sum, max_sum_x + max_subarray_x*(x-1))\n\nprint(max_sum)"
 ],
 "48": [
  "n, m, k = map(int, input().split())\nleft, right = 1, n*m\n\nwhile left < right:\n    mid = (left+right)//2\n    cnt = 0\n    for i in range(1, n+1):\n        cnt += min(mid//i, m)\n    if cnt < k:\n        left = mid+1\n    else:\n        right = mid\n\nprint(left)"
 ],
 "49": [
  "k = int(input())\nn = 9\ndigits = 1\nwhile k > n*digits:\n    k -= n*digits\n    n *= 10\n    digits += 1\n\nnum = (k-1) // digits + n//9\nposition = (k-1) % digits\n\nprint(str(num)[position])"
 ],
 "50": [
  "n, m, r = map(int, input().split())\ns = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nmax_buy = max(s)\nmin_sell = min(b)\n\nif max_buy >= min_sell:\n    print(r)\nelse:\n    shares = r // max_buy\n    remaining_money = r - shares * max_buy\n    new_money = shares * min_sell\n    print(remaining_money + new_money)"
 ],
 "51": [
  "t = input()\n\nfor i in range(1, len(t)):\n    prefix = t[:i]\n    suffix = t[-i:]\n    if prefix == suffix:\n        s = t[:-i] + t\n        print(\"YES\")\n        print(s)\n        break\nelse:\n    print(\"NO\")"
 ],
 "52": [
  "n = int(input())\nlo, hi = 1, n\nwhile lo < hi:\n    mid = (lo+hi+1)//2\n    # Number of games in initial stage\n    games_init = mid* (mid-1) // 2\n    # Number of games in round robin tournament (if needed)\n    games_rr = (n - games_init) // mid\n    if games_rr*(mid*(mid-1)//2) + games_init == n:\n        print(mid)\n        lo, hi = mid, mid\n    elif games_rr*(mid*(mid-1)//2) + games_init > n:\n        hi = mid - 1\n    else:\n        lo = mid + 1\nif lo == hi:\n    if lo * (lo-1) // 2 == n:\n        print(lo)\n    else:\n        print(-1)"
 ],
 "53": [
  "n = int(input())\ns = input().strip()\nb = list(map(int, input().split()))\n\ns_set = set(s)\ns_count = {char: s.count(char) for char in s_set}\nodd_char = [char for char, count in s_count.items() if count % 2 != 0]\nodd_count = sum(s_count[char] for char in odd_char)\n\nresult = sum([b[i] for i in range(n) if s[i] == s[n - 1 - i]])\nif len(odd_char) == 1:\n    result += max([b[i] for i in range(n) if s[i] == odd_char[0]])\nresult += sum([b[i] for i in range(n) if s[i] != s[n - 1 - i]])\nprint(result)"
 ],
 "54": [
  "w, m = map(int, input().split())\nwhile m > 0:\n    if m % w == 0:\n        m //= w\n    elif (m - 1) % w == 0:\n        m = (m - 1) // w\n    elif (m + 1) % w == 0:\n        m = (m + 1) // w\n    else:\n        print(\"NO\")\n        break\nelse:\n    print(\"YES\")"
 ],
 "55": [
  "n,k=map(int,input().split())\nif n<2**(k-1): print(\"No\")\nelse:\n    ans=[0]*k\n    for i in range(k-1,-1,-1):\n        x=2**i\n        while n>=x and k-i<=n-x:\n            ans[i]=1\n            n-=x\n    print(\"Yes\")\n    print(*[sum(ans[i::-1]) - sum(ans[i::-1]) - i - 1 for i in range(k)])"
 ],
 "56": [
  "n, t = map(int, input().split())\n\nglasses = [[0] * (i+1) for i in range(n)]\n\nglasses[0][0] = t\nfor i in range(n-1):\n    for j in range(i+1):\n        if glasses[i][j] > 1:\n            overflow = (glasses[i][j] - 1) / 2\n            glasses[i+1][j] += overflow\n            glasses[i+1][j+1] += overflow\n            glasses[i][j] = 1\n\ncount = 0\nfor row in glasses:\n    count += sum(1 for glass in row if glass == 1)\n\nprint(count)"
 ],
 "57": [
  "n = int(input())\npoints = []                      \nfor i in range(n):                 \n    x, y = map(int, input().split())   \n    points.append((x, y))          \n\n# Check if all x's are the same or all y's are the same\nif len(set([point[0] for point in points])) == 1:  \n    side = abs(points[0][1] - points[1][1])         \n    other_side = abs(points[2][1] - points[3][1])   \n    if side == other_side and side > 0:           \n        print(side**2)\n    else:\n        print(-1)\nelif len(set([point[1] for point in points])) == 1:\n    side = abs(points[0][0] - points[1][0])         \n    other_side = abs(points[2][0] - points[3][0])   \n    if side == other_side and side > 0:           \n        print(side**2)\n    else:\n        print(-1)\nelse:\n    print(-1)"
 ],
 "58": [
  "n = int(input())\na = int(input())\nb = int(input())\n\n# Calculate the total length of all sides of both frames\ntotal_length = (a + b) * 2\n\n# Calculate the minimum number of bars needed\nmin_bars = (total_length + n - 1) // n\n\nprint(min_bars)"
 ],
 "59": [
  "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input()))\nfor i in range(n-1):\n    if b[i] == 1 and a[i] > a[i+1]:\n        j = i+1\n        while j < n-1 and b[j] == 1 and a[j] > a[j+1]:\n            j += 1\n        a[i:j+1] = sorted(a[i:j+1])\nif a == sorted(a):\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "60": [
  "n, s = input().strip()\nn = int(n)\n\nif s == 'a' or s == 'f':\n    print((n - 1) * 2 + (s == 'f'))\nelif s == 'b' or s == 'e':\n    print((n - 1) * 2 + 1)\nelse:\n    print((n - 1) * 2 + 2)"
 ],
 "61": [
  "xb, yb = map(int, input().split())\nx = list(map(int, input().split()))\nyb, yb = map(int, input().split())\ny = list(map(int, input().split()))\n\nx_sum = 0\ny_sum = 0\nxb_pow = 1\nyb_pow = 1\n\nfor i in range(xb-1, -1, -1):\n    x_sum += x[i] * xb_pow\n    xb_pow *= xb\n\nfor i in range(yb-1, -1, -1):\n    y_sum += y[i] * yb_pow\n    yb_pow *= yb\n\nif x_sum < y_sum:\n    print('<')\nelif x_sum > y_sum:\n    print('>')\nelse:\n    print('=')"
 ],
 "62": [
  "def winner(n, a):\n    xor_sum = 0\n    for i in range(n):\n        xor_sum ^= a[i]\n    if xor_sum == 0 or n % 2 == 0:\n        return \"BitAryo\"\n    else:\n        return \"BitLGM\"\n\nn = int(input())\na = list(map(int, input().split()))\nprint(winner(n, a))"
 ],
 "63": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\nprod, ans = 1, 0\nl = -1\nr = n\n\nwhile r > 0:\n    r -= 1\n    prod *= a[r]\n    while prod >= k and l < r:\n        l += 1\n        prod //= a[l]\n    if prod % k == 0:\n        ans += l+1\n\nprint(ans)"
 ],
 "64": [
  "n, k = map(int, input().split())\ncolors = input()\ncolors_count = {}\n\nfor c in colors:\n    if c in colors_count:\n        colors_count[c] += 1\n    else:\n        colors_count[c] = 1\n\nfor count in colors_count.values():\n    if count > 2 * k:\n        print(\"NO\")\n        break\nelse:\n    print(\"YES\")"
 ],
 "65": [
  "n=int(input())\na=list(map(int,input().split()))\nmin_val=min(a)\nmin_idx=[i for i in range(n) if a[i]==min_val]\nprint(min([min_idx[i+1]-min_idx[i] for i in range(len(min_idx)-1)]))"
 ],
 "66": [
  "from math import gcd\n\nt, w, b = map(int, input().split())\n\nif w > b:\n    w, b = b, w\n\nx = gcd(w, b)\n\ny = (t // (w*b//x)) * min(w,b) + min(t % (w*b//x), min(w,b)-1)\n\nz = gcd(y, t)\n\nprint(f\"{y//z}/{t//z}\")"
 ],
 "67": [
  "x, y, z = map(int, input().split())\nif x > y + z:\n    print(\"+\")\nelif y > x + z:\n    print(\"-\")\nelif x == y and z == 0:\n    print(\"0\")\nelse:\n    print(\"?\")"
 ],
 "68": [
  "n = int(input())\ns = input().strip()\nx, y = map(int, input().split())\n\ndef check(k):\n    l = r = -1\n    ux = dx = ly = ry = 0\n    for i in range(k):\n        if s[i] == \"U\":\n            uy += 1\n        elif s[i] == \"D\":\n            dy += 1\n        elif s[i] == \"L\":\n            lx += 1\n        else:\n            rx += 1\n    for i in range(k, n):\n        if s[i] == \"U\":\n            uy += 1\n        elif s[i] == \"D\":\n            dy += 1\n        elif s[i] == \"L\":\n            lx += 1\n        else:\n            rx += 1\n        if abs(lx - rx) + abs(uy - dy) <= k:\n            return True\n\n    return False\n\nif abs(x) + abs(y) > n or (x + y) % 2 != n % 2:\n    print(-1)\n    exit()\n    \nl, r = 0, n\nwhile l < r:\n    mid = (l+r)//2\n    if check(mid):\n        r = mid\n    else:\n        l = mid+1\n\nprint(l)"
 ],
 "69": [
  "# Importing library\nimport sys\n\n# Function to calculate the number of prefixes of t with balance equal to x\ndef calculate_prefixes(n, x, s):\n    # Initializations\n    count_0 = s.count('0')\n    count_1 = s.count('1')\n    balance = count_0 - count_1\n    prefix_balance = [0]\n    \n    # If balance is zero, then check if x is zero or not\n    if balance == 0:\n        if x == 0:\n            return -1\n        else:\n            return 0\n    else:\n        # Calculate the prefix_balance for each prefix of s\n        for i in range(n):\n            if s[i] == '0':\n                prefix_balance.append(prefix_balance[-1]+1)\n            else:\n                prefix_balance.append(prefix_balance[-1]-1)\n        \n        # If balance is positive, then we need to add the prefix with balance x multiple times\n        if balance > 0:\n            if x < 0:\n                diff = abs(x)\n                if prefix_balance[n] >= diff:\n                    return 1\n                else:\n                    loop_balance = prefix_balance[n]\n                    loop_count = 1\n                    while loop_balance < diff:\n                        loop_balance += balance\n                        loop_count += 1\n                    if loop_balance == diff:\n                        return -1\n                    else:\n                        return loop_count\n            else:\n                loop_balance = prefix_balance[n]\n                loop_count = 0\n                while loop_balance >= 0:\n                    if loop_balance == x:\n                        return -1\n                    elif loop_balance < x:\n                        loop_balance += balance\n                        loop_count += 1\n                    else:\n                        break\n                return loop_count\n        else:\n            # Same as above for balance < 0\n            if x > 0:\n                diff = abs(x)\n                if prefix_balance[n] <= diff:\n                    return 1\n                else:\n                    loop_balance = prefix_balance[n]\n                    loop_count = 1\n                    while loop_balance > -diff:\n                        loop_balance += balance\n                        loop_count += 1\n                    if loop_balance == -diff:\n                        return -1\n                    else:\n                        return loop_count\n            else:\n                loop_balance = prefix_balance[n]\n                loop_count = 0\n                while loop_balance <= 0:\n                    if loop_balance == x:\n                        return -1\n                    elif loop_balance > x:\n                        loop_balance += balance\n                        loop_count += 1\n                    else:\n                        break\n                return loop_count\n\n# Reading input\ninput = sys.stdin.readline\nt = int(input())\nfor _ in range(t):\n    n, x = map(int, input().split())\n    s = input().strip()\n    # Calling function calculate_prefixes for each test case and printing the result\n    print(calculate_prefixes(n, x, s))"
 ],
 "70": [
  "n, k = map(int, input().split())\nif n == 0:\n    print(0)\nelse:\n    count = 0\n    while n % (10 ** k) != 0:\n        if n % 10 == 0:\n            n //= 10\n        else:\n            n -= 1\n        count += 1\n    print(count)"
 ],
 "71": [
  "n, m, k, x, y = map(int, input().split())\n\nif n == 1:\n    min_q = max_q = (k // m) + int(k % m > 0)\n    ser_q = min_q - int(y > k % m or k % m == 0)\nelse:\n    rows = 2 * n - 2\n    cycle = k // rows\n    rem = k % rows\n\n    if rem <= 2 * (n - 1):\n        que = rem // 2\n        if rem % 2 == 0:\n            ser_q = que if x == n else que + 1\n        else:\n            ser_q = que + 1 if x == n else que\n\n    else:\n        que = m\n        r = rem - 2 * (n - 1)\n        pos = m - r + 2 * (n - x - 1)\n        ser_q = que if x == n else que + cycle * 2\n        ser_q += (pos <= y and pos > 0)\n\n    if cycle > 0:\n        min_q = cycle * 2\n        max_q = min_q + 1\n    else:\n        min_q = (rem != 0)\n        max_q = (rem >= x * 2 - 1) + cycle * 2\n\nprint(max_q, min_q, ser_q)"
 ],
 "72": [
  "def get_beauty_count(ribbon: str) -> int:\n    ribbon += '#' # marker\n    max_count = 1\n    count = 1\n    for i in range(1, len(ribbon)):\n        if ribbon[i] == ribbon[i-1]:\n            count += 1\n        else:\n            max_count = max(max_count, count)\n            count = 1\n    return max_count\n\n\nn = int(input())\nplayers = [\"Kuro\", \"Shiro\", \"Katie\"]\n\nribbons = []\nfor i in range(3):\n    ribbon = input().strip()\n    ribbons.append(ribbon)\n\nres = {}\nfor i in range(3):\n    ribbon = ribbons[i]\n    for j in range(3):\n        if i != j:\n            other_ribbon = ribbons[j]\n            diff_count = 0\n            for k in range(len(ribbon)):\n                if ribbon[k] != other_ribbon[k]:\n                    diff_count += 1\n            temp_ribbon = ribbon\n            for k in range(len(ribbon)):\n                if diff_count >= n: break\n                if temp_ribbon[k] != other_ribbon[k]:\n                    temp_ribbon = temp_ribbon[:k] + other_ribbon[k] + temp_ribbon[k+1:]\n                    diff_count += 1\n            beauty_count = get_beauty_count(temp_ribbon)\n            if players[i] not in res: res[players[i]] = [0, 0] # ribbon, beauty\n            if beauty_count > res[players[i]][1]:\n                res[players[i]] = [temp_ribbon, beauty_count]\n\nmax_beauty = max(res.values(), key=lambda x: x[1])[1]\ncount = 0\nfor player, info in res.items():\n    if info[1] == max_beauty:\n        count += 1\n        winner = player\nif count > 1:\n    print(\"Draw\")\nelse:\n    print(winner)"
 ],
 "73": [
  "c, v0, v1, a, l = map(int, input().split())\ncurrent_page = 0\nday = 0\nwhile current_page < c:\n    day += 1\n    if day == 1:\n        read_page = v0\n    else:\n        read_page = min(v0 + (day - 1) * a, v1)\n    current_page += read_page\n    if day > 1:\n        current_page -= l\n    if current_page >= c:\n        break\nprint(day)"
 ],
 "74": [
  "n = int(input())\nif n < 4:\n    print(1)\n    print(n)\nelse:\n    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, int(i ** 0.5) + 1):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    for i in range(len(primes)):\n        for j in range(i, len(primes)):\n            for k in range(j, len(primes)):\n                if primes[i] + primes[j] + primes[k] == n:\n                    print(3)\n                    print(primes[i], primes[j], primes[k])\n                    exit()\n            if primes[i] + primes[j] == n:\n                print(2)\n                print(primes[i], primes[j])\n                exit()\n    print(1)\n    print(n)"
 ],
 "75": [
  "n, m = map(int, input().split())\nrows, cols = [0]*n, [0]*m\nfor i in range(n):\n    row = input().strip()\n    for j in range(m):\n        if row[j] == \"*\":\n            rows[i] += 1\n            cols[j] += 1\nfor i in range(n):\n    for j in range(m):\n        if rows[i] + cols[j] - (row[j] == \"*\") == 0:\n            print(\"YES\")\n            print(i+1, j+1)\n            exit()\nprint(\"NO\")"
 ],
 "76": [
  "python\nn, m, a, b = map(int,input().split())\nif n%m==0:\n    print(0)\nelse:\n    x = (n//m)*m\n    cost1 = (n-x)*a\n    cost2 = (x+m-n)*b\n    print(min(cost1,cost2))"
 ],
 "77": [
  "n = int(input())\na = list(map(int, input().split()))\nodd_sum = float('-inf')\nsum_even = 0\nfor i in range(n):\n    if a[i] % 2 != 0:\n        odd_sum = max(odd_sum, a[i])\n    else:\n        sum_even += a[i]\nif odd_sum == float('-inf'):\n    print(sum_even)\nelse:\n    print(odd_sum + sum_even)"
 ],
 "78": [
  "MOD = 10**9 + 7\n\nn, T = map(int, input().split())\n\nsongs = []\nfor _ in range(n):\n    t, g = map(int, input().split())\n    songs.append((t, g))\n\n# dp[i][mask][j] represents the number of playlists that end with song i, have the bitmask mask of the genres already played, and have total duration j\ndp = [[[0] * 4 for _ in range(1<<3)] for _ in range(n)]\nfor i in range(n):\n    if songs[i][0] == T:\n        dp[i][(1<<songs[i][1])-1][T] = 1\n\nfor j in range(T-1, -1, -1):\n    for mask in range(1<<3):\n        for i in range(n):\n            t, g = songs[i]\n            # If the song cannot be played at the current time\n            if j+t > T:\n                continue\n            # If the genre cannot be played in succession\n            if mask & (1<<(g-1)):\n                continue\n            for k in range(n):\n                # If the song has already been played\n                if mask & (1<<(songs[k][1]-1)):\n                    continue\n                dp[i][mask | (1<<(g-1))][j] = (dp[i][mask | (1<<(g-1))][j] + dp[k][mask][j+t]) % MOD\n\nans = 0\nfor i in range(n):\n    ans = (ans + dp[i][(1<<3)-1][0]) % MOD\n\nprint(ans)"
 ],
 "79": [
  "MOD = 10**9 + 7\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\nm = int(input())\n\ndp = [0] * (m + 1)\ndp[1] = 1\n\nfor i in range(2, m + 1):\n    p = pow(i, MOD - 2, MOD)\n    dp[i] = (1 + p * dp[i - 1]) % MOD\n\nans = 1\nfor i in range(1, m + 1):\n    ans = (ans * pow(i, dp[i], MOD)) % MOD\n\nprint(ans)"
 ],
 "80": [
  "from math import gcd\n\nl, r, x, y = map(int, input().split())\n\ncount = 0\n\nfor a in range(l, r+1):\n    if x <= a <= y and y % a == 0 and gcd(a, y//a) == x:\n        count += 1\nprint(count)"
 ],
 "81": [
  "from math import gcd\na, b = map(int, input().split())\nd = abs(a-b)\nans = 0\nmn = lcm = a*b//gcd(a,b)\nfor i in range(1, int(d**0.5)+1):\n    if d % i == 0:\n        if gcd(a+i, b+i) == i:\n            lcm_i = (a+i)*(b+i)//gcd(a+i, b+i)\n            if lcm_i < lcm:\n                lcm = lcm_i\n                ans = i\n            lcm_i = (a+d//i)+(b+d//i)\n            if lcm_i < lcm:\n                lcm = lcm_i\n                ans = d//i\nprint(ans)"
 ],
 "82": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\ncurrent_avg = sum(a) / n\nneeded_avg = (k + current_avg) / 2\n\nif needed_avg > current_avg:\n    additional_marks = int((needed_avg - current_avg) * 2)\nelse:\n    additional_marks = 0\n\nprint(additional_marks)"
 ],
 "83": [
  "n = int(input())\na = list(map(int, input().split()))\npos = sum(1 for x in a if x > 0)\nneg = sum(1 for x in a if x < 0)\nif pos >= (n+1)//2:\n    print(1)\nelif neg >= (n+1)//2:\n    print(-1)\nelse:\n    print(0)"
 ],
 "84": [
  "n = int(input())\ncnt = [0] * 10\nfor i in range(1, n+1):\n    s = str(i)\n    cnt[(int(s[-1]) * 2) % 10] += 1\nans = cnt[0] * (cnt[0]-1) // 2\nfor i in range(1, 5):\n    ans += cnt[i] * cnt[10-i]\nprint(ans)"
 ],
 "85": [
  "a1, b1 = map(int, input().split())\na2, b2 = map(int, input().split())\n\nif a1 * b1 != a2 * b2:\n    print(-1)\nelse:\n    m = float('inf')\n    sizes = []\n\n    for op1 in [1/2, 2/3]:\n        for op2 in [1/2, 2/3]:\n            for s1 in [a1, b1]:\n                for s2 in [a2, b2]:\n                    for t in range(2):\n                        for u in range(2):\n                            for v in range(2):\n                                for w in range(2):\n                                    a, b = s1, s2\n                                    cnt = 0\n                                    if t:\n                                        a = s1 * op1\n                                        cnt += 1\n                                    if u:\n                                        a = s1 - s1 * op1\n                                        cnt += 1\n                                    if v:\n                                        b = s2 * op2\n                                        cnt += 1\n                                    if w:\n                                        b = s2 - s2 * op2\n                                        cnt += 1\n                                    if a * b == a1 * b1:\n                                        if cnt < m:\n                                            m = cnt\n                                            sizes = [(a, b), (a1 - a, b1)]\n    print(m)\n    print(sizes[0][0], sizes[0][1])\n    print(sizes[1][0], sizes[1][1])"
 ],
 "86": [
  "xp, yp, xv, yv = map(int, input().split())\n \ndef can_reach(x1, y1, x2, y2):\n    return x1 + y1 <= x2 + y2 and (x2-x1) % 2 == (y2-y1) % 2\n \nif can_reach(xp, yp, xv, yv):\n    print(\"Polycarp\")\nelse:\n    print(\"Vasiliy\")"
 ],
 "87": [
  "m, d = map(int, input().split())\ndays = [0,31,28,31,30,31,30,31,31,30,31,30,31]\nprint((days[m] + d - 1 + 6)//7)"
 ],
 "88": [
  "a, b = map(int, input().split())\ncount = 0\nfor i in range(50):\n    mask = (1 << i) - 1\n    for j in range(i):\n        num = mask ^ (1 << j)\n        if a <= num <= b:\n            count += 1\nprint(count)"
 ],
 "89": [
  "n = int(input())\nlayers = 1\nfor i in range(1,n+1):\n    layers += i\nprint(layers)"
 ],
 "90": [
  "from itertools import combinations\nn, k, S = map(int, input().split())\ncubes = list(map(int, input().split()))\n\ncount = 0\nfor i in range(k+1):\n    for subset in combinations(enumerate(cubes), i):\n        sum_cubes = sum([x[1] if idx not in [y[0] for y in subset] else x[1]*x[1] for idx, x in enumerate(enumerate(cubes), start=1)])\n        if sum_cubes == S:\n            count += 1\n            \nprint(count)"
 ],
 "91": [
  "for _ in range(int(input())):\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    \n    j = 0\n    for i in range(61, -1, -1):\n        cnt = 0\n        for x in range(n):\n            if a[x] % (k**i) != 0:\n                cnt += 1\n                break\n        if cnt == 0:\n            continue\n        if j:\n            print(\"NO\")\n            break\n        j = 1\n        res = 0\n        for x in range(n):\n            res += a[x] // (k**i)\n        if res > sum(a) // (k**i):\n            print(\"NO\")\n            break\n    else:\n        if j:\n            print(\"YES\")\n        else:\n            print(\"NO\")"
 ],
 "92": [
  "import math\n\na, b, c = map(int, input().split())\n\nmod = 10**9 + 7\n\nans = 0\n\nfor i in range(1,a+1):\n    for j in range(1,b+1):\n        for k in range(1,c+1):\n            ans = (ans + math.floor((a/i)) * math.floor((b/j)) * math.floor((c/k)) * i * j * k) % mod\n\nprint(ans)"
 ],
 "93": [
  "bessie = [input() for i in range(2)]\nelsie = [input() for i in range(2)]\nif sorted(''.join(bessie)) == sorted(''.join(elsie)):\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "94": [
  "n = int(input())\nk = input()\n\n# We will start by converting k to decimal\ndecimal_k = 0\nfor i in range(len(k)):\n    decimal_k += int(k[i]) * (n ** (len(k) - i - 1))\n\n# Now we will try to find the minimum decimal number that can be converted to k in base n\nx = decimal_k\nwhile True:\n    converted = \"\"\n    remaining = x\n    while remaining > 0:\n        converted = str(remaining % n) + converted\n        remaining //= n\n    if converted == k:\n        print(x)\n        break\n    x += 1"
 ],
 "95": [
  "n = int(input())\na = list(map(int, input().split()))\ni = 0\n\nwhile i + 1 < n and a[i] < a[i+1]:\n    i += 1\n\nwhile i + 1 < n and a[i] == a[i+1]:\n    i += 1\n\nwhile i + 1 < n and a[i] > a[i+1]:\n    i += 1\n\nif i == n-1:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "96": [
  "n, k = map(int, input().split())\n\ndef f(x):\n    if x % 2 == 0:\n        return x // 2\n    else:\n        return x - 1\n\ncount = {}\nfor i in range(1, n+1):\n    val = i\n    while val not in count:\n        count[val] = i\n        val = f(val)\n\nfreq = {}\nfor i in range(1, n+1):\n    path = count[i]\n    if path not in freq:\n        freq[path] = 0\n    freq[path] += 1\n\nans = 0\nfor i in range(1, n+1):\n    if i in freq and freq[i] >= k:\n        ans = max(ans, i)\n\nprint(ans)"
 ],
 "97": [
  "n, m, x, y, vx, vy = map(int, input().split())\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef lcm(a, b):\n    return a // gcd(a, b) * b\n\ndef dist_to_wall(x, vx):\n    if vx == 0:\n        return float('inf')\n    if vx > 0:\n        return (n - x) / vx\n    return -x / vx\n\ndef dist_to_ceiling(y, vy):\n    if vy == 0:\n        return float('inf')\n    if vy > 0:\n        return (m - y) / vy\n    return -y / vy\n\ndef dist_to_floow(y, vy):\n    if vy == 0:\n        return float('inf')\n    if vy > 0:\n        return y / vy\n    return (m - y) / -vy\n\ndef dist_to_left_wall(x, vx):\n    if vx == 0:\n        return float('inf')\n    if vx > 0:\n        return x / vx\n    return (n - x) / -vx\n\ndef pocket(x, y, vx, vy):\n    t1 = dist_to_wall(x, vx)\n    t2 = dist_to_ceiling(y, vy)\n    t3 = dist_to_floow(y, vy)\n    t4 = dist_to_left_wall(x, vx)\n    t = min(t1, t2, t3, t4)\n\n    x += vx * t\n    y += vy * t\n\n    if abs(x - n) < 1e-6 and abs(y - m) < 1e-6:\n        return (0, 0)\n    if abs(x) < 1e-6 and abs(y - m) < 1e-6:\n        return (0, 0)\n    if abs(x - n) < 1e-6 and abs(y) < 1e-6:\n        return (0, 0)\n    if abs(x) < 1e-6 and abs(y) < 1e-6:\n        return (0, 0)\n    return -1\n\nT = lcm(abs(vx), abs(vy))\nvx *= T\nvy *= T\nx *= T\ny *= T\nprint(pocket(x, y, vx, vy)[0], pocket(x, y, vx, vy)[1])"
 ],
 "98": [
  "a1,b1 = map(int,input().split())\na2,b2 = map(int,input().split())\na3,b3 = map(int,input().split())\n\nif (a2+a3<=a1 and max(b2,b3)<=b1) or (b2+b3<=b1 and max(a2,a3)<=a1) or (a2+a3<=b1 and max(b2,b3)<=a1) or (b2+b3<=a1 and max(a2,a3)<=b1):\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "99": [
  "a, r, l, m = map(int, input().split())\nbad_nums = set(map(int, input().split()))\nif a == 0:\n    print(0 if 0 in bad_nums else \"inf\")\nelse:\n    if r == 0:\n        print(1 if abs(a) <= l and a not in bad_nums else 0)\n    elif r == 1:\n        if abs(a) <= l and a not in bad_nums:\n            print(\"inf\")\n        else:\n            print(0)\n    else:\n        if r > 0:\n            lo, hi = 0, l - abs(a)\n        else:\n            lo, hi = l - abs(a), float(\"inf\")\n        non_bad = 0\n        cur_term = a\n        while abs(cur_term) <= l:\n            if cur_term not in bad_nums:\n                non_bad += 1\n            cur_term *= r\n            if r > 0:\n                if cur_term > 0:\n                    if abs(cur_term) > hi:\n                        break\n                else:\n                    if abs(cur_term) < lo:\n                        if non_bad > 0:\n                            print(non_bad)\n                            break\n                        else:\n                            print(0)\n                            break\n            else:\n                if abs(cur_term) < lo:\n                    break\n        else:\n            if non_bad > 0:\n                print(non_bad)\n            else:\n                print(0))"
 ],
 "100": [
  "n, m = map(int, input().split())\ngrid = [list(input().strip()) for _ in range(n)]\ntop, bottom, left, right = n, -1, m, -1\n\n# find the boundaries of the white pixels\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 'w':\n            top = min(top, i)\n            bottom = max(bottom, i)\n            left = min(left, j)\n            right = max(right, j)\n            \n# check if all white pixels are on the border\nif 'w' not in [grid[top][j] for j in range(left, right+1)] + [grid[bottom][j] for j in range(left, right+1)] + [grid[i][left] for i in range(top, bottom+1)] + [grid[i][right] for i in range(top, bottom+1)]:\n    print('\\n'.join([''.join(row) for row in grid]))\nelse:\n    for i in range(top-1, bottom+2):\n        for j in range(left-1, right+2):\n            # check if the current cell is a valid position for a corner of the frame\n            if (i, j) not in [(top-1, left-1), (top-1, right+1), (bottom+1, left-1), (bottom+1, right+1)] and 0 <= i < n and 0 <= j < m and grid[i][j] != 'w':\n                valid = True\n                # check if all white pixels are on the frame\n                if i == top-1 and 'w' not in [grid[i][c] for c in range(left, j)] + [grid[i][c] for c in range(j+1, right+1)]:\n                    valid = False\n                if i == bottom+1 and 'w' not in [grid[i][c] for c in range(left, j)] + [grid[i][c] for c in range(j+1, right+1)]:\n                    valid = False\n                if j == left-1 and 'w' not in [grid[r][j] for r in range(top, i)] + [grid[r][j] for r in range(i+1, bottom+1)]:\n                    valid = False\n                if j == right+1 and 'w' not in [grid[r][j] for r in range(top, i)] + [grid[r][j] for r in range(i+1, bottom+1)]:\n                    valid = False\n                if valid:\n                    # paint the frame\n                    if i == top-1:\n                        for c in range(left, right+1):\n                            grid[i][c] = '+'\n                    if i == bottom+1:\n                        for c in range(left, right+1):\n                            grid[i][c] = '+'\n                    if j == left-1:\n                        for r in range(top, bottom+1):\n                            grid[r][j] = '+'\n                    if j == right+1:\n                        for r in range(top, bottom+1):\n                            grid[r][j] = '+'\n                    print('\\n'.join([''.join(row) for row in grid]))\n                    exit()\n    print(-1)"
 ],
 "101": [
  "n=int(input())\na=int(input())\nb=int(input())\nfor i in range(n//a + 1):\n    if (n-i*a)%b==0:\n        print(\"YES\")\n        print(i,(n-i*a)//b)\n        break\nelse:\n    print(\"NO\")"
 ],
 "102": [
  "num_to_word = {\n    0: \"zero\", 1: \"one\", 2: \"two\", 3: \"three\", 4: \"four\", 5: \"five\", \n    6: \"six\", 7: \"seven\", 8: \"eight\", 9: \"nine\", 10: \"ten\", \n    11: \"eleven\", 12: \"twelve\", 13: \"thirteen\", 14: \"fourteen\", \n    15: \"fifteen\", 16: \"sixteen\", 17: \"seventeen\", 18: \"eighteen\", \n    19: \"nineteen\", 20: \"twenty\", 30: \"thirty\", 40: \"forty\", \n    50: \"fifty\", 60: \"sixty\", 70: \"seventy\", 80: \"eighty\", \n    90: \"ninety\"\n}\n\ndef num_to_word_convert(num):\n    if num <= 20:\n        return num_to_word[num]\n    if num < 100:\n        return num_to_word[num//10*10] + \"-\" + num_to_word[num%10]\n    return \"ninety-nine\"\n\nscore = int(input())\nprint(num_to_word_convert(score))"
 ],
 "103": [
  "n = int(input())\na = list(map(int, input().split()))\n\nmax_erase = 0\nfor i in range(n):\n    for j in range(i+1, n):\n        if a[j] - a[i] == j - i:\n            max_erase = max(max_erase, j - i - 1)\n\nprint(max_erase)"
 ],
 "104": [
  "n = int(input())\na = list(map(int, input().split()))\ntotal = sum(a)\ncurrent_sum = 0\nfor i in range(n):\n    current_sum += a[i]\n    if current_sum * 2 >= total:\n        print(i+1)\n        break"
 ],
 "105": [
  "N = int(input())\na = []\nfor i in range(N) :\n    a.append(list(map(int, input().split())))\npos = [0,0]*N**2\nans = N**2\ndef Search(k, b ,now, subcnt):\n    global ans,pos\n    if b > ans:\n        return\n    if k == N*N:\n        ans = min(ans , b)\n        pos = now[:]\n        return\n    nextpos = divmod(now[k-1],N)\n    if k == 1:\n        for i in range(N*N):\n            y, x = divmod(i,N)\n            if a[y][x] == 1 :\n                for j in [0,1,2]:\n                    if j == 0:\n                        Search(k+1, b, now+[i], subcnt)\n                    elif j == 1:\n                        Search(k+1, b+1, now+[i], subcnt+1)\n                    else :\n                        Search(k+1, b+1, now+[i], subcnt+2)\n                break\n    else :\n        if b == 0:\n            for j in [0,2]:\n                if j == 0:\n                    for ni, nj in [(0,1),(1,0),(0,-1),(-1,0)]:\n                        ny, nx = nextpos[0]+ni, nextpos[1]+nj\n                        if 0<=ny<N and 0<=nx<N and now.count(ny*N+nx)==0 : \n                            Search(k+1, b+j, now+[ny*N+nx], subcnt)\n                else :\n                    for ny, nx in [(i,nextpos[1]) for i in range(N)] +[(nextpos[0],i) for i in range(N)]:\n                        if now.count(ny*N+nx)==0 : \n                            Search(k+1, b+j, now+[ny*N+nx], subcnt+2)\n        elif b == k-1 - subcnt :\n            for j in [0,1,2]:\n                if j == 0:\n                    for ni, nj in [(0,1),(1,0),(0,-1),(-1,0)]:\n                        ny, nx = nextpos[0]+ni, nextpos[1]+nj\n                        if 0<=ny<N and 0<=nx<N and now.count(ny*N+nx)==0 : \n                            Search(k+1, b+j, now+[ny*N+nx], subcnt)\n                elif j == 1:\n                    for ni, nj in [(0,1),(1,0),(0,-1),(-1,0)]:\n                        ny, nx = nextpos[0]+ni, nextpos[1]+nj\n                        if 0<=ny<N and 0<=nx<N and now.count(ny*N+nx)==0 : \n                            Search(k+1, b+j, now+[ny*N+nx], subcnt+1)\n                else :\n                    for ny, nx in [(i,nextpos[1]) for i in range(N)] +[(nextpos[0],i) for i in range(N)]:\n                        if now.count(ny*N+nx)==0 : \n                            Search(k+1, b+j, now+[ny*N+nx], subcnt+2)\n        else :\n            for j in [0,1,2]:\n                if j == 0:\n                    for ni, nj in [(0,1),(1,0),(0,-1),(-1,0)]:\n                        ny, nx = nextpos[0]+ni, nextpos[1]+nj\n                        if 0<=ny<N and 0<=nx<N and now.count(ny*N+nx)==0 : \n                            Search(k+1, b+j, now+[ny*N+nx], subcnt)\n                elif j == 1:\n                    for ny, nx in [(i,nextpos[1]) for i in range(N)] +[(nextpos[0],i) for i in range(N)]:\n                        if now.count(ny*N+nx)==0 : \n                            Search(k+1, b+j, now+[ny*N+nx], subcnt+1)\n                else :\n                    for ny, nx in [(i,nextpos[1]) for i in range(N)] +[(nextpos[0],i) for i in range(N)]:\n                        if now.count(ny*N+nx)==0 : \n                            Search(k+1, b+j, now+[ny*N+nx], subcnt+2)\n        \nSearch(1, 0, [0], 0)\nprint(ans, pos.count(0)) "
 ],
 "106": [
  "n, m, k = map(int, input().split())\na, b = map(int, input().split())\n\ndef dist(x, y):\n    floor_x = (x - 1) // (m * k) + 1\n    entrance_x = (x - 1) % n + 1\n    apt_x = ((x - 1) // k) % m + 1\n\n    floor_y = (y - 1) // (m * k) + 1\n    entrance_y = (y - 1) % n + 1\n    apt_y = ((y - 1) // k) % m + 1\n\n    if entrance_x == entrance_y:\n        return abs(floor_x - floor_y) * 5 + abs(apt_x - apt_y) * 5\n    else:\n        lift_time = min((entrance_x - entrance_y) % n, (entrance_y - entrance_x) % n) * 15 + 10\n        stair_time = abs(floor_x - floor_y) * 5 + abs(apt_x - apt_y) * 5\n        return lift_time + stair_time\n\nprint(dist(a, b))"
 ],
 "107": [
  "s = input()\nif '1' not in s:\n    print(\"no\")\nelse:\n    idx = len(s) - 1 - s[::-1].index('1')\n    if s[idx:].count('0') >= 6:\n        print(\"yes\")\n    else:\n        print(\"no\")"
 ],
 "108": [
  "s = input()\nresult = ''\nnext_char = 'a'\n\nfor char in s:\n    if char <= next_char:\n        result += next_char\n        next_char = chr(ord(next_char) + 1)\n    if next_char > 'z':\n        break\n\nif next_char > 'z':\n    print(result)\nelse:\n    print(\"-1\")"
 ],
 "109": [
  "from heapq import heapify, heappush, heappop\n\nn, m, r, k = map(int, input().split())\n\nif n < m:\n    n, m = m, n\n\nmid = (r - 1) // 2 + 1\nlo = [(-i * (r - i), i) for i in range(1, mid + 1)]\nhi = [(i * (r - i), i) for i in range(1, mid)]\nheapify(lo)\nheapify(hi)\n\nsm = [(-i * m, i) for i in range(1, mid + 1)]\nlg = [(i * m, i) for i in range(1, mid)]\nheapify(sm)\nheapify(lg)\n\ns = 0\nfor _ in range(k):\n    if lo and sm:\n        dl, l = lo[0]\n        ds, s0 = sm[0]\n        if -dl * m - s < -ds * l:\n            d, i = heappop(lo)\n            s -= d\n            j = heappop(hi)[1]\n            heappush(hi, (-(r - i - j) * (r - i - j + 1), j))\n        else:\n            d, j = heappop(lg)\n            s -= d\n            i = heappop(hi)[1]\n            heappush(hi, (-(r - i - j) * (r - i - j + 1), i))\n    elif lo:\n        d, i = heappop(lo)\n        s -= d\n        j = heappop(hi)[1]\n        heappush(hi, (-(r - i - j) * (r - i - j + 1), j))\n    else:\n        d, j = heappop(lg)\n        s -= d\n        i = heappop(hi)[1]\n        heappush(hi, (-(r - i - j) * (r - i - j + 1), i))\n\nprint(s / ((n - r + 1) * (m - r + 1)))"
 ],
 "110": [
  "n = int(input())\na = list(map(int, input().split()))\n\nif n == 1:\n    if a[0] < 0:\n        print(a[0] + 1)\n    else:\n        print(a[0])\n\nelse:\n    neg_count = sum(1 for x in a if x < 0)\n    zero_count = sum(1 for x in a if x == 0)\n\n    if neg_count % 2 == 0:\n        for i in range(n):\n            if a[i] < 0:\n                a[i] = -a[i] - 1\n    else:\n        if zero_count > 0:\n            for i in range(n):\n                if a[i] == 0:\n                    a[i] = -1\n                    break\n        else:\n            min_abs = min(abs(x) for x in a)\n            for i in range(n):\n                if abs(a[i]) == min_abs:\n                    a[i] = -a[i] - 1\n                    break\n\n    print(\" \".join(str(x) for x in a))"
 ],
 "111": [
  "n, k = map(int, input().split())\n\n# Get divisors of n and sort them\ndivisors = []\nfor i in range(1, int(n**0.5)+1):\n    if n % i == 0:\n        divisors.append(i)\n        if i != n//i:\n            divisors.append(n//i)\ndivisors.sort()\n\n# Check if there are at least k divisors\nif len(divisors) < k:\n    print(-1)\nelse:\n    print(divisors[k-1])"
 ],
 "112": [
  "n = int(input())\ncubes = []\nfor i in range(n):\n    cubes.append(list(map(int, input().split())))\n\nmax_num = 0\nfor i in range(1, 10):\n    for j in range(n if i == 1 else 0, n):\n        for k in range(n):\n            for l in range(n):\n                for m in range(n):\n                    for o in range(n):\n                        for p in range(n):\n                            num = int(str(cubes[j][0]) + str(cubes[k][1]) + str(cubes[l][2]) + str(cubes[m][3]) + str(cubes[o][4]) + str(cubes[p][5]))\n                            if len(str(num)) != len(set(str(num))) or '6' in str(num) and '9' in str(num):\n                                continue\n                            max_num = max(max_num, num)\n\nprint(max_num)"
 ],
 "113": [
  "n, k = map(int, input().split())\ni = 1\nwhile True:\n    if (n * i) % (10**k) == 0:\n        print(n * i)\n        break\n    i += 1"
 ],
 "114": [
  "n, m = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\nb = [[0] * m for _ in range(n)]\nops = []\n\ndef flip(x, y):\n    ops.append((x, y))\n    for i in range(x, x+2):\n        for j in range(y, y+2):\n            b[i][j] = 1\n\nfor i in range(n-1):\n    for j in range(m-1):\n        if a[i][j] and a[i+1][j] and a[i][j+1] and a[i+1][j+1]:\n            flip(i, j)\n\nfor i in range(n):\n    for j in range(m):\n        if a[i][j] != b[i][j]:\n            print(-1)\n            exit()\n\nprint(len(ops))\nfor i, j in ops:\n    print(i+1, j+1)"
 ],
 "115": [
  "from fractions import Fraction\n\nr, s, p = map(int, input().split())\n\ndp = [[[0]*101 for _ in range(101)] for _ in range(101)]\ndp[r][s][p] = 1\n\nfor i in range(r, -1, -1):\n    for j in range(s, -1, -1):\n        for k in range(p, -1, -1):\n            if i == 0 and j == 0:\n                dp[i][j][k] = 0\n                continue\n            if i == 0 and k == 0:\n                dp[i][j][k] = 1\n                continue\n            if j == 0 and k == 0:\n                dp[i][j][k] = 1\n                continue\n            all_total = i * j + j * k + i * k\n            win_rock = j * i\n            win_sciss = k * j\n            win_paper = i * k\n            if all_total == 0:\n                continue\n            dp[i][j][k] = Fraction(win_rock*dp[i][j-1][k] + win_sciss*dp[i][j][k-1] + win_paper*dp[i-1][j][k], all_total)\n\nprint(float(dp[1][0][0]), float(dp[0][1][0]), float(dp[0][0][1]))"
 ],
 "116": [
  "l1, r1, l2, r2, k = map(int, input().split())\nstart = max(l1, l2)\nend = min(r1, r2)\noverlap = max(0, end - start + 1)\nif l1 <= k <= r1:\n    overlap -= 1\nprint(overlap)"
 ],
 "117": [
  "from heapq import heappush, heappop\n\nINF = 10**18\n\ndef isect(px, py, qx, qy, a, b, c):\n    if px == qx:\n        if a <= px <= b:\n            return (px, max(min(py, qy), c), 1)\n        else:\n            return (0, 0, 0)\n    elif py == qy:\n        if c <= py <= max(a, b):\n            return (max(min(px, qx), a), py, 1)\n        else:\n            return (0, 0, 0)\n    else:\n        slope = (qy-py)/(qx-px)\n        yIntc = py - slope*px\n        # Intersecting the line y = cy with (px, py) and (qx, qy)\n        if px <= (c-yIntc)/slope <= qx and a <= (c-yIntc)/slope <= b:\n            return ((c-yIntc)/slope, c, 1)\n        else:\n            return (0, 0, 0)\n \n\nN, M = map(int, input().split())\nvertlines, horzlines = [], []\nfor i in range(N):\n    A, B, C = map(int, input().split())\n    vertlines.append((min(A, B), max(A, B), C))\nfor i in range(M):\n    D, E, F = map(int, input().split())\n    horzlines.append((min(E, F), max(E, F), D))\nvertlines.sort()\nhorzlines.sort()\n\n# Finding the intersections of the vertical and horizontal lines\nxyset = {(0, 0)}\nfor i in range(M):\n    a, b, c = horzlines[i]\n    hi = []\n    for j in range(N):\n        p, q, r = vertlines[j]\n        # Find the intersection of horzline[i] with vertline[j]\n        x, y, valid = isect(p, r, q, r, a, b, c)\n        if valid:\n            heappush(hi, x)\n    # If the horzline[i] intersects with one or more vertlines\n    while hi:\n        l, r = heappop(hi), heappop(hi)\n        if (l, a) not in xyset:\n            xyset.add((l, a))\n            xyset.add((l, b))\n        if(r, a) not in xyset:\n            xyset.add((r, a))\n            xyset.add((r, b))\n    \n# Finding the area by sweeping through the sorted ordered set\n# xyset contains all the intersection points of vertical and horizontal lines\n# These intersection points mark the vertices of our possible region\nlasty = xyset.pop()[1]\nrect = 0\nwhile xyset:\n    xy = xyset.pop()\n    if xy[1] == lasty:\n        continue\n    rect += xy[1] - lasty\n    lasty = xy[1]\nif rect == INF:\n    print(\"INF\")\nelse:\n    print(rect)"
 ],
 "118": [
  "t, s, x = map(int, input().split())\nif x < t:\n    print(\"NO\")\nelif x == t:\n    print(\"YES\")\nelif (x - t) % s == 1 or ((x - t) % s == 0 and (x - t) // s > 0 and (x - t - 1) / s % 2 == 1):\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "119": [
  "n = int(input())\nsegments = []\nfor i in range(n):\n    segment = tuple(map(int, input().split()))\n    segments.append((segment, i+1))\nsegments.sort()\n\nmin_right = segments[0][0][1]\nans = (-1, -1)\nfor i in range(1, n):\n    if segments[i][0][1] <= min_right:\n        ans = (segments[i][1], segments[i-1][1])\n        break\n    else:\n        min_right = segments[i][0][1]\n\nprint(ans[0], ans[1])"
 ],
 "120": [
  "n = int(input())\ns = input()\n\na = s.count('A')\nc = s.count('C')\ng = s.count('G')\nt = s.count('T')\nunknown = s.count('?')\n\nif (n % 4 != 0) or ((a > n//4) or (c > n//4) or (g > n//4) or (t > n//4)):\n    print(\"===\")\nelse:\n    num = n // 4\n    a_to_add = num - a\n    c_to_add = num - c\n    g_to_add = num - g\n    t_to_add = num - t\n    new_str = \"\"\n    for char in s:\n        if char == \"?\":\n            if a_to_add > 0:\n                new_str += \"A\"\n                a_to_add -= 1\n            elif c_to_add > 0:\n                new_str += \"C\"\n                c_to_add -= 1\n            elif g_to_add > 0:\n                new_str += \"G\"\n                g_to_add -= 1\n            elif t_to_add > 0:\n                new_str += \"T\"\n                t_to_add -= 1\n        else:\n            new_str += char\n    print(new_str)"
 ],
 "121": [
  "row_1 = input()\nrow_2 = input()\nrow_3 = input()\nrow_4 = input()\nif 'xxx.' in [row_1, row_2, row_3, row_4] or '.xxx' in [row_1, row_2, row_3, row_4]:\n    print(\"YES\")\nelif 'xx' in row_1 and row_2[row_1.index('xx')] == row_3[row_1.index('xx')] == '.':\n    print(\"YES\")\nelif 'xx' in row_2 and row_3[row_2.index('xx')] == row_4[row_2.index('xx')] == '.':\n    print(\"YES\")\nelif 'xx' in row_3 and row_2[row_3.index('xx')] == row_1[row_3.index('xx')] == '.':\n    print(\"YES\")\nelif 'xx' in row_4 and row_3[row_4.index('xx')] == row_2[row_4.index('xx')] == '.':\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "122": [
  "n = int(input())\na = list(map(int, input().split()))\nprefix_sum = [a[0]]\nsuffix_sum = [a[-1]]\nfor i in range(1, n):\n    prefix_sum.append(prefix_sum[-1] + a[i])\nfor i in range(n-2, -1, -1):\n    suffix_sum.insert(0, suffix_sum[0] + a[i])\nfor i in range(n):\n    if prefix_sum[i] == suffix_sum[i]:\n        print(\"YES\")\n        break\n    if i == n-1:\n        print(\"NO\")\n        break\n    if prefix_sum[i] > suffix_sum[i]:\n        index = suffix_sum.index(prefix_sum[i])\n        if index == n-1:\n            print(\"NO\")\n            break\n        if prefix_sum[i-1] == suffix_sum[index+1]:\n            print(\"YES\")\n            break\n        else:\n            print(\"NO\")\n            break\n    if prefix_sum[i] < suffix_sum[i]:\n        index = prefix_sum.index(suffix_sum[i])\n        if index == 0:\n            print(\"NO\")\n            break\n        if suffix_sum[i-1] == prefix_sum[index-1]:\n            print(\"YES\")\n            break\n        else:\n            print(\"NO\")\n            break"
 ],
 "123": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Sorting b in descending order\nb.sort(reverse=True)\n\n# Replacing each zero in a with the maximum element from b\nfor i in range(n):\n    if a[i] == 0:\n        a[i] = b[0]\n        b = b[1:]\n\n# Checking if the resulting sequence is not increasing\nfor i in range(1, n):\n    if a[i] <= a[i-1]:\n        print(\"Yes\")\n        break\nelse:\n    print(\"No\")"
 ],
 "124": [
  "x, y, z = map(int, input().split())\na, b, c = map(int, input().split())\n\nif a >= x:\n    a -= x\nelse:\n    print(\"NO\")\n    exit()\n\ntotal_grapes = a+b+c\n\nif (a+b) >= y:\n    grapes_left = (a+b) - y\n    total_grapes -= y\n    if grapes_left >= z:\n        total_grapes -= z\n    else:\n        print(\"NO\")\n        exit()\nelse:\n    print(\"NO\")\n    exit()\n\nif total_grapes >= z + y + x:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "125": [
  "part1 = input().split()\npart2 = input().split()\npart3 = input().split()\npart4 = input().split()\n\nif (part1[3] == \"1\" and (part1[0] == \"1\" or part4[2] == \"1\" or part3[1] == \"1\")) or \\\n   (part2[3] == \"1\" and (part2[0] == \"1\" or part4[1] == \"1\" or part3[2] == \"1\")) or \\\n   (part3[3] == \"1\" and (part3[0] == \"1\" or part1[2] == \"1\" or part2[1] == \"1\")) or \\\n   (part4[3] == \"1\" and (part4[0] == \"1\" or part1[1] == \"1\" or part2[2] == \"1\")):\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "126": [
  "n = int(input())\nnumber = input()\n\nkeypad = {\n    '1': (0,0),\n    '2': (0,1),\n    '3': (0,2),\n    '4': (1,0),\n    '5': (1,1),\n    '6': (1,2),\n    '7': (2,0),\n    '8': (2,1),\n    '9': (2,2),\n    '0': (3,1)\n}\n\ndef get_dist(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef check_same_finger_movements(num1, num2):\n    dist1 = 0\n    dist2 = 0\n    for i in range(n):\n        dist1 += get_dist(keypad[num1[i]], keypad[num1[i-1]])\n        dist2 += get_dist(keypad[num2[i]], keypad[num2[i-1]])\n    return dist1 == dist2\n\nsame_movements = False\nfor i in range(10**n):\n    num = str(i).zfill(n)\n    if check_same_finger_movements(number, num):\n        same_movements = True\n        break\n\nif same_movements:\n    print(\"NO\")\nelse:\n    print(\"YES\")"
 ],
 "127": [
  "n, f = map(int, input().split())\ndays = []\nfor i in range(n):\n    k, l = map(int, input().split())\n    days.append((k, min(k, l)))\n\ndays.sort(key=lambda x: -min(x[0], x[1]))\n\ntotal_products = sum(min(k, l) for (k, l) in days[:f])\ntotal_products += sum(min(k*2, l) for (k, l) in days[f:])\n\nprint(total_products)"
 ],
 "128": [
  "n, k = map(int, input().split())\nif n == 1:\n    print(0)\nelse:\n    if k > (n-1)//2:\n        k = (n-1)//2\n    max_messiness = k * n - k * (k+1)\n    print(max_messiness)"
 ],
 "129": [
  "import math\n\nn,m,k,l = map(int,input().split())\n\nif m > n:\n    print(\"-1\")\nelse:\n    x = math.ceil((l+k)/m)\n    if x*m > n:\n        print(\"-1\")\n    else:\n        print(x)"
 ],
 "130": [
  "n, m = map(int, input().split())\ncells = []\nfor i in range(n):\n    row = input()\n    cells.append([True if cell==\"B\" else False for cell in row])\n\nblack_cells = sum([sum(row) for row in cells])\nif black_cells == 0:\n    print(-1)\n    exit()\n\nmin_side = min(n, m)\n\nfor side_length in range(min_side, 0, -1):\n    for i in range(n - side_length + 1):\n        for j in range(m - side_length + 1):\n            if sum([sum(row[j:j+side_length]) for row in cells[i:i+side_length]]) == side_length ** 2:\n                print(black_cells - side_length ** 2)\n                exit()\nprint(-1)"
 ],
 "131": [
  "n = int(input())\nX = list(map(int, input().split()))\nY = list(map(int, input().split()))\n\ndiff = [Y[i] - X[i] for i in range(n)]\nsum_diff = sum(diff)\n\nif sum_diff < 0 or sum_diff % 2 != 0:\n    print(\"No\")\nelse:\n    half_diff = sum_diff // 2\n    s = set(X)\n    for x in X:\n        if x + half_diff in s:\n            print(\"Yes\")\n            break\n    else:\n        print(\"No\")"
 ],
 "132": [
  "n = int(input())\nangles = list(map(int, input().split()))\ntotal_angle = sum(angles)\nmin_diff = total_angle\nfor i in range(n):\n    cur_angle = angles[i]\n    for j in range(i+1, n):\n        cur_angle += angles[j]\n        diff = abs(total_angle - 2*cur_angle)\n        if diff < min_diff:\n            min_diff = diff\nprint(min_diff)"
 ],
 "133": [
  "n, m = map(int, input().split())\nMOD = 10**9+7\nans = pow((pow(2, m, MOD)-1), n, MOD)\nprint(ans)"
 ],
 "134": [
  "n = int(input())\nif n == 1:\n    print(-1)\nelse:\n    a = (n * n - 1) // 2\n    b = (n * n + 1) // 2\n    print(a, b)"
 ],
 "135": [
  "n, k = map(int, input().split())\nremainders = set()\n\nfor i in range(1, k+1):\n    remainder = n % i\n    if remainder in remainders:\n        print(\"No\")\n        break\n    remainders.add(remainder)\nelse:\n    print(\"Yes\")"
 ],
 "136": [
  "a = input().lstrip('0')\nb = input().lstrip('0')\nif len(a) > len(b):\n    print(\">\")\nelif len(a) < len(b):\n    print(\"<\")\nelse:\n    if a > b:\n        print(\">\")\n    elif a < b:\n        print(\"<\")\n    else:\n        print(\"=\")"
 ],
 "137": [
  "MOD = 10**9 + 7\nn, p = map(int, input().split())\ncolors = list(map(int, input().split()))\n\n# If we know the number of valid paths of all pieces numbered less than `i`, then it is\n# easy to calculate the number of valid paths for all pieces numbered exactly i. Let's\n# dp(i, j) be the number of ways to color and connect pieces numbered 1 to i, such that the\n# number of valid paths has parity j. The answer will be dp(n, p).\n# We can compute dp(i, j) by trying all the possible colors for piece i, all the possible\n# connections between i and pieces numbered less than i, and computing the contribution to\n# the valid paths with each choice. \n# Specifically, if we represent the valid paths with odd and even length separately, we \n# can update dp(i, j) using dp(i-1, j-k), where k = 0 or 1 depending on the number of \n# connections from piece i to pieces which have color different from i. \n\ndp = [[0 for _ in range(2)] for _ in range(n+1)]\ndp[0][0] = 1\ndp[0][1] = 0\n\nfor i in range(1, n+1):\n    if colors[i-1] == -1:\n        for j in range(2):\n            for k in range(2):\n                for l in range(i):\n                    if colors[l] != k-1:\n                        dp[i][j^((i-l-1)%2)^k] = (dp[i][j^((i-l-1)%2)^k] + dp[l][j]) % MOD\n    else:\n        for j in range(2):\n            for l in range(i):\n                if colors[l] != colors[i-1]:\n                    dp[i][j^((i-l-1)%2)] = (dp[i][j^((i-l-1)%2)] + dp[l][j]) % MOD\n\nprint(dp[n][p])"
 ],
 "138": [
  "n,a,b,c = map(int,input().split())\nrem = n%4\nif rem == 0:\n    print(0)\n    exit()\nif rem == 1:\n    k = 2\n    m = 1\nelif rem == 2:\n    k = 1\n    m = 2\nelse:\n    k = 0\n    m = 3\nprices = [a,b,c]\nprices.sort()\nprint(min(prices)*m + max(prices)*k)"
 ],
 "139": [
  "import sys\n\nsys.setrecursionlimit(10**6)\n\ndef dfs(node, visited, graph, parent):\n    visited[node] = True\n    for adj in graph[node]:\n        if adj == parent:\n            continue\n        if visited[adj]:\n            return True\n        if dfs(adj, visited, graph, node):\n            return True\n    return False\n\n\ndef is_acyclic(graph, n):\n    visited = [False] * (n + 1)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            if dfs(i, visited, graph, -1):\n                return False\n    return True\n\n\nn, m = map(int, input().split())\ngraph = [[] for i in range(n + 1)]\nfor i in range(m):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\nif is_acyclic(graph, n):\n    print(\"YES\")\nelse:\n    for i in range(1, n + 1):\n        for j in graph[i]:\n            graph[i].remove(j)\n            if is_acyclic(graph, n):\n                print(\"YES\")\n                exit()\n            graph[i].append(j)\n    print(\"NO\")"
 ],
 "140": [
  "n, m = map(int, input().split())\nantennas = []\nfor i in range(n):\n    x, s = map(int, input().split())\n    antennas.append((x, s))\n\nantennas.sort()\n\nmax_coverage = 0\ncost = 0\ni = 0\nwhile i < n and antennas[i][0] <= max_coverage + 1:\n    max_coverage = max(max_coverage, antennas[i][0] + antennas[i][1])\n    i += 1\n\ncost += max(0, (max_coverage - m))\n\nwhile i < n:\n    if max_coverage + 1 < antennas[i][0]:\n        return -1\n    curr_coverage = antennas[i][0] + antennas[i][1]\n    j = i + 1\n    while j < n and antennas[j][0] <= max_coverage + 1:\n        curr_coverage = max(curr_coverage, antennas[j][0] + antennas[j][1])\n        j += 1\n    cost += curr_coverage - max_coverage\n    max_coverage = curr_coverage\n    i = j\n\nprint(cost)"
 ],
 "141": [
  "w = int(input())\nitems = list(map(int, input().split()))\nans = 0\n\ndef dfs(weight, idx):\n    global ans\n    if idx == 9 or weight == w:\n        ans = max(ans, weight)\n        return\n    for i in range(items[idx]+1):\n        if weight + i * idx <= w:\n            dfs(weight + i * idx, idx+1)\n            \ndfs(0,1)\nprint(ans)"
 ],
 "142": [
  "n, L = map(int, input().split())\nc = list(map(int, input().split()))\n\nfor i in range(n-1, 0, -1):\n    c[i-1] = min(c[i-1], 2*c[i])\n    \nans = float('inf')\ntotal_vol = 0\nfor i in range(n):\n    vol = 2**i - 1\n    total_vol += vol\n    if total_vol >= L:\n        ans = min(ans, c[i])\n        break\n    for j in range(i):\n        if total_vol + 2**j*(2**i-1) >= L:\n            ans = min(ans, c[i]+c[j])\n            break\n\nprint(ans)"
 ],
 "143": [
  "n=int(input())\na=list(map(int,input().strip().split()))\na.sort()\nmex=1\nfor i in range(n):\n    if a[i]>=mex:\n        mex+=1\nprint(mex)"
 ],
 "144": [
  "n = int(input())\nticket = input().strip()\ntotal_sum = sum(list(map(int, list(ticket))))\nif total_sum % 2 == 0:\n    target_sum = total_sum // 2\n    curr_sum = 0\n    for i in range(n):\n        curr_sum += int(ticket[i])\n        if curr_sum == target_sum:\n            target_sum += total_sum // 2\n            curr_sum = 0\n    if curr_sum == 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    print(\"NO\")"
 ],
 "145": [
  "s = input()\nif len(set(s)) % 2 == 0:\n    print(\"CHAT WITH HER!\")\nelse:\n    print(\"IGNORE HIM!\")"
 ],
 "146": [
  "n, k = map(int, input().split())\ntabs = list(map(int, input().split()))\nmax_diff = 0\n\nfor b in range(n):\n    c = b\n    e_count = 0\n    s_count = 0\n    while c < n:\n        if tabs[c] == 1:\n            e_count += 1\n        else:\n            s_count += 1\n        c += k\n    max_diff = max(max_diff, abs(e_count - s_count))\n\nprint(max_diff)"
 ],
 "147": [
  "n, c0, c1 = map(int,input().split())\nif n == 1:\n    print(0)\nelse:\n    m = n - 1\n    print((n * min(c0, c1)) + (max(c0, c1) * m))"
 ],
 "148": [
  "n,a,x,b,y=map(int,input().split())\nwhile a!=x and b!=y:\n    if a==b:\n        print(\"YES\")\n        break\n    a=(a%n)+1\n    b=(b-2+n)%n+1\nelse:\n    print(\"NO\")"
 ],
 "149": [
  "x, y, l, r = map(int, input().split())\nnums = []\nfor i in range(64):\n    for j in range(64):\n        num = x**i + y**j\n        if l <= num <= r:\n            nums.append(num)\nnums = sorted(list(set(nums)))\nedges = [l - 1, r + 1]\nedges.extend(nums)\nedges = sorted(edges)\nmax_gap = 0\nfor i in range(len(edges)-1):\n    gap = edges[i+1] - edges[i] - 1\n    max_gap = max(max_gap, gap)\nprint(max_gap)"
 ],
 "150": [
  "n = int(input())\ni = 2\nwhile i*i <= n:\n    if n % i == 0:\n        while n % i == 0:\n            n //= i\n        break\n    i += 1\nif n > 1:\n    print(1)\nelse:\n    print(i)"
 ],
 "151": [
  "word = input().strip()\nvowels = ['a', 'e', 'i', 'o', 'u']\nconsonant_count = 0\nstart = 0\nresult = \"\"\n\nfor i in range(len(word)):\n    if i == len(word) - 1:  # If end of word is reached, process last block of consonants\n        if word[i] not in vowels:\n            consonant_count += 1\n        if consonant_count >= 3:\n            if str(set(word[start:i])) == \"{'\" + word[i] + \"'}\":\n                result += word[start:i+1]\n            else:\n                result += word[start:i] + \" \"\n                start = i\n    elif word[i] not in vowels:\n        consonant_count += 1\n    else:  # Vowel encountered, process previous block of consonants\n        if consonant_count >= 3:\n            if str(set(word[start:i])) == \"{'\" + word[i-1] + \"'}\":\n                result += word[start:i]\n            else:\n                result += word[start:i-1] + \" \"\n                start = i-1\n        else:\n            result += word[start:i] + word[i]\n            start = i + 1\n        consonant_count = 0\n\nprint(result)"
 ],
 "152": [
  "n,m,k = map(int,input().split())\nx,s = map(int,input().split())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\nc = list(map(int,input().split()))\nd = list(map(int,input().split()))\n\nmin_time = n*x\n\nfor i in range(m):\n    if b[i]<=s:\n        p = s-b[i]\n        j = bisect_right(d,p)\n        if j>0:\n            min_time = min(min_time,(n-c[j-1])*a[i])\n        else:\n            min_time = min(min_time, n*a[i])\n\nfor i in range(k):\n    if d[i]<=s:\n        j = bisect_right(c,n)\n        if j>i:\n            min_time = min(min_time,(n-c[j-1])*x)\n        else:\n            min_time = min(min_time,n*x)\n\nprint(min_time)"
 ],
 "153": [
  "n, k, M = map(int, input().split())\nt = list(map(int, input().split()))\n\nmax_points = 0\n\nfor subtasks_completed in range(k + 1):\n    total_time = sum(sorted(t)[:subtasks_completed]) * n + subtasks_completed\n    if total_time > M:\n        break\n    else:\n        max_points = subtasks_completed * n + min(n, (M - total_time) // sum(sorted(t)[:subtasks_completed] + [0]))\n\nprint(max_points)"
 ],
 "154": [
  "MOD = 998244353\n\nn = int(input())\n\ndp = [0] * (n + 1)\ndp[0] = 1\n\nfor i in range(1, n + 1):\n    dp[i] = pow(2, i - 1, MOD)\n    for j in range(i):\n        k = (i - 1) - j\n        if j >= k:\n            break\n        s = dp[j] * dp[k] % MOD\n        s = s * ((pow(2, k + 1, MOD) - 2) * dp[j] % MOD) % MOD\n        dp[i] = (dp[i] - s + MOD) % MOD\n\nif n % 2 == 0:\n    dp[n] = (dp[n] - dp[n // 2] + MOD) % MOD\n\nprint(dp[n])"
 ],
 "155": [
  "n, m, k = map(int, input().split())\nif k < n:\n    print(k+1, 1)\nelse:\n    k -= n\n    r = k // (m-1)\n    c = k % (m-1)\n    if r % 2 == 0:\n        print(n-r//2, c+2)\n    else:\n        print(n-r//2, m-c)"
 ],
 "156": [
  "x = int(input())\ni = 1\nwhile True:\n    j = x // i\n    if x % i == 0 and i*j == x:\n        print(i, j)\n        break\n    i += 1"
 ],
 "157": [
  "a = int(input())\nb = int(input())\nc = int(input())\n\nif b/2 <= a and c/4 <= a:\n    print(int(a+b+c))\nelse:\n    print(int(min(a, b//2, c//4)*7))"
 ],
 "158": [
  "n = int(input())\nratings = list(map(int, input().split()))\nratings.sort()\n\nif ratings[n-1] == ratings[n]:\n    print(\"NO\")\nelse:\n    print(\"YES\")"
 ],
 "159": [
  "from math import gcd\n\nn = int(input())\na = list(map(int, input().split()))\n\nmoves = 0\nnew_a = [a[0]]\n\nfor i in range(1, n):\n    if gcd(a[i], a[i-1]) == 1:\n        new_a.append(a[i])\n    else:\n        new_a.extend([1, a[i]])\n        moves += 1\n\nprint(moves)\nprint(*new_a)"
 ],
 "160": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\nlow, high = 1, max(a)\n\nwhile low < high:\n    mid = (low + high + 1) // 2\n    cnt = 0\n    for x in a:\n        cnt += (x + mid - 1) // mid - 1\n    if cnt <= k:\n        high = mid - 1\n    else:\n        low = mid\n\nprint(low)"
 ],
 "161": [
  "x = int(input())\nops = []\n\nwhile x:\n    m = x.bit_length() - 1  # find highest set bit\n    if x == (1 << m) - 1:  # if x is already perfect longcat\n        ops.append(0)\n        break\n    else:\n        ops.append(m)  # perform operation A with m\n        x ^= (1 << m) - 1  # apply operation A\n        if x & 1:  # if lowest bit is set\n            ops.append(0)  # perform operation B (add 1)\n            x += 1\nops_count = len(ops)\nprint(ops_count)\nfor i in range(ops_count):\n    print(ops[i], end=\" \")\n    if i % 2 == 1:\n        print()"
 ],
 "162": [
  "n, k = map(int, input().split())\nbuckets = list(map(int, input().split()))\nwatered = [False] * k\nhours = 0\n\nwhile not all(watered):\n    for i in range(n):\n        if k % buckets[i] == 0:\n            a = buckets[i]\n            break\n    else:\n        a = min(buckets)\n    \n    for i in range(k):\n        if not watered[i]:\n            for j in range(i, min(i+a, k)):\n                watered[j] = True\n            hours += 1\n            break\n            \nprint(hours)"
 ],
 "163": [
  "n, k = map(int, input().split())\nline = input()\ngrasshopper_pos = line.index(\"G\")\ninsect_pos = line.index(\"T\")\n\nfor i in range(grasshopper_pos, insect_pos, k if insect_pos>grasshopper_pos else -k):\n    if line[i] == \"#\":\n        print(\"NO\")\n        break\nelse:\n    print(\"YES\")"
 ],
 "164": [
  "import math\n\ndef check_validity(x_w, y_1, y_2, y_w, x_b, y_b, r):\n    theta2 = math.atan(((y_w - y_b)**2 - r**2)**0.5 / (x_w - x_b))\n    x_intersect = x_b + (y_w - y_b) / math.tan(theta2)\n    if x_intersect < 0 or x_intersect > x_w:\n        return False\n    theta1 = math.atan((y_b - y_1) / x_b)\n    tmp_theta = 2 * theta2 - theta1\n    theta_intersection = math.atan((y_w - y_b) / (x_intersect - x_b))\n    if tmp_theta < theta_intersection:\n        return True\n    else:\n        return False\n\ndef find_x_w(y_1, y_2, y_w, x_b, y_b, r):\n    max_x_w = x_b * y_w / y_b\n    min_x_w = 0\n    if not check_validity(max_x_w, y_1, y_2, y_w, x_b, y_b, r):\n        return -1\n    for i in range(10000):\n        mid_x_w = (max_x_w + min_x_w) / 2\n        if check_validity(mid_x_w, y_1, y_2, y_w, x_b, y_b, r):\n            max_x_w = mid_x_w\n        else:\n            min_x_w = mid_x_w\n    return min_x_w\n\ny_1, y_2, y_w, x_b, y_b, r = map(int, input().split())\nprint(\"%.10f\" % find_x_w(y_1, y_2, y_w, x_b, y_b, r))"
 ],
 "165": [
  "b, d, s = sorted(map(int, input().split()))\nprint(max(0, d + s - b - 2)//2 + max(0, s - d - 1) + max(0, b - s - 1))"
 ],
 "166": [
  "n = int(input())\npath = list(map(int, input().split()))\n\ndx1 = dx2 = dy1 = dy2 = 0\nfor i in range(1, n):\n    if path[i] == path[i-1]:\n        continue\n    r1, c1 = divmod(path[i-1]-1, y)\n    r2, c2 = divmod(path[i]-1, y)\n    dr, dc = r2-r1, c2-c1\n    if dr < dx1:\n        dx1 = dr\n    if dr > dx2:\n        dx2 = dr\n    if dc < dy1:\n        dy1 = dc\n    if dc > dy2:\n        dy2 = dc\n\nif dx1 <= dx2 and dy1 <= dy2:\n    print(\"YES\")\n    print(x, y)\nelse:\n    print(\"NO\")"
 ],
 "167": [
  "a = input()\nb = input()\n\ni = 0\nj = 0\nn = len(a)\nm = len(b)\nk = m - 1\n\nwhile i < n and j < m:\n    if a[i] == b[j]:\n        j += 1\n    i += 1\n\ni -= 1\nj -= 1\nans = ''\n\nwhile j >= 0:\n    if k < j or i < 0:\n        ans = '-'\n        break\n    \n    if a[i] == b[j]:\n        ans = a[i] + ans\n        i -= 1\n        j -= 1\n        k = j\n    else:\n        i -= 1\n\nprint(ans)"
 ],
 "168": [
  "n = int(input())\ns = input()\ncount = 0\nfor i in s:\n    if i == \"-\":\n        count -= 1\n        if count < 0: # we need to make sure that the count is always non-negative\n            count = 0\n    else:\n        count += 1\nprint(count)"
 ],
 "169": [
  "n = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\nif b - c >= a:\n    print(n // a)\nelse:\n    bottles = n // b\n    remaining_money = n - bottles * b\n    total_bottles = bottles\n    while remaining_money >= (b-c) and bottles > 0:\n        remaining_money -= (b-c)\n        bottles -= 1\n        total_bottles += 1\n    total_bottles += remaining_money // a\n    print(total_bottles)"
 ],
 "170": [
  "n = int(input())\nplayer_1_cards = input().split()[1:]\nplayer_2_cards = input().split()[1:]\ntable = []\nfights = 0\ncurrent_player = 1\n\nwhile True:\n    if not player_1_cards:\n        print(fights, 2)\n        break\n    elif not player_2_cards:\n        print(fights, 1)\n        break\n    elif fights > 1000:\n        print(-1)\n        break\n    else:\n        fights += 1\n        if current_player == 1:\n            table.append(player_1_cards.pop(0))\n            current_player = 2\n        else:\n            table.append(player_2_cards.pop(0))\n            current_player = 1\n        if len(table) == 2:\n            if int(table[0]) > int(table[1]):\n                player_1_cards.extend(table)\n                table = []\n            else:\n                player_2_cards.extend(table)\n                table = []\n                current_player = 1"
 ],
 "171": [
  "python\npassword = input()\nif len(password)>=5 and any(i.isdigit() for i in password) and any(i.islower() for i in password) and any(i.isupper() for i in password):\n    print(\"Correct\")\nelse:\n    print(\"Too weak\")"
 ],
 "172": [
  "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nexchanges = 0\nfor i in range(1, 6):\n    cnt_a = a.count(i)\n    cnt_b = b.count(i)\n    if (cnt_a + cnt_b) % 2 != 0:\n        print(-1)\n        break\n    else:\n        diff = abs(cnt_a - cnt_b) // 2\n        if cnt_a > cnt_b:\n            a_to_b = diff\n            b_to_a = 0\n        elif cnt_b > cnt_a:\n            a_to_b = 0\n            b_to_a = diff\n        else:\n            a_to_b = 0\n            b_to_a = 0\n        for j in range(len(a)):\n            if a[j] == i and a_to_b > 0:\n                if i in b:\n                    b.remove(i)\n                b.append(i)\n                a_to_b -= 1\n                exchanges += 1\n            elif b[j] == i and b_to_a > 0:\n                if i in a:\n                    a.remove(i)\n                a.append(i)\n                b_to_a -= 1\n                exchanges += 1\n        if a_to_b > 0 or b_to_a > 0:\n            print(-1)\n            break\nelse:\n    print(exchanges)"
 ],
 "173": [
  "n, m = map(int, input().split())\nhorizontal_direction = input()\nvertical_direction = input()\n\ngraph = [[] for _ in range(n * m)]\nreverse_graph = [[] for _ in range(n * m)]\n\nfor i in range(n):\n    for j in range(m):\n        node_num = i * m + j\n        if horizontal_direction[i] == \">\":\n            if j < m - 1:\n                graph[node_num].append(node_num + 1)\n                reverse_graph[node_num + 1].append(node_num)\n        else:\n            if j > 0:\n                graph[node_num].append(node_num - 1)\n                reverse_graph[node_num - 1].append(node_num)\n        if vertical_direction[j] == \"^\":\n            if i > 0:\n                graph[node_num].append(node_num - m)\n                reverse_graph[node_num - m].append(node_num)\n        else:\n            if i < n - 1:\n                graph[node_num].append(node_num + m)\n                reverse_graph[node_num + m].append(node_num)\n                \n\ndef dfs(node, visited, g):\n    visited[node] = True\n    for neighbor in g[node]:\n        if not visited[neighbor]:\n            dfs(neighbor, visited, g)\n            \ndef is_strongly_connected():\n    visited = [False] * (n * m)\n    dfs(0, visited, graph)\n    if False in visited:\n        return False\n    visited = [False] * (n * m)\n    dfs(0, visited, reverse_graph)\n    if False in visited:\n        return False\n    return True\n\nif is_strongly_connected():\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "174": [
  "n = int(input())\na = list(map(int, input().split()))\n\nif 0 not in a:\n    print(\"NO\")\nelse:\n    index = a.index(0) # find the index of the first occurrence of 0\n    \n    # place brackets around every implication to the right of this index\n    ans = \"1\" + \")-(\"*(n-1) + \">\"\n    for i in range(n-1):\n        if i < index:\n            ans = \"(\" + ans\n        if a[i+1] == 0:\n            ans += \"(\"\n        ans += str(a[i]) + \"->\"\n        if a[i+1] == 0:\n            ans += \")\"\n        if i >= index:\n            ans += \")\"\n    \n    print(\"YES\")\n    print(ans)"
 ],
 "175": [
  "a, b = map(int, input().split())\nwhile a > 0 and b > 0:\n    if a >= 2*b:\n        a %= 2*b\n    elif b >= 2*a:\n        b %= 2*a\n    else:\n        break\nprint(a, b)"
 ],
 "176": [
  "k, a, b = map(int, input().split())\nprint((b//k - (a-1)//k) if k!=1 else b-a+1)"
 ],
 "177": [
  "k = int(input())\ns = \"\"\nfor i in range(1, k + 1):\n    s += str(i)\nprint(s[k - 1])"
 ],
 "178": [
  "n = int(input())\ns = input()\n\ncount_8 = s.count(\"8\")\n \nif count_8 <= (n - 11)//2:\n    print(\"NO\")\nelse:\n    print(\"YES\")"
 ],
 "179": [
  "MOD = 10**9 + 7\n\nn, x, pos = map(int, input().split())\n\nleft, right = 0, n\nless, greater = x-1, n-x\nres = 1\nwhile left < right:\n    mid = (left + right) // 2\n    if mid == pos:\n        left = mid + 1\n    elif mid < pos:\n        res = res * (greater - (pos - mid - 1)) % MOD\n        greater -= 1\n        left = mid + 1\n    else:\n        res = res * (less - (mid - pos - 1)) % MOD\n        less -= 1\n        right = mid\n\nres = res * pow(greater + less + 1, MOD-2, MOD) % MOD \nprint(res if less >= 0 and greater >= 0 else 0)\n"
 ],
 "180": [
  "import sys\n\ns = input().strip()\nk = int(input().strip())\n\nif len(s) - s.count('?') - s.count('*') > k:\n    print('Impossible')\n    sys.exit()\n\ncount = k - (len(s) - s.count('*') - s.count('?'))\n\nif count < 0:\n    print('Impossible')\n    sys.exit()\n\nans = []\nfor i in range(len(s)-1):\n    if s[i] == '*' or s[i] == '?':\n        continue\n    if (s[i+1] == '*' or s[i+1] == '?') and count > 0:\n        count -= 1\n        if s[i+1] == '*':\n            ans.append(s[i] * (k - len(ans)-1))\n        else:\n            ans.append(s[i])\n    else:\n        ans.append(s[i])\n\nif s[-1] not in '*?' and len(ans) < k:\n    ans.append(s[-1])\n\nif len(ans) == k:\n    print(''.join(ans))\nelse:\n    print('Impossible')"
 ],
 "181": [
  "x = int(input())\nif x < 0:\n    x = abs(x)\n    if x % 90 == 0:\n        print(x//90)\n    elif x % 90 == 30:\n        print((x+30)//90)\n    elif x % 90 == 60:\n        print((x+30)//90 + 1)\n    else:\n        print((x+90)//90)\nelse:\n    if x % 90 == 0:\n        print(x//90)\n    elif x % 90 == 30:\n        print((x+60)//90)\n    elif x % 90 == 60:\n        print((x+30)//90)\n    else:\n        print((x+90)//90)"
 ],
 "182": [
  "a, b, c = map(int, input().split())\nx, y, z = map(int, input().split())\n\nblue_diff = x - a\nviolet_diff = y - b\norange_diff = z - c\n\nif blue_diff > 0:\n    violet_diff += blue_diff*2\nif violet_diff > 0:\n    orange_diff += violet_diff*2\n\nif orange_diff <= 0:\n    print(\"Yes\")\nelse:\n    print(\"No\")"
 ],
 "183": [
  "n, k, m = map(int, input().split())\ndp = [[0] * k for _ in range(n)]\nfor j in range(k):\n    dp[0][j] = 1\n    \nfor i in range(1, n):\n    for j in range(k):\n        for l in range(10):\n            dp[i][(j * 10 + l) % k] += dp[i-1][j]\n            \nans = 0\nfor j in range(k):\n    if j % k == 0:\n        ans = (ans + dp[n-1][j]) % m\n      \nprint(ans)"
 ],
 "184": [
  "l, r, a = map(int, input().split())\nif l > r: l, r = r, l\nif l + a >= r:\n    print(2 * ((r - l + a) // 2) + l)\nelse:\n    print(2 * l + 2 * a)"
 ],
 "185": [
  "n,k=map(int,input().split())\nprint(n+(n-2)+(2*min(k-1,n-k)))"
 ],
 "186": [
  "n,m=map(int,input().split())\ntwo=n*(n-1)//2+(n==1)*100000 #to avoid repetition\nthree=m*(m-1)//2+(m==1)*100000 #to avoid repetition\ni=1\nwhile True:\n    temp=i*(i+1)//2\n    if temp>max(two,three):\n        print(temp)\n        break\n    i+=1"
 ],
 "187": [
  "n = int(input())\ncards = []\nfor i in range(n):\n    cards.append(int(input()))\ncards.sort()\nif cards[0] == cards[-1]:\n    print(\"NO\")\nelse:\n    mid = sum(cards) // n\n    if sum(cards) % n != 0:\n        print(\"NO\")\n    else:\n        for i in range(n//2):\n            if cards[i]+cards[n-1-i] != mid:\n                print(\"NO\")\n                break\n        else:\n            print(\"YES\")\n            print(cards[n//2-1], cards[n//2])"
 ],
 "188": [
  "n, k = map(int, input().split())\ngroups = list(map(int, input().split()))\n\nseats = [0]*n*8\nfor i in range(k):\n    soldiers = groups[i]\n    j = 0\n    while soldiers > 0:\n        if j >= n*8:\n            print(\"NO\")\n            exit(0)\n        if seats[j] == 0 and (j%8 not in {2,3,6,7} or seats[j-1] == 0):\n            seats[j] = i+1\n            soldiers -= 1\n        j += 1\n\nprint(\"YES\")"
 ],
 "189": [
  "n = int(input())\nsticks = list(map(int, input().split()))\n \nans_t = 0\nans_cost = float('inf')\nfor t in range(1, 101):\n    cost = sum(abs(a - t - 1) if a >= t + 1 else abs(a - t) if a <= t else abs(a - t + 1) for a in sticks)\n    if cost < ans_cost:\n        ans_t = t\n        ans_cost = cost\n \nprint(ans_t, ans_cost)"
 ],
 "190": [
  "n, m = map(int, input().split())\nstars = []\nfor i in range(n):\n    stars.append(input())\nleft, right, top, bottom = m, 0, n, 0\nfor i in range(n):\n    for j in range(m):\n        if stars[i][j] == '*':\n            left = min(left, j)\n            right = max(right, j)\n            top = min(top, i)\n            bottom = max(bottom, i)\nlength = max(right - left, bottom - top) + 1\nprint(length)"
 ],
 "191": [
  "MOD = int(1e9+7)\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nif sum(a) == n or sum(a) == 0:\n    print(0)\nelse:\n    invq = pow(2 ** k, MOD-2, MOD)\n    p = 1\n    for l, r in [(i, j) for i in range(n-1) for j in range(i+1, n)]:\n        dp = [0] * (n+1)\n        dp[0] = 1\n        for i in range(1, n+1):\n            if i == l+1:\n                dp[i] = dp[i-1] * (a[r] - 1) % MOD\n            elif i == r+1:\n                dp[i] = dp[i-1] * a[l] % MOD\n            else:\n                dp[i] = dp[i-1] * ((1 - a[l]) * (1 - a[r]) + a[l] * a[r]) % MOD + dp[i-1] * (a[l] * (1 - a[r]) + (1 - a[l]) * a[r]) % MOD\n        p = (p + dp[n]) % MOD\n\n    print(p * invq % MOD)"
 ],
 "192": [
  "from math import ceil\nx, y = map(int, input().split())\nprint(ceil((x-y)/2))"
 ],
 "193": [
  "from math import sqrt\n\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\ndet = a*d - b*c\n\nif det == 0:\n    normA = max(abs(a), abs(b), abs(c), abs(d))\n    print('{:.10f}'.format(normA))\nelse:\n    lo = 0\n    hi = max(abs(a), abs(b), abs(c), abs(d))\n    while hi - lo > 1e-9:\n        mid = (lo + hi) / 2\n        discr = (a + mid)*(d + mid) - b*c\n        if discr >= 0:\n            hi = mid\n        else:\n            lo = mid\n    print('{:.10f}'.format(lo))"
 ],
 "194": [
  "n, a, b = map(int, input().split())\nt = list(map(int, input().split()))\n\none_seater = a\ntwo_seater = b\ndenied = 0\n\nfor i in range(n):\n    if t[i] == 1:\n        if one_seater > 0:\n            one_seater -= 1\n        elif two_seater > 0:\n            two_seater -= 1\n        elif two_seater == 0 and one_seater == 0 and one_seater < -1:\n            denied += 1\n        else:\n            one_seater -= 1\n            two_seater += 1\n    else:\n        if two_seater > 0:\n            two_seater -= 1\n        else:\n            denied += 2\n\nprint(denied)"
 ],
 "195": [
  "a, b, c, n = map(int, input().split())\nif a>n or b>n or c>n or (a-c)<0 or (b-c)<0 or (a+b-c)>n:\n    print(-1)\nelse:\n    print(n-(a+b-c))"
 ],
 "196": [
  "x, k = map(int, input().split())\nMOD = 10**9 + 7\nans = x\nfor i in range(k+1):\n    p = pow(2, i, MOD)\n    q = pow(2, k-i, MOD)\n    if i != k:\n        p -= 1\n    ans = (ans * (p * q + 1)) % MOD\nprint(ans)"
 ],
 "197": [
  "MOD = 998244353\n\n# Function to calculate inverse of a number using Extended Euclidean Algorithm\ndef mod_inverse(n):\n    return pow(n, MOD-2, MOD)\n\nn = int(input())\nproblems = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    problems.append((l, r))\n\n# Initialize dp table\ndp = [[0]*n for i in range(n)]\n\n# Populate first row of dp table\nfor j in range(n):\n    li, ri = problems[j]\n    dp[0][j] = (ri - li + 1) % MOD\n\n# Calculate dp table using recurrence relation\nfor i in range(1, n):\n    for j in range(n-i):\n        li, ri = problems[j]\n        total = 0\n        for k in range(j+1, n-i+1):\n            lj, rj = problems[k]\n            if lj > ri:\n                total += dp[i-1][k-1]\n        dp[i][j] = total % MOD\n\n# Calculate probability using total number of permutations and permutations with no inversions\ntotal_permutations = 1\nfor i in range(1, n+1):\n    total_permutations = (total_permutations * i) % MOD\n\ngood_permutations = 0\nfor i in range(n):\n    good_permutations = (good_permutations + dp[i][0]) % MOD\n\nprobability = (good_permutations * mod_inverse(total_permutations)) % MOD\nprint(probability)"
 ],
 "198": [
  "n = int(input())\ncount = 0\n\nfor i in range(1, int(n**0.5) + 1):\n    if n % i == 0:\n        factors = [i, n // i]\n        for j in range(2):\n            factor = factors[j]\n            if (n // factor) <= 2 * factor and (n // factor) > factor:\n                count += 1\n                \nprint(count)"
 ],
 "199": [
  "n, s = map(int, input().split())\nv = list(map(int, input().split()))\n\ntotal = sum(v)\nif total < s:\n    print(-1)\nelse:\n    min_vol_keg = min(v)\n    required_keg_vol = s/n\n    if min_vol_keg >= required_keg_vol:\n        print(required_keg_vol)\n    else:\n        remaining_vol = s - min_vol_keg\n        remaining_kegs = n - 1\n        remaining_kegs_vol = total - min_vol_keg\n        new_keg_vol = remaining_vol / remaining_kegs\n        if new_keg_vol <= required_keg_vol:\n            print(required_keg_vol)\n        else:\n            print(new_keg_vol)"
 ],
 "200": [
  "h1, h2 = map(int, input().split())\na, b = map(int, input().split())\nif a <= b and h1 + a*8 < h2:\n    print(-1)\nelse:\n    if a*12 >= h2-h1:\n        print(0)\n    else:\n        print(((h2 - h1 - 12 * a) // (12 * (a - b))) + min(((h2 - h1 - 12 * a) % (12 * (a - b)) != 0), 1))"
 ],
 "201": [
  "c, hr, hb, wr, wb = map(int, input().split())\nmax_joy = 0\n\nif wr > wb:\n    wr, wb = wb, wr # to make sure that wr is always less than or equal to wb\n \nif c >= wb:\n    # get the maximum number of red candies he can eat\n    max_red_candies = min(c // wr, int(1e13 // wr)) # considering very large c cases\n    # calculate the joy he can get by eating that many red candies\n    max_joy = max(max_joy, max_red_candies * hr)\n    \n    # calculate the remaining candy weight\n    remaining_weight = c - max_red_candies * wr\n    # get the maximum number of blue candies he can eat with remaining weight\n    max_blue_candies = min(remaining_weight // wb, int(1e13 // wb)) # considering very large c cases\n    # calculate the joy he can get by eating that many blue candies\n    max_joy = max(max_joy, max_blue_candies * hb + max_red_candies * hr)\n\nif wb > c:\n    # we can only eat the blue candies with the given weight\n    max_blue_candies = min(c // wb, int(1e13 // wb)) # considering very large c cases\n    max_joy = max(max_joy, max_blue_candies * hb)\n    \n    # calculate the remaining candy weight\n    remaining_weight = c - max_blue_candies * wb\n    # get the maximum number of red candies he can eat with remaining weight\n    max_red_candies = min(remaining_weight // wr, int(1e13 // wr)) # considering very large c cases\n    # calculate the joy he can get by eating that many red candies\n    max_joy = max(max_joy, max_blue_candies * hb + max_red_candies * hr)\n\nprint(max_joy)"
 ],
 "202": [
  "x1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\ndx = abs(x1 - x2)\ndy = abs(y1 - y2)\nd = min(dx, dy)\nans = d * 2\ndx -= d\ndy -= d\nif dx > 0 or dy > 0:\n    ans += 2 * (dx // 2 + dy // 2)\n    if dx % 2 == 1 or dy % 2 == 1:\n        ans += 1\nprint(ans)"
 ],
 "203": [
  "n=int(input())\ns=input()\nc1=s.count('R')\nc2=s.count('D')\nwhile c1>0 and c2>0:\n    R=-1\n    D=-1\n    for i in range(n):\n        if s[i]=='R':\n            if R==-1:\n                R=i\n        else:\n            if D==-1:\n                D=i\n        if D!=-1 and R!=-1:\n            break\n    if R<D:\n        s=s[:R]+'X'+s[R+1:]\n        c1-=1\n    else:\n        s=s[:D]+'X'+s[D+1:]\n        c2-=1\n    i=1\n    while c1>0 and c2>0 and i<n:\n        if s[(R+i)%n]=='R':\n            c1-=1\n        elif s[(D+i)%n]=='D':\n            c2-=1\n        i+=1\nprint('D' if c1>0 else 'R')"
 ],
 "204": [
  "a, b, x, y = map(int, input().split())\ngcd_xy = gcd(x, y)\nx //= gcd_xy\ny //= gcd_xy\nmin_ratio = min(a // x, b // y)\nprint(min_ratio)"
 ],
 "205": [
  "n, b = map(int, input().split())\np = 0\nq = b\nwhile q <= n:\n    p += n // q\n    q *= b\nprint(p)"
 ],
 "206": [
  "m, a, b = map(int, input().split())\n\ndef f(x):\n    if x < 0:\n        return 0\n    if x == 0:\n        return 1\n    s = f(x - a) + f(x - b)\n    return s - f(x - a - b)\n\nans = 0\nfor i in range(m + 1):\n    ans += f(i)\nprint(ans)"
 ],
 "207": [
  "n = int(input())\na = list(map(int, input().split()))\n\nodd_count = 0\nfor i in range(n):\n    if a[i] % 2 != 0:\n        odd_count += 1\n\nif odd_count % 2 != 0:\n    print(\"No\")\nelse:\n    if a[0] % 2 != 0 and a[-1] % 2 != 0:\n        print(\"Yes\")\n    else:\n        print(\"No\")"
 ],
 "208": [
  "x1, y1, x2, y2 = map(int, input().split())\n\nif x1 == x2:\n    diff = abs(y1 - y2)\n    print(x1 + diff, y1, x2 + diff, y2)\nelif y1 == y2:\n    diff = abs(x1 - x2)\n    print(x1, y1 + diff, x2, y2 + diff)\nelif abs(x1 - x2) == abs(y1 - y2):\n    print(x1, y2, x2, y1)\nelse:\n    print(-1)"
 ],
 "209": [
  "x, y = map(int, input().split())\nn = int(input())\nmod = 1000000007\n \ndef matrix_multiply(a, b):\n    c = [[0] * 2 for _ in range(2)]\n    for i in range(2):\n        for j in range(2):\n            for k in range(2):\n                c[i][k] = (c[i][k] + a[i][j] * b[j][k]) % mod\n    return c\n \ndef matrix_pow(matrix, n):\n    res = [[1, 0], [0, 1]]\n    while n > 0:\n        if n & 1:\n            res = matrix_multiply(res, matrix)\n        matrix = matrix_multiply(matrix, matrix)\n        n >>= 1\n    return res\n \ndef get_fn(x, y, n):\n    if n == 1:\n        return x\n    if n == 2:\n        return y\n    matrix = [[1, 1], [1, 0]]\n    res = matrix_pow(matrix, n - 2)\n    return (y * res[0][0] + x * res[1][0]) % mod\n \nprint(get_fn(x, y, n))"
 ],
 "210": [
  "n = int(input())\narr = list(map(int,input().split()))\ns = sum(arr)\nif s != 0:\n    print(\"YES\")\n    ans = []\n    ans.append([1, n])\nelse:\n    found = False\n    print(\"NO\")\n    for i in range(n):\n        if arr[i] != 0 and not found:\n            found = True\n            ans = []\n            ans.append([i+1,i+1])\n            print(\"YES\")\n        elif arr[i] == 0 and found:\n            ans[-1][1] += 1\n        elif arr[i] != 0 and found:\n            ans.append([i+1,i+1])\n            ans[-1][1] += 1\n    print(len(ans))\n    for i in ans:\n        print(*i)"
 ],
 "211": [
  "n, m, k = map(int, input().split())\nmod = 1000000009\nif m == 0:\n    print(0)\nelse:\n    min_points = 1\n    max_points = m\n    while min_points < max_points:\n        mid = (min_points+max_points)//2\n        if ((mid*(mid-1)//2) + (m-mid))*k + mid >= n:\n            max_points = mid\n        else:\n            min_points = mid+1\n    if min_points*(min_points-1)//2 + (m-min_points) < n:\n        print(m)\n    else:\n        print((((n-min_points*(min_points-1)//2))*k + min_points)%mod))"
 ],
 "212": [
  "n = input()\nif '0' in n:\n    print(\"YES\")\n    print(\"0\")\n    exit()\nif '8' in n or '0' in n or '00' in n:\n    print(\"YES\")\n    exit()\nfor i in range(1, 10):\n    for j in range(10):\n        for k in range(10):\n            num = str(i) + str(j) + str(k)\n            if int(num) % 8 == 0:\n                index_i = n.find(str(i))\n                if index_i == -1:\n                    continue\n                index_j = n.find(str(j), index_i + 1)\n                if index_j == -1:\n                    continue\n                index_k = n.find(str(k), index_j + 1)\n                if index_k == -1:\n                    continue\n                print(\"YES\")\n                print(num)\n                exit()\nprint(\"NO\")"
 ],
 "213": [
  "n, m = map(int, input().split())\npairs = []\nfor i in range(m):\n    k, f = map(int, input().split())\n    pairs.append((k, f))\n    \nfloors = set()\nfor p in pairs:\n    floors.add(p[1])\n\npossible_floors = []\nfor f in range(1, 101):\n    if all(((k-1)//f + 1) == p[1] for k, p in pairs):\n        possible_floors.append(f)\n\ncount = 0\nfloor = -1\nfor f in possible_floors:\n    cur_count = (n-1)//f + 1\n    if count == 0:\n        count = cur_count\n        floor = f\n    elif count != cur_count:\n        print(-1)\n        exit()\n        \nprint(floor)"
 ],
 "214": [
  "s1=input()\ns2=input()\nans = 0\nfor i in range(len(s1)):\n    if s1[i] == '0' and s2[i] == '0':\n        if i == 0 or s1[i-1] == '0' and s2[i-1] == '0':\n            ans += 1\n        elif i > 0 and i < len(s1)-1 and s1[i-1] == 'X' and s2[i-1] == 'X' and s1[i+1] == '0' and s2[i+1] == '0':\n            ans += 1\nprint(ans)"
 ],
 "215": [
  "n = int(input())\ns = input()\n\nans = 0\nfor i in range(n):\n    letters = set()\n    for j in range(i, n):\n        if s[j].islower():\n            if s[j] not in letters:\n                letters.add(s[j])\n                ans = max(ans, len(letters))\n        else:\n            break\nprint(ans)"
 ],
 "216": [
  "n = int(input())\na = list(map(int, input().split()))\n\na.sort(reverse=True)\nb = sum(filter(lambda x: x > 0, a))\nc = sum(a) - b\n\nprint(b - c)"
 ],
 "217": [
  "a, b, f, k = map(int, input().split())\n\nif b < f or b < a-f:\n    print(-1)\n    exit()\n    \nx = [0, f]\nfor i in range(1, k+1):\n    if i % 2 == 0:\n        x.append(a-f + x[-2])\n    else:\n        x.append(f + x[-2])\n        \nrefuels = 0\nd = b\nfor i in range(1, len(x)):\n    d_needed = x[i] - x[i-1]\n    if d_needed > d:\n        refuels += 1\n        d = b\n        if d_needed > d:\n            print(-1)\n            exit()\n    d -= d_needed\n    \nprint(refuels)"
 ],
 "218": [
  "n, p, q = map(int, input().split())\ns = input()\n\nfor i in range(n//p + 1):\n    for j in range((n-i*p)//q + 1):\n        if i*p+j*q == n:\n            ans = []\n            start = 0\n            for k in range(i):\n                ans.append(s[start:start+p])\n                start += p\n            for k in range(j):\n                ans.append(s[start:start+q])\n                start += q\n            print(len(ans))\n            print('\\n'.join(ans))\n            exit()\n\nprint(-1)"
 ],
 "219": [
  "n, m, s, d = map(int, input().split())\nobstacles = list(map(int, input().split()))\n\ncur_pos = 0\nfor obs in sorted(obstacles):\n    if obs - cur_pos <= s:\n        print('IMPOSSIBLE')\n        break\n    else:\n        remaining_dist = obs - cur_pos - 1\n        num_jumps = remaining_dist // d\n        remaining_dist -= num_jumps * d\n        if remaining_dist < s:\n            remaining_dist += d\n            num_jumps -= 1\n        # make the jumps\n        jump_count = 0\n        run_count = 0\n        while num_jumps > 0:\n            print('RUN', s)\n            run_count += s\n            print('JUMP', d)\n            jump_count += d\n            num_jumps -= 1\n            remaining_dist -= s + d\n        if remaining_dist > 0:\n            print('RUN', remaining_dist)\n            run_count += remaining_dist\n        if obs == obstacles[-1]:\n            remaining_dist = m - obs\n            if remaining_dist > s:\n                print('RUN', remaining_dist)\n                run_count += remaining_dist\n            else:\n                print('IMPOSSIBLE')\n        cur_pos = obs"
 ],
 "220": [
  "s, x = map(int, input().split())\nif (s - x) % 2 == 1 or s < x:\n  print(0)\nelse:\n  a_xor_b = (s - x) // 2\n  a, b = 0, 0\n  while a_xor_b:\n    if a_xor_b % 2 == 1 and x & 1 == 1:\n      print(0)\n      break\n    elif a_xor_b % 2 == 1:\n      a |= 1 << b\n      b += 1\n    elif x & 1 == 1:\n      a |= 1 << b\n      b += 1\n    x //= 2\n    a_xor_b //= 2\n  else:\n    print(1 << bin(s - x).count('1'))"
 ],
 "221": [
  "n, k = map(int, input().split())\n\nturning_points = []\nfor i in range(1, n+1, 2*k+1):\n    turning_points.append(i)\n\nif turning_points[-1] != n:\n    turning_points.append(n)\n\nnum_turns = len(turning_points) - 1\nprint(num_turns)\n\nfor i in range(num_turns):\n    skewer_to_turn = (turning_points[i] + turning_points[i+1]) // 2\n    print(skewer_to_turn, end=' ')"
 ],
 "222": [
  "n = input()\nans = -1 # default answer if it is impossible to make a square\n\nfor i in range(len(n)):\n    if n[i] in ['0', '4', '9']:\n        possible_square = int(n[:i]+n[i+1:]) # delete the i-th digit\n        if possible_square != 0 and int(possible_square**0.5)**2 == possible_square:\n            # check if the resulting number is a perfect square\n            # and also check if it is not equal to zero (to avoid leading zeroes)\n            if ans == -1 or ans > 1: # update answer if it's not yet updated or the new answer is smaller\n                ans = len(n) - len(str(possible_square)) \n                # calculate the number of deleted digits by subtracting \n                # the length of resulting square from the length of original number\n\nprint(ans) # print the final answer"
 ],
 "223": [
  "MOD = 10**9+7\n\ndef solve(n):\n    ans = 1\n    cnt = [0]*(n+1)\n    for i in range(2,n+1):\n        if cnt[i] == 0:\n            for j in range(i,n+1,i):\n                cnt[j] += 1\n        ans = (ans * (cnt[i]+1)) % MOD\n    return ans\n\nn = int(input())\nprint(solve(n))"
 ],
 "224": [
  "s = input().strip()\nvowels = \"AEIOUY\"\nmax_jump = 0\njump = 0\nfor i in range(len(s)):\n    if s[i] in vowels:\n        jump = i - max_jump\n        max_jump = i\n    if jump > max_jump:\n        max_jump = jump\nif len(s) - max_jump > max_jump:\n    max_jump = len(s) - max_jump\nprint(max_jump)"
 ],
 "225": [
  "a1, a2, a3, a4 = map(int, input().split())\nif (a1+a2+a3+a4) % 2 == 0 and ((a1+a2+a3) == (a4) or (a1+a2+a4) == (a3) or (a1+a3+a4) == (a2)):\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "226": [
  "n = int(input())\npies = list(map(int, input().split()))\nalice_pie = 0\nbob_pie = 0\n\nwhile pies:\n    if len(pies) == 1:\n        alice_pie += pies[0]\n        break\n    elif len(pies) == 2:\n        alice_pie += max(pies)\n        bob_pie += min(pies)\n        break\n    else:\n        a, b, c = pies[:3]\n        if a + c > 2*b: # Alice takes both ends\n            alice_pie += a + c\n            pies = pies[1:-1]\n        else:\n            alice_pie += b\n            bob_pie += b\n            pies = pies[2:]\n\nprint(alice_pie, bob_pie)"
 ],
 "227": [
  "n = int(input())\na = list(map(int, input().split()))\n\n# Initialize dp array with -1 for all possible combinations of bits up to 2^n\ndp = [[-1] * (1 << n) for i in range(n + 1)]\nfor i in range(n):\n    dp[1][1 << i] = a[i]\n\n# Iterate over each possible number of variables\nfor i in range(2, n+1):\n    # Iterate over all possible combinations of variables\n    for j in range(1<<n):\n        # Iterate over all possible subsets of the combination of variables j\n        for k in range(j):\n            if bin(k).count(\"1\") == i-2:\n                # Calculate the sum of values stored in the variables k and j-k\n                sum1, sum2 = 0, 0\n                for l in range(n):\n                    if (1 << l) & k:\n                        sum1 += dp[i-1][1 << l]\n                    elif (1 << l) & (j-k):\n                        sum2 += dp[i-1][1 << l]\n                \n                # Check if the value of the current operation matches with the sum\n                for l in range(n):\n                    if a[l] == sum1 + sum2:\n                        dp[i][j] = a[l]\n                        break\n        # If it is not possible to perform the sequence of operations with i variables, break the loop\n        if dp[i][j] == -1:\n            break\n\n# Find the minimum number of variables required to perform the sequence of operations\nfor i in range(n, 0, -1):\n    for j in range(1 << n):\n        if dp[i][j] != -1:\n            print(i)\n            exit()\n\n# If it is not possible to perform the sequence of operations with any number of variables, print -1\nprint(-1)"
 ],
 "228": [
  "n = int(input())\na = list(map(int, input().split()))\n\ns = sum(a)\nm = max(a)\n\nif m > s/2:\n    print(\"Bob\")\nelse:\n    print(\"Alice\")"
 ],
 "229": [
  "n = int(input())\na = list(map(int, input().split()))\nsorted_a = sorted(a)\n\nif sorted_a[0] == sorted_a[-1]:\n    print(\"YES\")\nelif n < 3:\n    print(\"NO\")\nelif n == 3:\n    if (sorted_a[0] + sorted_a[2]) == 2 * sorted_a[1]:\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    x = sorted_a[1] - sorted_a[0]\n    for i in range(2, n):\n        if sorted_a[i] - sorted_a[i-1] != x:\n            if (sorted_a[i] - sorted_a[i-1] != 2*x) or (sorted_a[i-2]+x != sorted_a[i]):\n                print(\"NO\")\n                break\n    else:\n        print(\"YES\")"
 ],
 "230": [
  "n = int(input())\ns = input()\nans = 0\nfor i in range(n):\n    for j in range(i+1,n):\n        if s[i:j] == s[j:j+j-i]:\n            ans = max(ans, j-i)\nprint(ans)"
 ],
 "231": [
  "n,a = map(int,input().split())\nif a<=n/2:\n    print(a + (a-1))\nelse:\n    print(n-a+1 + n%2 +(n-a)//2)"
 ],
 "232": [
  "n, m = map(int, input().split())\ncolors = list(map(int, input().split()))\ncounts = list(map(int, input().split()))\n\nfor i in range(n):\n    end = i\n    cur_counts = [0] * m\n    for j in range(i, n):\n        cur_counts[colors[j]-1] += 1\n        if cur_counts == counts:\n            print(\"YES\")\n            quit()\n        elif cur_counts > counts:\n            break\n\nprint(\"NO\")"
 ],
 "233": [
  "n = int(input())\nm_total = 0\nc_total = 0\n\nfor i in range(n):\n    m, c = map(int, input().split())\n    if m > c:\n        m_total += 1\n    elif c > m:\n        c_total += 1\n\nif m_total > c_total:\n    print(\"Mishka\")\nelif c_total > m_total:\n    print(\"Chris\")\nelse:\n    print(\"Friendship is magic!^^\")"
 ],
 "234": [
  "n, m = map(int, input().split())\nfield = [input() for _ in range(n)]\nvalid = True\n \nfor i in range(n):\n    for j in range(m):\n        if field[i][j] == '*':\n            continue\n        count_bombs = 0\n        for dx in range(-1, 2):\n            for dy in range(-1, 2):\n                ni, nj = i + dx, j + dy\n                if ni < 0 or ni >= n or nj < 0 or nj >= m:\n                    continue\n                if field[ni][nj] == '*':\n                    count_bombs += 1\n        if field[i][j] == '.':\n            valid = valid and count_bombs == 0\n        else:\n            valid = valid and count_bombs == int(field[i][j])\nprint(\"YES\" if valid else \"NO\")"
 ],
 "235": [
  "n = int(input())\n\ndef check(k):\n    eaten = 0\n    i = 0\n    leftover = n\n    while leftover > 0:\n        today_eaten = min(k, leftover)\n        eaten += today_eaten\n        leftover -= today_eaten\n        i += 1\n        if i % 2 == 0:\n            petya_eaten = leftover // 10\n            if petya_eaten >= 10:\n                leftover -= petya_eaten\n            else:\n                leftover -= leftover % 10\n    return eaten >= (n+1)//2\n\nl = 1\nr = n\nwhile l < r:\n    mid = (l + r) // 2\n    if check(mid):\n        r = mid\n    else:\n        l = mid + 1\n\nprint(l)"
 ],
 "236": [
  "necklace = input()\npearl_count = necklace.count('o')\nlink_count = necklace.count('-')\nif pearl_count == 0 or link_count % pearl_count == 0:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "237": [
  "n, m, k = map(int, input().split())\nlow, high = 1, m\n\nwhile low < high:\n    mid = (low + high + 1) // 2\n    left = k - 1\n    right = k + 1\n    pillows = 1\n    \n    while left > 0 and right <= n and pillows <= m:\n        pillows += 2\n        left -= 1\n        right += 1\n        \n    while left >= 0 and right <= n and pillows <= m:\n        pillows += 1\n        left -= 1\n        right += 1\n    \n    while left >= 0 and right > n and pillows <= m:\n        pillows += 1\n        left -= 1\n    \n    if pillows <= m:\n        low = mid\n    else:\n        high = mid - 1\n\nprint(high)"
 ],
 "238": [
  "n, m, k = map(int, input().split())\na = list(map(int, input().split()))\n\ndp = [[-float('inf')] * (m + 1) for _ in range(2)]\ncur, prv = 0, 1\nans = 0\n\nfor i in range(n):\n    dp[cur][0] = 0\n    for j in range(1, m + 1):\n        dp[cur][j] = max(dp[prv][j - 1], dp[cur][j - 1] + a[i] - (j * ((i + 1) % m == 0 and i > 0) * k))\n        \n    ans = max(ans, dp[cur][0])\n    for j in range(1, m + 1):\n        ans = max(ans, dp[cur][j] - j * ((i + 1) % m == 0 and i > 0) * k)\n        \n    cur, prv = prv, cur\n    \nprint(ans)"
 ],
 "239": [
  "n, m = map(int, input().split())\n\nif n <= m:\n    print(0, m)\n    print(n, 0)\n    print(n, m-n)\n    print(0, 0)\nelse:\n    print(n, 0)\n    print(0, m)\n    print(n-m, m)\n    print(0, 0)"
 ],
 "240": [
  "from collections import Counter\ns = input().strip()\nt = input().strip()\nn = len(s)-len(t)\ncnt_s = Counter(s)\ncnt_t = Counter(t)\n\nfor i in range(10):\n    if cnt_s[str(i)] < cnt_t[str(i)]:\n        x = str(i)\n        n += 1\n        break\n        \nres = [x]*(n+cnt_t['0'])\nfor i in range(10):\n    res += [str(i)]*cnt_s[str(i)]\nprint(\"\".join(res))"
 ],
 "241": [
  "n, m, min_temp, max_temp = map(int, input().split())\ntemperatures = list(map(int, input().split()))\n\nif min(temperatures) < min_temp or max(temperatures) > max_temp:\n    print(\"Incorrect\")\nelse:\n    remaining_temperatures = n - m\n    min_remaining = min_temp - min(temperatures)\n    max_remaining = max_temp - max(temperatures)\n    total_remaining = min_remaining + max_remaining\n    if remaining_temperatures >= total_remaining and remaining_temperatures % 2 == total_remaining % 2:\n        print(\"Correct\")\n    else:\n        print(\"Incorrect\")"
 ],
 "242": [
  "from math import log, floor\n\nm = int(input())\n\nif m % 5 != 0:\n    print(0)\nelse:\n    k = 0\n    res = []\n    for i in range(1, 10**6 + 1):\n        if i % 5 == 0:\n            num_fives = 1\n            while i % (5**(num_fives + 1)) == 0:\n                num_fives += 1\n            if num_fives == m:\n                k += 1\n                res.append(i)\n    print(k)\n    print(*res)"
 ],
 "243": [
  "from collections import defaultdict\nfrom heapq import heappop, heappush\nimport sys\ninput = sys.stdin.readline\n\nn, m, k = map(int, input().split())\n\nspecial = {int(x): i for i, x in enumerate(input().split(), start=1)}\n\ngraph = defaultdict(list)\nfor _ in range(m):\n    u, v, w = map(int, input().split())\n    graph[u].append((v, w))\n    graph[v].append((u, w))\n\n\ndef dijkstra(start):\n    dist = [-1] * (n+1)\n    dist[start] = 0\n    heap = [(0, start)]\n    while heap:\n        udist, u = heappop(heap)\n        if dist[u] != -1 and dist[u] < udist:\n            continue\n        for v, w in graph[u]:\n            if dist[v] == -1 or max(udist, w) < dist[v]:\n                dist[v] = max(udist, w)\n                heappush(heap, (dist[v], v))\n    return dist\n\nans = []\nfor i in range(1, k+1):\n    dist = dijkstra(special[i])\n    ans.append(max(dist[x] for x in special.values() if x != i))\n\nprint(*ans)"
 ],
 "244": [
  "n = int(input())\nx = int(input())\n\nfor i in range(n%6):\n    if i%2 == 0:\n        if x == 0:\n            x = 1\n        elif x == 1:\n            x = 0\n    else:\n        if x == 1:\n            x = 2\n        elif x == 2:\n            x = 1\n\nprint(x)"
 ],
 "245": [
  "n = int(input())\ns = set()\narea = 0\nfor i in range(n):\n    x1, y1, x2, y2 = map(int, input().split())\n    for x in range(x1, x2):\n        for y in range(y1, y2):\n            if (x, y) in s:\n                s.remove((x, y))\n            else:\n                s.add((x, y))\n    area += (x2 - x1) * (y2 - y1)\nif not s and int(area ** 0.5) ** 2 == area:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "246": [
  "n, s = map(int, input().split())\n\ndef get_sum(x):\n    res = 0\n    while x > 0:\n        res += x % 10\n        x //= 10\n    return res\n\nleft, right = 1, n\nans = 0\nwhile left <= right:\n    mid = (left + right) // 2\n    if mid - get_sum(mid) >= s:\n        ans = mid\n        right = mid - 1\n    else:\n        left = mid + 1\n\nprint(n - ans + 1)"
 ],
 "247": [
  "n = int(input())\npoints = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    points.append((x, y))\n\nif n <= 4:\n    print(\"YES\")\nelse:\n    def check_line(p1, p2, p3):\n        return (p3[1]-p1[1])*(p2[0]-p1[0]) == (p2[1]-p1[1])*(p3[0]-p1[0])\n\n    for i in range(n):\n        for j in range(i+1, n):\n            line1 = [points[i], points[j]]\n            valid = True\n            for k in range(n):\n                if k != i and k != j:\n                    if not check_line(line1[0], line1[1], points[k]):\n                        valid = False\n                        break\n            if valid:\n                print(\"YES\")\n                exit()\n    print(\"NO\")"
 ],
 "248": [
  "a, b, k, t = map(int, input().split())\nmod = 10**9 + 7\ndp = [[0]*(a+b+1) for _ in range(t+1)]\ndp[0][a] = 1\nfor i in range(1, t+1):\n    for j in range(a+b+1):\n        for l in range(-k, k+1):\n            if 0 <= j+l <= a+b:\n                if l < 0:\n                    dp[i][j] += dp[i-1][j+l]\n                else:\n                    dp[i][j] += dp[i-1][j+l]\n                dp[i][j] %= mod\nres = 0\nfor i in range(a+1, a+b+1):\n    res = (res + dp[t][i]) % mod\nprint(res)"
 ],
 "249": [
  "n, l, x, y = map(int, input().split())\na = list(map(int, input().split()))\n\ns = set(a)\nans = []\n\nif x in s and y in s:\n    print(0)\nelif x in s:\n    ans.append(y)\n    print(1)\n    print(*ans)\nelif y in s:\n    ans.append(x)\n    print(1)\n    print(*ans)\nelse:\n    for i in range(n):\n        if a[i] + x in s and a[i] + y in s:\n            print(0)\n            exit()\n        elif a[i] + x in s:\n            ans.append(a[i] + y)\n            break\n        elif a[i] + y in s:\n            ans.append(a[i] + x)\n            break\n    else:\n        for i in range(n):\n            if a[i] - x in s and a[i] + y in s:\n                ans.append(a[i] - x)\n                ans.append(a[i] + y)\n                break\n            elif a[i] - y in s and a[i] + x in s:\n                ans.append(a[i] - y)\n                ans.append(a[i] + x)\n                break\n        else:\n            ans.append(x)\n            ans.append(y)\n    print(len(ans))\n    print(*ans)\n"
 ],
 "250": [
  "import math\n \nn = int(input())\ncakes = []\nfor i in range(n):\n    r, h = map(int, input().split())\n    cakes.append((r, h))\n \nvolumes = [0] * n\nfor i in range(n):\n    volume = math.pi * cakes[i][0] ** 2 * cakes[i][1]\n    volumes[i] = volume\n \ndp = [0] * n\nfor i in range(n):\n    dp[i] = volumes[i]\n \nfor i in range(n):\n    for j in range(i):\n        if cakes[i][0] > cakes[j][0] and cakes[i][1] > cakes[j][1]:\n            dp[i] = max(dp[i], dp[j] + volumes[i])\n \nprint(\"%.10f\" % max(dp))"
 ],
 "251": [
  "n, k = map(int, input().split())\nh = list(map(int, input().split()))\nh.sort()\nans = 0\nwhile len(h) > 1:\n    diff = h[-1] - h[0]\n    if diff * len(h) <= k:\n        ans += diff\n        k -= diff * len(h)\n        h.pop()\n        h[0] += diff\n    else:\n        num_slices = k // len(h)\n        ans += num_slices\n        break\nprint(ans)"
 ],
 "252": [
  "n = int(input())\na = list(map(int, input().split()))\n\n# Compute prefix sum\npref_sum = [0] * (n+1)\nfor i in range(n):\n    pref_sum[i+1] = pref_sum[i] + a[i]\n\n# Compute suffix sum\nsuff_sum = [0] * (n+1)\nfor i in range(n-1, -1, -1):\n    suff_sum[i] = suff_sum[i+1] + a[i]\n\n# Find index j that minimizes segment score\nmin_score_index = 1\nmin_score = pref_sum[1] + suff_sum[1]\nfor j in range(2, n+1):\n    score = pref_sum[j] + suff_sum[j]\n    if score < min_score:\n        min_score = score\n        min_score_index = j\n\n# Find the maximum segment score, considering Bob's move\nmax_score = 0\nfor i in range(1, n+1):\n    if i < min_score_index:\n        score = pref_sum[i] + suff_sum[min_score_index-1] - pref_sum[i] - a[i-1]\n    elif i > min_score_index:\n        score = pref_sum[min_score_index] + suff_sum[i] - suff_sum[min_score_index] - a[i-1]\n    else:\n        score = 0\n    max_score = max(max_score, score)\n\nprint(max_score)"
 ],
 "253": [
  "k1, k2, k3 = map(int, input().split())\n\nif 2 * max(k1, k2, k3) >= (k1 + k2 + k3):\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "254": [
  "n = int(input())\ns = input()\n\ndp = [[0] * n for _ in range(n)]\n\nfor length in range(1, n+1):\n    for i in range(n-length+1):\n        j = i + length - 1\n        if length == 1:\n            dp[i][j] = 1\n        else:\n            dp[i][j] = 1 + dp[i+1][j]\n            for k in range(i+1, j+1):\n                if s[k] == s[i]:\n                    dp[i][j] = min(dp[i][j], dp[i+1][k-1] + dp[k][j])\n\nprint(dp[0][-1])"
 ],
 "255": [
  "n=int(input())\nboys = sorted(list(map(int,input().split())))\nm=int(input())\ngirls = sorted(list(map(int,input().split())))\nboy_index=girl_index=0\npairs=0\nwhile boy_index<n and girl_index<m:\n    if abs(boys[boy_index]-girls[girl_index])<=1:\n        pairs+=1\n        boy_index+=1\n        girl_index+=1\n    elif boys[boy_index]<girls[girl_index]:\n        boy_index+=1\n    else:\n        girl_index+=1\nprint(pairs)"
 ],
 "256": [
  "a = []\nb = []\nfor i in range(4):\n  ai, bi = map(int, input().split())\n  a.append(ai)\n  b.append(bi)\n  \nif max(a[:2]) > min(b[2:]) and max(b[:2]) > min(a[2:]):\n  print('Team 1')\nelif max(a[2:]) > min(b[:2]) and max(b[2:]) > min(a[:2]):\n  print('Team 2')\nelse:\n  print('Draw')"
 ],
 "257": [
  "import math\n\nn, k = map(int, input().split())\nmeat = [list(map(int, input().split())) for i in range(n)]\n\ndef time(x, y):\n    times = []\n    for i in range(n):\n        time_i = meat[i][2] * math.sqrt((x - meat[i][0]) ** 2 + (y - meat[i][1]) ** 2)\n        times.append(time_i)\n    times.sort()\n    return sum(times[:k])\n\nleft = -100\nright = 100\nwhile right - left > 10 ** -10:\n    lx = (2 * left + right) / 3\n    rx = (left + 2 * right) / 3\n    if time(lx, 0) > time(rx, 0):\n        left = lx\n    else:\n        right = rx\n\nprint(time((left + right) / 2, 0))"
 ],
 "258": [
  "n = int(input())\nticket = input()\n\nsum1 = sum(map(int, ticket[:n//2].replace(\"?\", \"0\")))\nsum2 = sum(map(int, ticket[n//2:].replace(\"?\", \"0\")))\nq1, q2 = ticket[:n//2].count(\"?\"), ticket[n//2:].count(\"?\")\n\nif (q1+q2 == 0):\n    print(\"Bicarp\" if sum1==sum2 else \"Monocarp\")\nelse:\n    if (q1+q2) % 2 == 1:\n        print(\"Monocarp\")\n    else:\n        half = (q1+q2) // 2\n        if (sum1 > sum2):\n            sum1, sum2 = sum2, sum1\n        if (sum1+9*half >= sum2 and sum1+half <= sum2+9*half):\n            print(\"Bicarp\")\n        else:\n            print(\"Monocarp\")"
 ],
 "259": [
  "n, t = map(int, input().split())\nbuses = []\nfor i in range(n):\n    s_i, d_i = map(int, input().split())\n    buses.append((s_i, d_i))\n\nmin_wait_time = float('inf')\nbus_route = None\nfor i in range(n):\n    s_i, d_i = buses[i]\n    if s_i > t:\n        wait_time = s_i - t\n    else:\n        wait_time = d_i - ((t - s_i) % d_i)\n    if wait_time < min_wait_time:\n        min_wait_time = wait_time\n        bus_route = i + 1\n\nprint(bus_route)"
 ],
 "260": [
  "m, k = map(int, input().split())\nlow, high = 1, 10**18\nwhile low < high:\n    mid = (low + high) // 2\n    count = 0\n    for c in range(1, k+1):\n        count += ((mid >> c) - (mid >> (c+1))) * (2**c - 1)\n    if count == m:\n        print(mid)\n        break\n    elif count < m:\n        low = mid+1\n    else:\n        high = mid-1\nelse:\n    print(low)"
 ],
 "261": [
  "n = int(input())\ns = input()\n\nfor i in range(n):\n    for j in range(i+1, n):\n        d = j - i\n        if i + 4*d >= n:\n            break\n        if s[i+d] == s[i] and s[i+2*d] == s[i] and s[i+3*d] == s[i]:\n            print(\"yes\")\n            exit()\n\nprint(\"no\")"
 ],
 "262": [
  "n = int(input())\nmatrix = []\nr = -1\nfor i in range(n):\n    a = list(map(int, input().split()))\n    if 0 in a:\n        r = i\n    matrix.append(a)\nsum_r = sum(matrix[r])\nsum_c = [0]*n\nfor c in range(n):\n    s = 0\n    for r in range(n):\n        s += matrix[r][c]\n    sum_c[c] = s\nsum_d1, sum_d2 = 0, 0\nfor i in range(n):\n    sum_d1 += matrix[i][i]\n    sum_d2 += matrix[i][n-i-1]\nx = (sum_r - sum_c[r] + sum_d1) // 2\nif sum_r != sum_c[r]+x or sum_r != sum_d2+x:\n    print(-1)\nelse:\n    print(x)"
 ],
 "263": [
  "n=int(input())\nm=int(input())\na=list(map(int,input().split()))\na.sort()\nmax_possible_seat = a[-1]+m\nlow,high=a[-1],max_possible_seat\nwhile(low<high):\n    mid=(low+high+1)//2\n    total_seat=mid*n\n    total_people=0\n    for i in a:\n        if i >=mid:\n            break\n        total_people+=mid-i\n    if total_seat-total_people>=m:\n        low=mid\n    else:\n        high=mid-1\nmax_seat=low\nmin_seat=max_possible_seat\nfor i in a:\n    m1=min(m,max_seat-i)\n    min_seat=max(min_seat,i+m1)\n    m-=m1\n    if m==0:\n        break\nprint(max_seat,min_seat)"
 ],
 "264": [
  "n, m = map(int, input().split())\n\nMOD = 10**9 + 7\n\nfact = [1] * (m+1)\nfor i in range(2, m+1):\n    fact[i] = (i * fact[i-1]) % MOD\n\ndef inverse(x):\n    return pow(x, MOD-2, MOD)\n\ninv_fact = [0] * (m+1)\ninv_fact[m] = inverse(fact[m])\n\nfor i in range(m-1, 0, -1):\n    inv_fact[i] = (inv_fact[i+1] * (i+1)) % MOD\n\ndef nCk(n, k):\n    if k > n:\n        return 0\n    return (fact[n] * inv_fact[k] * inv_fact[n-k]) % MOD\n\nans = 0\n\nfor i in range(n):\n    if i % 2 == 0:\n        ans = (ans + nCk(n, i) * fact[m] * fact[m-i] * pow(2, m-i, MOD)) % MOD\n    else:\n        ans = (ans - nCk(n, i) * fact[m] * fact[m-i] * pow(2, m-i, MOD)) % MOD\n\nprint(ans)"
 ],
 "265": [
  "n,m=map(int,input().split())\nfave_ingr=[set(map(int,input().split()[1:])) for i in range(n)]\npizzas=[tuple(map(int,input().split()[1:])) for i in range(m)]\nmax_friends=0\nj1,j2=-1,-1\nfor i in range(m-1):\n    for j in range(i+1,m):\n        ingr=set(pizzas[i]+pizzas[j])\n        friends=0\n        for f in fave_ingr:\n            if f.issubset(ingr):\n                friends+=1\n        if friends>max_friends or (friends==max_friends and pizzas[i][0]+pizzas[j][0]<pizzas[j1][0]+pizzas[j2][0]):\n            max_friends=friends\n            j1,j2=i,j\nprint(j1+1,j2+1)"
 ],
 "266": [
  "m, s = map(int, input().split())\n\n# Smallest number\nif s == 0 and m == 1:\n    print(0, 0)\nelif s == 0 or s > 9 * m:\n    print(-1, -1)\nelse:\n    min_num = [1] + [0] * (m - 1)\n    sum_digit = 1\n    idx = m - 1\n    while sum_digit < s and idx >= 0:\n        addend = min(9, s - sum_digit)\n        min_num[idx] += addend\n        sum_digit += addend\n        idx -= 1\n    print(''.join(map(str, min_num)), end=' ')\n\n# Largest number\nmax_num = [0] * m\nsum_digit = 0\nidx = 0\nwhile sum_digit < s and idx < m:\n    addend = min(9, s - sum_digit)\n    max_num[idx] += addend\n    sum_digit += addend\n    idx += 1\nprint(''.join(map(str, max_num[::-1])))"
 ],
 "267": [
  "MOD = 998244353\n\ndef num_digits(n,k):\n    d = []\n    while n:\n        d.append(n%10)\n        n//=10\n    d.reverse()\n    n = len(d)\n    if k>n:\n        return 0\n    if k==0:\n        return 1\n    dp = [[[0 for kk in range(k+1)] for j in range(2)] for i in range(n+1)]\n    dp[0][1][0] = 1\n    for i in range(1,n+1):\n        for b in range(2):\n            for kk in range(k+1):\n                for dig in range(10):\n                    coef = 1 if b else dig<d[i-1]\n                    if coef:\n                        for j in range(kk+1):\n                            dp[i][b and (dig==d[i-1])][j+1] += dp[i-1][b][j]\n                            dp[i][b and (dig==d[i-1])][j+1] %= MOD\n                    else:\n                        dp[i][0][kk] += dp[i-1][b][kk]\n                        dp[i][0][kk] %= MOD\n\n    res = 0   \n    for kk in range(1,k+1):\n        for b in range(2):\n            res += dp[n][b][kk]*(((l+r)*(r-l+1)//2)%MOD)*pow(10,kk,MOD)\n            res %= MOD\n    for i in range(l,r+1):\n        d = set(list(str(i)))\n        if len(d)>k:\n            continue\n        res -= i\n        res %= MOD\n    return res%MOD\n\nl,r,k = map(int,input().split())\nans = num_digits(r,k)-num_digits(l-1,k)\nprint(ans%MOD)"
 ],
 "268": [
  "n, k, d = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort()\ndp = [[False for j in range(k)] for i in range(n)]\n\nfor i in range(n):\n    for j in range(k):\n        if j == 0:\n            dp[i][j] = True\n        else:\n            left = 0\n            right = i\n            while left < right:\n                mid = (left+right)//2\n                if a[i] - a[mid] <= d:\n                    right = mid\n                else:\n                    left = mid+1\n            for l in range(max(0, right-1), i):\n                if dp[l][j-1] and a[i] - a[l] <= d:\n                    dp[i][j] = True\n                    break\n\nif dp[-1][-1]:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "269": [
  "s = input()\nkr, kb, ky, kg = s.count('!R'), s.count('!B'), s.count('!Y'), s.count('!G')\nprint(kr, kb, ky, kg)"
 ],
 "270": [
  "import queue\n\nn,m = map(int,input().split())\n\nedges = [[] for _ in range(n)]\n\nfor i in range(m):\n    s,t = map(int,input().split())\n    edges[s-1].append(t-1)\n\ndef bfs(s):\n    q = queue.Queue()\n    q.put(s)\n    distance = [-1]*n\n    distance[s] = 0\n    while not q.empty():\n        v = q.get()\n        for e in edges[v]:\n            if distance[e] == -1:\n                distance[e] = distance[v] + 1\n                q.put(e)\n    return distance\n\nd1 = bfs(0)\nd2 = bfs(n-1)\n\nfor i in range(n):\n    s = sum(1 for e in edges[i] if d1[i]+1+d2[e]==d1[n-1])\n    print(\"{:.10f}\".format(1-(s/len(edges[i])) if s>0 else 0)) # formatted output with 10 decimal places"
 ],
 "271": [
  "n = int(input())\nif n % 10 <= 5:\n    print(n // 10 * 10)\nelse:\n    print((n // 10 + 1) * 10)"
 ],
 "272": [
  "s = input()\nt = input()\ndiff = [(s[i], t[i]) for i in range(len(s)) if s[i] != t[i]]\nif len(diff) % 2 == 1:\n    print(-1)\nelse:\n    pairs = []\n    for i in range(0, len(diff)-1, 2):\n        if diff[i][0] == diff[i+1][1] and diff[i][1] == diff[i+1][0]:\n            pairs.append((diff[i][0], diff[i][1]))\n        elif diff[i][0] == diff[i+1][0]:\n            pairs.append((diff[i][1], diff[i+1][1]))\n        else:\n            pairs.append((diff[i][0], diff[i+1][1]))\n    print(len(pairs))\n    for p in pairs:\n        print(p[0], p[1])"
 ],
 "273": [
  "first_name, last_name = input().split()\nlogin = \"\"\nfor i in range(1, len(first_name)+1):\n    for j in range(1, len(last_name)+1):\n        temp_login = (first_name[:i] + last_name[:j]).lower()\n        if not login or temp_login < login:\n            login = temp_login\nprint(login)"
 ],
 "274": [
  "n = int(input())\ns = input()\n\nlevel = 0\nstack = []\nfor c in s:\n    if c == \"[\":\n        stack.append(level)\n        level += 1\n    else:\n        level -= 1\n        stack.append(level)\n\nheight = max(stack) + 1\nwidths = [0] * height\nfor i in range(0, len(stack), 2):\n    l, r = stack[i], stack[i+1]\n    for j in range(l, r):\n        widths[j] += 1\n\ngrid = [[\" \"] * sum(widths) for _ in range(height)]\n\nx = 0\nfor i in range(len(stack)):\n    if i % 2 == 0:\n        draw = \"+\"\n        fill = \"|\"\n        for j in range(height):\n            grid[j][x] = fill\n            if j == stack[i]:\n                grid[j][x] = draw\n            elif j > stack[i] and j <= stack[i+1]:\n                grid[j][x] = \"-\"\n    else:\n        draw = \"-\"\n        fill = \"|\"\n        for j in range(height-1, -1, -1):\n            grid[j][x] = fill\n            if j == stack[i]:\n                grid[j][x] = draw\n            elif j >= stack[i+1] and j < stack[i]:\n                grid[j][x] = \"-\"\n        x += 1\n\nfor row in grid:\n    print(\"\".join(row))"
 ],
 "275": [
  "from decimal import Decimal, getcontext\n\ngetcontext().prec = 100001\n\ngold_num1 = input().strip()[::-1] # reverse the input to ease in implementation\ngold_num2 = input().strip()[::-1]\n\ndef convert_gold_to_dec(gold):\n    dec = 0\n    for i in range(len(gold)):\n        dec += int(gold[i]) * Decimal(pow((Decimal(5).sqrt() + Decimal(1))/Decimal(2), i))\n    return dec\n\ndec1 = convert_gold_to_dec(gold_num1)\ndec2 = convert_gold_to_dec(gold_num2)\n\nif dec1 > dec2:\n    print(\">\")\nelif dec1 < dec2:\n    print(\"<\")\nelse:\n    print(\"=\")"
 ],
 "276": [
  "n = int(input())\ngems = set()\nfor i in range(n):\n    gems.add(input())\n\ncolors = {\n    \"purple\": \"Power\",\n    \"green\": \"Time\",\n    \"blue\": \"Space\",\n    \"orange\": \"Soul\",\n    \"red\": \"Reality\",\n    \"yellow\": \"Mind\"\n}\n\nabsent_gems = set(colors.values()) - set([colors[color] for color in gems])\n\nprint(len(absent_gems))\nfor gem in absent_gems:\n    print(gem)"
 ],
 "277": [
  "n, a, b = map(int, input().split())\nrounds = 0\nwhile n > 1:\n    rounds += 1\n    if (a + 1) // 2 == (b + 1) // 2:\n        if n == 2:\n            print(\"Final!\")\n        else:\n            break\n    else:\n        n = (n + 1) // 2\n\nif n > 1:\n    print(rounds)"
 ],
 "278": [
  "n = int(input())\np = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nvisited = [False] * n * 2\ncycles = 0\nfor i in range(n):\n    if not visited[i * 2]:\n        start = i\n        while not visited[start * 2]:\n            visited[start * 2] = True\n            start = p[start] - 1\n            if b[start]:\n                visited[start * 2 + 1] = True\n            else:\n                visited[start * 2 - 1] = True\n        cycles += 1\n\nif cycles == 1:\n    print(0)\nelse:\n    print(cycles)    "
 ],
 "279": [
  "v1, v2 = map(int, input().split())\nt, d = map(int, input().split())\ntotal_length = v1 + v2\ncur_speed = v1\nfor i in range(2, t):\n    max_speed = v1 + d*(i-1)\n    min_speed = v2 - d*(t-i)\n    cur_speed = min(max_speed, cur_speed+d)\n    cur_speed = max(min_speed, cur_speed-d)\n    total_length += cur_speed\nprint(total_length)"
 ],
 "280": [
  "import itertools\n\nN, M = map(int, input().split())\nw = list(map(int, input().split()))\nbridges = [tuple(map(int, input().split())) for _ in range(M)]\n\nmin_dist = float('inf')\n\nfor order in itertools.permutations(range(N)):\n    dist = 0\n    for i in range(N-1):\n        dist += abs(w[order[i]] - w[order[i+1]])\n    for l, v in bridges:\n        total_w = 0\n        last = 0\n        for i, j in zip(order, order[1:]):\n            total_w += w[i]\n            if total_w * (l-last) > v:\n                break\n            last = w[i]\n        else:\n            if total_w * (l-last) <= v:\n                dist += l\n    else:\n        min_dist = min(min_dist, dist)\n\nprint(min_dist if min_dist != float('inf') else -1)"
 ],
 "281": [
  "import math\na, b = map(int, input().split())\nlast_digit = 1\nfor i in range(a+1, b+1):\n    last_digit *= i % 10\n    last_digit %= 10\nprint(last_digit)"
 ],
 "282": [
  "n, d = map(int, input().split())\ns = input()\n\njumps = [0] * n\njumps[0] = 1\n\nfor i in range(1, n):\n    if s[i] == '1':\n        jumps[i] = n\n        for j in range(max(0, i-d), i):\n            if s[j] == '1':\n                jumps[i] = min(jumps[i], jumps[j]+1)\n    else:\n        jumps[i] = -1\n\nprint(jumps[-1])"
 ],
 "283": [
  "n = int(input())\nfor i in range(1, 1001):\n    if not (n*i+1) in [2] + [j for j in range(3, int((n*i+1)**0.5)+1, 2)]:\n        print(i)\n        break"
 ],
 "284": [
  "n = int(input())\n\nfor i in range(n//1234567 + 1):\n    for j in range((n - i*1234567)//123456 + 1):\n        if (n - i*1234567 - j*123456)%1234 == 0:\n            print(\"YES\")\n            exit()\n\nprint(\"NO\")"
 ],
 "285": [
  "n = int(input())\nx1, x2 = map(int, input().split())\n\nlines = []\nfor i in range(n):\n    k, b = map(int, input().split())\n    lines.append((k, b))\n    \nlines.sort()\n\nfor i in range(n-1):\n    if lines[i][0] == lines[i+1][0]:\n        continue\n    x = (lines[i+1][1] - lines[i][1]) / (lines[i][0] - lines[i+1][0])\n    if x1 < x < x2:\n        print(\"YES\")\n        exit()\n\nprint(\"NO\")"
 ],
 "286": [
  "n = int(input())\nres = 0\ni = 1\nwhile i <= n:\n    cnt = n // i - (i - 1)\n    res += cnt if cnt > 0 and n % cnt == i % cnt else 0\n    i += 1\nprint(res)"
 ],
 "287": [
  "n,k = map(int, input().split())\nmin_good = max(0,k-1)\nmax_good = min(n-1, 2*k-n)\nprint(min_good, max_good)"
 ],
 "288": [
  "n = int(input())\nans = 0\nwhile n > 1:\n    n = n//2\n    ans += 1\nprint(ans)"
 ],
 "289": [
  "s = input()\ncount = 0\nfor i in range(len(s)-1):\n    if s[i] == 'V' and s[i+1] == 'K':\n        count += 1\nif 'VV' in s:\n    count += s.count('VV')\nif 'KK' in s:\n    count += s.count('KK')\nif count > 0:\n    print(count)\nelse:\n    print(0)"
 ],
 "290": [
  "n = int(input())\nlow, high = 1, n\nans = n\nwhile low <= high:\n    mid = (low+high)//2\n    temp = mid*(mid+1)//2\n    if temp < n:\n        low = mid+1\n    else:\n        ans = min(ans, mid+(temp-n)%2)\n        high = mid-1\nprint(ans)"
 ],
 "291": [
  "a, b = map(int, input().split())\nyears = 0\nwhile a <= b:\n    a *= 3\n    b *= 2\n    years += 1\nprint(years)"
 ],
 "292": [
  "h, n = map(int, input().split())\n\ndef count_nodes(height, target):\n    # base case: target is a leaf node\n    if height == 0:\n        return 0\n\n    # calculate total number of nodes in the left and right subtrees\n    num_nodes = 2**(height-1)\n\n    # check which subtree the target node is in\n    if target <= num_nodes:\n        # target is in the left subtree\n        return 1 + count_nodes(height-1, target)\n    else:\n        # target is in the right subtree\n        return 1 + count_nodes(height-1, target-num_nodes)\n\n# start at root of tree\ncurrent_node = 1\n# initialize some variables\nsteps = 0\nconsecutive_skips = 0\n\n# iterate over the commands\nfor command in \"LRLRLRLRL\" * h:\n    if command == \"L\":\n        next_node = current_node * 2\n    else:\n        next_node = current_node * 2 + 1\n    if next_node == n or (current_node == n and command == \"L\"):\n        break\n    if next_node > 2**h:\n        consecutive_skips += 1\n        if consecutive_skips == 2:\n            current_node //= 2\n            consecutive_skips = 0\n        continue\n    else:\n        consecutive_skips = 0\n        steps += 1\n        current_node = next_node\n\n# count number of visited nodes\nnum_visited = count_nodes(h, current_node)\n\n# output result\nprint(steps + num_visited)"
 ],
 "293": [
  "from math import sqrt\n\nx = int(input())\n\ncount = 0\nans = []\n\nfor n in range(1, int(sqrt(2*x))+1):\n    if 2*x % n == 0:\n        m = 2*x // n\n        if (n+m-1) % 2 == 0:\n            k = (n+m-1) // 2\n            if k-m+1 >= 1 and k+n-1 <= x//k:\n                count += 1\n                ans.append((k, n))\n                \nprint(count)\nfor a in ans:\n    print(a[0], a[1])"
 ],
 "294": [
  "n = int(input())\ndays = list(map(int, input().split()))\nleap = [31,29,31,30,31,30,31,31,30,31,30,31]\nnot_leap = [31,28,31,30,31,30,31,31,30,31,30,31]\n\ndef check_consecutive_months(days_in_month, is_leap):\n    for i in range(12):\n        if days_in_month == is_leap[i:i+n]:\n            return True\n    return False\n\nif check_consecutive_months(days, leap) or check_consecutive_months(days, not_leap):\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "295": [
  "from math import gcd\n \ndef gcd_complement(n, d):\n    return d // gcd(n, d), n // gcd(n, d)\n \ndef solve(n):\n    res = []\n    for i in range(1, n):\n        if gcd(i, n) == 1:\n            res.append(gcd_complement(i, n))\n \n    if len(res) <= 1:\n        return \"NO\"\n    return [\"YES\", len(res), *res]\n \nn = int(input())\nprint(*solve(n), sep=\"\\n\")"
 ],
 "296": [
  "n = int(input().strip())\nar, ag = map(int, input().split())\nh = list(map(int, input().split()))\n\ndp = [[10**9 for x in range(ar+1)] for y in range(ag+1)]\ndp[0][0] = 0\n\nfor i in range(n):\n    for r in range(ar+1):\n        for g in range(ag+1):\n            if h[i]%2 == 1: #If odd, it can only be painted in green\n                if g >= h[i] <= ag:\n                    dp[r][g] = min(dp[r][g], dp[r][g-h[i]]+int(i > 0 and clr != 0))\n            else: #If even, it can be painted in both colors\n                clr = 1\n                if r < h[i] <= ar: #Check if it can be painted red\n                    dp[r][g] = min(dp[r][g], dp[r-h[i]][g]+int(i > 0 and clr != 0))\n                if g < h[i] <= ag: #Check if it can be painted green\n                    dp[r][g] = min(dp[r][g], dp[r][g-h[i]]+int(i > 0 and clr != 1))\n                    \nans = min(dp[ar][ag], dp[ag][ar])\nif ans == 10**9:\n    ans = -1\nprint(ans)"
 ],
 "297": [
  "n,m,k=map(int,input().split())\nif n*m*2%k!=0:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    if n%2==0:\n        x1=n//2\n    else:\n        x1=n-1\n    print(x1,0)\n    print(0,m)\n    y2=2*n*m//k//x1\n    print(x1,y2)"
 ],
 "298": [
  "n, k = map(int, input().split())\nif n%k == 0 or (n//k)%2 == 0:\n    print(\"NO\")\nelse:\n    print(\"YES\")"
 ],
 "299": [
  "n = int(input())\nexercises = list(map(int, input().split()))\nchest_total = 0\nbicep_total = 0\nback_total = 0\nfor i in range(n):\n    if i % 3 == 0:\n        chest_total += exercises[i]\n    elif i % 3 == 1:\n        bicep_total += exercises[i]\n    else:\n        back_total += exercises[i]\nif max(chest_total, bicep_total, back_total) == chest_total:\n    print(\"chest\")\nelif max(chest_total, bicep_total, back_total) == bicep_total:\n    print(\"biceps\")\nelse:\n    print(\"back\")"
 ],
 "300": [
  "n = int(input())\ngrades = list(map(int, input().split()))\n\nnum_of_failing_grades = 0\nsum_of_grades = sum(grades)\nwhile sum_of_grades / n < 4.5:\n    num_of_failing_grades += 1\n    sum_of_grades += 5 - min(grades + [5])\n\nprint(num_of_failing_grades)"
 ],
 "301": [
  "u, v = map(int, input().split())\n\nif u == 0:\n    if v == 0:\n        print(0)\n    else:\n        print(-1)\nelse:\n    if (v - u) % 2 != 0:\n        print(-1)\n    else:\n        x = (v - u) // 2\n        if x & u != 0:\n            print(-1)\n        else:\n            ans = []\n            cur = 1\n            while u or x:\n                if u & 1:\n                    ans.append(cur)\n                    x -= cur\n                cur *= 2\n                u >>= 1\n            if x != 0:\n                ans.append(x)\n            print(len(ans))\n            print(*ans)"
 ],
 "302": [
  "n = int(input())\n\ndef get_num_of_ones(k):\n    num_of_ones = 0\n    while k > 0:\n        num_of_ones += 1\n        k //= 10\n    return num_of_ones\n\nmin_num_of_ones = float('inf')\n\ndef dfs(curr_sum, curr_num_of_ones):\n    global min_num_of_ones\n    if curr_sum == n:\n        min_num_of_ones = min(min_num_of_ones, curr_num_of_ones)\n        return\n    elif curr_sum > n:\n        return\n    else:\n        for i in range(1, 10):\n            dfs(curr_sum + i, curr_num_of_ones + get_num_of_ones(i))\n\n\ndfs(0, 0)\nprint(min_num_of_ones)"
 ],
 "303": [
  "x1, y1, x2, y2 = map(int, input().split())\nx, y = map(int, input().split())\n\nif (x2 - x1) % x == 0 and (y2 - y1) % y == 0 and \\\n    (x2 - x1) // x % 2 == (y2 - y1) // y % 2:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "304": [
  "n = input().strip()\ndigits = len(n)\nfreq = {}\nfor d in n:\n    freq[d] = freq.get(d,0)+1\nans = 0\nif digits == 1:\n    if int(n) == 0:\n        ans = 0\n    elif int(n) == 8:\n        ans = 1\n    else:\n        ans = 2\nelif digits == 2:\n    for i in range(int(n)+1,100):\n        if i%8 == 0:\n            ans += 1\nelif digits >= 3:\n    for i in range(104,1000,8):\n        freq_i = {x:str(i).count(x) for x in str(i)}\n        if all([freq.get(key,0)>=value for key,value in freq_i.items()]):\n            ans += 1\n    for i in range(1000,10000):\n        freq_i = {x:str(i).count(x) for x in str(i)}\n        if all([freq.get(key,0)>=value for key,value in freq_i.items()]):\n            ans += 1\n    for i in range(10000,100000):\n        freq_i = {x:str(i).count(x) for x in str(i)}\n        if all([freq.get(key,0)>=value for key,value in freq_i.items()]):\n            ans += 1\n    for i in range(100000,1000000):\n        freq_i = {x:str(i).count(x) for x in str(i)}\n        if all([freq.get(key,0)>=value for key,value in freq_i.items()]):\n            ans += 1\n    for i in range(1000000,10000000):\n        freq_i = {x:str(i).count(x) for x in str(i)}\n        if all([freq.get(key,0)>=value for key,value in freq_i.items()]):\n            ans += 1\n    for i in range(10000000,100000000):\n        freq_i = {x:str(i).count(x) for x in str(i)}\n        if all([freq.get(key,0)>=value for key,value in freq_i.items()]):\n            ans += 1\n    for i in range(100000000,1000000000):\n        freq_i = {x:str(i).count(x) for x in str(i)}\n        if all([freq.get(key,0)>=value for key,value in freq_i.items()]):\n            ans += 1\n    for i in range(1000000000,10000000000):\n        freq_i = {x:str(i).count(x) for x in str(i)}\n        if all([freq.get(key,0)>=value for key,value in freq_i.items()]):\n            ans += 1\nprint(ans)"
 ],
 "305": [
  "a = int(input())\nb = int(input())\nc = int(input())\nd = int(input())\ne = int(input())\nf = int(input())\n\n# Maximum suits of type 1 that can be made\nmax_suit_1 = min(a,d)\n\n# Maximum suits of type 2 that can be made\nmax_suit_2 = min(b,c,d)\n\n# Calculate maximum possible cost\nmax_cost = max_suit_1 * e + max_suit_2 * f\n\n# If only type 1 suits can be made, add remaining jackets to the cost\nif max_suit_2 < max_suit_1:\n    max_cost += (min(d-max_suit_1, max(b,c,d-max_suit_2))*f)\n\nprint(max_cost)"
 ],
 "306": [
  "from math import gcd\n\na, b, p, x = map(int, input().split())\nans = 0\nif a == 1:\n    if b == 1:\n        ans = min(x, p-1)\nelse:\n    inv = pow(a, p-2, p)\n    d = (inv * b) % p\n    f = pow(a, p-2*x, p)\n    for i in range(p):\n        if i > x:\n            break\n        if d == 1:\n            ans += min(x-i+1, p-1)\n            break\n        d = (d * f) % p\n    else:\n        r, clc = d, 0\n        mp = {}\n        for i in range(p>>1):\n            if r not in mp:\n                mp[r] = clc\n            r = (r * a) % p\n            clc += 1\n        f = pow(a, x, p)\n        for i in range(p):\n            if d in mp:\n                ans += min((x-i+1 + mp[d])//p, (p-1- i + p-mp[d])//p)\n            d = (d * f) % p\nprint(ans)"
 ],
 "307": [
  "k2, k3, k5, k6 = map(int, input().split())\n\n# First we want to create as many 256s as possible\nnum_256 = min(k2, k5, k6)\nk2 -= num_256\nk5 -= num_256\nk6 -= num_256\n\n# Then we create as many 32s as possible with the remaining 2s and 3s\nnum_32 = min(k2, k3)\nprint(num_256 * 256 + num_32 * 32)"
 ],
 "308": [
  "n, x, y, c = map(int, input().split())\n\ndef count_cells(val):\n    # Count number of switched on cells after val seconds\n    side_count = min(val, x-1) + min(val, y-1) + min(val, n-x) + min(val, n-y)\n    diag_count = 0\n    if x+y <= val+1:\n        diag_count += min(val+1-x-y, x-1) + min(val+1-x-y, y-1)\n    if x+y >= val+3:\n        diag_count += min(x+y-val-3, n-x) + min(x+y-val-3, n-y)\n    if x-y <= val:\n        diag_count += min(val+1-x+y, x-1) + min(val+1-x+y, n-y)\n    if y-x <= val:\n        diag_count += min(val+1-y+x, y-1) + min(val+1-y+x, n-x)\n    return side_count + diag_count\n\nif count_cells(0) >= c:\n    print(0)\nelse:\n    l, r = 0, 10**18\n    while l+1 < r:\n        mid = (l + r) // 2\n        if count_cells(mid) >= c:\n            r = mid\n        else:\n            l = mid\n    print(r)"
 ],
 "309": [
  "l, r = map(int, input().split())\nx = l ^ r\nbits = 0\nwhile x:\n    bits += 1\n    x >>= 1\nprint((1 << bits) - 1)"
 ],
 "310": [
  "n, k = map(int, input().split())\n\nif k % (n+1) == 0:\n    print(k // (n+1))\nelse:\n    print(k // (n+1) + 1)"
 ],
 "311": [
  "x, y, z, t1, t2, t3 = map(int, input().split())\ndist_by_stairs = abs(x-y) * t1\ndist_by_elevator = abs(x-z) * t2 + abs(x-y) * t2 + t3 * 3\nif dist_by_stairs < dist_by_elevator:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "312": [
  "n, m = map(int, input().split())\nif m == 1:\n    print(2)\nelif m == n:\n    print(n - 1)\nelse:\n    if m - 1 > n - m:\n        print(m - 1)\n    else:\n        print(m + 1)"
 ],
 "313": [
  "n = int(input())\nschedule = [int(x) for x in input().split()]\n\nstay_count = 0\ni = 0\n\nwhile i < n:\n    if schedule[i] == 1:\n        stay_count += 1\n        i += 1\n    else:\n        i += 1\n        if i < n and schedule[i] == 0:\n            i += 1\n        else:\n            continue\n\nprint(stay_count)"
 ],
 "314": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\ntotal_candies = 0\nday = 0\nwhile total_candies < k and day < n:\n    day += 1\n    total_candies += a[day-1]\n    if total_candies > 8:\n        total_candies -= 8\n    else:\n        total_candies = 0\n\nif total_candies + a[-1] < k:\n    print(-1)\nelse:\n    print(day)"
 ],
 "315": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\nb = a[:]\nans = 0\nfor i in range(1, n):\n    if b[i-1] + b[i] < k:\n        ans += k - b[i-1] - b[i]\n        b[i] = k - b[i-1]\nprint(ans)\nprint(*b)"
 ],
 "316": [
  "n = int(input())\nif n == 1:\n    print(1)\nelse:\n    ans = 1\n    for i in range(n):\n        ans += 4 * i\n    print(ans)"
 ],
 "317": [
  "n = int(input())\ns = input().lower()\nif len(set(s)) == 26:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "318": [
  "curr_time = input()\na = int(input())\nhours, minutes = map(int, curr_time.split(':'))\nminutes += a\nhours += minutes // 60\nminutes %= 60\nhours %= 24\nprint(f\"{hours:02d}:{minutes:02d}\")"
 ],
 "319": [
  "n, m = map(int, input().split())\n\na = []\nfor i in range(n):\n    a.append(input())\n\nfor i in range(n):\n    if all(a[j][k] == '0' or a[i][k] == '1' for j in range(n) if j != i for k in range(m)):\n        print(\"YES\")\n        break\nelse:\n    print(\"NO\")"
 ],
 "320": [
  "n = int(input())\nup_sum, down_sum = 0, 0\nodd_up, odd_down = False, False\n\nfor _ in range(n):\n    x, y = map(int, input().split())\n    up_sum += x\n    down_sum += y\n    if x % 2 != 0:\n        odd_up = True\n    if y % 2 != 0:\n        odd_down = True\n        \nif up_sum % 2 == 0 and down_sum % 2 == 0:\n    print(0)\nelif odd_up != odd_down:\n    print(-1)\nelse:\n    print(1)"
 ],
 "321": [
  "def is_prime(n):\n    if n == 1:\n        return False\n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            return False\n    return True\n\nt = int(input())\nfor _ in range(t):\n    a, b = map(int, input().split())\n    area = a*a - b*b\n    prime = is_prime(area)\n    print(\"YES\" if prime else \"NO\")"
 ],
 "322": [
  "n = int(input())\npoints = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    points.append((x, y))\n\non_left = set()\non_right = set()\n\nfor i in range(n):\n    curr_x, curr_y = points[i]\n    on_left.clear()\n    on_right.clear()\n\n    for j in range(n):\n        if i == j:\n            continue\n        next_x, next_y = points[j]\n        if next_x < curr_x:\n            on_left.add(j)\n        else:\n            on_right.add(j)\n\n    if len(on_left) == 0 or len(on_right) == 0:\n        print(\"Yes\")\n        exit(0)\n\nprint(\"No\")"
 ],
 "323": [
  "from math import gcd, factorial\na, b = map(int, input().split())\nprint(gcd(factorial(a), factorial(b)))"
 ],
 "324": [
  "n = int(input())\nprint(n+4, 4)"
 ],
 "325": [
  "import heapq\n\nclass Edge:\n    def __init__(self, fromV, toV, cost):\n        self.fromV = fromV\n        self.toV = toV\n        self.cost = cost\n\nN, M, P = map(int, input().split())\nedges = [[] for _ in range(N+1)]\nrevedges = [[] for _ in range(N+1)]\nfor _ in range(M):\n    a, b, c = map(int, input().split())\n    edges[a].append(Edge(a, b, c-P))\n    revedges[b].append(Edge(b, a, c-P))\n\nreachable = [False]*(N+1)\nreachable[1] = True\n\ndef dfs(edges, v):\n    for e in edges[v]:\n        if not reachable[e.toV]:\n            reachable[e.toV] = True\n            dfs(edges, e.toV)\ndfs(edges, 1)\nif not reachable[N]:\n    print(-1)\n    exit()\n\ndist = [float('inf')]*(N+1)\ndist[1] = 0\nfor _ in range(N-1):\n    for v in range(1, N+1):\n        if not reachable[v]: continue\n        for e in edges[v]:\n            if not reachable[e.toV]: continue\n            if dist[e.toV] > dist[v]+e.cost:\n                dist[e.toV] = dist[v]+e.cost\n                heapq.heappush(edges, dist[e.toV])\n\nfor _ in range(N-1):\n    for v in range(1, N+1):\n        if not reachable[v]: continue\n        for e in revedges[v]:\n            if not reachable[e.toV]: continue\n            if dist[e.toV] > dist[v]+e.cost:\n                dist[e.toV] = dist[v]+e.cost\n                heapq.heappush(revedges, dist[e.toV])\n\nprint(max(0, -dist[N])) "
 ],
 "326": [
  "n = int(input())\nstrings = []\nfor i in range(n):\n    s, c = input().split()\n    cost = int(c)\n    reverse_s = s[::-1]\n    strings.append((s, reverse_s, cost))\n\ndp = [[float('inf')] * (n+1) for _ in range(1<<n)]\n\nfor i in range(n):\n    dp[1<<i][i] = strings[i][2]\n\nans = float('inf')\nfor bit in range(1<<n):\n    for last in range(n):\n        if not bit&(1<<last):\n            continue\n        for nxt in range(n):\n            if bit&(1<<nxt):\n                continue\n            if strings[last][1] == strings[nxt][0]:\n                dp[bit|(1<<nxt)][nxt] = min(dp[bit|(1<<nxt)][nxt], dp[bit][last]+strings[nxt][2])\n                if bit|(1<<nxt) == (1<<n)-1:\n                    ans = min(ans, dp[bit|(1<<nxt)][nxt])\n\nif ans == float('inf'):\n    print(-1)\nelse:\n    print(ans)"
 ],
 "327": [
  "n, k = map(int, input().split())\nif k == n:\n    print(n-1)\nelse:\n    bit = 1\n    while bit <= n:\n        bit <<= 1\n    ans = bit - 1\n    if k == 1:\n        print(ans)\n    else:\n        cnt = 1\n        while cnt < k:\n            ans ^= (bit >> cnt)\n            cnt += 1\n        print(ans)"
 ],
 "328": [
  "import sys\n \nn = int(sys.stdin.readline().strip())\n \nmin_len = float('inf')\n \nfor i in range(n):\n    x, y = map(int, sys.stdin.readline().strip().split())\n    min_len = min(min_len, x + y)\n \nprint(min_len)"
 ],
 "329": [
  "from collections import Counter\ns = input()\ncounts = Counter(s)\nnineteen = [counts.get(c, 0) for c in 'nineteen']\nnineteen[3] //= 2\nnineteen[4] //= 2\nprint(min(nineteen))"
 ],
 "330": [
  "p, y = map(int, input().split())\n\nfor i in range(y, p, -1):\n    flag = True\n    for j in range(2, int(i**0.5)+1):\n        if i%j == 0:\n            if j <= p or i//j <= p:\n                flag = False\n                break\n    if flag:\n        print(i)\n        exit()\n\nprint(-1)"
 ],
 "331": [
  "n, m, k = map(int, input().split())\nhouses = list(map(int, input().split()))\n\nmin_distance = float('inf')\nfor i in range(n):\n    if houses[i] != 0 and houses[i] <= k:\n        distance = abs(m - (i + 1)) * 10 # distance in meters\n        min_distance = min(min_distance, distance)\n\nprint(min_distance)"
 ],
 "332": [
  "n,m = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\nb = [list(map(int, input().split())) for _ in range(n)]\n\ndef check(a,b): \n    for i in range(n):\n        for j in range(m):\n            if i+1<n and j+1<m and sorted([a[i][j], a[i+1][j], a[i][j+1], a[i+1][j+1]]) != sorted([b[i][j], b[i+1][j], b[i][j+1], b[i+1][j+1]]):\n                return False\n    return True\n\nprint(\"YES\" if check(a,b) else \"NO\")"
 ],
 "333": [
  "a = input()\nb = input()\nif a == b:\n    print(\"-1\")\nelse:\n    print(max(len(a), len(b)))"
 ],
 "334": [
  "a, b = map(int, input().split())\nc, d = map(int, input().split())\n\nfor i in range(10000):\n    for j in range(10000):\n        t1 = b + a * i\n        t2 = d + c * j\n        if t1 == t2:\n            print(t1)\n            exit()\nprint(\"-1\")"
 ],
 "335": [
  "n = int(input())\nif n % 3 == 0:\n    print(\"1 2 \" + str(n-3))\nelse:\n    print(\"1 1 \" + str(n-2))"
 ],
 "336": [
  "n,a,b,c,d=map(int,input().split())\ncount=0\nfor i in range(1,n+1):\n    x=a+i-d\n    y=b+i-c\n    z=i-b+c-d\n    if 1<=x<=n and 1<=y<=n and 1<=z<=n: \n        if len(set([i,x,y,z]))==4:\n            if i+x==a+d and i+y==b+c and x+y==c+a and i+z==b+d:\n                count+=1\nprint(count)"
 ],
 "337": [
  "w, h = map(int, input().split())\nu1, d1 = map(int, input().split())\nu2, d2 = map(int, input().split())\n\nfor i in range(h, -1, -1):\n    w += i\n    if i == d1:\n        w = max(w - u1, 0)\n    if i == d2:\n        w = max(w - u2, 0)\n\nprint(w)"
 ],
 "338": [
  "m = int(input())\nc = list(map(int, input().split()))\nx, y = map(int, input().split())\n\nfor k in range(1, m+1):\n    group1 = sum(c[:k])\n    group2 = sum(c[k:])\n    if x <= group1 <= y and x <= group2 <= y:\n        print(k)\n        break\nelse:\n    print(0)"
 ],
 "339": [
  "n = int(input())\nk = int(input())\nA = int(input())\nB = int(input())\n\ncost = 0\n\nwhile n > 1:\n    if n % k == 0:\n        if B < A * (n - n//k):\n            cost += B\n            n //= k\n        else:\n            cost += A * (n - n//k)\n            n //= k\n    else:\n        cost += A * (n % k)\n        n -= n % k\n        \nprint(cost)"
 ],
 "340": [
  "import math\nn = int(input())\nmini = n\nans = 0\nfor i in range(2, int(math.sqrt(n)) + 1):\n    count = 0\n    while n % i == 0:\n        n //= i\n        count += 1\n    if count:\n        temp = mini\n        while count:\n            temp //= i\n            count -= 1\n        temp *= i\n        ans += 1\n        mini = min(mini, temp)\nif n > 1:\n    ans += 1\n    mini = min(mini, n)\nprint(mini, ans)"
 ],
 "341": [
  "n, k = map(int, input().split())\nr, s, p = map(int, input().split())\nt = input()\n\nhands = {'r': p, 's': r, 'p': s} # stores the points earned for each hand\nused = ['']*n # stores the last K hands played\nans = 0\n\nfor i in range(n):\n    curr_hand = t[i]\n    if i >= k:\n        if curr_hand == used[i-k]:\n            curr_hand = '*' # if the current hand is the same as the one played K rounds ago, we mark it as invalid\n    if curr_hand != '*':\n        ans += hands[curr_hand]\n        used[i] = curr_hand\n\nprint(ans)"
 ],
 "342": [
  "a, b, c = map(int, input().split())\nif a > b:\n    a, b = b, a\nans = (2*c + 1) * min(a + 1, b)\nif a == b:\n    ans -= 1\nprint(ans)"
 ],
 "343": [
  "n, k, p, x, y = map(int, input().split())\na = list(map(int, input().split()))\nm = (n + 1) // 2 - k\na.sort()\ns = sum(a)\nif s + m * p > x:\n    print(\"-1\")\nelse:\n    for i in range(m):\n        if s + (m - i - 1) * y + (i + 1) * p <= x:\n            for j in range(i + 1):\n                print(p, end=\" \")\n            for j in range(m - i - 1):\n                print(y, end=\" \")\n            break\nelse:\n    print(\"-1\")"
 ],
 "344": [
  "s = input()\nn = len(s)\nvowels = ['a', 'e', 'i', 'o', 'u']\n\nfor i in range(n):\n    if s[i] not in vowels and s[i] != 'n':\n        if i == n-1 or (i < n-1 and s[i+1] not in vowels and s[i+1] != 'n'):\n            print(\"NO\")\n            break\n    if i == n-1:\n        print(\"YES\")"
 ],
 "345": [
  "from itertools import combinations\n\nn, m = map(int, input().split())\n\nedges = [[] for _ in range(n)]\n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edges[a-1].append(b-1)\n    edges[b-1].append(a-1)\n\ndominos = [(i, j) for i in range(7) for j in range(i, 7)]\n\nans = 0\n\nfor chosen_dominos in combinations(dominos, len(edges)):\n    vertex_mapping = {}\n    valid = True\n    for idx, (a, b) in enumerate(chosen_dominos):\n        v1, v2 = sorted([a, b])\n        if v1 not in vertex_mapping and v2 not in vertex_mapping:\n            vertex_mapping[v1] = vertex_mapping[v2] = idx\n        elif v1 in vertex_mapping and v2 not in vertex_mapping:\n            if chosen_dominos[vertex_mapping[v1]][0] != a and chosen_dominos[vertex_mapping[v1]][1] != a:\n                valid = False\n                break\n            vertex_mapping[v2] = idx\n        elif v2 in vertex_mapping and v1 not in vertex_mapping:\n            if chosen_dominos[vertex_mapping[v2]][0] != a and chosen_dominos[vertex_mapping[v2]][1] != a:\n                valid = False\n                break\n            vertex_mapping[v1] = idx\n        elif vertex_mapping[v1] != vertex_mapping[v2]:\n            valid = False\n            break\n    if valid:\n        matched_edges = set()\n        for v, edgs in enumerate(edges):\n            for e in edgs:\n                if (e, v) not in matched_edges:\n                    matched_edges.add((v, e))\n                    matched_edges.add((e, v))\n                    a, b = chosen_dominos[vertex_mapping[v]]\n                    if a == b:\n                        ans += 1\n                    else:\n                        if a == v+1 or b == v+1:\n                            ans += 1\n\nprint(ans)"
 ],
 "346": [
  "n, m = map(int, input().split())\nprices = list(map(int, input().split()))\nauctions = set(map(int, input().split()))\n\nr2_points = 0\nlast_chosen = None\nfor i in range(n):\n    max_price = max(prices)\n    if i+1 in auctions and max_price < r2_points:\n        max_price = r2_points\n    if i+1 == last_chosen:\n        r2_points += max_price\n    else:\n        last_chosen = max(prices.index(max_price)+1, last_chosen)\n        r2_points += max_price\n    prices[prices.index(max_price)] = 0\n    \nprint(r2_points)"
 ],
 "347": [
  "m = list(map(int, input().split()))\nw = list(map(int, input().split()))\nh_s, h_u = map(int, input().split())\n\nx = [500, 1000, 1500, 2000, 2500]\nscore = 0\n\nfor i in range(5):\n    s_i = max(0.3 * x[i], (1 - m[i]/250) * x[i] - 50 * w[i])\n    score += s_i\n\nscore += h_s * 100 - h_u * 50\n\nprint(int(score))"
 ],
 "348": [
  "n, m, L, R = map(int, input().split())\nMOD = 998244353\n\nif (n * m) % 2 == 1:\n    ans1 = pow(R-L+1, n*m, MOD)\n    ans2 = pow(R-L+1, (n*m+1)//2, MOD)\n    print((ans1+ans2)%MOD * pow(2, MOD-2, MOD) % MOD)\nelse:\n    ans = pow(R-L+1, n*m, MOD)\n    print((ans+pow(-1, n*m)*pow(R-L+1, n*m//2, MOD)) % MOD * pow(2, MOD-2, MOD) % MOD)"
 ],
 "349": [
  "n, m = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\nb = [list(map(int, input().split())) for _ in range(n)]\n\ndef is_increasing(matrix):\n    for i in range(n):\n        for j in range(1, m):\n            if matrix[i][j] <= matrix[i][j-1]:\n                return False\n    for j in range(m):\n        for i in range(1, n):\n            if matrix[i][j] <= matrix[i-1][j]:\n                return False\n    return True\n\ndef is_possible():\n    if not is_increasing(a) or not is_increasing(b):\n        return False\n    \n    for i in range(n):\n        for j in range(m):\n            if a[i][j] > b[i][j]:\n                a[i][j], b[i][j] = b[i][j], a[i][j]\n    \n    return is_increasing(a) and is_increasing(b)\n\nprint(\"Possible\" if is_possible() else \"Impossible\")"
 ],
 "350": [
  "n = int(input())\nlimitations = list(map(int, input().split()))\n\nsorted_limitations = sorted(limitations)\n\ndistinct_occurrences = []\noccurrence_count = {}\n\nfor limit in sorted_limitations:\n    if limit not in occurrence_count:\n        occurrence_count[limit] = 1\n        distinct_occurrences.append(1)\n    else:\n        occurrence_count[limit] += 1\n\nmax_length = 0\nfor i in range(len(distinct_occurrences)):\n    occurrence = distinct_occurrences[i]\n    count = occurrence_count[sorted_limitations[i]]\n    while count > occurrence:\n        max_length += occurrence\n        count -= occurrence\n        occurrence += 1\n    max_length += count\n\nprint(max_length)"
 ],
 "351": [
  "n, k = map(int, input().split())\na = sorted(list(map(int, input().split())))\n\ncount = 0\ni = 0\nwhile i < n:\n    if a[i] > 2*k:\n        count += 1\n        k *= 2\n    else:\n        i += 1\n\nprint(count)"
 ],
 "352": [
  "n = int(input())\nmin1, max1 = map(int, input().split())\nmin2, max2 = map(int, input().split())\nmin3, max3 = map(int, input().split())\n\n# First, maximize the number of first degree diplomas\nnum_first = min(n - (min2+min3), max1)\nn -= num_first\n\n# Then maximize the number of second degree diplomas\nnum_second = min(n - min3, max2)\nn -= num_second\n\n# The rest of the students get third degree diplomas\nnum_third = n\n\nprint(num_first, num_second, num_third)"
 ],
 "353": [
  "n = int(input())\na = list(map(int, input().split()))\n\nif a[-1] == 15:\n    print(\"DOWN\")\nelif a[-1] == 0:\n    print(\"UP\")\nelif n == 1:\n    print(\"-1\")\nelif a[-1] > a[-2]:\n    print(\"UP\")\nelse:\n    print(\"DOWN\")"
 ],
 "354": [
  "s = input()\nt = input()\n\nvowels = {'a', 'e', 'i', 'o', 'u'} \nif len(s) != len(t):\n    print(\"No\")\nelse:\n    for i in range(len(s)):\n        if s[i] in vowels and t[i] not in vowels:\n            print(\"No\")\n            break\n        elif s[i] not in vowels and t[i] in vowels:\n            print(\"No\")\n            break\n    else:\n        print(\"Yes\")"
 ],
 "355": [
  "board = [input() for i in range(8)] # input the board\n\ndef solve(board):\n    white_pawns = []\n    for i in range(8):\n        for j in range(8):\n            if board[i][j] == 'W':\n                white_pawns.append((i, j))\n\n    # assume A is the winner, check if any white pawn can reach the first row\n    for wp in white_pawns:\n        if wp[0] == 0:\n            return 'A'\n\n    # check if any black pawn can block white pawns from reaching the first row\n    for wp in white_pawns:\n        for bp in [(wp[0]+1, wp[1]-1), (wp[0]+1, wp[1]+1)]:\n            if bp[0] < 0 or bp[0] >= 8 or bp[1] < 0 or bp[1] >= 8 or board[bp[0]][bp[1]] == 'B':\n                continue\n            can_block = True\n            for wp2 in white_pawns:\n                if wp2 == wp:\n                    continue\n                if wp2[0] > bp[0]:\n                    can_block = False\n                    break\n                if wp2[0] == bp[0] and abs(wp2[1]-bp[1]) <= 1:\n                    can_block = False\n                    break\n            if can_block:\n                return 'B'\n\n    # check if any black pawn can reach the last row\n    black_pawns = []\n    for i in range(8):\n        for j in range(8):\n            if board[i][j] == 'B':\n                black_pawns.append((i, j))\n    for bp in black_pawns:\n        if bp[0] == 7:\n            return 'B'\n\n    # check if any white pawn can block black pawns from reaching the last row\n    for bp in black_pawns:\n        for wp in [(bp[0]-1, bp[1]-1), (bp[0]-1, bp[1]+1)]:\n            if wp[0] < 0 or wp[0] >= 8 or wp[1] < 0 or wp[1] >= 8 or board[wp[0]][wp[1]] == 'W':\n                continue\n            can_block = True\n            for bp2 in black_pawns:\n                if bp2 == bp:\n                    continue\n                if bp2[0] < wp[0]:\n                    can_block = False\n                    break\n                if bp2[0] == wp[0] and abs(bp2[1]-wp[1]) <= 1:\n                    can_block = False\n                    break\n            if can_block:\n                return 'A'\n\nprint(solve(board)) # output the result"
 ],
 "356": [
  "n = int(input())\na = list(map(int, input().split()))\nm = int(input())\nb = list(map(int, input().split()))\n\nsuma = sum(a)\nsumb = sum(b)\n\nif suma != sumb:\n    print(-1)\nelse:\n    i = 0\n    j = 0\n    cnt = 0\n    while i < n and j < m:\n        if a[i] == b[j]:\n            cnt += 1\n            i += 1\n            j += 1\n        elif a[i] < b[j]:\n            i += 1\n            a[i] += a[i-1]\n        else:\n            j += 1\n            b[j] += b[j-1]\n    print(cnt)"
 ],
 "357": [
  "problem_name = input()\nfriends = [\"Danil\", \"Olya\", \"Slava\", \"Ann\", \"Nikita\"]\ncount = 0\nfor friend in friends:\n    if problem_name.count(friend) == 1:\n        count += 1\nif count == 1:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "358": [
  "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n  \n  \na, b, k = map(int, input().split())\n\nleft, right = 1, b - a + 1\nans = -1\n\nwhile left <= right:\n    mid = (left + right) // 2\n    flag = False\n    for i in range(a, b - mid + 2):\n        if sum(is_prime(j) for j in range(i, i+mid)) < k:\n            flag = True\n            break\n    if flag:\n        left = mid + 1\n    else:\n        ans = mid\n        right = mid - 1\n\nprint(ans)"
 ],
 "359": [
  "a, h, w = map(int, input().split())\n\nif h < a or w < a:\n    print(-1)\nelse:\n    max_vertical = (h // a) * a\n    max_horizontal = (w // a) * a\n    possible_x = []\n    for i in range(1, (h // a) + 1):\n        possible_x.append(abs((h - (i * a)) - max_vertical))\n    for i in range(1, (w // a) + 1):\n        possible_x.append(abs((w - (i * a)) - max_horizontal))\n    print(min(possible_x) / 2)"
 ],
 "360": [
  "n = int(input())\nchapters = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    chapters.append((l, r))\nk = int(input())\n\nunread_chapters = 0\nfor i in range(n):\n    if chapters[i][0] <= k <= chapters[i][1]:\n        if k == chapters[i][0]:\n            unread_chapters = n - i\n        else:\n            unread_chapters = n - i - 1\n        break\n    elif k < chapters[i][0]:\n        unread_chapters = n\n        break\nprint(unread_chapters)"
 ],
 "361": [
  "s = input()\nn = len(s)\n\nfor i in range(1, n+1):\n    for j in range(i):\n        sub1 = s[:j]\n        sub2 = s[i:n]\n        if sub1 + sub2 == 'CODEFORCES':\n            print('YES')\n            exit()\n\nprint('NO')"
 ],
 "362": [
  "n = int(input())\ndp = [[0] * (n+1) for i in range(n+1)]\nfor len_ in range(2,n+1):\n    for i in range(1,n-len_+2):\n        j = i+len_-1\n        dp[i][j] = float('inf')\n        for k in range(i+1,j):\n            dp[i][j] = min(dp[i][j], dp[i][k]+dp[k][j]+i*j*k)\nprint(dp[1][n])"
 ],
 "363": [
  "n = input()\ndigits = len(n)\nif digits == 1:\n    print(int(n))\nelif digits == 2:\n    print((int(n)-9)*2+9)\nelif digits == 3:\n    print((int(n)-99)*3+9*2+90*2)\nelif digits == 4:\n    print((int(n)-999)*4+9*3+90*2+900*2)\nelif digits == 5:\n    print((int(n)-9999)*5+9*4+90*2+900*2+9000*2)\nelif digits == 6:\n    print((int(n)-99999)*6+9*5+90*2+900*2+9000*2+90000*2)\nelif digits == 7:\n    print((int(n)-999999)*7+9*6+90*2+900*2+9000*2+90000*2+900000*2)\nelif digits == 8:\n    print((int(n)-9999999)*8+9*7+90*2+900*2+9000*2+90000*2+900000*2+9000000*2)\nelif digits == 9:\n    print((int(n)-99999999)*9+9*8+90*2+900*2+9000*2+90000*2+900000*2+9000000*2+90000000*2)"
 ],
 "364": [
  "n, A = map(int, input().split())\ncars = list(map(int, input().split()))\ncolors = set(cars)\nwinning_color = -1\nfor color in colors:\n    if color == A:\n        continue\n    cnt_A, cnt_B = 0, 0\n    for car in cars:\n        if car == A:\n            cnt_A += 1\n        elif car == color:\n            cnt_B += 1\n        if cnt_B > cnt_A:\n            break\n    else:\n        if cnt_B == cnt_A:\n            continue\n        if winning_color == -1 or cnt_B > cnt_A:\n            winning_color = color\nprint(winning_color)"
 ],
 "365": [
  "n, x = map(int, input().split())\na = list(map(int, input().split()))\n\nif sum(a) + n - 1 == x:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "366": [
  "n, s = map(int, input().split()) \nres = (s + n - 1) // n\nprint(res)"
 ],
 "367": [
  "s = input()\ns = list(s)\nn = len(s)\nfreq = {}\nfor i in s:\n    if i not in freq:\n        freq[i] = 1\n    else:\n        freq[i] += 1\n        \nodd_freq_count = 0\nodd_freq_char = ''\nfor char, count in freq.items():\n    if count % 2 != 0:\n        odd_freq_count += 1\n        odd_freq_char = char\n\nif odd_freq_count > 1:\n    print(\"NO SOLUTION\")\n    \nelse:\n    result = [''] * n\n    start, end = 0, n-1\n    for char, count in freq.items():\n        if count % 2 == 0:\n            half_count = count // 2\n            while half_count > 0:\n                result[start] = char\n                result[end] = char\n                start += 1\n                end -= 1\n                half_count -= 1\n                \n        else:\n            half_count = count // 2\n            while half_count > 0:\n                result[start] = char\n                result[end] = char\n                start += 1\n                end -= 1\n                half_count -= 1\n                \n            odd_freq_char_count = freq[odd_freq_char]\n            while odd_freq_char_count > 0:\n                result[n//2] = odd_freq_char\n                odd_freq_char_count -= 1\n            \n    print(\"\".join(result))"
 ],
 "368": [
  "board = []\nfor i in range(8):\n    board.append(input().strip())\n\nwhite_weight, black_weight = 0, 0\nweights = {'Q': 9, 'R': 5, 'B': 3, 'N': 3, 'P': 1,\n           'q': 9, 'r': 5, 'b': 3, 'n': 3, 'p': 1}\n\nfor row in board:\n    for piece in row:\n        if piece in weights:\n            if piece.isupper():\n                white_weight += weights[piece]\n            else:\n                black_weight += weights[piece]\n\nif white_weight > black_weight:\n    print(\"White\")\nelif black_weight > white_weight:\n    print(\"Black\")\nelse:\n    print(\"Draw\")"
 ],
 "369": [
  "from collections import deque\n\nn, m = map(int, input().split())\ngame_over = list(map(int, input()))\n\n# start BFS from square 0\nque = deque([(0, [])])\nvisited = set()\n\nwhile que:\n    sq, seq = que.popleft()\n    if sq == n:\n        print(*seq)\n        break\n    if sq > n or sq in visited or game_over[sq]:\n        continue\n    visited.add(sq)\n    for i in range(1, m+1):\n        que.append((sq+i, seq+[i]))\nelse:\n    print(-1)    "
 ],
 "370": [
  "K, X, Y = map(int, input().split())\n\nif (X + Y) % 2 == 0:\n    d = (X + Y) // 2\n    if abs(d - X) <= K:\n        print(1)\n        print(X, d)\n        exit()\n    else:\n        k = K - d + X\n        if k % 2 == 0:\n            s = 2\n            print(2)\n            print(X, d - K// 2)\n            print(X + K // 2, d)\n            exit()\n        else:\n            s = 3\n            print(3)\n            print(X, d - K // 2 - 1)\n            print(X + K // 2 + 1, d + 1)\n            print(X, d)\n            exit()\nelse:\n    d = (X + Y + 1) // 2\n    if abs(d - X) <= K:\n        print(1)\n        print(X, d)\n        exit()\n    else:\n        k = K - d + X\n        if k % 2 == 0:\n            s = 2\n            print(2)\n            print(X, d - K // 2)\n            print(X + K // 2, d)\n            exit()\n        else:\n            s = 3\n            print(3)\n            print(X, d - K // 2)\n            print(X + K // 2, d)\n            print(X + K // 2 + 1, d - K // 2 + 1)\n            exit()"
 ],
 "371": [
  "def possible_chocolates(m):\n    for n in range(1, 101):\n        count = 0\n        for i in range(1, 101):\n            for j in range(i * (i + 1) // 2, n + 1):\n                left = j\n                for k in range(i):\n                    if left % (k + 2):\n                        break\n                    left //= k + 2\n                else:\n                    if left == 1:\n                        count += 1\n                        if count == m:\n                            return n\n                        break\n        if count > m:\n            break\n    return -1\n\nm = int(input())\nprint(possible_chocolates(m))"
 ],
 "372": [
  "import math\n\nx1, y1, r1 = map(int, input().split())\nx2, y2, r2 = map(int, input().split())\n\nd = math.dist([x1, y1], [x2, y2])\nr = r1 + r2\n\nif d >= r:\n    print(0)\nelif r1 >= d + r2:\n    print(math.pi * r2 ** 2)\nelif r2 >= d + r1:\n    print(math.pi * r1 ** 2)\nelse:\n    a1 = 2 * math.acos((r1 ** 2 - r2 ** 2 + d ** 2) / (2 * r1 * d))\n    a2 = 2 * math.acos((r2 ** 2 - r1 ** 2 + d ** 2) / (2 * r2 * d))\n    A1 = 0.5 * a1 * r1 ** 2 - 0.5 * r1 ** 2 * math.sin(a1)\n    A2 = 0.5 * a2 * r2 ** 2 - 0.5 * r2 ** 2 * math.sin(a2)\n    print(A1 + A2)"
 ],
 "373": [
  "n = int(input())\nif n == 2:\n    print(2)\nelse:\n    print(1)"
 ],
 "374": [
  "import sys\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\ndef dfs(node, graph, a, dp):\n    child_dp = [0]*2 # dp of children\n    for child in graph[node]:\n        dfs(child, graph, a, dp)\n        child_dp[0] += dp[child][0]\n        child_dp[1] += dp[child][1]\n    # choosing whether to pass node to children or not\n    dp[node][0] = child_dp[1] + a[node-1] # not passing\n    dp[node][1] = float(\"-inf\")\n    for child in graph[node]:\n        without_me = child_dp[1] - dp[child][1] # subtracting child[1] as it's not needed\n        with_me = child_dp[0] - dp[child][0] + dp[child][1] # adding back child[1] to account for child\n        dp[node][1] = max(dp[node][1], max(with_me, without_me)+a[node-1])\n    dp[node][1] = max(dp[node][1], child_dp[0]) # no child would be on left side\n    return\n\nn = int(input())\ngraph = defaultdict(list)\nfor i in range(2, n+1):\n    parent = int(input())\n    graph[parent].append(i)\na = list(map(int, input().split()))\ndp = [[0]*2 for _ in range(n+1)]\ndfs(1, graph, a, dp)\nprint(dp[1][1])"
 ],
 "375": [
  "n = int(input())\nS = input()\nT = input()\n\ncount = 0\nfor i in range(n):\n    if S[:i] + S[i+1:] == T[:i] + T[i+1:]:\n        count += 1\n\nif count == 1:\n    # there is only one word that can be transformed to both S and T due to a typo\n    print(n+1)\nelif count >= 2:\n    # there are multiple words that can be transformed to both S and T due to a typo\n    print(0)\nelse:\n    # there is no word that can be transformed to both S and T due to a typo\n    print(0)"
 ],
 "376": [
  "from collections import deque\n\nn = int(input())\nstrength = list(map(int, input().split()))\nadj_list = [[] for _ in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\ndef bfs(start, visited):\n    q = deque()\n    q.append(start)\n    visited[start] = True\n    while q:\n        curr = q.popleft()\n        for neighbor in adj_list[curr]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                q.append(neighbor)\n                strength[neighbor-1] -= strength[curr-1]\n\nvisited = [False] * (n+1)\nbfs(1, visited)\nresult = max(strength[i] for i in range(n) if visited[i+1])\nprint(result)"
 ],
 "377": [
  "n, m = map(int, input().split())\nif m == 0:\n    print(1)\nelse:\n    k = n - m\n    min_groups = k // (m + 1)\n    max_groups = min_groups + 1\n    count_max_groups = k % (m + 1)\n    print((min_groups * (m - count_max_groups + 1)) + (max_groups * count_max_groups))"
 ],
 "378": [
  "k, r = map(int, input().split())\ni = 1\nwhile True:\n    if ((k*i)%10 == r) or ((k*i)%10 == 0):\n        print(i)\n        break\n    i += 1"
 ],
 "379": [
  "n, m = map(int, input().split())\ngrid = []\nfor i in range(n):\n  row = input().strip()\n  grid.append(row)\n\n# count the number of X's\ncount = 0\nfor i in range(n):\n  for j in range(m):\n    if grid[i][j] == \"X\":\n      count += 1\n\n# check if count is a multiple of 4\nif count % 4 == 0:\n  # check if we can find a rectangle\n  for i in range(n):\n    for j in range(m):\n      if grid[i][j] == \"X\":\n        # check if there are three other X's in the same row and column\n        in_row = sum(grid[i][k] == \"X\" for k in range(m))\n        in_col = sum(grid[k][j] == \"X\" for k in range(n))\n        if in_row == 2 and in_col == 2:\n          # we found a rectangle\n          print(\"YES\")\n          exit()\n\n# no rectangle found\nprint(\"NO\")"
 ],
 "380": [
  "x = []\ny = []\n\nfor i in range(3):\n    a, b = map(int, input().split())\n    x.append(a)\n    y.append(b)\n\nif x.count(x[0]) == 2 or y.count(y[0]) == 2:\n    print(1)\n    \nelse:\n    if x.count(x[1]) == 2 or y.count(y[1]) == 2:\n        print(1)\n        \n    else:\n        print(2)"
 ],
 "381": [
  "# Solution\n\nk = int(input())\nif k % 2 == 1:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(4*k, 2*k*k)\n    for i in range(1, 2*k+1):\n        print(i, (i % (2*k)) + 1)\n        print(i, ((i+k-1) % (2*k)) + 1)"
 ],
 "382": [
  "n, m, q = map(int, input().split())\ns = input()\nt = input()\n\nfor i in range(q):\n    l, r = map(int, input().split())\n    ans = 0\n    for j in range(l-1, r-m+1):\n        if s[j:j+m] == t:\n            ans += 1\n    print(ans)"
 ],
 "383": [
  "MOD = int(1e9+7)\n\nn, k, d = map(int, input().split())\n\ndp = [0] * (n+1)\ndp[0] = 1\nfor i in range(1, n+1):\n    s = 0\n    for j in range(1, k+1):\n        if i < j:\n            break\n        if j < d:\n            s = (s + dp[i-j]) % MOD\n        else:\n            s = (s + dp[i-j] - dp[i-d-j-1] + MOD) % MOD\n    dp[i] = s\n\nprint((dp[n] - dp[d-1]) % MOD)"
 ],
 "384": [
  "n = int(input())\nrow = input()\ncount, ans = 0, []\nfor i in range(n):\n    if row[i] == 'B':\n        count += 1\n        if i == n-1:\n            ans.append(count)\n    else:\n        if count != 0:\n            ans.append(count)\n            count = 0\nprint(len(ans))\nprint(*ans)"
 ],
 "385": [
  "n, m, p = map(int, input().split())\ns = input()\nstack = []\nmatch = [0]*n\nfor i in range(n):\n    if s[i] == \"(\":\n        stack.append(i)\n    else:\n        j = stack.pop()\n        match[i], match[j] = j, i\n\nfor _ in range(m):\n    op = input()\n    if op == \"L\":\n        if p > 1:\n            p -= 1\n    elif op == \"R\":\n        if p < n:\n            p += 1\n    else:\n        if s[p-1] == \"(\":\n            q = match[p-1]+1\n        else:\n            q = match[p-2]+1\n        if p > q:\n            p, q = q, p\n        s = s[:p-1] + s[q:]\n        n -= q - p\n        if p > n:\n            p = n if n%2==0 else n-1\n        if p > 1 and s[p-2] == \")\":\n            p -= 1\nprint(s)"
 ],
 "386": [
  "n=int(input())\nq=[]\nfor i in range(n):\n    q.append(input().split())\n\nl,r=-2*(10**9),2*(10**9)\nfor i in range(n):\n    s,x,a=q[i]\n    x=int(x)\n    if s=='>':\n        if a=='Y':\n            l=max(l,x+1)\n        else:\n            r=min(r,x)\n    elif s=='<':\n        if a=='Y':\n            r=min(r,x-1)\n        else:\n            l=max(l,x)\n    elif s=='>=':\n        if a=='Y':\n            l=max(l,x)\n        else:\n            r=min(r,x-1)\n    else:\n        if a=='Y':\n            r=min(r,x)\n        else:\n            l=max(l,x+1)\n\nif l>r:\n    print(\"Impossible\")\nelse:\n    print(l)"
 ],
 "387": [
  "python\na, b = map(int, input().split())\ndef gcd(a, b): \n    if(b == 0): \n        return a \n    else: \n        return gcd(b, a % b)  \nanswer = 0\nfor i in range(1, b+1): \n    if(b % i == 0):\n        g = gcd(a+i, b-i) \n        answer += (1 if (a+i) // g == (a+i+ (b-i)) // g else 0)\nprint(answer)"
 ],
 "388": [
  "n, k = map(int, input().split())\ns = input().split()\n\nsoldiers = []\nused = set()\nfor i in range(n-k+1):\n    if s[i] == 'YES':\n        for j in range(k):\n            if i+j not in used:\n                used.add(i+j)\n                soldiers.append(chr(ord('A')+j)*10)\n            else:\n                for name in soldiers:\n                    if name[0] == chr(ord('A')+j):\n                        used.add(i+j)\n                        soldiers.append(name)\n                        soldiers.remove(name)\n                        break\n    else:\n        for j in range(k):\n            soldiers.append(chr(ord('A')+j)*10)\n\nprint(' '.join(soldiers))"
 ],
 "389": [
  "a, b = map(int, input().split())\n\ncount_2a = count_2b = count_3a = count_3b = count_5a = count_5b = 0\n\nwhile a % 2 == 0:\n    a //= 2\n    count_2a += 1\nwhile b % 2 == 0:\n    b //= 2\n    count_2b += 1\n\nwhile a % 3 == 0:\n    a //= 3\n    count_3a += 1\nwhile b % 3 == 0:\n    b //= 3\n    count_3b += 1\n\nwhile a % 5 == 0:\n    a //= 5\n    count_5a += 1\nwhile b % 5 == 0:\n    b //= 5\n    count_5b += 1\n\nif a != b:\n    print(-1)\nelse:\n    print(abs(count_2a - count_2b) + abs(count_3a - count_3b) + abs(count_5a - count_5b))"
 ],
 "390": [
  "n,a,b=map(int,input().split())\nc=list(map(int,input().split()))\ncost=0\nfor i in range(n//2):\n    if c[i]==2 and c[-i-1]==2:\n        cost+=2*min(a,b)\n    elif c[i]==2:\n        cost+=b if c[-i-1]==1 else a\n    elif c[-i-1]==2:\n        cost+=b if c[i]==1 else a\n    elif c[i]!=c[-i-1]:\n        cost=-1\n        break\nelse:\n    cost+=b*(c.count(1)//2)+a*(c.count(0)//2)\nprint(cost)"
 ],
 "391": [
  "k = int(input())\nif k % 2 == 1:\n    print(-1)\nelse:\n    for i in range(k):\n        for j in range(k):\n            layer = i // 2\n            if layer % 2 == 0 and j % 2 == 0:\n                print(\"b\", end=\"\")\n            elif layer % 2 == 0 and j % 2 == 1:\n                print(\"w\", end=\"\")\n            elif layer % 2 == 1 and j % 2 == 0:\n                print(\"w\", end=\"\")\n            else:\n                print(\"b\", end=\"\")\n        print()"
 ],
 "392": [
  "n = int(input())\nans = n\nfor i in range(2, int(n ** 0.5) + 1):\n    if n % i == 0:\n        while n % i == 0:\n            n //= i\n        ans //= i\n        ans *= i - 1\nif n > 1:\n    ans //= n\n    ans *= n - 1\nprint(ans)"
 ],
 "393": [
  "n = int(input())\nseating = input()\n\nmaximal = True\n\nif '11' in seating:\n    maximal = False\nelif '000' in seating:\n    maximal = False\nelif n > 2 and seating[0] == '1' and seating[-1] == '1':\n    maximal = False\n\nif maximal:\n    print(\"Yes\")\nelse:\n    print(\"No\")"
 ],
 "394": [
  "n = int(input())\na = list(map(int,input().split()))\n\npossible_k = []\nfor k in range(1,n+1):\n    flag = True\n    for i in range(k,n):\n        if a[i]!=a[i%k]+a[i-k]:\n            flag = False\n            break\n    if flag:\n        possible_k.append(k)\n\nprint(len(possible_k))\nprint(*possible_k)"
 ],
 "395": [
  "scores = list(map(int, input().split()))\ntotal_score = sum(scores)\npossible = False\nfor i in range(6):\n    for j in range(i + 1, 6):\n        for k in range(j + 1, 6):\n            if scores[i] + scores[j] + scores[k] == total_score / 2:\n                possible = True\nif possible:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "396": [
  "l, r = map(int, input().split())\na, b = 1, 1\ncount = 0\nwhile a <= r:\n  b = 1\n  while b <= r:\n    val = a * b\n    if l <= val <= r:\n      count += 1\n    if val > r:\n      break\n    b *= 3\n  if a > r/2:\n    break\n  a *= 2\nprint(count)"
 ],
 "397": [
  "n,k = map(int,input().split())\nl,r = 0,n+1\nwhile l<r:\n    m = (l+r)//2\n    if m*(m+1)//2 - (n-m) > k:\n        r = m\n    else:\n        l = m+1\nprint(n-l)"
 ],
 "398": [
  "n = int(input())\nsegments = sorted(list(map(int, input().split())))\n\nfor i in range(n-2):\n    if segments[i] + segments[i+1] > segments[i+2]:\n        print(\"YES\")\n        break\nelse:\n    print(\"NO\")"
 ],
 "399": [
  "x, y = map(int, input().split())\nif x == 0 and y == 1:\n    print(\"Yes\")\nelif x == 0:\n    print(\"No\")\nelif (y - x) % 2 == 0 and (y - x) // 2 <= x and (y - x) // 2 >= 0:\n    print(\"Yes\")\nelse:\n    print(\"No\")"
 ],
 "400": [
  "n, k = map(int, input().split())\na = sorted(list(map(int, input().split())))\n\ncnt = 0\nwhile k > 0 and cnt < n:\n    if k >= 10 - a[cnt] % 10 and a[cnt] < 100:\n        k -= 10 - a[cnt] % 10\n        a[cnt] += 10 - a[cnt] % 10\n    cnt += 1\n\nprint(sum(map(lambda x: x // 10, a)))"
 ],
 "401": [
  "n, m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nfor i in range(1, 10):\n    if i in a and i in b:\n        print(i)\n        break"
 ],
 "402": [
  "n,k = map(int,input().split())\ntime_left = 240 - k\ncount = 0\nfor i in range(1,n+1):\n    if time_left >= i*5:\n        time_left -= i*5\n        count += 1\nprint(count if count<=n else n)"
 ],
 "403": [
  "n, x, y = map(int, input().split())\na = list(map(int, input().split()))\n\nmax_teams = 0\n\nfor i in range(n):\n    if a[i] <= x:\n        max_teams += 1\n    elif a[i] > x and a[i] <= x + y:\n        max_teams += 1\n        y -= (a[i] - x)\n    else:\n        break\n\nprint(max_teams)"
 ],
 "404": [
  "from math import gcd \nn = int(input())\nans1 = 1 \nfor i in range(2, int(n**0.5)+1):\n    if n % i == 0:\n        ans1 += 1\n        while n % i == 0:\n            n //= i \nif n > 1:\n    ans1 += 1\n\nans2 = 1 \nfor i in range(2, int(n**0.5)+1):\n    if n % i == 0:\n        ans2 += 1\n        while n % i == 0:\n            n //= i \nif n > 1:\n    ans2 += 1\n    \nprint(ans1*ans2)"
 ],
 "405": [
  "n = int(input())\ns = input()\ncount = 0\nfor i in range(n):\n    if s[i] == '<':\n        if i == 0 or s[i-1] == '>':\n            count += 1\n    elif s[i] == '>':\n        if i == n-1 or s[i+1] == '<':\n            count += 1\nprint(count)"
 ],
 "406": [
  "n = int(input())\nsticks = list(map(int, input().split()))\nsticks.sort()\ni = 0\nans = 0\nwhile i < n - 1:\n    if sticks[i] == sticks[i + 1]:\n        if sticks[i + 2] == sticks[i + 3]:\n            ans += sticks[i] * sticks[i + 2]\n            i += 4\n        else:\n            i += 2\n    else:\n        i += 1\nprint(ans)"
 ],
 "407": [
  "n = int(input())\nnums = []\nnum_map = {}\nfor i in range(n):\n    num = input().strip()\n    nums.append(num)\n    for j, c in enumerate(num):\n        num_map[c] = num_map.get(c, set())\n        num_map[c].add(j)\n\nused = set()\nnum_dict = {}\nfor num in sorted(nums, key=len):\n    for i, c in enumerate(num):\n        if c not in used:\n            if i == 0:\n                if len(num) > 1 and 'a' in num_map[c]:\n                    continue\n                num_dict[c] = '1'\n                used.add(c)\n            else:\n                if not any('a' in num_map[digit] and digit in used for digit in num[:i]):\n                    num_dict[c] = str(len(used))\n                    used.add(c)\n                    break\n\ntotal_sum = 0\nfor num in nums:\n    val = 0\n    for c in num:\n        val = val * 10 + int(num_dict[c])\n    total_sum += val\n\nprint(total_sum)"
 ],
 "408": [
  "n, m = map(int, input().split())\nteams = 0\nwhile n > 0 and m > 0:\n    if n >= m:\n        teams += m\n        n -= m\n        m = 0\n    else:\n        teams += n\n        m -= n\n        n = 0\nteams += (n // 3) + (m // 3)\nprint(teams)"
 ],
 "409": [
  "s = input()\n\nif \"AB\" in s and \"BA\" in s[s.index(\"AB\")+2:] or \"BA\" in s and \"AB\" in s[s.index(\"BA\")+2:]:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "410": [
  "n = int(input())\na = list(map(int, input().split()))\nk = int(input())\nb = list(map(int, input().split()))\n\nqueue = list(range(n))\n\nmoves = []\n\nfor monster in b:\n    if monster not in a:\n        print(\"NO\")\n        break\n    index = a.index(monster)\n    target_index = queue.index(index)\n    while target_index > 0 and a[queue[target_index]] > a[queue[target_index-1]]:\n        queue[target_index], queue[target_index-1] = queue[target_index-1], queue[target_index]\n        moves.append((queue[target_index-1]+1, \"R\"))\n        target_index -= 1\n\n    while target_index < len(queue)-1 and a[queue[target_index]] > a[queue[target_index+1]]:\n        queue[target_index], queue[target_index+1] = queue[target_index+1], queue[target_index]\n        moves.append((queue[target_index]+1, \"L\"))\n        target_index += 1\nelse:\n    print(\"YES\")\n    for m in moves:\n        print(*m)"
 ],
 "411": [
  "R, B = map(int, input().split())\nrebels = [tuple(map(int, input().split())) for _ in range(R)]\nbases = [tuple(map(int, input().split())) for _ in range(B)]\n\n# Check if it is possible to connect every base to a rebel without intersections\nfor i, b in enumerate(bases):\n    possible_rebels = []\n    for r in rebels:\n        if all(r[j] < b[j] for j in range(2)) or all(r[j] > b[j] for j in range(2)):\n            possible_rebels.append(r)\n    if len(possible_rebels) != 1:\n        print(\"No\")\n        break\nelse:\n    print(\"Yes\")"
 ],
 "412": [
  "n = int(input())\na = list(map(int, input().split()))\nr = 0\ncount = 0\nfor i in a:\n    if i % 2 == 0:\n        count += 1\n        while i % 2 == 0:\n            i //= 2\n        r = max(r, i)\nprint(r, count)"
 ],
 "413": [
  "n, m = map(int, input().split())\n\ncount = 0\nwhile n < m:\n    if m % 2 == 0:\n        m //= 2\n    else:\n        m += 1\n    count += 1\n\ncount += n - m\nprint(count)"
 ],
 "414": [
  "n = int(input())\nsegments = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r, i))\n\nsegments.sort()\nedges = []\nfor i in range(n-1):\n    for j in range(i+1, n):\n        if segments[j][0] <= segments[i][1]:\n            if segments[j][1] > segments[i][1]:\n                edges.append((segments[i][2], segments[j][2]))\n            else:\n                edges.append((segments[j][2], segments[i][2]))\n        else:\n            break\n\nparent = [i for i in range(n)]\n\ndef find(x):\n    if parent[x] == x:\n        return x\n    parent[x] = find(parent[x])\n    return parent[x]\n\ndef union(x, y):\n    parent[find(x)] = find(y)\n\nfor edge in edges:\n    if find(edge[0]) == find(edge[1]):\n        print(\"NO\")\n        exit()\n    else:\n        union(edge[0], edge[1])\n\nif len(set(find(i) for i in range(n))) == 1:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "415": [
  "n = int(input())\nr = list(map(int,input().split()))\nans = 0\n\nfor i in range(n):\n    cur_total = 0\n    for j in range(i, n):\n        cur_total += r[j]\n        time_period = j - i + 1\n        if cur_total > time_period * 100:\n            ans = max(ans, time_period)\nprint(ans)"
 ],
 "416": [
  "n, k = map(int, input().split())\nepisodes = input()\ndp = [[0]*(k+1) for i in range(n+1)]\ncnt = 0\nfor i in range(1, n+1):\n    if episodes[i-1] == 'N':\n        cnt += 1\n    else:\n        cnt = 0\n    for j in range(k+1):\n        dp[i][j] = max(dp[i-1][j], cnt + dp[i-1][j-1] if j > 0 else 0)\nif dp[n][k] >= k:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "417": [
  "n,x,d = map(int, input().split())\n\n# Removing negative sign in front of integer (x)\nif d < 0:\n    d = -d\n    x = -x\n\n# Maximum sum T, Minimum sum S of given sequence\nmaxSum = (n-1)*n//2*d + x\nminSum = x\nif maxSum < 0:\n    maxSum, minSum = -minSum, -maxSum\n    \n# Number of times T will be repeated\nt_times = min(maxSum//d,n-1)\n\n# First T and Last T of the sequence\nT_first = (n-t_times)*x + t_times*(t_times-1)//2*d\nT_last = (n-1)*x - (t_times-1)*t_times//2*d\n\n# Set of distinct possible values of S-T\ndiffSet = set()\nfor i in range(t_times+1):\n    S = T_first + (t_times-i)*T_last + i*(i-1)//2*d\n    diffSet.add(2*S - maxSum)\n\n# Length of the set\nans = len(diffSet)\nprint(ans)"
 ],
 "418": [
  "n = int(input())\nflag = 0\nfor i in range(n):\n    p, b, a = input().split()\n    if int(a) >= 2400 and int(b) < 2400:\n        flag = 1\nif flag == 1:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "419": [
  "s = int(input(), 2)\ncount = 0\nwhile s:\n    count += s & 1\n    s //= 4\nprint(count)"
 ],
 "420": [
  "n, m = map(int, input().split())\na = []\nfor i in range(n):\n    row = list(map(int, input().split()))\n    a.append(row)\n\ndef is_palindrome(matrix):\n    n = len(matrix)\n    m = len(matrix[0])\n    for i in range(n//2):\n        if matrix[i] != matrix[n-i-1]:\n            return False\n    return True\n\nwhile n > 1:\n    if is_palindrome(a):\n        print(n)\n        break\n    \n    if n % 2 == 0:\n        if is_palindrome(a[:n//2]) and is_palindrome(a[n//2:]):\n            n //= 2\n            a = a[:n]\n        else:\n            print(n)\n            break\n    else:\n        print(n)\n        break\nelse:\n    print(1)"
 ],
 "421": [
  "n = int(input())\norders = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    orders.append((l, r))\norders.sort(key=lambda x: x[1])\naccepted, last_end = 0, 0\nfor i in range(n):\n    if orders[i][0] >= last_end:\n        accepted += 1\n        last_end = orders[i][1]\nprint(accepted)"
 ],
 "422": [
  "n, k = map(int, input().split())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\n\nrunning_tables = 0\nrunning_formulas = 0\n\nfor i in range(n):\n    for j in range(x[i]):\n        if running_tables >= k:\n            print(\"NO\")\n            exit(0)\n        running_tables += 1\n        running_formulas = 0\n    \n    for j in range(y[i]):\n        if running_formulas >= k:\n            print(\"NO\")\n            exit(0)\n        running_formulas += 1\n        running_tables = 0\n\nprint(\"YES\")"
 ],
 "423": [
  "import sys\n\ndef solve(n, k, a):\n    # find the degree of the polynomial by linear search\n    deg = n\n    for i in range(n+1):\n        if a[i] == '?':\n            deg = i\n            break\n    # if k is 0, then human wins if and only if the constant coefficient is 0\n    if k == 0:\n        return a[0] == 0\n    # if degree is even and the constant coefficient is non-zero, then the human wins\n    if deg % 2 == 0 and a[0] != 0:\n        return True\n    # if degree is odd and the constant coefficient is zero, then the human wins\n    if deg % 2 == 1 and a[0] == 0:\n        return True\n    # otherwise, the computer wins\n    return False\n\nn, k = map(int, input().split())\na = [None] * (n+1)\nfor i in range(n+1):\n    a[i] = input().strip()\nprint(\"Yes\" if solve(n, k, a) else \"No\")"
 ],
 "424": [
  "n = int(input())\n\n# function to check if a number is prime\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\n# function to find the smallest multiple of a prime number that is\n# not smaller than the given number\ndef smallest_multiple(num, prime):\n    if num % prime == 0:\n        return num\n    return (num // prime + 1) * prime\n\n# loop through all possible starting numbers X_0 and check if it is possible\n# to reach X_2 from that number\nfor i in range(3, n):\n    # if X_2 is divisible by i, skip to the next number\n    if n % i == 0:\n        continue\n    # Alice's turn\n    x1 = smallest_multiple(i, 2)\n    # Bob's turn\n    for j in range(3, n // x1 + 1, 2):\n        # if X_2 is divisible by x1 * j, we have found a possible starting number\n        if n % (x1 * j) == 0:\n            print(i)\n            exit()\nprint(n-1) # if no possible starting number is found, the answer is X_2 - "
 ],
 "425": [
  "n,p=map(int,input().split())\nans=[]\nfor i in range(30):\n    for j in range(30):\n        if i+j==0:\n            continue\n        k=n-(2**i)*j\n        if k<0:\n            break\n        if bin(k)[2:].count('1')<=j and k%abs(p)==0:\n            ans.append(i+j)\nprint(min(ans) if len(ans)>0 else -1)"
 ],
 "426": [
  "n, k = map(int, input().split())\ns = input()\ns = list(s)\n\nfor i in range(n):\n    if k == 0:\n        break\n    if i == 0 and s[i] != '1':\n        s[i] = '1'\n        k -= 1\n    elif i > 0 and s[i] != '0' and s[i] != '1':\n        s[i] = '0'\n        k -= 1\n\nprint(''.join(s))"
 ],
 "427": [
  "from math import gcd\n\n\ndef check(mid, cnt1, cnt2, x, y):\n    # calculate numbers divisible by x and not divisible by y\n    a = mid//x - mid//(x*y)\n    # calculate numbers divisible by y and not divisible by x\n    b = mid//y - mid//(x*y)\n    # calculate numbers divisible by both x and y\n    c = mid//(x*y)\n    # check if there are enough numbers for each friend\n    return cnt1 <= mid-a and cnt2 <= mid-b and cnt1+cnt2 <= mid-a-b+c\n\n\ncnt1, cnt2, x, y = map(int, input().split())\n\n# conduct binary search to find the minimum v that satisfies the conditions\nl, r = 1, 10**18\nwhile l < r:\n    mid = (l+r)//2\n    if check(mid, cnt1, cnt2, x, y):\n        r = mid\n    else:\n        l = mid+1\n\nprint(l)"
 ],
 "428": [
  "n, sx, sy, dx, dy, t = map(int, input().split())\nx_shift = dx * t\ny_shift = dy * t\ncurr_x, curr_y = sx, sy\nnum_raspberries = sx + sy\n\nfor i in range(t):\n    num_raspberries += 1\n    k = num_raspberries\n    dx += k\n    dy += k\n    curr_x = ((curr_x + dx - 1) % n) + 1\n    curr_y = ((curr_y + dy - 1) % n) + 1\n\nprint(curr_x, curr_y)"
 ],
 "429": [
  "from collections import defaultdict\n\ns = input()\nn = len(s)\n\nif n < 26:\n    print(-1)\nelse:\n    freq = defaultdict(int)\n    question_marks = 0\n    for i in range(26):\n        if s[i] == '?':\n            question_marks += 1\n        else:\n            freq[s[i]] += 1\n    \n    if len(freq) + question_marks == 26:\n        for i in range(question_marks):\n            if chr(ord('A') + i) not in freq:\n                freq[chr(ord('A') + i)] = 1\n        \n        res = \"\"\n        for i in range(n):\n            if s[i] != '?':\n                res += s[i]\n            elif i >= 26:\n                freq[s[i - 26]] -= 1\n                if freq[s[i - 26]] == 0:\n                    del freq[s[i - 26]]\n                if 'A' not in freq:\n                    freq['A'] = 1\n                else:\n                    c = ord('A')\n                    while chr(c) in freq:\n                        c += 1\n                    freq[chr(c)] = 1\n                res += chr(c)\n            else:\n                if 'A' not in freq:\n                    freq['A'] = 1\n                else:\n                    c = ord('A')\n                    while chr(c) in freq:\n                        c += 1\n                    freq[chr(c)] = 1\n                res += chr(c)\n        \n        print(res)\n    else:\n        for i in range(26, n):\n            freq[s[i - 26]] -= 1\n            if freq[s[i - 26]] == 0:\n                del freq[s[i - 26]]\n            if s[i] == '?':\n                question_marks += 1\n            else:\n                freq[s[i]] += 1\n            \n            if len(freq) + question_marks == 26:\n                break\n        \n        else:\n            print(-1)\n            exit()\n        \n        for i in range(question_marks):\n            if chr(ord('A') + i) not in freq:\n                freq[chr(ord('A') + i)] = 1\n        \n        res = \"\"\n        for i in range(26):\n            if s[i] != '?':\n                res += s[i]\n            else:\n                res += list(set('ABCDEFGHIJKLMNOPQRSTUVWXYZ') - set(freq.keys()))[0]\n                freq[res[-1]] = 1\n        \n        for i in range(26, n):\n            if s[i] != '?':\n                res += s[i]\n            else:\n                freq[res[i - 26]] -= 1\n                if freq[res[i - 26]] == 0:\n                    del freq[res[i - 26]]\n                if 'A' not in freq:\n                    freq['A'] = 1\n                else:\n                    c = ord('A')\n                    while chr(c) in freq:\n                        c += 1\n                    freq[chr(c)] = 1\n                res += chr(c)\n        \n        print(res)"
 ],
 "430": [
  "n = int(input())\nweights = list(map(int, input().split()))\n\ntotal_weight = sum(weights)\nnum_100grams = weights.count(100)\nnum_200grams = weights.count(200)\n\nif total_weight % 2 != 0:\n    print(\"NO\")\nelif total_weight == 200 * num_200grams:\n    print(\"YES\")\nelif num_100grams % 2 != 0:\n    print(\"NO\")\nelse:\n    print(\"YES\")"
 ],
 "431": [
  "n,m=[int(i) for i in input().split()]\na=[]\nfor i in range(n):\n    a.append(input())\ndp=[[float('inf')]*(1<<m) for i in range(n)] \ndef cnt(state): # count the number of light bulbs that are turned on\n    c=0\n    for i in range(m):\n        if(state&(1<<i)):\n            c+=1\n    return c\ndef solve(i,state):\n    if(i==n):\n        return 0\n    if(dp[i][state]!=float('inf')):\n        return dp[i][state]\n    for j in range(2): # 0 means using left stair and 1 means using right stair\n        curr_state=state\n        t=0\n        for k in range(m):\n            if(a[i][k+1]=='1' and not (state & (1<<k))):\n                curr_state|=1<<k;\n                t=max(t,k+1)\n        if(j==0):\n            if(t!=0):\n                t=t*2+1 # go up through left stair\n            else:\n                t=0 # no bulb was turned on\n            dp[i][state]=min(dp[i][state],solve(i+1,curr_state)+(t+1))\n        else:\n            if(t!=0):\n                t=(m-t+1)*2+1 # go up through right stair\n            else:\n                t=0 # no bulb was turned on\n            dp[i][state]=min(dp[i][state],solve(i+1,curr_state)+(t+1))\n    return dp[i][state]\n \nprint(solve(0,0))"
 ],
 "432": [
  "n = int(input())\nc = list(map(int, input().split()))\na = list(map(int, input().split()))\n\nvisited = [False] * n\ntrap = set()\n\ndef dfs(room):\n    visited[room-1] = True\n    next_room = a[room-1]\n    if not visited[next_room-1]:\n        dfs(next_room)\n    if next_room in trap:\n        trap.remove(next_room)\n\nfor i in range(1, n+1):\n    if not visited[i-1]:\n        trap.add(a[i-1])\n        dfs(i)\n\nprint(sum([c[room-1] for room in trap]))"
 ],
 "433": [
  "n, a, b = map(int, input().split())\nk = (a + b) % n\nif k == 0:\n    k = n\nelif k < 0:\n    k += n\nprint(k)"
 ],
 "434": [
  "n = int(input())\na = list(map(int,input().split()))\nans, prev, count = 0, None, 0\nfor i in range(n):\n    if a[i] == -1:\n        count+=1\n        if prev != None:\n            a[i] = prev\n    else:\n        if prev != None and prev != -1 and i>0 and a[i]-prev != diff:\n            ans+=1\n            prev = None\n        if i>0 and a[i] != prev and prev != -1:\n            if count>0:\n                diff = (a[i]-prev)//count\n                for j in range(i-count,i):\n                    a[j] = prev + diff*(j+1-(i-count))\n                count = 0\n            else:\n                diff = a[i]-prev\n        prev = a[i]\nif count > 0:\n    ans+=1\nelse:\n    for i in range(1,n):\n        if a[i]-a[i-1] != diff and a[i-1]!=-1 and a[i]!=-1:\n            ans+=1\n            break\nif prev == -1:\n    a[-1] = a[-2]+diff\n    \nprint(ans+1)"
 ],
 "435": [
  "n, k = map(int, input().split())\ns = input()\n\nans = 1\nfor c in set(s):\n    cnt = lo = hi = 0\n    while hi < n:\n        if s[hi] != c:\n            cnt += 1\n        hi += 1\n        if cnt > k:\n            if s[lo] != c:\n                cnt -= 1\n            lo += 1\n        ans = max(ans, hi - lo)\n\nprint(ans)"
 ],
 "436": [
  "n = int(input())\na = list(map(int, input().split()))\n\ntotal = sum(a)\nalice = a[0]\n\ncoalition = [1] # Alice's party is always included in the coalition\nfor i in range(1, n):\n    if a[i] * 2 <= alice:\n        continue\n    if alice + a[i] > total / 2:\n        coalition.append(i+1)\n        break\n    else:\n        coalition.append(i+1)\n        alice += a[i]\n\nif len(coalition) == 1:\n    print(0)\nelse:\n    print(len(coalition))\n    print(\" \".join(str(p) for p in coalition))"
 ],
 "437": [
  "n = int(input())\ntotal_reward = 0\nfor i in range(1, n+1):\n    total_reward += i/n\nprint(\"%.12f\" % total_reward)"
 ],
 "438": [
  "n = int(input())\nk = int((-1 + (1 + 8*n)**0.5)/2) # maximum number of kids\nres = n - k*(k+1)//2 # remaining candies\nif res == 0:\n    print(k)\n    print(*list(range(1, k+1)))\nelse:\n    print(k+1)\n    print(*(list(range(1, k+1)) + [res]))"
 ],
 "439": [
  "n = int(input())\nm = int(input())\nprint(m % (2**n))"
 ],
 "440": [
  "n = int(input())\ns = input()\nvowels = set(['a', 'e', 'i', 'o', 'u', 'y'])\noutput = ''\ni = 0\nwhile i < n:\n    output += s[i] \n    if i+1 < n and s[i] in vowels and s[i+1] in vowels:\n        i += 1\n    i += 1\nprint(output)"
 ],
 "441": [
  "n, a, b = map(int, input().split())\ns = input()\n\ncount = 0\nlast = ''\nfor i in range(n):\n    if s[i] == '*':\n        last = '*'\n        continue\n    if last == '':\n        count += 1\n        last = 'a'\n        a -= 1\n    elif last == 'a' and b > 0:\n        count += 1\n        last = 'b'\n        b -= 1\n    elif last == 'b' and a > 0:\n        count += 1\n        last = 'a'\n        a -= 1\n    else:\n        last = ''\nprint(count)"
 ],
 "442": [
  "r = int(input())\nfor x in range(1,int(r**0.5)+1):\n    if (r-x-1)%(2*x) == 0:\n        y = (r-x-1)//(2*x)\n        print(x,y)\n        break\nelse:\n    print(\"NO\")"
 ],
 "443": [
  "n = int(input())\na = list(map(int, input().split()))\n\ntotal_balloons = sum(a)\nif total_balloons % 2 == 1:\n    print(\"-1\")\nelse:\n    grigory = []\n    andrew = []\n    for i in range(n):\n        if a[i] % 2 == 1:\n            grigory.append(i+1)\n            andrew.append(i+1)\n        else:\n            grigory.append(i+1) if len(grigory) < len(andrew) else andrew.append(i+1)\n    if sum(a[i-1] for i in grigory) == sum(a[i-1] for i in andrew):\n        print(len(grigory))\n        print(*grigory)\n    else:\n        print(\"-1\")"
 ],
 "444": [
  "n=int(input())\nans=[]\nfor i in range(9,0,-1):\n    while n>=i:\n        n-=i\n        ans.append(i)\nans.sort()\nk=len(ans)\nprint(k)\nprint(*ans)"
 ],
 "445": [
  "from math import isqrt\nn = int(input())\na = list(map(int, input().split()))\n\nprimes = set()\nfor i in range(n):\n    for j in range(i+1, n):\n        x = a[i] + a[j]\n        for d in range(2, isqrt(x)+1):\n            if x % d == 0:\n                break\n        else:\n            primes.add(a[i])\n            primes.add(a[j])\n\nprint(len(primes))\nprint(*primes)"
 ],
 "446": [
  "n = int(input())\n\nfor k in range(20, -1, -1):\n    divisor = (1<<k) - 1\n    if divisor == n//divisor and n%divisor == 0:\n        print(divisor)\n        break"
 ],
 "447": [
  "MOD = 10**9 + 7\n\nm, d = map(int, input().split())\na, b = input().strip(), input().strip()\nn = len(a)\ndp = [[[0 for j in range(m)] for i in range(2)] for k in range(n+1)]\ndp[0][1][0] = 1\n\nfor i in range(1, n+1):\n    for tight in range(2):\n        limit = int(b[i-1]) if tight else 9\n        for j in range(m):\n            for dig in range(limit+1):\n                if dig == d:\n                    continue\n                if tight and dig != limit:\n                    continue\n                newTight = tight and (dig == limit)\n                newRem = (j*10+dig)%m\n                if (i%2 == 0 and d == dig) or (i%2 == 1 and d != dig):\n                    dp[i][newTight][newRem] += dp[i-1][tight][j]\n                    dp[i][newTight][newRem] %= MOD\n\nans = (dp[n][0][0] + dp[n][1][0] - 1)%MOD\n\na = str(int(a)-1)\nn = len(a)\ndp = [[[0 for j in range(m)] for i in range(2)] for k in range(n+1)]\ndp[0][1][0] = 1\n\nfor i in range(1, n+1):\n    for tight in range(2):\n        limit = int(a[i-1]) if tight else 9\n        for j in range(m):\n            for dig in range(limit+1):\n                if dig == d:\n                    continue\n                if tight and dig != limit:\n                    continue\n                newTight = tight and (dig == limit)\n                newRem = (j*10+dig)%m\n                if (i%2 == 0 and d == dig) or (i%2 == 1 and d != dig):\n                    dp[i][newTight][newRem] += dp[i-1][tight][j]\n                    dp[i][newTight][newRem] %= MOD\n\nans -= (dp[n][0][0] + dp[n][1][0] - 1)%MOD\n\nprint(ans%MOD)"
 ],
 "448": [
  "n, m = map(int, input().split())\na = list(map(int, input().split()))\n\nqueue = list(range(n))\nwhile queue:\n    i = queue.pop(0)\n    if a[i] <= m:\n        m -= a[i]\n    else:\n        queue.append(i)\nprint(i+1)"
 ],
 "449": [
  "n=int(input())\nbills=[100,20,10,5,1] # denominations in decreasing order\ncount=0\nfor bill in bills:\n    count+=n//bill       # count number of bills of current denomination\n    n=n%bill             # update remaining balance\nprint(count)"
 ],
 "450": [
  "n, k = map(int, input().split())\n\nMOD = 10**9 + 7\n\n# Initializing DP table\ndp = [[0] * (n+1) for _ in range(n+1)]\ndp[0][0] = 1\n\n# DP table calculation\nfor i in range(1, n+1):\n    for j in range(i+1):\n        if j == 0:\n            dp[i][j] = dp[i-1][j+1]\n        elif j == i:\n            dp[i][j] = dp[i-1][j-1]\n        else:\n            dp[i][j] = (dp[i-1][j-1] + dp[i-1][j+1]) % MOD\n\n# Final answer\nprint(dp[n][k])"
 ],
 "451": [
  "n, k = map(int, input().split())\nb = list(map(int, input().split()))\nc = input()\n\nred = sorted([b[i] for i in range(n) if c[i] == 'R'], reverse=True)\nwhite = sorted([b[i] for i in range(n) if c[i] == 'W'], reverse=True)\norange = sorted([b[i] for i in range(n) if c[i] == 'O'], reverse=True)\n\nif len(red) == n or len(red) == 0 or k > n - len(white) or k < 2:\n    print(-1)\nelse:\n    ans = sum(red[:min(k, len(red))]) + sum(orange[:max(k - len(red), 0)])\n    if k > len(red) and len(orange) - max(k - len(red), 0) < n - len(white) - k:\n        print(-1)\n    else:\n        ans += sum(white[:n - len(red) - max(k - len(red), 0)])\n        print(ans)"
 ],
 "452": [
  "from fractions import Fraction\n\n# Reading inputs\np, q = map(int, input().split())\nn = int(input())\na = list(map(int, input().split()))\n\n# Calculating the continued fraction\nx = Fraction(a[n-1])\nfor i in range(n-2, -1, -1):\n    x = a[i] + 1 / x\nx = x.numerator * q == x.denominator * p\n\n# Checking if the two fractions are equal\nif x:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "453": [
  "sticks = input()\na, b, c = sticks.split(\"+\")\nc, r = c.split(\"=\")\n\nif len(a) + len(b) == len(c):\n    print(sticks)\nelif len(a) + len(b) == len(c) + 2:\n    print(\"|\"*(len(a)+1) + \"+\" + \"|\"*(len(b)-1) + \"=\" + \"|\"*(len(c)-1) + \"|\")\nelif len(a) + len(b) == len(c) - 2:\n    print(\"|\"*len(a) + \"+\" + \"|\"*(len(b)+1) + \"=\" + \"|\"*(len(c)-1) + \"|\")\nelif len(a) + len(b) == len(c) + 1:\n    print(\"|\"*len(a) + \"+\" + \"|\"*len(b) + \"=\" + \"|\"*(len(c)+1) + \"|\")\nelif len(a) + len(b) == len(c) - 1:\n    print(\"|\"*len(a) + \"+\" + \"|\"*len(b) + \"=\" + \"|\"*(len(c)-1) + \"|\")\nelse:\n    print(\"Impossible\")"
 ],
 "454": [
  "n, k = map(int, input().split())\n\ndp = [[0] * (k+1) for _ in range(n+1)]\ndp[0][0] = 1\n\nMOD = 10 ** 9 + 7\n\nfor i in range(1, n+1):\n    for j in range(k+1):\n        for d in [1, -1]:\n            nj = j - d * (i - 1)\n            if 0 <= nj <= k:\n                dp[i][j] += dp[i-1][nj]\n                dp[i][j] %= MOD\n\nprint(dp[n][k])"
 ],
 "455": [
  "n=int(input())\na=[list(map(int,input().split())) for i in range(n)]\n\ndef dist(p1,p2):\n\treturn abs(p1[0]-p2[0])+abs(p1[1]-p2[1])\n\nansM=51\nansArms=[]\nfor i in range(1<<n):\n\tarms=[-1]*n\n\tfor j in range(n):\n\t\tif((i>>j)&1):\n\t\t\tarms[j]=4\n\td={}\n\tstop=False\n\tfor j in range(n):\n\t\tif(arms[j]==-1):\n\t\t\tstop=True\n\t\t\tbreak\n\t\tif(arms[j]==4):\n\t\t\td[(0,0)]=0\n\t\t\tcontinue\n\t\tsign=1\n\t\tif(arms[j]==0 or arms[j]==3):\n\t\t\tsign=-1\n\t\tx,y=a[j][0],a[j][1]\n\t\tif(arms[j]==0 or arms[j]==1):\n\t\t\tx*=sign\n\t\telse:\n\t\t\ty*=sign\n\t\tvalid=False\n\t\tnewD={}\n\t\tfor k,v in d.items():\n\t\t\tnv=v+dist(k,(x,y))\n\t\t\tif(nv<=j):\n\t\t\t\tvalid=True\n\t\t\t\tnewD[min(k[0],x),min(k[1],y)]=nv\n\t\tif(not valid):\n\t\t\tstop=True\n\t\t\tbreak\n\t\td=newD\n\tif(not stop):\n\t\tif(ansM>len(arms)):\n\t\t\tansM=len(arms)\n\t\t\tansArms=[arms[::-1]]\nm=ansM-1\nd=[0]*m\nfor i in range(m):\n\td[i]=2**i+1\nprint(m)\nprint(*d)\nfor i in range(n):\n\tansAns=\"R\"*(m-1)\n\tfor j in range(m-1):\n\t\tif(ansArms[0][j]==1):\n\t\t\tif(a[i][0]>0):\n\t\t\t\tansAns=ansAns[:j]+\"R\"+ansAns[j+1:]\n\t\t\telse:\n\t\t\t\tansAns=ansAns[:j]+\"L\"+ansAns[j+1:]\n\t\telif(ansArms[0][j]==2):\n\t\t\tif(a[i][1]>0):\n\t\t\t\tansAns=ansAns[:j]+\"U\"+ansAns[j+1:]\n\t\t\telse:\n\t\t\t\tansAns=ansAns[:j]+\"D\"+ansAns[j+1:]\n\tif(ansArms[0][-1]==1):\n\t\tif(a[i][0]==d[-1]-1):\n\t\t\tansAns=ansAns[:m-1]+\"R\"\n\t\telif(a[i][0]==-(d[-1]-1)):\n\t\t\tansAns=ansAns[:m-1]+\"L\"\n\tif(ansArms[0][-1]==2):\n\t\tif(a[i][1]==d[-1]-1):\n\t\t\tansAns=ansAns[:m-1]+\"U\"\n\t\telif(a[i][1]==-(d[-1]-1)):\n\t\t\tansAns=ansAns[:m-1]+\"D\"\n\tprint(ansAns)"
 ],
 "456": [
  "n = int(input())\ns = input()\nfiller = \"ogo\"\ngo = \"go\"\ni = 0\nwhile i < n:\n    if s[i:i+3] == filler:\n        j = i+3\n        while j+2 <= n and s[j:j+2] == go:\n            j += 2\n        print(\"***\", end='')\n        i = j\n    else:\n        print(s[i], end='')\n        i += 1"
 ],
 "457": [
  "from math import sqrt\nMOD = 10**9 + 7\n\ndef prime_divisors(x):\n    res = set()\n    for i in range(2, int(sqrt(x))+1):\n        if x % i == 0:\n            while x % i == 0:\n                x //= i\n            res.add(i)\n    if x > 1:\n        res.add(x)\n    return res\n\ndef max_power(x, p):\n    res = 0\n    while x % p == 0:\n        x //= p\n        res += 1\n    return p**res\n\nx, n = map(int, input().split())\nprime_divs = prime_divisors(x)\n\nans = 1\nfor p in prime_divs:\n    cur_pow = max_power(n, p)\n    ans *= pow(x, cur_pow, MOD) * pow(p, cur_pow * (cur_pow + 1) // 2 * (n // cur_pow - n // (cur_pow+1)), MOD)\n    ans %= MOD\n\nprint(ans)"
 ],
 "458": [
  "a, b, c = map(int, input().split())\n\ndef s(x):\n    return sum(map(int, str(x)))\n\nans = []\nfor i in range(1, 10**9):\n    if i == b * (s(i) ** a) + c and i < 10**9:\n        ans.append(str(i))\nprint(len(ans))\nprint(\" \".join(ans))"
 ],
 "459": [
  "colors = list(map(int, input().split()))\n\nfor i in range(6):\n    c = colors.count(i+1)\n    if c == 4 or c == 0:\n        continue\n    else:\n        print('NO')\n        break\nelse:\n    print('YES')"
 ],
 "460": [
  "p, x, y = map(int, input().split())\ntarget_score = x + ((26 + p - x) % 475)\nhacks = 0\n\nwhile x < target_score and x < y:\n    x += 100\n    hacks += 1\n\n# Check if unsuccessful hacks needed after reaching target score\nif x < y:\n    hacks += (y - x + 49) // 50\n\nprint(hacks)"
 ],
 "461": [
  "n = int(input())\na = int(input())\nb = int(input())\nc = int(input())\n\nif n == 1:\n    print(0)\nelse:\n    if a <= b and a <= c:\n        x = (n-1) * min(b, c) + a\n        print(x)\n    elif b <= a and b <= c:\n        y = (n-1) * min(a, c) + b\n        print(y)\n    else:\n        z = (n-1) * min(a, b) + c\n        print(z)"
 ],
 "462": [
  "x = sorted(list(map(int, input().split())))\nprint(x[2] - x[0])"
 ],
 "463": [
  "n, x = map(int, input().split())\na = list(map(int, input().split()))\ns = set(a)\n\nif len(a) != len(s):\n    print(0)\nelse:\n    for i in range(n):\n        if a[i] & x in s:\n            print(1)\n            break\n    else:\n        for i in range(n):\n            if a[i] & x & x in s:\n                print(2)\n                break\n        else:\n            print(-1)"
 ],
 "464": [
  "h, w = map(int, input().split())\ngrid = [input() for _ in range(h)]\n\ncenter_row = center_col = -1\nfor i in range(h):\n    for j in range(w):\n        if grid[i][j] == \"*\":\n            if center_row == -1:\n                center_row = i\n                center_col = j\n            else:\n                if center_row != i and center_col != j:\n                    print(\"NO\")\n                    exit()\n\nif center_row == -1:\n    print(\"NO\")\n    exit()\n\nfor i in range(center_row-1, -1, -1):\n    if grid[i][center_col] != \"*\":\n        break\nelse:\n    print(\"NO\")\n    exit()\n\nfor i in range(center_row+1, h):\n    if grid[i][center_col] != \"*\":\n        break\nelse:\n    print(\"NO\")\n    exit()\n\nfor j in range(center_col-1, -1, -1):\n    if grid[center_row][j] != \"*\":\n        break\nelse:\n    print(\"NO\")\n    exit()\n\nfor j in range(center_col+1, w):\n    if grid[center_row][j] != \"*\":\n        break\nelse:\n    print(\"NO\")\n    exit()\n\nprint(\"YES\")"
 ],
 "465": [
  "n, a, b = map(int, input().split())\n\nif b == 1:\n    if a > 1 or n == 2:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\"01\\n10\")\nelse:\n    if a == 1:\n        if b > 1:\n            print(\"NO\")\n        else:\n            matrix = [[\"0\" for _ in range(n)] for _ in range(n)]\n            for i in range(n):\n                for j in range(i + 1, n):\n                    matrix[i][j] = matrix[j][i] = \"1\"\n            print(\"YES\")\n            for row in matrix:\n                print(\"\".join(row))\n    elif a + b - 2 > n:\n        print(\"NO\")\n    else:\n        connected = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(a - 1):\n            connected[i][i + 1] = connected[i + 1][i] = 1\n        for i in range(a - 1, n - b + 1):\n            for j in range(i + 1, n - b + 1):\n                connected[i][j] = connected[j][i] = 1\n        for i in range(n - b + 1, n):\n            connected[i][i - 1] = connected[i - 1][i] = 1\n        complement = [[\"0\" for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                complement[i][j] = complement[j][i] = str(int(not connected[i][j]))\n        print(\"YES\")\n        for row in connected:\n            print(\"\".join(map(str, row)))"
 ],
 "466": [
  "c,d = map(int,input().split())\nn,m = map(int,input().split())\nk = int(input())\n\nneeded = n * m - k\nif needed <= 0:\n    print(0)\nelse:\n    main_rounds = needed // n + int(needed % n != 0)\n    problems = main_rounds * c\n    remaining = m - (k + main_rounds * n - needed)\n    if remaining > 0:\n        problems += (remaining * d)\n    print(problems)"
 ],
 "467": [
  "from itertools import permutations\n\n# Read input string\ns = input()\n\n# Find all permutations of s that can form a path in the grid\nperms = list(filter(lambda x: all(x[i] != x[i+1] for i in range(len(x)-1)) and all(x[i] in neighbors[x[i+1]] for i in range(len(x)-1)), permutations(s)))\n\n# If no valid permutation is found, print \"Impossible\"\nif not perms:\n    print(\"Impossible\")\nelse:\n    # Construct the grid using the first valid permutation found\n    path = perms[0]\n    grid = [list(path[i:i+13]) for i in range(0, len(path), 13)]\n    for row in grid:\n        print(\"\".join(row))\n\n# A dictionary indicating the neighbors of each letter\nneighbors = {\n    \"A\": \"BOCN\",\n    \"B\": \"AOPCDQEN\",\n    \"C\": \"BPQDERFN\",\n    \"D\": \"CQERFSGO\",\n    \"E\": \"BRDFTHGPN\",\n    \"F\": \"CSEGTOHQU\",\n    \"G\": \"EDTHUPVQ\",\n    \"H\": \"EFTVQWUIO\",\n    \"I\": \"GHUWKOXJN\",\n    \"J\": \"IKXN\",\n    \"K\": \"IJLXOMYP\",\n    \"L\": \"JKLMYPN\",\n    \"M\": \"KLPYN\",\n    \"N\": \"ABQLPYZO\",\n    \"O\": \"BPCRQSZAF\",\n    \"P\": \"CQDSRGTAFN\",\n    \"Q\": \"DERSHUTFGO\",\n    \"R\": \"EFSGTUIJAV\",\n    \"S\": \"FGTHUJVWBX\",\n    \"T\": \"EHUIVWKCXY\",\n    \"U\": \"FJVKXYLN\",\n    \"V\": \"GIWLYMN\",\n    \"W\": \"HIXMZNO\",\n    \"X\": \"JIYNOP\",\n    \"Y\": \"BKJZOPQ\",\n    \"Z\": \"LNKQ\"\n}"
 ],
 "468": [
  "x, y = map(int, input().split())\n\nif y * log(x) > x * log(y):\n    print(\">\")\nelif y * log(x) < x * log(y):\n    print(\"<\")\nelse:\n    print(\"=\")"
 ],
 "469": [
  "from math import pi, sqrt, floor\n\nr, h = map(int, input().split())\n\ndef calc_vol(h, r):\n    return pi * (r/2) ** 2 * (2 * r - h)\n\nans = 0\nif h >= r:\n    ans = floor(h/r) * 2\n    h = h - floor(h/r) * r\n    if h >= r - r/sqrt(2):\n        ans += 1\n        h -= r - r/sqrt(2)\n    if h >= r - r/2:\n        ans += 1\n        h -= r - r/2\nr_vol = pi * (r/2) ** 2 * r\nans += floor(calc_vol(h + r, r)/r_vol)\n\nprint(ans)"
 ],
 "470": [
  "cards = list(map(int, input().split()))\n\nmin_sum = sum(cards)\nfor c in set(cards):\n    if cards.count(c) > 1:\n        sum_with_removed = sum([card for card in cards if card != c])\n        if cards.count(c) == 2:\n            sum_with_removed -= c * 2\n        else:\n            sum_with_removed -= c * 3\n        min_sum = min(min_sum, sum_with_removed)\n\nprint(min_sum)"
 ],
 "471": [
  "n, a = map(int, input().split())\nx = list(map(int, input().split()))\nx.sort()\nif n == 1:\n    print(0)\nelif x[0] >= a:\n    print(x[-1] - a)\nelif x[-1] <= a:\n    print(a - x[0])\nelse:\n    d1 = x[-1] - a + x[-1] - x[1]\n    d2 = a - x[0] + x[-2] - x[0]\n    print(min(d1, d2))"
 ],
 "472": [
  "n = int(input())\nfor i in range(1, 82):\n    x = int(str(n + i*i).rstrip('0'))\n    if sum(int(d) for d in str(x)) == i and x*x + i*x == n:\n        print(x)\n        break\nelse:\n    print(-1)"
 ],
 "473": [
  "s = input()\nt = input()\nss = int(s[:2]) * 60 + int(s[3:])\ntt = int(t[:2]) * 60 + int(t[3:])\np = ss - tt\nif p < 0:\n    p += 24 * 60\nprint(\"{:02d}:{:02d}\".format(p // 60, p % 60))"
 ],
 "474": [
  "n = int(input())\na = list(map(int, input().split()))\nmax_mean = 0\nlength = 0\nstart = 0\ncurr_sum = 0\n\nfor end in range(n):\n    curr_sum += a[end]\n    curr_mean = curr_sum / (end - start + 1)\n    if curr_mean > max_mean:\n        max_mean = curr_mean\n        length = end - start + 1\n    while start < end and curr_mean > (curr_sum - a[start]) / (end - start):\n        curr_sum -= a[start]\n        start += 1\n        curr_mean = curr_sum / (end - start + 1)\n        if curr_mean > max_mean:\n            max_mean = curr_mean\n            length = end - start + 1\n\nprint(length)"
 ],
 "475": [
  "n, m, k = map(int, input().split())\n\nMOD = 998244353\n\ndef power(x, y):\n    res = 1\n    while y:\n        if y & 1:\n            res = res * x % MOD\n        x = x * x % MOD\n        y >>= 1\n    return res\n\nif k == 0:\n    print(power(m, n))\nelse:\n    dp = [0] * (n+1)\n    dp[1] = m\n    dp[2] = m*(m-1) % MOD\n    for i in range(3, n+1):\n        dp[i] = (m-1) * dp[i-1] % MOD + (m-1) * dp[i-2] % MOD\n        dp[i] %= MOD\n    print(dp[n] * power(m-1, k) % MOD)"
 ],
 "476": [
  "n = input()\nwhile len(n) > 0:\n    if n.startswith('144'):\n        n = n[3:]\n    elif n.startswith('14'):\n        n = n[2:]\n    elif n.startswith('1'):\n        n = n[1:]\n    else:\n        print(\"NO\")\n        break\nelse:\n    print(\"YES\")"
 ],
 "477": [
  "n,m,i,j,a,b = map(int,input().split())\n\nif (i-a)%(2*a) != 0 or (j-b)%(2*b) != 0:\n    if (i-b)%(2*a) != 0 or (j-a)%(2*b) != 0:\n        if (i-a)%(2*a) != 0 or (j+b)%(2*b) != 0:\n            if (i+b)%(2*a) != 0 or (j-a)%(2*b) != 0:\n                print(\"Poor Inna and pony!\")\n                exit()\nprint(min(max((i-1)//a,(n-i)//a),max((j-1)//b,(m-j)//b)))"
 ],
 "478": [
  "n = int(input()) # length of string\ns = input() # the given string\n\n# to check if s[i] follows the condition for removal\ndef check(i):\n    if i == 0:\n        return s[1] == chr(ord(s[0])-1)\n    elif i == n-1:\n        return s[n-2] == chr(ord(s[n-1])-1)\n    else:\n        return s[i-1] == chr(ord(s[i])-1) or s[i+1] == chr(ord(s[i])-1)\n\nres = 0 # the maximum possible number of characters that can be removed\nwhile True:\n    removed = False # to check if any character was removed\n    for i in range(n):\n        if check(i):\n            s = s[:i] + s[i+1:] # remove the i-th character from the string\n            n -= 1 # update the length of the string\n            res += 1 # increment the count of removed characters\n            removed = True\n            break\n    if not removed:\n        break\n\nprint(res) # output the maximum possible number of characters that can be removed"
 ],
 "479": [
  "import bisect\n\nn,k=map(int,input().split())\na=list(map(int,input().split()))\nq=int(input())\nfor i in range(q):\n    x=int(input())\n    ans=1e9\n    for j in range(n):\n        if a[j]>x:\n            break\n        if x%a[j]==0:\n            ans=min(ans,x//a[j])\n        elif k==1:\n            continue\n        else:\n            idx=bisect.bisect_right(a,x-a[j])-1\n            if idx>=0:\n                ans=min(ans,(x-a[j])//a[idx]+1)\n    if ans==1e9:\n        print(-1)\n    else:\n        print(ans)"
 ],
 "480": [
  "s, x1, x2 = map(int,input().split())\nt1, t2 = map(int,input().split())\np, d = map(int,input().split())\n\nif x1 > x2:\n    x1, x2, d = s-x1, s-x2, -d\n    \nif d == 1 and p <= x1 or d == -1 and p >= x1:\n    ans = (x2 - x1) * t2\nelse:\n    ans = float('inf')\n    ans = min(ans, abs(x1-p)*t2 + abs(x2-p)*t2)\n    \n    if d == 1:\n        ans = min(ans, (p+x2)*t1)\n        ans = min(ans, (s-p) * t1 + x2 * t2)\n        \n    else:\n        ans = min(ans, (s-p+x2)*t2)\n        ans = min(ans, p*t1 + x2*t2)\n        \nprint(ans)"
 ],
 "481": [
  "n, x = map(int,input().split())\ncount = 0\nfor i in range(1, n+1):\n    if x % i == 0 and x // i <= n:\n        count += 1\nprint(count)"
 ],
 "482": [
  "n, k = map(int, input().split())\nalphabet = \"abcdefghijklmnopqrstuvwxyz\"\npassword = alphabet[:k]\npassword += alphabet[:k-2:-1]\nprint(password[:n])"
 ],
 "483": [
  "n = int(input())\ndirections = input().strip()\npositions = list(map(int, input().split()))\n\nmin_collision_time = float('inf')\n\nfor i in range(n-1):\n    if directions[i] == 'R' and directions[i+1] == 'L':\n        collision_time = (positions[i+1] - positions[i]) // 2\n        min_collision_time = min(min_collision_time, collision_time)\n        \nif min_collision_time == float('inf'):\n    print(-1)\nelse:\n    print(min_collision_time)"
 ],
 "484": [
  "n,a,b=map(int,input().split())\nseals=[list(map(int,input().split())) for i in range(n)]\nmax_area=0\nfor i in range(n-1):\n    for j in range(i+1,n):\n        if (seals[i][0]+seals[j][0]<=a and max(seals[i][1],seals[j][1])<=b) or \\\n           (seals[i][0]+seals[j][1]<=a and max(seals[i][1],seals[j][0])<=b) or \\\n           (seals[i][1]+seals[j][0]<=a and max(seals[i][0],seals[j][1])<=b) or \\\n           (seals[i][1]+seals[j][1]<=a and max(seals[i][0],seals[j][0])<=b):\n            max_area=max(max_area,seals[i][0]*seals[i][1]+seals[j][0]*seals[j][1])\nprint(max_area)"
 ],
 "485": [
  "n = int(input())\npoints = []\nfor i in range(4*n+1):\n    x, y = map(int, input().split())\n    points.append((x,y))\n\nx_coords = [p[0] for p in points]\ny_coords = [p[1] for p in points]\n\nfor p in points:\n    if x_coords.count(p[0]) == 1 or y_coords.count(p[1]) == 1:\n        print(p[0], p[1])\n        break"
 ],
 "486": [
  "n = int(input())\nmax_prod = 0\nwhile n > 0:\n    prod = 1\n    for digit in str(n):\n        prod *= int(digit)\n    if prod > max_prod:\n        max_prod = prod\n    n -= 1\nprint(max_prod)"
 ],
 "487": [
  "n = int(input())\na = list(map(int, input().split()))\n\nlower = max(a)\nupper = n*(lower+1)\n\nwhile lower < upper:\n    mid = (lower + upper) // 2\n    total = sum(mid - x for x in a)\n    if total > mid*n // 2:\n        upper = mid\n    else:\n        lower = mid + 1\n\nprint(lower)"
 ],
 "488": [
  "s = input()\n\ncount = 0\n\nwhile True:\n    i = 0\n    delete = []\n    while i < len(s):\n        j = i + 1\n        while j < len(s) and s[j] == s[i]:\n            j += 1\n        if j == i+1:\n            delete.append(i)\n        i = j\n    if not delete:\n        break\n    count += 1\n    for i in reversed(delete):\n        s = s[:i] + s[i+1:]\n        \nprint(count)"
 ],
 "489": [
  "n=int(input())\na=list(map(int,input().split()))\nm1,m2,m3=float('inf'),float('inf'),float('inf')\nM=-1\nfor i in range(n):\n    x=a[i]\n    if x<=m1:\n        m1,m2,m3=x,m1,m2\n    elif x<=m2:\n        m2,m3=x,m2\n    elif x<=m3:\n        m3=x\n    if x>M:\n        M=x\nif m1==m3:\n    print(n*(n-1)*(n-2)//6)\nelif m1==m2:\n    c=a.count(m1)\n    print(c*(c-1)//2*(n-c))\nelse:\n    print(a.count(m1)*a.count(m2)*a.count(m3))"
 ],
 "490": [
  "import math\nn = int(input())\nresult = math.ceil(n/2)\nprint(result)"
 ],
 "491": [
  "n = input()\nif n >= '0':\n    print(n)\nelse:\n    a = int(n[:-1])\n    b = int(n[:-2] + n[-1])\n    print(max(a,b))"
 ],
 "492": [
  "start, end = input().split()\nn = int(input())\n\npositions = [\"^\", \">\", \"v\", \"<\"]\nstart_index = positions.index(start)\nend_index = positions.index(end)\n\nclockwise = (end_index - start_index) % 4\ncounter_clockwise = (start_index - end_index) % 4\n\nif n % 2 == 0:\n    if clockwise == counter_clockwise:\n        print(\"undefined\")\n    elif clockwise < counter_clockwise:\n        print(\"cw\")\n    else:\n        print(\"ccw\")\nelse:\n    if clockwise == counter_clockwise:\n        print(\"undefined\")\n    elif clockwise > counter_clockwise:\n        print(\"cw\")\n    else:\n        print(\"ccw\")"
 ],
 "493": [
  "n = int(input())\ns = input()\n\nleft = -1\nlast_R = -1\nstanding = 0\n\nfor i in range(n):\n    if s[i] == 'R':\n        last_R = i\n        if left != -1:\n            standing += (i-left-1) + (i-left-1)%2\n            left = -1\n    elif s[i] == 'L':\n        if last_R != -1:\n            standing += (i-last_R-1) + (i-last_R-1)%2\n            last_R = -1\n        if left == -1:\n            left = i\n    else:\n        if left != -1:\n            standing += (i-left-1) + (i-left-1)%2\n            left = -1\n\n        if last_R != -1:\n            standing += (i-last_R-1) + (i-last_R-1)%2\n            last_R = -1\n\nprint(n-standing)"
 ],
 "494": [
  "n, m = map(int, input().split())\nl = list(map(int, input().split()))\n\na = [0] * n\nfor i in range(n):\n    a[i] = i + 1\n\nfor i in range(m - 1):\n    if l[i] > l[i + 1]:\n        a = a[l[i + 1] - 1:l[i] - 1:-1] + a[:l[i + 1] - 1] + a[l[i] - 1:]\n    else:\n        a = a[:l[i] - 1] + a[l[i + 1] - 1:l[i] - 1:-1] + a[l[i + 1] - 1:]\n\nif l[0] > l[m - 1]:\n    a = a[l[m - 1] - 1::-1] + a[:l[m - 1] - 1]\nelse:\n    a = a[:l[m - 1] - 1] + a[l[m - 1] - 1::-1]\n\nif 1 not in a:\n    print(-1)\nelse:\n    for num in a:\n        print(num, end=' ')"
 ],
 "495": [
  "a,k = input().split()\na = list(a)\nk = int(k)\n\nfor i in range(len(a)):\n    if k == 0:\n        break\n    max_idx = i\n    for j in range(i+1, len(a)):\n        if a[j] > a[max_idx]:\n            max_idx = j\n    if max_idx != i:\n        a[i], a[max_idx] = a[max_idx], a[i]\n        k -= 1\n\nprint(\"\".join(a))"
 ],
 "496": [
  "a, b, c, d = map(int, input().split())\n\nif b-a == c-b == d-c:\n    print(d+(d-c))\nelif b/a == c/b == d/c:\n    res = d*(d/c)\n    print(res if res.is_integer() else 42)\nelse:\n    print(42)"
 ],
 "497": [
  "n = int(input())\ncolors = list(map(int, input().split()))\n\nfirst_color_pos = {}\nmax_distance = 0\n\nfor i in range(n):\n    color = colors[i]\n    if color not in first_color_pos:\n        first_color_pos[color] = i\n    else:\n        max_distance = max(max_distance, i - first_color_pos[color])\n\nprint(max_distance)"
 ],
 "498": [
  "n, m, k = map(int, input().split())\nrow = (k - 1) // (2 * m) + 1\ncol = ((k - 1) // 2) % m + 1\nside = 'L' if k % 2 == 1 else 'R'\nprint(row, col, side)"
 ],
 "499": [
  "n = int(input())\ns = input()\n\ncolors = set(s)\n\nwhile len(colors) > 1:\n    if \"R\" in colors and \"G\" in colors and \"B\" not in colors:\n        print(\"B\")\n        break\n    elif \"R\" not in colors and \"G\" in colors and \"B\" in colors:\n        print(\"R\")\n        break\n    elif \"R\" in colors and \"G\" not in colors and \"B\" in colors:\n        print(\"G\")\n        break\n    elif len(colors) == 2:\n        print(\"\".join(sorted(colors)))\n        break\n    elif \"R\" in colors and \"G\" in colors and \"B\" in colors:\n        colors = set()\n        if \"R\" in s:\n            colors.add(\"R\")\n        if \"G\" in s:\n            colors.add(\"G\")\n        if \"B\" in s:\n            colors.add(\"B\")\nprint(s if len(colors) < 2 else \"\")"
 ]
}