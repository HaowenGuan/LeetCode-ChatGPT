{
 "2000": [
  "n = int(input())\na = list(map(int, input().split()))\npowers_of_2 = [2**i for i in range(31)]\ncount = 0\nfreq = {}\nfor num in a:\n    if num in freq:\n        freq[num] += 1\n    else:\n        freq[num] = 1\nfor i in range(n):\n    for j in range(i+1, n):\n        if a[i]+a[j] in powers_of_2:\n            if a[i] == a[j]:\n                count += (freq[a[i]]*(freq[a[i]]-1))//2\n            else:\n                count += freq[a[i]]*freq[a[j]]\nprint(count)"
 ],
 "2001": [
  "MOD = 10**9 + 7\n\nn, q = map(int, input().split())\nxs = list(map(int, input().strip()))\npre = [0]*(n+1)\nfor i in range(1, n+1):\n    pre[i] = pre[i-1] + xs[i-1]\n\nfor _ in range(q):\n    l, r = map(int, input().split())\n    x = pre[r] - pre[l-1]\n    y = r - l + 1 - x\n    ans = x*(x-1)//2 + y*(y-1)//2 + x*y\n    print(ans % MOD)"
 ],
 "2002": [
  "MOD = 1000000007\nn = int(input())\nx = [int(num) for num in input().split()]\n\nadj = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    adj[a - 1].append(b - 1)\n    adj[b - 1].append(a - 1)\n\nSUB = [0] * n\ntot = [0] * n\n\n\ndef dfs(now, par):\n    SUB[now] = x[now]\n    for i in adj[now]:\n        if i == par:\n            continue\n        dfs(i, now)\n        SUB[now] += SUB[i]\n\n\ndef dfs2(now, par):\n    if now == 0:\n        tot[now] = SUB[now]\n    else:\n        tot[now] = tot[par] - SUB[now] + (x[now] if now > par else 0) + SUB[0] - SUB[now]\n\n    for i in adj[now]:\n        if i == par:\n            continue\n        dfs2(i, now)\n\n\ndfs(0, -1)\ndfs2(0, -1)\n\nans = 0\nfor i in range(n):\n    ans += tot[i]\n    ans %= MOD\n\nprint(ans)"
 ],
 "2003": [
  "import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict\n\n# Node class for trie\nclass Node:\n    def __init__(self):\n        self.left = None\n        self.right = None\n\n# Insert a number into trie\ndef insert(num, root):\n    temp = root\n    for i in range(31, -1, -1):\n        bit = (num >> i) & 1\n        if bit == 0:\n            if temp.left == None:\n                temp.left = Node()\n            temp = temp.left\n        else:\n            if temp.right == None:\n                temp.right = Node()\n            temp = temp.right\n\n# Search the trie for maximum XOR of given number\ndef search(num, root):\n    temp = root\n    curr_xor = 0\n    for i in range(31, -1, -1):\n        bit = (num >> i) & 1\n        if bit == 0:\n            if temp.right != None:\n                curr_xor += (1 << i)\n                temp = temp.right\n            else:\n                temp = temp.left\n        else:\n            if temp.left != None:\n                curr_xor += (1 << i)\n                temp = temp.left\n            else:\n                temp = temp.right\n    return curr_xor\n\n# Driver Code\nn = int(input())\nroot = Node()\nmulti_set = defaultdict(int)\n\n# For every query, perform corresponding operation\nfor i in range(n):\n    op, num = input().split()\n    num = int(num)\n    if op == '+':\n        multi_set[num] += 1\n        insert(num, root)\n    elif op == '-':\n        multi_set[num] -= 1\n    else:\n        ans = search(num, root)\n        print(ans ^ num)"
 ],
 "2004": [
  "n = int(input())\nm = 2*n-1\n\nprint(m)\nprint(*[i for i in range(1,n+1)]+[i for i in range(n-1,0,-1)])"
 ],
 "2005": [
  "n, n1, n2 = map(int, input().split())\na = sorted(list(map(int, input().split())), reverse=True)\nif n1 > n2:\n    n1, n2 = n2, n1\npart1 = sum(a[:n1])\npart2 = sum(a[n1:n1+n2])\nprint((part1/n1)+(part2/n2))"
 ],
 "2006": [
  "n, m = map(int, input().split())\nfield = [input() for _ in range(n)]\n\npositions = []\n\nfor i in range(n):\n    dwarf_pos = field[i].find(\"G\")\n    candy_pos = field[i].find(\"S\")\n    if dwarf_pos > candy_pos:\n        print(-1)\n        break\n    positions.append(candy_pos)\n\nelse:\n    unique_positions = set(positions)\n    print(len(unique_positions))"
 ],
 "2007": [
  "from collections import defaultdict\n\nn, m = map(int, input().split())\ns = input().strip()\ngraph = defaultdict(list)\nin_degree = defaultdict(int)\nfor i in range(m):\n    x, y = map(int, input().split())\n    graph[x].append(y)\n    in_degree[y] += 1\n\nqueue = []\nfor i in range(1, n+1):\n    if in_degree[i] == 0:\n        queue.append(i)\n\nresult = -1\nwhile queue:\n    freq = [0] * 26\n    curr_level = []\n    for i in range(len(queue)):\n        node = queue.pop(0)\n        curr_level.append(node)\n        freq[ord(s[node-1]) - ord('a')] += 1\n        for adj in graph[node]:\n            in_degree[adj] -= 1\n            if in_degree[adj] == 0:\n                queue.append(adj)\n    \n    max_freq = max(freq)\n    if max_freq == 0:\n        break\n    result = max(result, max_freq)\n    \n    for node in curr_level:\n        if freq[ord(s[node-1]) - ord('a')] == max_freq:\n            continue\n        for adj in graph[node]:\n            in_degree[adj] -= 1\n            if in_degree[adj] == 0:\n                queue.append(adj)\n\nprint(result)"
 ],
 "2008": [
  "n = int(input())\nstudents = []\nfor i in range(n):\n    a, b = map(int, input().split())\n    students.append((a, b, i+1))\nstudents.sort(key=lambda x: (x[0]-x[1], x[0]), reverse=True)\ndissatisfaction = 0\nfor i in range(n):\n    dissatisfaction += students[i][0]*i + students[i][1]*(n-i-1)\nprint(dissatisfaction)"
 ],
 "2009": [
  "n = int(input())\nr1, c1 = map(int, input().split())\nr2, c2 = map(int, input().split())\ngrid = []\nfor i in range(n):\n    row = input().strip()\n    grid.append(row)\n\nland_coords = []\nfor i in range(n):\n    for j in range(n):\n        if grid[i][j] == '0':\n            land_coords.append((i+1, j+1))\n\ndef distance(coord1, coord2):\n    return ((coord1[0]-coord2[0])**2 + (coord1[1]-coord2[1])**2)\n\ndef can_reach(coord1, coord2):\n    visited = [[False]*n for i in range(n)]\n    queue = [coord1]\n\n    while queue:\n        curr = queue.pop(0)\n        if curr == coord2:\n            return True\n        if visited[curr[0]-1][curr[1]-1]:\n            continue\n        visited[curr[0]-1][curr[1]-1] = True\n\n        adjacents = [(curr[0]+1, curr[1]), (curr[0]-1, curr[1]), (curr[0], curr[1]+1), (curr[0], curr[1]-1)]\n        adjacents = [x for x in adjacents if x[0]>0 and x[1]>0 and x[0]<=n and x[1]<=n]\n        adjacents = [x for x in adjacents if not visited[x[0]-1][x[1]-1]]\n        adjacents = [x for x in adjacents if grid[x[0]-1][x[1]-1] == '0']\n        queue += adjacents\n\n    return False\n\nmin_cost = float('inf')\nfor coord1 in land_coords:\n    for coord2 in land_coords:\n        if coord1 == coord2:\n            continue\n        if can_reach(coord1, coord2):\n            cost = distance(coord1, coord2)\n            cost += distance(coord1, (r1, c1))\n            cost += distance(coord2, (r2, c2))\n            min_cost = min(min_cost, cost)\n\nif can_reach((r1, c1), (r2, c2)):\n    min_cost = min(min_cost, distance((r1, c1), (r2, c2)))\n\nprint(min_cost)"
 ],
 "2010": [
  "n, m = map(int, input().split())\na = list(map(int, input().split()))\n\nfor i in range(m):\n    op = list(map(int, input().split()))\n\n    if op[0] == 1:\n        a[op[1]-1] = op[2]\n    elif op[0] == 2:\n        for j in range(n):\n            a[j] += op[1]\n    else:\n        print(a[op[1]-1])"
 ],
 "2011": [
  "from collections import defaultdict\n\nn, m = map(int, input().split())\n\n# read debts\ndebts = defaultdict(int)\nfor _ in range(m):\n    u, v, d = map(int, input().split())\n    debts[u, v] += d\n\n# process debt consolidation\nfor k in range(1, n+1):\n    for i in range(1, n+1):\n        if i != k:\n            for j in range(1, n+1):\n                if j != i and j != k:\n                    # perform type 1 operation\n                    z = min(debts[i, k], debts[k, j])\n                    debts[i, k] -= z\n                    debts[k, j] -= z\n                    debts[i, j] += z\n            # perform type 2 operation\n            z = debts[i, i]\n            debts[i, i] = 0\n            debts[k, k] += z\n            debts[i, k] += z\n            debts[k, i] += z\n        \n# output consolidated debts\nconsolidated_debts = [(u, v, d) for ((u, v), d) in debts.items() if d > 0]\nprint(len(consolidated_debts))\nfor u, v, d in consolidated_debts:\n    print(u, v, d)"
 ],
 "2012": [
  "n = int(input())\nc = list(map(int, input().split()))\n\ns = ['']*n\n\nfor i in range(n):\n    j = 0\n    while j<=i and c[j]:\n        c[j] -= 1\n        s[i] = s[j]\n        j += 1\n    s[i] += chr(ord('a') + i)\n\nprint(''.join(s))"
 ],
 "2013": [
  "n, m, k = map(int, input().split())\nstart = [tuple(map(int, input().split())) for _ in range(k)]\nend = [tuple(map(int, input().split())) for _ in range(k)]\n\ndef move(chips, direction):\n    return [(x + dx, y + dy) for x, y in chips if 1 <= x + dx <= n and 1 <= y + dy <= m]\n\ndef move_horizontal(chips, dest_x):\n    res = []\n    while chips:\n        x, y = chips.pop()\n        while y < dest_x:\n            y += 1\n            res.append('R')\n        while y > dest_x:\n            y -= 1\n            res.append('L')\n        res.append('U' if x % 2 == 0 else 'D')\n    return res\n\ndef move_vertical(chips, dest_y):\n    res = []\n    while chips:\n        x, y = chips.pop()\n        while x < dest_y:\n            x += 1\n            res.append('D')\n        while x > dest_y:\n            x -= 1\n            res.append('U')\n        res.append('L' if y % 2 == 0 else 'R')\n    return res\n\nres = []\nchips = start\nfor x in range(1, n+1, 2):\n    res += move_horizontal(chips, m if x % 4 == 1 else 1)\n    chips = move(chips, (1, 0))\n    if x < n:\n        res += ['D']\n    res += move_vertical(chips, end[0][1])\n    res += move_vertical([start[0]], end[0][1])\n    chips = move(chips, (1, 0))\n    end = end[1:] + [end[0]]\n\nres += move_horizontal(chips, m)\n\nif len(res) > 2 * n * m:\n    print(-1)\nelse:\n    print(len(res))\n    print(''.join(res))"
 ],
 "2014": [
  "n, k = map(int, input().split())\npermutations = [list(map(int, input().split())) for _ in range(k)]\n\ndp = [[0] * (n+1) for _ in range(k+1)]\n\nfor i in range(1, k+1):\n    for j in range(1, n+1):\n        if j in permutations[i-1]:\n            dp[i][j] = dp[i-1][permutations[i-1].index(j)] + 1\n        else:\n            dp[i][j] = dp[i-1][j]\n\nprint(dp[-1][-1])"
 ],
 "2015": [
  "t = int(input())\nfor _ in range(t):\n    r, g, b = sorted(map(int, input().split()))\n    print(\"Yes\" if g <= r+b+1 else \"No\")"
 ],
 "2016": [
  "q, m = map(int, input().split())\n\nspells = []\nspell_damage = spell_mana = max_spell_damage = 0\n\nfor _ in range(q):\n    query = input().split()\n\n    if query[0] == '1': # learn new spell\n        x, y = int(query[1]), int(query[2])\n        spells.append((x, y))\n        max_spell_damage = max(max_spell_damage, x)\n\n    else: # fight with monster\n        t, h = int(query[1]), int(query[2])\n\n        if max_spell_damage == 0 or h > m: \n            print(\"NO\") # Vova cannot win since he has no spells or not enough mana\n            continue\n\n        # binary search to find maximum time Vova can fight while spending at most m mana\n        l, r = 0, t\n        while l < r:\n            mid = (l + r + 1) // 2\n            total_damage = 0\n            total_mana = 0\n\n            # calculate total damage and mana used for each spell used for time mid\n            for spell in spells:\n                damage, mana = spell\n                count = min(mid, h // damage)\n\n                total_damage += count * damage\n                total_mana += count * mana\n\n            # check if Vova can use spells for time mid without exceeding mana limit\n            if total_mana <= m and total_damage >= h:\n                l = mid\n            else:\n                r = mid - 1\n\n        if l < t:\n            print(\"YES\")\n        else:\n            print(\"NO\")"
 ],
 "2017": [
  "def mergeSortInversions(arr):\n    if len(arr) == 1:\n        return arr, 0\n    else:\n        mid = len(arr) // 2\n        left_half, left_inversions = mergeSortInversions(arr[:mid])\n        right_half, right_inversions = mergeSortInversions(arr[mid:])\n        merged, split_inversions = merge(left_half, right_half)\n        return merged, left_inversions + right_inversions + split_inversions\n\n\ndef merge(left_half, right_half):\n    merged = []\n    i, j = 0, 0\n    split_inversions = 0\n    while i < len(left_half) and j < len(right_half):\n        if left_half[i] <= right_half[j]:\n            merged.append(left_half[i])\n            i += 1\n        else:\n            merged.append(right_half[j])\n            j += 1\n            split_inversions += len(left_half) - i\n    merged += left_half[i:]\n    merged += right_half[j:]\n    return merged, split_inversions\n\n\nn = int(input())\nswaps = [list(map(int, input().split())) for _ in range(n)]\n\nswaps_dict = {}\nfor a, b in swaps:\n    swaps_dict[a] = b\n    swaps_dict[b] = a\n\np = list(range(1, n+1))\nfor i in range(5 * 10**6 // n):\n    for a, b in swaps_dict.items():\n        p[a-1], p[b-1] = p[b-1], p[a-1]\n\n_, inversions = mergeSortInversions(p)\nprint(inversions)"
 ],
 "2018": [
  "from math import gcd\n\nn, m, q = map(int, input().split())\n\ninner_gap = n // gcd(n, m)  # gap width in degrees in the inner circle\nouter_gap = m // gcd(n, m)  # gap width in degrees in the outer circle\n\nfor _ in range(q):\n    s_x, s_y, e_x, e_y = map(int, input().split())\n\n    if s_x == e_x:\n        if s_y == e_y:\n            print(\"YES\")\n        elif s_x == 1 and e_x == 1:\n            if abs(s_y - e_y) % inner_gap == 0:\n                print(\"YES\")\n            else:\n                print(\"NO\")\n        else:\n            if abs(s_y - e_y) % outer_gap == 0:\n                print(\"YES\")\n            else:\n                print(\"NO\")\n    else:\n        if s_x == 1:\n            start_gap = (s_y - 1) // inner_gap\n        else:\n            start_gap = (s_y - 1) // outer_gap\n\n        if e_x == 1:\n            end_gap = (e_y - 1) // inner_gap\n        else:\n            end_gap = (e_y - 1) // outer_gap\n\n        if start_gap == end_gap:\n            print(\"YES\")\n        else:\n            print(\"NO\")"
 ],
 "2019": [
  "for _ in range(int(input())):\n    s = input()\n    if s.count('01') % 2 == 1:\n        print('DA')\n    else:\n        print('NET')"
 ],
 "2020": [
  "n = int(input())\nx_cords = set()\ny_cords = set()\nfor i in range(n):\n    x, y = map(int, input().split())\n    x_cords.add(x)\n    y_cords.add(y)\nprint(min(len(x_cords), len(y_cords)))"
 ],
 "2021": [
  "n = int(input())\na = list(map(int, input().split()))\nm = int(input())\ncoupons = list(map(int, input().split()))\n\na_sorted = sorted(a, reverse=True)\nprefix_sum = [a_sorted[0]]\nfor i in range(1, n):\n    prefix_sum.append(prefix_sum[-1] + a_sorted[i])\n\nfor i in coupons:\n    print(prefix_sum[i-1] + sum(a_sorted[i:]))"
 ],
 "2022": [
  "from collections import deque\n\nn, m, k = map(int, input().split())\n\n# Constructing Graph\ngraph = [[] for i in range(n)]\nfor i in range(m):\n    a, b = map(int, input().split())\n    graph[a-1].append(b-1)\n    graph[b-1].append(a-1)\n\n# Finding Cycle first\ncycle = []\nparent = [-1]*n\nstack = []\nvisited = [False]*n\nfor i in range(n):\n    if visited[i]:\n        continue\n    stack.append(i)\n    while stack:\n        node = stack.pop()\n        if visited[node]:\n            cycle = []\n            while parent[node] != -1:\n                cycle.append(node)\n                if node == stack[-1]:\n                    break\n                node = parent[node]\n            cycle.append(node)\n            cycle.reverse()\n            break\n        visited[node] = True\n        cycle.append(node)\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                parent[neighbor] = node\n                stack.append(neighbor)\n    if cycle:\n        break\n\nif cycle:\n    print(\"2\")\n    print(min(len(cycle), k))\n    print(\" \".join(str(i+1) for i in cycle[:min(len(cycle), k)]))\nelse:\n    # Greedy approach for finding independent set\n    answer = []\n    degrees = [len(x) for x in graph]\n    while len(answer) < k:\n        chosen = -1\n        max_degree = -1\n        for i in range(n):\n            if degrees[i] > max_degree:\n                chosen = i\n                max_degree = degrees[i]\n        if max_degree == 0:\n            break\n        answer.append(chosen)\n        degrees[chosen] = 0\n        for neighbor in graph[chosen]:\n            degrees[neighbor] -= 1\n    print(\"1\")\n    print(\" \".join(str(i+1) for i in answer[:((k+1)//2)]))"
 ],
 "2023": [
  "n, m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nfor i in range(m):\n    query = list(map(int, input().split()))\n    if query[0] == 1:\n        x, y, k = query[1:]\n        for j in range(k):\n            b[y+j-1] = a[x+j-1]\n    else:\n        x = query[1]\n        print(b[x-1])"
 ],
 "2024": [
  "n = int(input())\na = list(map(int, input().split()))\n\nmod = 998244353\n\nfact = [1]*(n+1)\nfor i in range(1,n+1):\n    fact[i] = (i*fact[i-1]) % mod\n\nans = 0\n\nfor i in range(1,n+1):\n    lt = [j for j in range(n) if a[j] < a[i-1] and j < i-1]\n    rt = [j for j in range(n) if a[j] < a[i-1] and j > i-1]\n\n    lcnt = len(lt)\n    rcnt = len(rt)\n\n    good_left = (fact[lcnt+1] - 1) % mod\n    good_right = (fact[rcnt+1] - 1) % mod\n\n    bad_left = fact[lcnt]\n    bad_right = fact[rcnt]\n\n    ans = (ans + (good_left*good_right*bad_left*bad_right*2) % mod) % mod\n\nprint(ans)"
 ],
 "2025": [
  "import math\n\n# function to check if a number is prime or not\ndef is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\n# function to find maximum composite summands\ndef max_composite_summands(n):\n    if n < 4:\n        # n cannot be split into composite summands if it is less than 4\n        return -1\n    elif n % 2 == 0:\n        # if n is even, split it into summands of 4 until the remainder is odd\n        num_summands = n//4\n        while n % 4 != 3 and num_summands > 0:\n            num_summands -= 1\n            n -= 4\n    else:\n        # if n is odd, split it into summands of 4 until the remainder is even\n        num_summands = (n-9)//4 + 1\n        n -= 3*num_summands\n    # check if the remaining number is prime or not\n    if is_prime(n):\n        return -1\n    else:\n        return num_summands + n//4\n\n# main program\nq = int(input())\nfor i in range(q):\n    n = int(input())\n    print(max_composite_summands(n))"
 ],
 "2026": [
  "n=int(input())\nmoves=input()\n\nx,y=0,0\nvisited={(0,0)}\nfor move in moves:\n    if move=='L':\n        x-=1\n    elif move=='R':\n        x+=1\n    elif move=='U':\n        y+=1\n    elif move=='D':\n        y-=1\n    visited.add((x,y))\n\nprint(len(visited))"
 ],
 "2027": [
  "n = int(input())\na = list(map(int, input().split()))\n\nb = [0] * n\nb[-1] = a[-1]\nfor i in range(n - 2, -1, -1):\n    b[i] = a[i] - b[i + 1]\n\nprint(*b)"
 ],
 "2028": [
  "MOD = 10**9 + 7\n\ndef find(parents, x):\n    if parents[x] != x:\n        parents[x] = find(parents, parents[x])\n    return parents[x]\n\ndef union(parents, ranks, x, y):\n    px = find(parents, x)\n    py = find(parents, y)\n    if px == py:\n        return\n    if ranks[px] > ranks[py]:\n        parents[py] = px\n    elif ranks[py] > ranks[px]:\n        parents[px] = py\n    else:\n        parents[py] = px\n        ranks[px] += 1\n\ndef solve():\n    n = int(input())\n    curr = []\n    dest = []\n    for i in range(n):\n        c, d = map(int, input().split())\n        curr.append(c)\n        dest.append(d)\n    parents = [i for i in range(2*n+1)]\n    ranks = [0]*(2*n+1)\n    for i in range(n):\n        union(parents, ranks, curr[i], dest[i])\n    groups = set()\n    for i in range(1, 2*n+1):\n        groups.add(find(parents, i))\n    ans = 1\n    for _ in range(len(groups)):\n        ans = (ans*2) % MOD\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()"
 ],
 "2029": [
  "from collections import defaultdict\nfrom math import sqrt\n\nclass Tree:\n    def __init__(self, n, s):\n        self.adj_list = defaultdict(list)\n        self.n, self.s = n, s\n        \n    def add_edge(self, u, v):\n        self.adj_list[u].append(v)\n        self.adj_list[v].append(u)\n    \n    def dfs(self, u, p, d):\n        sub = {u: 1}\n        for v in self.adj_list[u]:\n            if v != p:\n                sub.update(self.dfs(v, u, d))\n                \n        if p is not None:\n            x = (self.s - sub[u]) / d\n            if x < 0: \n                x = 0\n            elif x > 1:\n                x = 1\n            self.res += 2 * x * (1 - x) * d\n            \n        return sub\n    \n    def solve(self):\n        l, r, ans = 0, self.s, 1e18\n        while l <= r:\n            mid = (l + r) / 2\n            self.res = 0\n            self.dfs(1, None, mid)\n            if self.res <= self.s:\n                ans = mid\n                r = mid - 1\n            else:\n                l = mid + 1\n                \n        return ans\n\nn, s = map(int, input().split())\ntree = Tree(n, s)\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    tree.add_edge(u, v)\n    \nprint(\"{:.10f}\".format(tree.solve()))"
 ],
 "2030": [
  "import sys\n\nn = int(input()) # read the integer n\nmax_values = list(map(float, input().split())) # read the array for max(a,b)\nmin_values = list(map(float, input().split())) # read the array for min(a,b)\n\n# initialize the arrays for the probability distribution of a and b\na_distribution = [0.0]*n\nb_distribution = [0.0]*n\n\n# calculate the probability distribution of a and b\nfor i in range(n):\n    for j in range(i, n):\n        if i == j:\n            a_distribution[i] += max_values[j] - (0 if i == 0 else max_values[i-1])\n            b_distribution[i] += min_values[j] - (0 if i == 0 else min_values[i-1])\n        else:\n            a_distribution[j] += max_values[i]\n            b_distribution[i] += min_values[j]\n\n# output the probability distribution of a and b\nprint(*a_distribution)\nprint(*b_distribution)"
 ],
 "2031": [
  "n = int(input())\na = list(map(int,input().split()))\nm = int(input())\nfor i in range(m):\n    k,j = map(int,input().split())\n    sub = sorted((a[q],q) for q in range(n) if q not in list(range(j-1)))  \n    selec = [(i,0) for i in range(k-1)] + [(j-1,0)]\n    selec.sort(key=lambda x: sub[x[0]][1])\n    res = sum(sub[x[0]][0] for x in selec)\n    print(sub[selec[-1][0]][0]) "
 ],
 "2032": [
  "n, m, k = map(int, input().split())\ncastle = [[0]*3 for i in range(n)]\nfor i in range(n):\n    castle[i] = list(map(int, input().split()))\nadj = [[] for i in range(n)]\nfor i in range(m):\n    u, v = map(int, input().split())\n    adj[u-1].append(v-1)\n    \ndp = [[-1]*(k+1) for i in range(n)]\n\ndef solve(node, army):\n    if node == n-1:\n        return 0\n    if dp[node][army] != -1:\n        return dp[node][army]\n    ans = -1\n    for i in range(army+1):\n        next_node = node+1\n        next_army = army-i+castle[next_node-1][1]\n        if next_army > k:\n            continue\n        ans2 = solve(next_node, next_army)\n        if ans2 == -1:\n            continue\n        ans = max(ans, ans2+((i==0)*castle[node][2])+((i!=0)*castle[node][2]+castle[node][2]*(i-1)))\n    for next_node in adj[node]:\n        next_army = army-1\n        if next_army > k:\n            continue\n        ans2 = solve(next_node, next_army)\n        if ans2 == -1:\n            continue\n        ans = max(ans, ans2+castle[node][2])\n    dp[node][army] = ans\n    return ans\n\nans = solve(0, k)\nprint(ans)"
 ],
 "2033": [
  "from collections import defaultdict, deque\nn,m = map(int, input().split())\norder_of_nodes = defaultdict(list)\ngraph = defaultdict(list)\nfor i in range(1,m+1):\n    a,b = map(int, input().split())\n    graph[a].append(b)\norder = list(map(int, input().split()))\ndist = {i:float('inf') for i in range(1,n+1)}\ndist[order[-1]] = 0\nfor i in range(len(order)-1):\n    order_of_nodes[order[i]] = (i+1,order[-1])\nq = deque([order[-1]])\nwhile q:\n    node = q.popleft()\n    for adj in graph[node]:\n        new_dist = dist[node]+1\n        if new_dist<dist[adj]:\n            dist[adj] = new_dist\n            q.append(adj)\nans = [0,0]\nfor i in range(1,len(order)):\n    prev_node = order[i-1]\n    curr_node = order[i]\n    temp = []\n    for adj in graph[curr_node]:\n        if dist[prev_node]>dist[adj]:\n            temp.append(order_of_nodes[adj])\n    if not temp:\n        continue\n    first_node = min(temp)\n    last_node = max(temp)\n    if i>=last_node[0] and i<first_node[0]:\n        ans[0] += 1\n        ans[1] += 1\n    elif i<first_node[0] or i>=last_node[0]:\n        ans[1] += 1 \nprint(*ans)                "
 ],
 "2034": [
  "n, m = map(int, input().split())\n\nindegree = [0] * (n+1)\noutdegree = [0] * (n+1)\n\nfor i in range(m):\n    a, b = map(int, input().split())\n    outdegree[a] += 1\n    indegree[b] += 1\n\ncount = 0\nfor i in range(1, n+1):\n    if indegree[i] == 0:\n        count += 1\n\n    if indegree[i] == 1 and outdegree[i] == 1:\n        count -= 1\n\nprint(count)"
 ],
 "2035": [
  "n, sx, sy = map(int, input().split())\nx_sum, y_sum = 0, 0\nhouses = []\nfor i in range(n):\n    xi, yi = map(int, input().split())\n    houses.append((xi, yi))\n    x_sum += xi\n    y_sum += yi\n\nhouses.sort()\n\nmax_students = 0\nbest_pos = None\n\nfor i in range(n):\n    xi, yi = houses[i]\n    left = [(houses[j][1] - yi) - abs(houses[j][0] - xi) for j in range(i)] \n    right = [(houses[j][1] - yi) + abs(houses[j][0] - xi) for j in range(i + 1, n)]\n    total = x_sum - xi * (n - 1) + y_sum - yi * (n - 1) + sum(sorted(left + right, reverse=True)[:min(n - 1, i + 1)] )\n    if total > max_students:\n        max_students = total\n        best_pos = (xi, yi)\n\nprint(max_students)\nprint(best_pos[0], best_pos[1])"
 ],
 "2036": [
  "n, m, sx, sy = map(int, input().split())\nfor i in range(1, m+1):\n    if i != sy:\n        print(sx, i)\nfor i in range(1, n+1):\n    if i != sx:\n        print(i, sy)\nfor i in range(1, n+1):\n    if i != sx:\n        if i%2 == 0:\n            for j in range(m, 0, -1):\n                if j != sy:\n                    print(i, j)\n        else:\n            for j in range(1, m+1):\n                if j != sy:\n                    print(i, j)"
 ],
 "2037": [
  "n, m = map(int, input().split())\ndifficulties = set()\nanswer = ''\nfor problem in map(int, input().split()):\n    difficulties.add(problem)\n    if len(difficulties) == n:\n        answer += '1'\n        difficulties.clear()\n    else:\n        answer += '0'\nprint(answer)"
 ],
 "2038": [
  "n = int(input())\np = list(map(int, input().split()))\nswaps = []\n\nfor i in range(0, n-1, 2):\n    if abs(p[i] - p[i+1]) != n-1:\n        idx = p.index(n-i) if p.index(n-i) % 2 == 0 else p.index(n-i)-1\n        p[i], p[idx] = p[idx], p[i]\n        swaps.append((i+1, idx+1))\n\nfor i in range(1, n-1, 2):\n    if abs(p[i] - p[i+1]) != n-1:\n        idx = p.index(n-i) if p.index(n-i) % 2 != 0 else p.index(n-i)-1\n        p[i], p[idx] = p[idx], p[i]\n        swaps.append((i+1, idx+1))\n\nprint(len(swaps))\nfor a,b in swaps:\n    print(a,b)"
 ],
 "2039": [
  "n = int(input())\na = list(map(int, input().split()))\ncount = 0\n\nfor i in range(1, n-1):\n    if a[i] > a[i-1] and a[i] > a[i+1]:\n        count += 1\n    elif a[i] < a[i-1] and a[i] < a[i+1]:\n        count += 1\n        \nprint(count)"
 ],
 "2040": [
  "n = int(input())\nb = list(map(int, input().split()))\n\na = [0] * n\na[-1] = b[-1]\n\nfor i in range(n - 2, -1, -1):\n    a[i] = a[i+1] + 1 if b[i] >= 9 else a[i+1]\n    while sum(int(digit) for digit in str(a[i])) != b[i]:\n        a[i] += 1\n\nprint('\\n'.join(str(num) for num in a))"
 ],
 "2041": [
  "import heapq\n\nn = int(input())\na = list(map(int, input().split()))\nm = int(input())\n\n# Create a list of tuples (a[i], i) and sort it in descending order\nt = [(-a[i], i) for i in range(n)]\nheapq.heapify(t)\n\n# Initialize indices of the max values\npos = [-1, -1, -1]\n# Initialize number of values selected for each length\ncnt = [0] * (n + 1)\n\n# Main loop for processing queries\nfor _ in range(m):\n    k, p = map(int, input().split())\n    # Check if we've already computed the optimal subsequence for this length\n    if pos[k] == -1:\n        # Pop the k highest values\n        b = []\n        for _ in range(k):\n            x, i = heapq.heappop(t)\n            b.append((i, -x))\n            # Update cnt for the selected value\n            cnt[k] += 1\n        # Sort the values in increasing order of their indices\n        b.sort()\n        # Put the values back in the heap\n        for i, x in b:\n            heapq.heappush(t, (-x, i))\n        # Update pos to mark that we've already computed the optimal subsequence for this length\n        pos[k] = len(b) - 1\n    # Print the result\n    print(a[b[pos[k] - cnt[k] + p][0]])"
 ],
 "2042": [
  "n, m, k = map(int, input().split())\nmuseum = [input() for _ in range(n)]\nstarts = [tuple(map(int, input().split())) for _ in range(k)]\n\ndef dfs(x, y):\n    if visited[x][y]:\n        return\n    visited[x][y] = True\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        nx, ny = x + dx, y + dy\n        if 0 <= nx < n and 0 <= ny < m and museum[nx][ny] == '.':\n            dfs(nx, ny)\n        elif 0 <= nx < n and 0 <= ny < m and museum[nx][ny] == '*' and not visited[nx][ny]:\n            walls.add((nx, ny))\n\nfor start in starts:\n    walls = set()\n    visited = [[False] * m for _ in range(n)]\n    x, y = start[0]-1, start[1]-1\n    dfs(x, y)\n    count = 0\n    for wx, wy in walls:\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = wx + dx, wy + dy\n            if 0 <= nx < n and 0 <= ny < m and museum[nx][ny] == '.' and visited[nx][ny]:\n                count += 1\n                break\n    print(count)"
 ],
 "2043": [
  "s = input()\nt = input()\nn = len(t)\nm = len(s)\n\ndef check(substr):\n    i, j = 0, 0\n    while i < len(s) and j < len(substr):\n        if s[i] == substr[j]:\n            i += 1\n        j += 1\n    return i == len(s)\n\nans = 0\nfor i in range(n):\n    if check(t[i:i+m]) and i+m < n and check(t[i+m:]):\n        ans += 1\n\nprint(ans)"
 ],
 "2044": [
  "n, m = map(int, input().split())\na = list(map(int, input().split()))\n\ntotal_page = 0\npages = [1] # 1-based indexing\ni = 0\nwhile i < n:\n    if a[i] <= m - total_page:\n        total_page += a[i]\n        pages.append(pages[-1])\n        i += 1\n    else:\n        turn_page = pages[-1] - 1\n        total_page = 0\n        pages.append(turn_page + 1)\n\nprint(\" \".join(str(p) for p in pages[1:]))"
 ],
 "2045": [
  "n = int(input())\nwords = input().split()\n\ndef merge_words(word1, word2):\n    for i in range(min(len(word1), len(word2)), -1, -1):\n        if word1[-i:] == word2[:i]:\n            return word1 + word2[i:]\n    return word1 + word2\n\nmerged_word = words[0]\n\nfor i in range(1, n):\n    merged_word = merge_words(merged_word, words[i])\n\nprint(merged_word)"
 ],
 "2046": [
  "n = int(input())\nsnacks = list(map(int, input().split()))\n\ntower = []\nmissing = set(range(1,n+1))\n\nfor snack in snacks:\n    tower.append(snack)\n    if snack in missing:\n        missing.remove(snack)\n\n        for i in range(snack+1, n+1):\n            if i in missing:\n                break\n            missing.remove(i)\n        print(\" \".join(str(x) for x in sorted(tower, reverse=True)))\n    else:\n        print()"
 ],
 "2047": [
  "from collections import defaultdict\n\ndef dfs(materials, supply, req, visited, src):\n    visited[src] = True\n    if supply[src] >= req[src]:\n        materials.append(src)\n        diff = supply[src] - req[src]\n        supply[src] = req[src]\n    else:\n        diff = supply[src]\n    \n    for neighbour, conversion in adj_list[src]:\n        if not visited[neighbour]:\n            kg = conversion * diff\n            supply[neighbour] += kg\n            dfs(materials, supply, req, visited, neighbour)\n            \nn = int(input())\nsupply = list(map(int, input().split()))\nreq = list(map(int, input().split()))\n\nadj_list = defaultdict(list)\n\nfor i in range(n-1):\n    x, k = map(int, input().split())\n    adj_list[i+1].append((x-1, k))\n    adj_list[x-1].append((i+1, k))\n\nvisited = [False] * n\ncan_produce = True\nfor i in range(n):\n    if req[i] > supply[i]:\n        materials = []\n        dfs(materials, supply, req, visited, i)\n        if not materials:\n            can_produce = False\n            break\n            \nif can_produce:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "2048": [
  "n = int(input())\ns = list(map(int, input().split()))\nc = list(map(int, input().split()))\n\nmin_cost = float('inf')\n\nfor j in range(n):\n    left_small = [c[i] for i in range(j) if s[i] < s[j]]\n    right_big = [c[k] for k in range(j+1, n) if s[j] < s[k]]\n    \n    if len(left_small) >= 1 and len(right_big) >= 1:\n        cost = min(left_small) + c[j] + min(right_big)\n        min_cost = min(min_cost, cost)\n\nif min_cost == float('inf'):\n    print(-1)\nelse:\n    print(min_cost)"
 ],
 "2049": [
  "n, m = map(int, input().split())\na = list(map(int, input().split()))\n\ndef is_ladder(l, r):\n    if l == r:\n        return True\n    inc = False\n    dec = False\n    for i in range(l+1, r+1):\n        if a[i] > a[i-1]:\n            inc = True\n        elif a[i] < a[i-1]:\n            dec = True\n        if inc and dec:\n            return False\n    return True\n\nfor i in range(m):\n    l, r = map(int, input().split())\n    if is_ladder(l-1, r-1):\n        print(\"Yes\")\n    else:\n        print(\"No\")"
 ],
 "2050": [
  "from math import gcd\n\nn, k = map(int, input().split())\n\n# Find all pairs of distinct numbers whose gcd is k\npairs_k = []\nfor i in range(1, k+1):\n    for j in range(i+1, k+1):\n        if gcd(i,j) == k:\n            pairs_k.append((i,j))\n\n# Find all possible sets of 4 numbers that use the pairs of k gcd\nsets_k = []\nfor i in range(len(pairs_k)):\n    for j in range(i+1, len(pairs_k)):\n        set_k = set(pairs_k[i]).union(set(pairs_k[j]))\n        if len(set_k) == 4:\n            sets_k.append(set_k)\n\n# Calculate the minimal m\nm = max(max(s) for s in sets_k)\n\n# Print the minimal m and one possible solution\nprint(m)\nfor s in sets_k[:n]:\n    print(*s)"
 ],
 "2051": [
  "n,m,k=map(int,input().split())\nc=[0]+list(map(int,input().split()))\np=[i for i in range(n+1)]\n\ndef find(x):\n    if p[x]==x:\n        return x\n    p[x]=find(p[x])\n    return p[x]\n\nfor i in range(m):\n    l,r=map(int,input().split())\n    p[find(l)]=find(r)    \n\nans=0\nfor i in range(1,n+1):\n    if find(i)==i:\n        freq=[0]*(k+1)\n        cnt=0\n        for j in range(i,n+1):\n            if find(j)==i:\n                freq[c[j]]+=1\n                cnt+=1\n        ans+=cnt-max(freq)\n\nprint(ans)"
 ],
 "2052": [
  "w, l = map(int, input().split())\nstones = list(map(int, input().split()))\n\nans = 0\ncurr_stones = 0\nfor i in range(w-1):\n    curr_stones += stones[i]\n    if curr_stones >= l:\n        ans += 1\n        curr_stones = 0\n\nprint(ans)"
 ],
 "2053": [
  "n = int(input())\na = list(map(int, input().split()))\nm = int(input())\nb = list(map(int, input().split()))\n\ndiff = abs(sum(a) - sum(b))\n\ndef get_swaps():\n    for i in range(n):\n        for j in range(m):\n            new_sum_a = sum(a) - a[i] + b[j]\n            new_sum_b = sum(b) - b[j] + a[i]\n            new_diff = abs(new_sum_a - new_sum_b)\n            if new_diff < diff:\n                return [(i+1, j+1)]\n    for i in range(n):\n        for j in range(m):\n            for k in range(n):\n                for l in range(m):\n                    new_sum_a = sum(a) - a[i] + b[j] - a[k] + b[l]\n                    new_sum_b = sum(b) - b[j] + a[i] - b[l] + a[k]\n                    new_diff = abs(new_sum_a - new_sum_b)\n                    if new_diff < diff:\n                        return [(i+1, j+1), (k+1, l+1)]\n    return []\n\nswaps = get_swaps()\nprint(diff)\nprint(len(swaps))\nfor s in swaps:\n    print(s[0], s[1])"
 ],
 "2054": [
  "t = int(input())\n\nfor i in range(t):\n    a, b = map(int, input().split())\n    x = min(a, b, (a + b) // 3)\n    print(x * 2 + (a + b - 3 * x) // 5)"
 ],
 "2055": [
  "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    max_a = max(a)\n    possible = True\n    for i in range(n):\n        if max_a > b[i] + b[(i+1)%n]:\n            possible = False\n            break\n    if possible:\n        print(\"YES\")\n    else:\n        print(\"NO\")"
 ],
 "2056": [
  "n = int(input())\na = list(map(int, input().split()))\nb = [0] * 20\nfor ai in a:\n    for j in range(20):\n        if ai & (1 << j):\n            b[j] += 1\nans = 0\nfor ai in a:\n    cur = 0\n    for j in range(20):\n        if b[j] * 2 > n and ai & (1 << j):\n            cur += (1 << j)\n    ans += cur * cur\nprint(ans)"
 ],
 "2057": [
  "n = int(input())\nt = list(map(int, input().split()))\nvisited = set()\ncurrent = 1\nfor ti in t:\n    if ti in visited:\n        current += 1\n        visited.clear()\n    visited.add(ti)\nprint(current)"
 ],
 "2058": [
  "a = input()\nb = input()\nn = len(a)\nm = len(b)\nans = 0\nfor i in range(m-n+1):\n    cur = b[i:i+n]\n    diff = sum([cur[j]!=a[j] for j in range(n)])\n    ans += diff\nprint(ans)"
 ],
 "2059": [
  "n = int(input())\na = list(map(int, input().split()))\n\nl, r, ans = 0, 10**9, 0\nwhile l <= r:\n    mid = (l + r) // 2\n    flag = True\n    for i in range(n):\n        for j in range(i + 1, n):\n            if mid * abs(i - j) > min(a[i], a[j]):\n                flag = False\n                break\n        if not flag:\n            break\n    if flag:\n        ans = mid\n        l = mid + 1\n    else:\n        r = mid - 1\n\nprint(ans)"
 ],
 "2060": [
  "n = int(input())\nfor i in range(n):\n    x = int(input())\n    if x % 3 == 0 or x % 3 == 2 and x > 2 * 3:\n        print(\"YES\")\n    else:\n        print(\"NO\")"
 ],
 "2061": [
  "import sys\nsys.setrecursionlimit(10**6)\n\nn, m, k = map(int, input().split())\ngrid = [input() for _ in range(n)]\nwater = set()\n\n# Get all water cells\nfor i in range(1, n-1):\n    for j in range(1, m-1):\n        if grid[i][j] == '.':\n            water.add((i, j))\n\n# DFS to get all lakes\ndef dfs(i, j, lake):\n    lake.add((i, j))\n    for ni, nj in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\n        if (ni, nj) in water and (ni, nj) not in lake:\n            dfs(ni, nj, lake)\n\nlakes = []\nwhile water:\n    i, j = water.pop()\n    if i == 0 or i == n-1 or j == 0 or j == m-1:\n        # Ignore water cells connected to the border\n        continue\n    lake = set()\n    dfs(i, j, lake)\n    if lake:\n        lakes.append(lake)\n    water = water - lake\n\n# Sort lakes by size\nlakes.sort(key=len)\n\n# Transform smallest lakes until there are k left\nans = 0\nfor i in range(len(lakes)-k):\n    lake = lakes[i]\n    ans += len(lake)\n    for i, j in lake:\n        grid[i] = grid[i][:j] + '*' + grid[i][j+1:]\n\nprint(ans)\nprint('\\n'.join(grid))"
 ],
 "2062": [
  "n = int(input())\ncards = list(map(int, input().split()))\ncards.sort()\nmax_power = 0\nfor i in range(n):\n    flag = True\n    tmp_power = cards[i]\n    for j in range(n):\n        if i == j:\n            continue\n        if cards[j] % cards[i] != 0:\n            if flag:\n                tmp_power += cards[j]  # add this card to the team\n                flag = False\n            else:\n                break  # can't use this card anymore\n    max_power = max(max_power, tmp_power)\nprint(max_power)"
 ],
 "2063": [
  "n, m, w = map(int, input().split())\na = list(map(int, input().split()))\n\nl, r = 1, max(a)\nwhile l <= r:\n    mid = (l+r)//2\n    cnt = 0\n    for i in range(w):\n        cnt += max(0, mid-a[i])\n    if cnt <= m:\n        ans = mid\n        l = mid + 1\n    else:\n        r = mid - 1\n        \nprint(ans)"
 ],
 "2064": [
  "n = int(input())\nif n%2==0:\n    print(\"1\"*(n//2))\nelse:\n    print(\"7\" + \"1\"*((n-3)//2))"
 ],
 "2065": [
  "import sys \nsys.setrecursionlimit(1000000)\ndef dfs(u):  \n    if visited[u]: \n        return False  \n    visited[u] = True \n    for i in adj[u]:\n        if dfs(i):\n            gift_order.append(u) \n            assigned[i] = True \n            return False \n        elif assigned[i]:\n            gift_order.append(u) \n            return False\n    return True\n\nn,m = map(int, input().split()) \nadj = [[] for _ in range(n)] \nassigned = [False]*n \nvisited = [False]*n \ngifts = list(map(int, input().split()))\nfor i in range(m):\n    u,v = map(int, input().split())\n    adj[u-1].append(v-1) \n\ngift_order = []\nfor i in range(n):\n    if dfs(i):\n        print(-1)\n        exit()\n\nprint(len(gift_order))\nfor u in gift_order[::-1]:\n    print(u+1)"
 ],
 "2066": [
  "from collections import Counter\nt = int(input())\nfor _ in range(t):\n    s = input()\n    c = Counter(s) # counting the frequency of each letter\n    ans = []\n    for i in range(26): \n        ch = chr(ord('a')+i)\n        if ch not in c: \n            continue\n        ans.append(ch) # appending the character in ans\n        c[ch] -= 1\n        if c[ch] == 0: \n            del c[ch]\n        for j in range(i+1, 26):\n            ch2 = chr(ord('a')+j)\n            if ch2 not in c: \n                continue\n            ans.append(ch2) # appending the next neighboring character in ans\n            c[ch2] -= 1\n            if c[ch2] == 0:\n                del c[ch2]\n            break\n        else:\n            break\n    if c: # if the string contain unpaired letters\n        print(\"No answer\")\n        continue\n    print(\"\".join(ans)) # output the answer"
 ],
 "2067": [
  "n, m = map(int,input().split())\nvert = sorted([int(input()) for _ in range(n)])\nhoriz = sorted([tuple(map(int,input().split())) for _ in range(m)], key = lambda x: x[2], reverse = True)\nl, r = 0, n-1\nans = n\nfor i in range(m):\n    while l <= r and vert[l] <= horiz[i][0]:\n        l += 1\n        ans -= 1\n    while l <= r and vert[r] >= horiz[i][1]:\n        r -= 1\n        ans -= 1\n    if l > r:\n        break\n\nprint(ans)"
 ],
 "2068": [
  "n = int(input())\nreposts = {}\nreposts[\"polycarp\"]  = 1\nfor i in range(n):\n    line = input().lower().split()\n    reposts[line[0]] = reposts[line[2]] + 1\nprint(max(reposts.values()))"
 ],
 "2069": [
  "from collections import defaultdict\n\nn, m = map(int, input().split())\np = list(map(int, input().split()))\nfoes = defaultdict(set)\nfor _ in range(m):\n    a, b = map(int, input().split())\n    if p.index(a) > p.index(b):\n        a, b = b, a\n    foes[a].add(b)\n\nans = n * (n + 1) // 2\nj = 1\nfor i in range(n):\n    while j < n and all(q not in foes[p[j - 1]] for q in foes[p[i]]):\n        j += 1\n    ans -= j - i\nprint(ans)"
 ],
 "2070": [
  "# Reading input values\na = list(map(int, input().split()))\ns = input()\n\n# Initializing variables\nn = len(s)\nfreq = [0] * 26\ncount = 0\nans = 0\n\n# Looping through string s and calculating the answer\nfor i in range(n):\n    index = ord(s[i]) - ord('a')\n    freq[index] += 1\n    count += a[index]\n\n    if freq[index] > 1:\n        count -= a[index]\n        for j in range(i-1, i-freq[index]-1, -1):\n            freq[ord(s[j])-ord('a')] -= 1\n            count -= a[ord(s[j])-ord('a')]\n\n    if i > 0 and (ord(s[i]) == ord(s[i-1]) or count == 0):\n        ans += 1\n\n# Printing the final answer\nprint(ans)"
 ],
 "2071": [
  "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\ndp = [[0]*n for _ in range(3)]\ndp[0][0] = 0\ndp[1][0] = a[0]\ndp[2][0] = b[0]\n\nfor i in range(1,n):\n    dp[0][i] = max(dp[0][i-1], dp[1][i-1], dp[2][i-1])\n    dp[1][i] = max(dp[0][i-1], dp[2][i-1]) + a[i]\n    dp[2][i] = max(dp[0][i-1], dp[1][i-1]) + b[i]\n\nprint(max(dp[0][n-1], dp[1][n-1], dp[2][n-1]))"
 ],
 "2072": [
  "import sys\n\nn = int(sys.stdin.readline())\nx = list(map(int, sys.stdin.readline().split()))\nv = list(map(int, sys.stdin.readline().split()))\n\n\ndef canMeet(t):\n    leftMost, rightMost = float('-inf'), float('inf')\n    for i in range(n):\n        leftMost = max(leftMost, x[i] - v[i] * t)\n        rightMost = min(rightMost, x[i] + v[i] * t)\n    return leftMost <= rightMost\n\n\nlo, hi = 0, 10 ** 9\nwhile hi - lo > 10 ** -7:\n    mid = (lo + hi) / 2\n    if canMeet(mid):\n        hi = mid\n    else:\n        lo = mid\n\nprint(hi)"
 ],
 "2073": [
  "MOD = 1000000007\n\ndef dfs(u,v,vis,arr,road):\n    if vis[u]!=0:return vis[u]==v\n    vis[u] = v\n    return dfs(arr[u],v,vis,arr,road|1<<u)\n\ndef solve(n,arr):\n    ans,has = 0,[0]*n\n    for i in range(n):\n        if has[i] or arr[arr[i]-1]!=i+1:continue\n        vis,k = [0]*n,i\n        while not has[k] and vis[k]==0:\n            vis[k],k = 1,arr[k]-1\n        if vis[k]>0 or has[k]:has[k] = 2\n        else:\n            cycle = 0\n            while has[k]!=2:\n                has[k],k,cycle = 1,arr[k]-1,cycle+1\n            ans += (1<<cycle)-1\n    cnt,noCycle = 0,0\n    for i in range(n):\n        if has[i]!=0:continue\n        cnt += 1\n        vis,k = [0]*n,i\n        while vis[k]==0:\n            if has[k]==2:has[i],noCycle = 1,noCycle+1;break\n            vis[k],k = 1,arr[k]-1\n    ans = (ans+(1<<noCycle)*(pow(2,cnt-noCycle,MOD)-1))%MOD\n    return ans \n\nn,arr = int(input()),list(map(int,input().split()))\nprint(solve(n,arr))"
 ],
 "2074": [
  "n, m = map(int, input().split())\n\nmin_costs = [min(map(int, input().split())) for _ in range(n)]\n\nprint(max(min_costs))"
 ],
 "2075": [
  "MOD = 10**9 + 7\n\nn, m = map(int, input().split())\nbrackets = input()\n\ndp = [0] * (n-m+1)\n\nbalance = 0\nfor i in range(m):\n    if brackets[i] == '(':\n        balance += 1\n    else:\n        balance -= 1\n\nif balance != -1:\n    print(0)\nelse:\n    dp[0] = 1\n    mult = 1\n    for i in range(1, n-m+1):\n        mult = (mult * 2) % MOD\n        dp[i] = (dp[i-1] + mult) % MOD\n    ans = 0\n    balance = 0\n    for i in range(m):\n        if brackets[i] == '(':\n            balance += 1\n        else:\n            balance -= 1\n\n        if balance < 0:\n            break\n\n        if i == m-1:\n            ans += dp[n-m]\n        elif balance == 0:\n            ans += (dp[i-m] * dp[n-(i+1)]) % MOD\n\n    print(ans % MOD)"
 ],
 "2076": [
  "t = int(input())\nfor i in range(t):\n    a, b, c = map(int, input().split())\n    ans = 0\n    for j in range(0, min(b, c//2) + 1):\n        ans = max(ans, 3*j + min(a, (b-j)//2)*3)\n    print(ans)"
 ],
 "2077": [
  "import heapq\n\ndef topological_sort(graph, in_degree, topics):\n\n    n = len(graph)\n    visited = [False] * n\n    order = []\n    q = []\n\n    # Push all nodes with in-degree 0 into q.\n    for i in range(n):\n        if in_degree[i] == 0:\n            q.append(i)\n\n    # While q is not empty, pop the node with smallest desired topic and\n    # add it to the result order. Update the in-degree of its neighbors and\n    # add them to q if their in-degree becomes 0.\n    while q:\n        u = heapq.heappop(q)\n        visited[u] = True\n        order.append(u)\n        for v in graph[u]:\n            in_degree[v] -= 1\n            if in_degree[v] == 0:\n                heapq.heappush(q, v)\n\n        # Find the smallest topic not covered by neighbors\n        topics_covered = set(topics[v] for v in graph[u])\n        smallest_topic = None\n        for t in range(1, len(topics) + 1):\n            if t not in topics_covered:\n                smallest_topic = t\n                break\n\n        if smallest_topic is None:\n            return -1\n\n        # If the smallest topic is not the desired topic of the current node,\n        # it means we can't write the nodes in the given order.\n        if smallest_topic != topics[u]:\n            return -1\n\n    # If not all nodes are visited, it means there is a cycle in the graph.\n    if not all(visited):\n        return -1\n\n    return order\n\nn, m = map(int, input().split())\ngraph = [[] for _ in range(n)]\nin_degree = [0] * n\nfor _ in range(m):\n    u, v = map(int, input().split())\n    u, v = u - 1, v - 1\n    graph[u].append(v)\n    graph[v].append(u)\n    in_degree[v] += 1\n    in_degree[u] += 1\n\ntopics = list(map(int, input().split()))\n\norder = topological_sort(graph, in_degree, topics)\nif order == -1:\n    print(-1)\nelse:\n    print(\" \".join(str(x + 1) for x in order))"
 ],
 "2078": [
  "from bisect import bisect_left,bisect_right\nn,m=[int(x)for x in input().split()]\nh=[]\nv=[]\nfor i in range(n):\n    y,xi,xf=[int(x)for x in input().split()]\n    h.append((y,xi,xf))\nfor i in range(m):\n    x,yi,yf=[int(x)for x in input().split()]\n    v.append((x,yi,yf))\nh.sort()\nv.sort()\npts=[(0,0),(0,10**6),(10**6,0),(10**6,10**6)]\nfor pt in pts:\n    h.append((pt[1],pt[0],pt[0]))\n    v.append((pt[0],pt[1],pt[1]))\nh.sort()\nv.sort()\ndef get_count(lst,token):\n    counts=[lst[0][0]!=token]\n    for i in range(1,len(lst)):\n        if lst[i][0]!=token:\n            counts.append(counts[-1]+1)\n        else:\n            counts.append(counts[-1])\n    return counts\nhc=get_count(h,0)\nvc=get_count(v,0)\nhl=len(hc)\nvl=len(vc)\ngrids=[[0 for i in range(vl)]for j in range(hl)]\ngrid_counts=[0]*(len(hc)*len(vc)+1)\ngrid_counts[0]=1\nfor y,xi,xf in h:\n    l=bisect_left(v,(xi,-10**9,-10**9))\n    r=bisect_right(v,(xf,10**9,10**9))\n    lcnt=vc[l-1]\n    rcnt=vc[r-1]\n    for i in range(l-1,r):\n        k=(lcnt+(vc[i]-lcnt)*hl+h[i][1]*hl)\n        id=(k-1)*vl+hc[y]\n        back=grid_counts[id]\n        if y+1<10**6:\n            id2=(k-1)*vl+hc[y+1]\n            grid_counts[id2]=grid_counts[id]\n        if h[i][2]==xf:\n            grid_counts[id]=back\n        elif h[i][2]<xf:\n            id2=id+1\n            grid_counts[id2]=grid_counts[id]\n        else:\n            new_val=grid_counts[id]\n            id2=id-1\n            while id2>=0 and grid_counts[id2]==0:\n                id2-=1\n            if id2>=0:\n                new_val+=grid_counts[id2]\n            grid_counts[id]=new_val\n    rcoord=bisect_left(h,(y,-10**9,xi))\n    lcoord=bisect_right(h,(y,xf,10**9))\n    for i in range(rcoord,lcoord):\n        k=(y-1)+(hc[h[i][1]]+(h[i][2]-hc[h[i][1]])*vl)*hl\n        back=grid_counts[k]\n        if h[i][2]==xf:\n            grid_counts[k]=back\n        elif h[i][2]<xf:\n            id2=k+hl\n            grid_counts[id2]=grid_counts[k]\n        else:\n            new_val=grid_counts[k]\n            id2=k-hl\n            while id2>=0 and grid_counts[id2]==0:\n                id2-=hl\n            if id2>=0:\n                new_val+=grid_counts[id2]\n            grid_counts[k]=new_val\nprint(grid_counts[-1])"
 ],
 "2079": [
  "n = int(input())\nwidths = list(map(int, input().split()))\norder = input()\n\nintrovert_seats = []\noccupied_rows = set()\nfor i in range(n):\n    if not occupied_rows:\n        introvert_seats.append(i+1)\n    elif widths[i] < widths[introvert_seats[-1]-1]:\n        introvert_seats.append(i+1)\n    occupied_rows.add(i+1)\n        \noccupied_seats = {}\nfor i in range(2*n):\n    if order[i] == \"0\":\n        row = introvert_seats.pop(0)\n        occupied_rows.add(row)\n        occupied_seats[row] = 1\n        print(row, occupied_seats[row])\n    else:\n        for row in sorted(occupied_rows):\n            if row not in occupied_seats:\n                occupied_seats[row] = 2\n                print(row, occupied_seats[row])\n                break"
 ],
 "2080": [
  "import math\nq = int(input())\nfor i in range(q):\n    n = int(input())\n    print(math.floor(n*(n-1)/4))"
 ],
 "2081": [
  "n = int(input())\na = list(map(int, input().split()))\n\nprefix_max = [0] * (n + 1)\nprefix_min = [0] * (n + 1)\nsuffix_max = [0] * (n + 1)\nsuffix_min = [0] * (n + 1)\n\nfor i in range(1, n+1):\n    prefix_max[i] = max(prefix_max[i-1], a[i-1])\n    prefix_min[i] = min(prefix_min[i-1], a[i-1])\n    \nfor i in range(n, 0, -1):\n    suffix_max[i] = max(suffix_max[i+1], a[i-1])\n    suffix_min[i] = min(suffix_min[i+1], a[i-1])\n    \nans = 0\nfor i in range(1, n+1):\n    ans += (prefix_max[i]-prefix_min[i])*(n-i+1)\n    ans += (suffix_max[i]-suffix_min[i])*(i-1)\n    \nprint(ans)"
 ],
 "2082": [
  "from collections import defaultdict\n\ndef find(parent, node):\n    if parent[node] != node:\n        parent[node] = find(parent, parent[node])\n    return parent[node]\n\ndef union(parent, size, u, v):\n    u_parent = find(parent, u)\n    v_parent = find(parent, v)\n    if u_parent == v_parent:\n        return\n    if size[u_parent] < size[v_parent]:\n        u_parent, v_parent = v_parent, u_parent\n    parent[v_parent] = u_parent\n    size[u_parent] += size[v_parent]\n\nn,m = map(int,input().split())\narr = list(map(int,input().split()))\nedges = []\nfor i in range(m):\n    x,y = map(int,input().split())\n    x -= 1\n    y -= 1\n    edges.append([arr[x]+arr[y],x,y])\n    \nedges.sort(reverse=True)\n\nparent = [i for i in range(n)]\nsize = [1]*n\n\ngraph = defaultdict(set)\n\nans = 0\ncnt = 0\nfor weight, i, j in edges:\n    if find(parent, i) == find(parent, j):\n        continue\n    ans += weight*size[find(parent,i)]*size[find(parent,j)]\n    union(parent, size, i, j)\n    cnt += 1\n    if cnt == n-1:\n        break\n        \nans *= 2\nans /= n*(n-1)\n\nprint(\"{:.6f}\".format(ans))\n"
 ],
 "2083": [
  "n, T, c = map(float, input().split())\na = list(map(int, input().split()))\nm = int(input())\np = list(map(int, input().split()))\n\n# Real value calculation\nreal_value = []\nfor j in range(m):\n    temp = 0\n    for i in range(p[j] - T + 1, p[j] + 1):\n        temp += a[i - 1]\n    real_value.append(temp / T)\n\n# Approximate value calculation\napprox_value = []\nmean, t = 0, 1\nfor j in range(p[0] - 1):\n    mean = (mean + a[j] / T) / c\nwhile t <= max(p) and t <= n:\n    mean = (mean + a[t - 1] / T) / c\n    if t in p:\n        approx_value.append(mean * T)\n    t += 1\n\n# Error calculation\nerror = [abs(real_value[j] - approx_value[j]) / real_value[j] for j in range(len(real_value))]\n\n# Output results\nfor j in range(len(real_value)):\n    print(\"{:.6f} {:.6f} {:.6f}\".format(real_value[j], approx_value[j], error[j]))"
 ],
 "2084": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\na.sort(reverse=True)\nprint(sum(a[:k]))"
 ],
 "2085": [
  "n = int(input())\na = [int(x) for x in input().split()]\n\nans = 0\nfor mask in range(62, -1, -1):\n  cur = 0\n  for i in range(n):\n    if (a[i] >> mask) & 1:\n      cur += 1\n       \n  if cur < 2:\n    continue\n\n  cur_sum = 0\n  for i in range(n):\n    if (a[i] >> mask) & 1:\n      cur_sum += a[i]\n  ans = max(ans, cur_sum)\n\n  cur_sum = 0\n  for i in range(n):\n    if (a[i] >> mask) & 1:\n      cur_sum += a[i]\n\n  for k in range(2, cur+1):\n    cur_sum -= a[k-2] * ((a[k-2] >> mask) & 1)\n    ans = max(ans, cur_sum)\nprint(ans)"
 ],
 "2086": [
  "n = int(input())\na = list(map(int, input().split()))\ns, f = map(int, input().split())\n\n# shift list so that start time is 1\na_shift = a[s-1:]+a[0:s-1]\n\nmax_participants = -1\nmax_i = -1\n\nleft = right = 0\nsum_a = a_shift[0]\n\nwhile right < n:\n    if right - left + 1 <= f - s + 1:\n        if sum_a > max_participants:\n            max_participants = sum_a\n            max_i = left\n        right += 1\n        if right < n:\n            sum_a += a_shift[right]\n    else:\n        sum_a -= a_shift[left]\n        left += 1\n\nprint(max_i+1)"
 ],
 "2087": [
  "MOD = 998244353\nA, B, C = map(int, input().split())\nresult = (A*(A+1)//2) * (B*(B+1)//2) * (C*(C+1)//2)\nprint(result % MOD)"
 ],
 "2088": [
  "from collections import defaultdict\n\nn = int(input())\nadj_list = defaultdict(list)\nfor i, p in enumerate(input().split()):\n    adj_list[int(p)].append(i+2)\n\nans = [0] * n\ncolors = [0] * n\n\ndef dfs(node):\n    if len(adj_list[node]) == 0:\n        ans[0] += 1\n        colors[node-1] = 1\n        return\n\n    subtrees = []\n    for nei in adj_list[node]:\n        dfs(nei)\n        subtrees.append(colors[nei-1])\n    subtrees.sort()\n\n    curr_color = 1\n    for subtree in subtrees:\n        if subtree == curr_color:\n            curr_color += 1\n        colors[node-1] = max(colors[node-1], subtree)\n    \n    ans[curr_color-1] += 1\n\ndfs(1)\nprint(*ans)"
 ],
 "2089": [
  "from collections import deque\n\nn, m, s, t = map(int, input().split())\ns -= 1\nt -= 1\n\ngraph = [[] for _ in range(n)]\nfor _ in range(m):\n    u, v = map(int, input().split())\n    u -= 1\n    v -= 1\n    graph[u].append(v)\n    graph[v].append(u)\n\ndef bfs(s):\n    dist = [-1] * n\n    dist[s] = 0\n    q = deque([s])\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if dist[v] == -1:\n                dist[v] = dist[u] + 1\n                q.append(v)\n    return dist\n\n# Calculate the original distance from s and t to other junctions\ndist_s = bfs(s)\ndist_t = bfs(t)\n\n# Count the number of junction pairs that are not directly connected and can have the new road built\ncount = 0\nfor u in range(n):\n    for v in range(u+1, n):\n        # If u and v are not connected and building a road between them won't decrease the distance between s and t\n        if v not in graph[u] and dist_s[t] == dist_s[u] + 1 + dist_t[v]:\n            count += 1\n\nprint(count)"
 ],
 "2090": [
  "n, k = map(int, input().split())\nsongs = []\nfor i in range(n):\n    ti, bi = map(int, input().split())\n    songs.append((ti, bi))\n\nsongs.sort(key=lambda x: -x[1]) \n\nbeauties = [0]\nfor i in range(n):\n    beauties.append(beauties[-1] + songs[i][1])\n\nmax_pleasure = 0\nfor i in range(1, k+1):\n    for j in range(n-i+1):\n        total_time = sum(songs[j:j+i][0])\n        total_beauty = beauties[j+i] - beauties[j]\n        max_pleasure = max(max_pleasure, total_beauty * total_time)\n\nprint(max_pleasure)"
 ],
 "2091": [
  "t = int(input())\nfor _ in range(t):\n    s = input().strip()\n    n = len(s)\n    i = 0\n    j = n-1\n    while i < j and s[i] == s[j]:\n        i += 1\n        j -= 1\n    if i == j:\n        print(s)\n    elif i > j:\n        print(s[:i] + s[j] + s[i:])\n    else:\n        temp1 = s[i:j+1]\n        temp2 = temp1[::-1]\n        if i > 0:\n            temp3 = s[:i]+temp1+s[j+1:]\n        else:\n            temp3 = temp1+s[j+1:]\n        if j < n-1:\n            temp4 = s[:i]+temp2+s[j+1:]\n        else:\n            temp4 = s[:i]+temp2\n        if len(temp3) > len(temp4):\n            print(temp3)\n        else:\n            print(temp4)"
 ],
 "2092": [
  "m, n, k, t = map(int, input().split())\na = list(map(int, input().split()))\n\ntraps = []\nfor i in range(k):\n    l, r, d = map(int, input().split())\n    traps.append((l, r, d))\n\ntraps.sort()\n\ndef can_reach(num):\n    # dp[i][j] = True if first i soldiers can reach j-th segment in time <= t\n    dp = [[False] * (n+2) for _ in range(num+1)]\n    for i in range(1, num+1):\n        if a[i-1] >= traps[0][2]:\n            dp[i][1] = True\n    for j in range(2, n+2):\n        for i in range(1, num+1):\n            if dp[i][j-1]:\n                dp[i][j] = True\n            else:\n                for p in range(1, i+1):\n                    if a[p-1] >= traps[j-2][2] and traps[j-2][1] >= j-1+(i-p): # can move to the right\n                        dp[i][j] = dp[i][j] or dp[p-1][j-1]\n                    if a[p-1] >= traps[j-2][2] and traps[j-2][0] <= j-1-(i-p): # can move to the left\n                        dp[i][j] = dp[i][j] or dp[p-1][j-1]\n            if dp[i][j] and j == n+1:\n                return True\n    return False\n\nlow, high = 0, m\nans = 0\nwhile low <= high:\n    mid = (low + high) // 2\n    if can_reach(mid):\n        ans = mid\n        low = mid + 1\n    else:\n        high = mid - 1\n\nprint(ans)"
 ],
 "2093": [
  "n = int(input())\na = list(map(int, input().split()))\nd = {}\nfor i in range(n):\n    for j in range(a[i]):\n        if i+1 != j+1 and j+1 in d and d[j+1] == i+1:\n            d[j+1] = -1\n        else:\n            d[j+1] = i+1\nans = 0\nfor key in d:\n    if d[key] == -1:\n        ans += 1\nprint(ans//2)"
 ],
 "2094": [
  "n, k = map(int, input().split())\nh = list(map(int, input().split()))\nmod = 998244353\n\nfact = [1] * (n + 1)\nfor i in range(1, n + 1):\n    fact[i] = fact[i-1] * i % mod\n\ninv = [1] * (n + 1)\ninv[n] = pow(fact[n], mod - 2, mod)\nfor i in range(n - 1, 0, -1):\n    inv[i] = inv[i+1] * (i+1) % mod\n\ndef comb(n, r):\n    return fact[n] * inv[r] % mod * inv[n-r] % mod\n\nans = 0\nfor i in range(n):\n    t = h[(i+1)%n] - 1\n    ans += comb(n-1, t) * pow(k-1, n-1-t, mod)\n    ans %= mod\n\nprint(ans)"
 ],
 "2095": [
  "n = int(input())\nA = []\ngood_cars = []\n\nfor i in range(n):\n    A.append(list(map(int, input().split())))\n\nfor i in range(n):\n    is_good = True\n    for j in range(n):\n        if A[i][j] == 1 or A[i][j] == 3:\n            is_good = False\n            break\n    if is_good:\n        good_cars.append(i+1)\n\nprint(len(good_cars))\nif len(good_cars) > 0:\n    print(' '.join(map(str, good_cars)))"
 ],
 "2096": [
  "n = int(input())\na = list(map(int, input().split()))\n\nnums = set()\nfor i in range(2 * n):\n    for j in range(2 * n):\n        if i != j:\n            num = (a[i] % 10) * 10 + (a[j] // 10)\n            nums.add(num)\n\nheap = [0] * (2 * n)\nfor i in range(2 * n):\n    heap[i] = 1 if i < n or a[i] % 2 == 0 else 2\n\nprint(len(nums))\nprint(' '.join(map(str, heap)))"
 ],
 "2097": [
  "for _ in range(int(input())):\n    n=int(input())\n    a=list(map(int,input().split()))\n    non_zero_count = sum([1 for i in a if i!=0])\n    zero_count     = n-non_zero_count\n    pos_count      = sum([1 for i in a if i>0])\n    neg_count      = non_zero_count-pos_count\n    lower_limit    = 0 if zero_count==0 else 1\n    if neg_count%2!=0 and zero_count==0:\n        lower_limit=min(lower_limit,2)\n    print(lower_limit+zero_count)"
 ],
 "2098": [
  "from collections import defaultdict\n\nn = int(input())\npairs = [tuple(map(int, input().split())) for _ in range(n-1)]\n\n# Check if it's impossible to construct a tree\nmins = map(min, pairs)\nmaxs = map(max, pairs)\nif sorted(mins) != list(range(1, n)) or max(maxs) != n:\n    print(\"NO\")\n    exit()\n\n# Construct the tree\ngraph = defaultdict(list)\nfor i in range(n-1):\n    for j in range(i+1, n-1):\n        if maxs[i] > maxs[j] and mins[i] < maxs[j] and mins[j] < mins[i]:\n            graph[i].append(j)\n            graph[j].append(i)\n            break\n\n# DFS to order the nodes by child node count\ncounts = [0] * (n-1)\nstack = [0]\nvisited = set()\nwhile stack:\n    node = stack.pop()\n    visited.add(node)\n    count = len(graph[node])\n    counts[node] = count\n    for neighbor in graph[node]:\n        if neighbor not in visited:\n            stack.append(neighbor)\n        \norder = sorted(range(n-1), key=counts.__getitem__)\nedges = []\nfor i in order:\n    for j in graph[i]:\n        if j > i:\n            edges.append((mins[i], mins[j]))\n            break\nprint(\"YES\")\nprint('\\n'.join([' '.join(map(str, edge)) for edge in edges]))"
 ],
 "2099": [
  "from datetime import datetime,timedelta\nn, m, t = map(int, input().split())\nqueries = [datetime.strptime(input().strip(), '%H:%M:%S') for _ in range(n)]\nonline = [0] * n\nuser_id = [0] * n\n\nleft, right = 0, 0\nonline_cnt = 0\ncur_user_id = 1\nwhile right < n:\n    while online_cnt < m and right < n:\n        if online[right] == 0:\n            online_cnt += 1\n        online[right] += 1\n        user_id[right] = cur_user_id\n        right += 1\n\n    if online_cnt < m:\n        print(\"No solution\")\n        exit()\n        \n    while True:\n        if (queries[right-1] - queries[left]).total_seconds() <= t:\n            break\n            \n        online[left] -= 1\n        if online[left] == 0:\n            online_cnt -= 1\n        left += 1\n    cur_user_id += 1\n\nprint(cur_user_id-1)\nfor u in user_id:\n    print(u)"
 ],
 "2100": [
  "n = int(input())\nleft = [0] * n\nright = [0] * n\nfor i in range(n):\n    l, r = map(int, input().split())\n    left[i] = l\n    right[i] = r\n\nt_00 = t_01 = t_10 = t_11 = 0\nfor i in range(n):\n    if left[i] == 0 and right[i] == 0:\n        t_00 += 1\n    elif left[i] == 0 and right[i] == 1:\n        t_01 += 1\n    elif left[i] == 1 and right[i] == 0:\n        t_10 += 1\n    else:\n        t_11 += 1\n\nprint(min(t_00 + t_11, t_01 + t_10))"
 ],
 "2101": [
  "r, g, b = map(int, input().split())\nr_sticks = sorted(list(map(int, input().split())), reverse=True)\ng_sticks = sorted(list(map(int, input().split())), reverse=True)\nb_sticks = sorted(list(map(int, input().split())), reverse=True)\n\nrg_rectangles = [r_sticks[i] * g_sticks[j] for i in range(min(r, g)) for j in range(min(r, g)) if i != j]\nrb_rectangles = [r_sticks[i] * b_sticks[j] for i in range(min(r, b)) for j in range(min(r, b)) if i != j]\ngb_rectangles = [g_sticks[i] * b_sticks[j] for i in range(min(g, b)) for j in range(min(g, b)) if i != j]\n\ntotal_rectangles = sorted(rg_rectangles + rb_rectangles + gb_rectangles, reverse=True)\n\ntotal_area = 0\nfor i in range(min(r + g + b, len(total_rectangles))): \n    total_area += total_rectangles[i]\n\nprint(total_area)"
 ],
 "2102": [
  "a = list(map(int, input().split()))\nn = int(input())\nb = list(map(int, input().split()))\n\nmin_diff = float('inf')\n\nfor i in range(6):\n    for j in range(i+1, 6):\n        used_frets = [a[i]+k for k in range(1, n+1) if b[k-1] <= a[j]]\n        if used_frets:\n            min_diff = min(min_diff, max(used_frets) - min(used_frets))\n\nprint(min_diff)"
 ],
 "2103": [
  "n = int(input())\na = list(map(int, input().split()))\n\nused = [False]*(n+1)\nb = [-1]*n\n\nfor i in range(n):\n    if a[i] <= n and not used[a[i]]:\n        b[i] = a[i]\n        used[a[i]] = True\n\nj = 0\nfor i in range(n):\n    if b[i] == -1:\n        while used[j]:\n            j += 1\n        b[i] = j\n        used[j] = True\n\nif any(x == -1 for x in b):\n    print(-1)\nelse:\n    print(*b)"
 ],
 "2104": [
  "from math import gcd\n\nl, r = map(int, input().split())\nif (r - l + 1) % 2 == 0: \n    print(\"NO\")\nelse:\n    print(\"YES\")\n    for i in range(l, r + 1, 2):\n        print(i, i+1)"
 ],
 "2105": [
  "n,m= map(int,input().split())\ns=input().split()\nt=input().split()\nq=int(input())\n\ns_idx=0\nt_idx=0\nfor i in range(q):\n    year=int(input())\n    s_name=s[s_idx]\n    t_name=t[t_idx]\n    name=s_name+t_name\n    year_name=name* (year// (n*m))\n    year%=n*m\n    year_name+=s_name+(t[t_idx+(year%n)])\n    print(year_name)\n    \n    s_idx= (s_idx+1)%n\n    t_idx= (t_idx+1)%m"
 ],
 "2106": [
  "m, k = map(int, input().split())\nd = list(map(int, input().split()))\ns = list(map(int, input().split()))\n\ntotal_time = d[0] + k   # time to travel first road and replenish fuel at city c_1\nremaining_fuel = s[0]  # remaining fuel after replenishing at city c_1\n\nfor i in range(1, m):\n    if remaining_fuel < d[i]:  # if there's not enough fuel to travel to next city\n        time_to_refuel = k * (d[i] - remaining_fuel)  # time to wait for fuel to replenish\n        remaining_fuel = s[i]  # fill fuel tank at current city\n        total_time += time_to_refuel + d[i]  # add time for refueling and time to travel to next city\n    else:  # there's enough fuel to travel to next city\n        remaining_fuel -= d[i]  # consume fuel to travel to next city\n        total_time += d[i]  # add time to travel to next city\n\nprint(total_time)  # Output the minimum time needed to reach city c_n"
 ],
 "2107": [
  "n, m, k, s = map(int, input().split())\na = []\nfor _ in range(n):\n    a.append(list(map(int, input().split())))\nq = list(map(int, input().split()))\n\nnotes_pos = [[] for _ in range(k)]\nfor i in range(n):\n    for j in range(m):\n        notes_pos[a[i][j]-1].append((i, j))\n\ndef get_dist(p1, p2):\n    return abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])\n\nmax_complexity = -1\nfor i in range(1, s):\n    curr_note_pos = notes_pos[q[i-1]-1]\n    next_note_pos = notes_pos[q[i]-1]\n    min_dist = float('inf')\n    for curr_pos in curr_note_pos:\n        for next_pos in next_note_pos:\n            dist = get_dist(curr_pos, next_pos)\n            min_dist = min(min_dist, dist)\n    max_complexity = max(max_complexity, min_dist)\nprint(max_complexity)"
 ],
 "2108": [
  "from collections import deque\n\n# read input\nn, m = map(int, input().split())\nn1, n2, n3 = map(int, input().split())\n\n# create the graph\ngraph = [[] for _ in range(n+1)]\nfor _ in range(m):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n    graph[v].append(u)\n\n# initialize the colors\ncolors = [-1] * (n+1)\n\n# start coloring using BFS\nfor i in range(1, n+1):\n    if colors[i] == -1:\n        # start with color 1 for each connected component\n        colors[i] = 1\n        n1 -= 1\n        queue = deque([i])\n        while queue:\n            node = queue.popleft()\n            for nei in graph[node]:\n                if colors[nei] == -1:\n                    # assign neighboring node a different color than current node\n                    colors[nei] = 3 - colors[node]\n                    if colors[nei] == 1:\n                        n1 -= 1\n                    elif colors[nei] == 2:\n                        n2 -= 1\n                    else:\n                        n3 -= 1\n                    queue.append(nei)\n\n# check if a valid coloring is possible\nif n1 < 0 or n2 < 0 or n3 < 0:\n    print('NO')\nelse:\n    # output the coloring\n    print('YES')\n    print(''.join(str(colors[i]) for i in range(1, n+1)))"
 ],
 "2109": [
  "n = int(input())\narr = list(map(int, input().split()))\n\nnegatives = []\npositives = []\nzeros = []\n\nfor i in arr:\n    if i < 0:\n        negatives.append(i)\n    elif i > 0:\n        positives.append(i)\n    else:\n        zeros.append(i)\n\nif not positives:\n    positives.append(negatives[0])\n    positives.append(negatives[1])\n    negatives = negatives[2:]\n\nif len(negatives) % 2 == 0:\n    zeros.append(negatives.pop())\n\nprint(len(negatives), *negatives)\nprint(len(positives), *positives)\nprint(len(zeros), *zeros)"
 ],
 "2110": [
  "n, h, m, k = map(int, input().split())\ntrains = []\nfor i in range(n):\n    hi, mi = map(int, input().split())\n    trains.append(((hi * 60 + mi) % (h * 60), i + 1))\ntrains.sort()\n\nbest_t = None\nmin_cancelled = n\nfor t in range(m // 2):\n    cancelled = 0\n    last_train = -1\n    for i in range(0, 2 * h, 2):\n        tram_time = (i * 60 + t) % (h * 60)\n        if i < 2 * h - 2:\n            next_tram_time = ((i + 2) * 60 + t) % (h * 60)\n        else:\n            next_tram_time = (t + m // 2) % (h * 60)\n        if next_tram_time < tram_time:\n            next_tram_time += h * 60\n        ok = True\n        for j in range(last_train + 1, n):\n            train_time, train_id = trains[j]\n            if train_time < tram_time - k:\n                last_train = j\n                continue\n            if train_time > tram_time + k:\n                break\n            if train_time < next_tram_time - k:\n                cancelled += 1\n                ok = False\n                break\n        if not ok:\n            break\n    if cancelled < min_cancelled:\n        min_cancelled = cancelled\n        best_t = t\n\nprint(min_cancelled, best_t)\nfor train_time, train_id in trains:\n    tram_time = (train_time - best_t + h * 60) % (h * 60)\n    if tram_time <= k or tram_time >= m // 2 - k:\n        print(train_id)"
 ],
 "2111": [
  "from bisect import bisect_left, bisect_right\nn, q = map(int, input().split())\nl_top, r_bot = [i-1 for i in input().split()], [n-j for j in input().split()]\nl_cnt, r_cnt = l_top[0], r_bot[0]\nrow_cnt = [n]*n\ncol_cnt = [n]*n\nresult = []\nfor i in range(q):\n    x, y, d = input().split()\n    x, y = int(x)-1, int(y)-1\n    if d == \"L\":\n        if x < l_top[bisect_left(l_top, y)]: result.append(0)\n        else:\n            result.append(n-1-row_cnt[x])\n            r_bot_idx = bisect_left(r_bot, x)\n            if r_bot_idx == len(r_bot): continue\n            col_cnt[r_bot[r_bot_idx]] = min(col_cnt[r_bot[r_bot_idx]], x)\n    else:\n        if y < r_bot[bisect_right(r_bot, x)]: result.append(0)\n        else:\n            result.append(n-1-col_cnt[y])\n            l_top_idx = bisect_left(l_top, y)\n            if l_top_idx == len(l_top): continue\n            row_cnt[l_top[l_top_idx]] = min(row_cnt[l_top[l_top_idx]], y)\nprint('\\n'.join(map(str, result)))"
 ],
 "2112": [
  "n, m = map(int, input().split())\nx, k, y = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nans = float('inf')\ni = 0\nj = 0\nwhile i < n and j < m:\n    if a[i] == b[j]:\n        i += 1\n        j += 1\n    else:\n        break\n\nif j == m:\n    print(0)\n    exit()\n\nif k >= m:\n    print(-1)\n    exit()\n\nwhile i < n and j < m:\n    while i < n and a[i] < b[j]:\n        i += 1\n    l = i\n    r = i + k - 1\n    while r < n and a[r] > b[j]:\n        r -= 1\n        l -= 1\n        if l >= 0 and (r == n-1 or a[l] >= a[r+1]):\n            ans = min(ans, x*(k-1) + y)\n    j += 1\n\nif j == m and ans != float('inf'):\n    print(ans)\nelse:\n    print(-1)"
 ],
 "2113": [
  "n = int(input())\nadj_list = [[] for _ in range(n+1)]\nvisited = [False]*(n+1)\ncolor = [-1]*(n+1)\n\nfor _ in range(n-1):\n    u, v = map(int, input().split())\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\ndef dfs(node, c):\n    visited[node] = True\n    color[node] = c\n    for child in adj_list[node]:\n        if not visited[child]:\n            dfs(child, 1-c)\n\ndfs(1, 0)\nnum_of_ones = color.count(1)\nnum_of_zeros = color.count(0)\n\nans = num_of_ones*num_of_zeros - (n-1)\nprint(ans)"
 ],
 "2114": [
  "n = int(input())\n\nif n == 1:\n    print(1)\n    exit()\nif n <= 3:\n    print(-1)\n    exit()\n\nboard = [[0] * n for _ in range(n)]\n\nk = 1\nfor i in range(n // 2):\n    for j in range(i, n - i - 1):\n        board[i][j] = board[j][i] = k\n        board[n - i - 1][n - j - 1] = board[n - j - 1][n - i - 1] = k + 1\n        k += 2\n\nif n % 2:\n    for i in range(n):\n        board[i][n // 2] = board[n // 2][i] = k\n        k += 1\n\nfor row in board:\n    print(*row)"
 ],
 "2115": [
  "n=int(input())\na=list(map(int, input().split()))\n \ni=0\nwhile(i<len(a)-1):\n    if a[i]==a[i+1]:\n        k=i+1\n        while k<len(a)-1 and a[k]==a[k+1]:\n            k+=1\n        a = a[:i]+[a[i]+1]+a[k+1:]\n        i=max(i-1, 0)\n    else:\n        i+=1\n \nprint(len(a))\nprint(*a)"
 ],
 "2116": [
  "n, m, k = map(int, input().split())\npos = list(map(int, input().split()))\ntime = 0\nfor _ in range(n):\n    order_list = list(map(int, input().split()))\n    for order in order_list:\n        time += pos.index(order) + 1\n        pos.pop(pos.index(order))\n        pos.insert(0, order)\nprint(time)"
 ],
 "2117": [
  "from collections import defaultdict\n \ndef dfs(node, parent, adj, dp, dist):\n    children = []\n    for neighbour in adj[node]:\n        if neighbour != parent:\n            dfs(neighbour, node, adj, dp, dist)\n            children.append(dp[neighbour][0] + dist[(node, neighbour)])\n \n    children.sort(reverse=True)\n    dp[node][0] = 1\n    dp[node][1] = 0\n \n    for i in range(len(children)):\n        if i == 0:\n            dp[node][0] += children[i]\n        else:\n            dp[node][1] = max(dp[node][1], dp[node][0] + children[i-1] - 1)\n            dp[node][0] += children[i]\n    return\n \nn = int(input())\nadj = defaultdict(list)\ndist = {}\ndp = [[0, 0] for _ in range(n+1)]\n \nfor _ in range(n-1):\n    u, v = map(int, input().split())\n    adj[u].append(v)\n    adj[v].append(u)\n    dist[(u, v)] = 1\n    dist[(v, u)] = 1\n \ndfs(1, 0, adj, dp, dist)\nanswer = []\n \nfor i in range(1, n+1):\n    k = min(i, 2)\n    max_controlled = dp[1][0] if k == 1 else dp[1][1]\n    answer.append(max_controlled)\n \n    for j in range(2, i+1):\n        if j > len(adj[1]):\n            break\n        max_controlled = max(max_controlled, dp[adj[1][j-1]][0] + dp[1][min(k, j)-1])\n        answer[-1] = max(answer[-1], max_controlled)\n \nprint(' '.join(str(x) for x in answer))"
 ],
 "2118": [
  "n,k=map(int,input().split())\nif k>((n-1)*n)//2:\n    print(\"-1\")\nelse:\n    p=[i for i in range(1,n+1)]\n    for j in range(n-2,-1,-1):\n        x=(n-1)-j\n        m=max(x-1,1)\n        if k>=m:\n            p[j:j+x]=p[j:j+x][::-1]\n            k-=m\n        else:\n            p[j:j+k]=p[j:j+k][::-1]\n            break\n    print(*p)"
 ],
 "2119": [
  "MOD = 998244353\n\ndef count_partitions(a, l, r):\n\n    n = len(a)\n    p = [-1] * n\n    s = [-INF] + [0] * n\n    S = [-INF] + [0] * n\n\n    L = len(str(l))\n    R = len(str(r))\n\n    for i in range(n):\n        for j in range(max(i - R, 0), max(i - L, -1), -1):\n            if (j > 0 and a[j] == \"0\") or int(a[j:i + 1]) > r: break\n            if int(a[j:i + 1]) >= l:\n                if s[j] + 1 > s[i + 1]:\n                    s[i + 1] = s[j] + 1\n                    S[i + 1] = (S[j] + p[j] + 1) % MOD\n                elif s[j] + 1 == s[i + 1]:\n                    S[i + 1] = (S[i + 1] + S[j] + p[j] + 1) % MOD\n            p[i] = (p[i] + S[i]) % MOD\n\n    return p[n - 1]\n\nif __name__ == '__main__':\n    a, l, r = input().strip(), int(input()), int(input())\n    print(count_partitions(a, l, r))"
 ],
 "2120": [
  "from heapq import heappush, heappop\n\nn, m = map(int, input().split())\nv = list(map(int, input().split()))\n\nadj = [[] for _ in range(n)]\nindegree = [0] * n\nfor i in range(m):\n    a, b = map(int, input().split())\n    adj[a - 1].append(b - 1)\n    indegree[b - 1] += 1\n\npq = []\nfor i in range(n):\n    if indegree[i] == 0:\n        heappush(pq, i)\n\nresult = 0\nwhile len(pq) > 0:\n    u = heappop(pq)\n    result += v[u]\n    for v in adj[u]:\n        indegree[v] -= 1\n        if indegree[v] == 0:\n            heappush(pq, v)\n\nprint(result)"
 ],
 "2121": [
  "from collections import defaultdict\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\ngraph = defaultdict(list)\n\nfor i in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n    graph[v].append(u)\n\ndef dfs(node, parent):\n    grades = []\n    for child in graph[node]:\n        if child != parent:\n            grades.append(dfs(child, node))\n    if not grades:\n        return a[node - 1]\n    grades.sort()\n    return min(a[node - 1], grades[0])\n\nl, r = 1, n\nans = n\nwhile l <= r:\n    mid = (l + r) // 2\n    values = []\n    for root in range(1, n + 1):\n        value = dfs(root, -1)\n        values.append(value)\n    values.sort()\n    if len(values) >= k and values[k - 1] >= mid:\n        ans = mid\n        l = mid + 1\n    else:\n        r = mid - 1\n\nprint(ans)"
 ],
 "2122": [
  "n, k = map(int, input().split())\nbooks = list(map(int, input().split()))\n\nleft, right = 0, 0\nbook_dict = {books[0]: 1}\nmax_books = 1\nwhile right < n:\n    if len(book_dict) <= k:\n        max_books = max(max_books, right - left + 1)\n        right += 1\n        if right < n:\n            book_dict[books[right]] = book_dict.get(books[right], 0) + 1\n    else:\n        book_dict[books[left]] -= 1\n        if book_dict[books[left]] == 0:\n            del book_dict[books[left]]\n        left += 1\n\nprint(max_books)"
 ],
 "2123": [
  "n = int(input())\nheights = list(map(int, input().split()))\nmin_energy = 0\nmoney_paid = 0\nfor height in heights:\n    energy_gain = height - min_energy\n    if energy_gain < 0:\n        money_paid += abs(energy_gain)\n        min_energy = height + abs(energy_gain)\n    else:\n        min_energy = height\nprint(money_paid)"
 ],
 "2124": [
  "from collections import defaultdict\n\nfor _ in range(int(input())):\n    n = int(input())\n    usernames = input().split()\n    usernames_dict = defaultdict(int)\n    for idx, username in enumerate(usernames):\n        usernames_dict[username] = idx\n\n    m = int(input())\n    messages = []\n    for _ in range(m):\n        message = input().strip()\n        if message[0].isalpha():\n            sender, text = message.split(':', 1)\n            sender_idx = usernames_dict[sender]\n            messages.append((sender_idx, text))\n        else:\n            messages.append((-1, message[2:]))\n\n    result = []\n    prev_sender = -1\n    for sender, text in messages:\n        if sender != -1:\n            result.append((sender, text))\n            prev_sender = sender\n        else:\n            for idx in range(n):\n                if idx != prev_sender:\n                    if usernames[idx] in text.split():\n                        result.append((idx, text))\n                        prev_sender = idx\n                        break\n            else:\n                print(\"Impossible\")\n                break\n    else:\n        for sender_idx, text in result:\n            print(usernames[sender_idx] + ':' + text)"
 ],
 "2125": [
  "n, m = map(int, input().split())\nmat = [input() for _ in range(n)]\n\ncount = 0\nfor i in range(n-2):\n    for j in range(m):\n        if mat[i][j] != mat[i+1][j] and mat[i][j] != mat[i+2][j] and mat[i+1][j] != mat[i+2][j]:\n            count += 1\n\nprint(count)"
 ],
 "2126": [
  "import sys\n\ninput = sys.stdin.readline\n\nn, m, h = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nt = [list(map(int, input().split())) for _ in range(n)]\n\nans = [[0]*m for _ in range(n)]\nfor i in range(n):\n    for j in range(m):\n        if t[i][j]:\n            ans[i][j] = min(a[j], b[i])\nprint('\\n'.join([' '.join(list(map(str, i))) for i in ans]))"
 ],
 "2127": [
  "from collections import defaultdict\n\nh, w = 0, 0\nbills = defaultdict(int)\n\nfor _ in range(int(input())):\n    q, x, y = input().split()\n    x, y = int(x), int(y)\n    if q == '+':\n        if x <= h and y <= w:\n            print('YES')\n        elif y <= h and x <= w:\n            print('YES')\n        else:\n            print('NO')\n        bills[x, y] += 1\n    else:\n        if all(x >= max(bill[0], bill[1]) or y >= min(bill[0], bill[1]) for bill in bills):\n            print('YES')\n        else:\n            print('NO')\n        h, w = x, y"
 ],
 "2128": [
  "MOD = 998244353\n\nn = int(input())\np = list(map(int, input().split()))\n\ndp = [0] * (n+1)\ndp[0] = 1\n\nfor i in range(1, n+1):\n    p_i = p[i-1] / 100\n    for j in range(i, 0, -1):\n        dp[j] = (dp[j] * (1 - p_i) + dp[j-1] * p_i) % MOD\n    dp[0] = dp[0] * (1 - p_i) % MOD\n\nans = sum(dp[i] for i in range(n+1))\nans %= MOD\n\ninv_q = pow(2, MOD-2, MOD)\nprint((ans * inv_q) % MOD)"
 ],
 "2129": [
  "from collections import defaultdict\ndef dfs(s,adj,vis,dirc,instk,stk,N):\n    vis[s]=1\n    instk[s]=1\n    stk.append(s)\n    for i in adj[s]:\n        if(vis[i]==0):\n            dirc[s]=i\n            dfs(i,adj,vis,dirc,instk,stk,N)\n        elif(instk[i]==1):\n            u=stk[-1]\n            while(u!=i):\n                dirc[u]=dirc[dirc[u]]\n                u=stk.pop()\n            dirc[u]=i\n    instk[s]=0\n    return\n\nfor _ in range(int(input())):\n    n,m=input().split()\n    n=int(n)\n    m=int(m)\n    a=[0]*n\n    b=[0]*n\n    adj=defaultdict(list)\n    for i in range(m):\n        x,y=input().split()\n        x=int(x)\n        y=int(y)\n        a[x-1]+=1\n        b[y-1]+=1\n        adj[x-1].append(y-1)\n   \n    vis=[0]*n\n    dirc=[0]*n\n    instk=[0]*n\n    stk=[]\n\n    for i in range(n):\n        if(vis[i]==0):\n            dfs(i,adj,vis,dirc,instk,stk,n)\n\n    #calculating answer\n    ans=0\n    for i in range(n):\n        if(dirc[i]!=0):\n            u=i\n            cnt=1\n            while(dirc[u]!=i):\n                cnt+=1\n                u=dirc[u]\n            cnt+=1\n            if(cnt==a[i]+b[i]):\n                ans+=1\n\n    print(ans)\n    #printing oriented roads\n    for i in range(n):\n        if(dirc[i]!=0):\n            print(i+1,dirc[i]+1)"
 ],
 "2130": [
  "from collections import defaultdict\n\nn = int(input())\nb = list(map(int, input().split()))\n\nprefix_xor = [0] * n\nprefix_xor[0] = b[0]\nfor i in range(1, n):\n    prefix_xor[i] = prefix_xor[i-1] ^ b[i]\n\nb_freq = defaultdict(int)\nfor x in b:\n    b_freq[x] += 1\n\nsorted_b = sorted(b_freq.items(), key=lambda x:x[0])\n\ncurr_xor = 0\nfor x, freq in sorted_b:\n    if freq == 1:\n        curr_xor ^= x\n    else:\n        if freq % 2 == 1:\n            if curr_xor == 0:\n                curr_xor ^= x\n                freq -= 1\n            else:\n                print(\"No\")\n                exit()\n        half_freq = freq // 2\n        if (curr_xor ^ x) <= curr_xor:\n            print(\"No\")\n            exit()\n        for i in range(half_freq):\n            idx1 = b.index(curr_xor ^ x)\n            b[idx1], b[idx1+1] = b[idx1+1], b[idx1]\n            idx2 = n - b[::-1].index(x)\n            b[idx2], b[idx2-1] = b[idx2-1], b[idx2]\n            curr_xor ^= x\n        if freq % 2 == 1:\n            curr_xor ^= x\n\nif prefix_xor == [curr_xor ^ b[i] for i in range(n)]:\n    print(\"Yes\")\n    print(*b)\nelse:\n    print(\"No\")"
 ],
 "2131": [
  "from collections import deque\n\nn = int(input())\nadj = [[] for _ in range(n)]\n\nfor i in range(n - 1):\n    u, v = map(int, input().split())\n    u -= 1\n    v -= 1\n    adj[u].append(v)\n    adj[v].append(u)\n\ndeg = [len(adj[i]) for i in range(n)]\nif max(deg) >= 4:\n    print(\"No\")\n    exit()\n\n# bfs to mark the edges belongs to which path\npath = [-1] * (n - 1)\nq = deque()\nfor i in range(n):\n    if deg[i] == 1:\n        q.append(i)\n\nwhile q:\n    u = q.popleft()\n    for v in adj[u]:\n        if deg[v] > 1:\n            path_id = -1\n            for i, w in enumerate(adj[v]):\n                if deg[w] > 1 and path[w] == -1:\n                    path_id = i\n                    break\n\n            if path_id == -1:\n                print(\"No\")\n                exit()\n\n            path[adj[v][path_id]] = path_id\n            deg[v] -= 1\n            deg[adj[v][path_id]] -= 1\n\n            if deg[adj[v][path_id]] == 1:\n                q.append(adj[v][path_id])\n\nprint(\"Yes\")\nprint(max(deg) + 1)\nfor i in range(n - 1):\n    if path[i] == -1:\n        print(i % n + 1, (i + n // 2) % n + 1)\n    else:\n        u = i % n + 1\n        while deg[u - 1] == 2:\n            for v in adj[u - 1]:\n                if path[v - 1] == path[u - 1]:\n                    u = v\n                    break\n        v = u\n        while deg[v - 1] == 2:\n            for w in adj[v - 1]:\n                if path[w - 1] == path[v - 1] and w != u:\n                    v = w\n                    break\n        print(u, v)\n"
 ],
 "2132": [
  "n = int(input())\nspeed = [0]*(n+1)\novertake = [True]*(n+1)\nspeedLimit = [0]*(n+1)\n\nfor i in range(1,n+1):\n    event = list(map(int,input().split()))\n    \n    if event[0] == 1:\n        speed[i] = event[1]\n        speedLimit[i] = speedLimit[i-1]\n        \n    elif event[0] == 2:\n        overtake[i] = (overtake[i-1] and (speed[i] > speed[i-1]))\n        speedLimit[i] = speedLimit[i-1]\n        \n    elif event[0] == 3:\n        speedLimit[i] = event[1]\n        speed[i] = min(speed[i-1],speedLimit[i])\n        \n    elif event[0] == 4:\n        overtake[i] = overtake[i-1]\n        speedLimit[i] = speedLimit[i-1]\n        \n    elif event[0] == 5:\n        speedLimit[i] = speedLimit[i-1]\n        speed[i] = speed[i-1]\n        overtake[i] = True\n        \n    else:\n        speed[i] = speed[i-1]\n        overtake[i] = overtake[i-1]\n        if not overtake[i]:\n            if overtake[j]==1:\n                speedLimit[j]=speed[j-1]\n            j = i - 1\n            while j>=1 and overtake[j]==0:\n                j-=1\n            if overtake[j]:\n                speedLimit[j] = speed[j-1]\n                \nprint(sum([speed[i]>speedLimit[i] and overtake[i]==False for i in range(1,n+1)])) "
 ],
 "2133": [
  "import sys\n\nsys.setrecursionlimit(2*10**5+10)\n\nn = int(input())\ncolors = list(map(int, input().split()))\n\ntree = [[] for _ in range(n)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    tree[u-1].append(v-1)\n    tree[v-1].append(u-1)\n\nans = 0\n\ndef dfs(v, p, black_path, white_path):\n    global ans\n    if colors[v]:\n        black_path += 1\n        white_path = 0\n    else:\n        white_path += 1\n        black_path = 0\n\n    if black_path > white_path:\n        colors[v] = 1\n    else:\n        colors[v] = 0\n\n    for u in tree[v]:\n        if u == p:\n            continue\n        dfs(u, v, black_path, white_path)\n\ndfs(0, -1, 0, 0)\nans = sum(colors)\nans = min(ans, n-ans)\n\nprint(ans)"
 ],
 "2134": [
  "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nmax_sum = 0\n\nfor i in range(n):\n    for j in range(i+1, n):\n        if (a[i] | a[j]) == max(a[i], a[j]):\n            max_sum = max(max_sum, b[i]+b[j])\n\nprint(max_sum)"
 ],
 "2135": [
  "h, w = map(int, input().split())\ngrid = [[0]*w for i in range(h)]\nfor i in range(h):\n    line = input()\n    for j in range(w):\n        if line[j] == '.':\n            grid[i][j] = 1\n            \npre = [[0]*w for i in range(h)]\nsuf = [[0]*w for i in range(h)]\nfor i in range(h):\n    for j in range(w):\n        if grid[i][j]:\n            if j > 0:\n                pre[i][j] = pre[i][j-1]\n            pre[i][j] += 1\n            \n    for j in range(w-1, -1, -1):\n        if grid[i][j]:\n            if j < w-1:\n                suf[i][j] = suf[i][j+1]\n            suf[i][j] += 1\n            \nfor j in range(w):\n    for i in range(h):\n        if grid[i][j]:\n            if i > 0:\n                pre[i][j] = pre[i-1][j]\n            pre[i][j] += 1\n            \n        for i in range(h-1, -1, -1):\n            if grid[i][j]:\n                if i < h-1:\n                    suf[i][j] = suf[i+1][j]\n                suf[i][j] += 1\n                \nq = int(input())\nfor i in range(q):\n    r1, c1, r2, c2 = map(int, input().split())\n    r1, c1, r2, c2 = r1-1, c1-1, r2-1, c2-1\n    ans = 0\n    for i in range(r1, r2):\n        ans += max(0, min(pre[i][c2], c2-c1) - min(pre[i][c1], c2-c1-1))\n    for j in range(c1, c2):\n        ans += max(0, min(suf[r2-1][j], r2-r1) - min(suf[r1][j], r2-r1-1))\n    print(ans)"
 ],
 "2136": [
  "t = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    grid = [input() for _ in range(n)]\n    # check if there is a path with digit 0\n    seen = [[False] * n for _ in range(n)]\n    stack = [(0,0)]\n    while stack:\n        i, j = stack.pop()\n        if i < 0 or i >= n or j < 0 or j >= n or seen[i][j] or grid[i][j] == '1':\n            continue\n        seen[i][j] = True\n        stack.append((i+1, j))\n        stack.append((i-1, j))\n        stack.append((i, j+1))\n        stack.append((i, j-1))\n    if not seen[n-1][n-1]:\n        # invert a maximum of two cells\n        ans = []\n        for i in range(n):\n            for j in range(n):\n                if i == j == 0 or i == j == n-1:\n                    continue\n                # try inverting this cell\n                orig = grid[i][j]\n                grid[i] = grid[i][:j] + str(1-int(grid[i][j])) + grid[i][j+1:]\n                seen = [[False] * n for _ in range(n)]\n                stack = [(0,0)]\n                while stack:\n                    i, j = stack.pop()\n                    if i < 0 or i >= n or j < 0 or j >= n or seen[i][j] or (grid[i][j] == orig and (i, j) != (0, 0) and (i, j) != (n-1, n-1)):\n                        continue\n                    seen[i][j] = True\n                    stack.append((i+1, j))\n                    stack.append((i-1, j))\n                    stack.append((i, j+1))\n                    stack.append((i, j-1))\n                if not seen[n-1][n-1]:\n                    ans.append((i+1, j+1))\n                    if len(ans) == 2:\n                        break\n                else:\n                    grid[i] = grid[i][:j] + str(1-int(grid[i][j])) + grid[i][j+1:]\n            else:\n                continue\n            break\n        print(len(ans))\n        for a in ans:\n            print(a[0], a[1])\n    else:\n        print(0)"
 ],
 "2137": [
  "n, a, b = map(int, input().split())\n\nfreq = {}\nfor i in range(n):\n    x, vx, vy = map(int, input().split())\n    t = (x - b) / (a - vx / vy) if vy != 0 else x\n    if t not in freq:\n        freq[t] = 0\n    freq[t] += 1\n\nans = 0\nfor key in freq:\n    ans += (freq[key] * (freq[key]-1)) // 2\n\nprint(ans)"
 ],
 "2138": [
  "n = int(input())\ndegrees = list(map(int, input().split()))\n\ntotal_vertices = degrees[-1] + 1\nedges = []\ncurr_degree = degrees.pop()\n\nfor i in range(total_vertices):\n    for j in range(i+1, total_vertices):\n        if len(degrees) > 0 and curr_degree == 0:\n            curr_degree = degrees.pop()\n        if curr_degree > 0:\n            edges.append((i+1, j+1))\n            curr_degree -= 1\n            degree_j = len([e for e in edges if j+1 in e])\n            if degree_j >= curr_degree:\n                curr_degree -= 1\n        if len(degrees) == 0 and curr_degree == 0:\n            break\n    if len(degrees) == 0 and curr_degree == 0:\n        break\n\nprint(len(edges))\nfor e in edges:\n    print(e[0], e[1])"
 ],
 "2139": [
  "s = input()\ncount = 0\nfor i in range(len(s)-3):\n    if s[i:i+4] == \"bear\":\n        count += (i+1)*(len(s)-i-3)\nprint(count)"
 ],
 "2140": [
  "s = input()\nm = int(input())\na = list(map(int, input().split()))\n\nfor i in range(m):\n    start = a[i]-1\n    end = len(s) - a[i]\n    s = s[:start] + s[start:len(s)-end][::-1] + s[len(s)-end:]\n\nprint(s)"
 ],
 "2141": [
  "n = int(input())\nfor i in range(n):\n    for j in range(n):\n        if (i+j)%2 == 0:\n            print(\"B\", end='')\n        else:\n            print(\"W\", end='')\n    print()"
 ],
 "2142": [
  "for _ in range(int(input())):\n    n,m=map(int,input().split())\n    a=set(map(int,input().split()))\n    b=set(map(int,input().split()))\n    common=list(a&b)\n    if common:\n        print(\"YES\")\n        print(\"1\",common[0])\n    else:\n        print(\"NO\")"
 ],
 "2143": [
  "n = int(input())\nsweets = list(map(int, input().split()))\ncount = 0\nsweets.sort()\nfor i in range(0, n-1, 2):\n    if sweets[i] + sweets[i+1] == sweets[i+1] + sweets[i+2]:\n        count += 1\nprint(count)"
 ],
 "2144": [
  "import math\n\ndef count_x(a, m):\n    gcd_am = math.gcd(a, m)\n    m_prime = m//gcd_am\n    count = m_prime\n    for i in range(2, int(gcd_am**0.5) + 1):\n        if gcd_am % i == 0:\n            while gcd_am % i == 0:\n                gcd_am //= i\n            count *= (m_prime//i) - (m_prime//(i+1))\n    if gcd_am > 1:\n        count *= (m_prime//gcd_am) - (m_prime//(gcd_am+1))\n    return count\n\nt = int(input())\nfor i in range(t):\n    a, m = map(int, input().split())\n    print(count_x(a, m))"
 ],
 "2145": [
  "for _ in range(int(input())):\n    x,y=map(int,input().split())\n    while x<y:\n        if y%2:y-=1\n        else:\n            if y>x*3//2:y=x*3//2\n            else:break\n    print('YES' if x==y else 'NO')"
 ],
 "2146": [
  "n=int(input())\na=list(map(int,input().split()))\n\ndef dfs(v):\n    if a[v-1]==v:\n        d[v-1]=0\n        return\n    if used[v-1]:\n        cycle=[v]\n        u=p[v-1]\n        while u!=v:\n            cycle.append(u)\n            u=p[u-1]\n        cycle.append(v)\n        for i in cycle:\n            d[i-1]=cnt\n        return\n    used[v-1]=True\n    dfs(a[v-1])\n    d[v-1]=d[a[v-1]-1]+1\n\nused=[False]*n\nd=[0]*n\np=[i for i in range(1,n+1)]\nfor i in range(1,n+1):\n    dfs(i)\n    cnt=d[i-1]\n\nprint(' '.join([str(x) for x in d]))"
 ],
 "2147": [
  "from collections import deque\nn=int(input())\nto = [[] for i in range(n+1)]\nfroms = [0]*(4*n+1)\ncnt = [0]*(n+1)\nfor i in range(1,4*n+1):\n    a,b,c=map(int,input().split())\n    idx = -1\n    if cnt[a] == 0:\n        idx = i\n    else:\n        for j in to[a]:\n            if froms[j] == 0:\n                idx = j\n                froms[j] = i\n                break\n    if idx == -1:\n        print(\"NO\")\n        exit()\n    cnt[a]+=1\n    cnt[b]+=1\n    cnt[c]+=1\n    to[b].append(idx)\n    to[c].append(idx)\nans = deque()\nfor i in range(1,n+1):\n    if cnt[i] != 2:\n        print(\"NO\")\n        exit()\nq = deque([i for i in range(1,n+1) if cnt[i]==2])                            \nwhile q:\n    nod = q.popleft()\n    for idx in to[nod]:\n        if froms[idx] != 0:\n            continue\n        a,b,c = map(int,input().split())\n        if cnt[a] != 2:\n            print(\"NO\")\n            exit()\n        if cnt[b] == 9 or cnt[c] == 9:\n            continue\n        cnt[a]-=1\n        cnt[b]+=1\n        cnt[c]+=1\n        froms[idx] = a,b,c\n        ans.append(idx)\n        if cnt[b] == 2:\n            q.append(b)\n        if cnt[c] == 2:\n            q.append(c)\nif len(ans) != 4*n:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(\" \".join([str(x) for x in ans]))"
 ],
 "2148": [
  "import math\n\nn, r = map(int, input().split())\nx = list(map(int, input().split()))\n\ny = [10**100] * n\n\nfor i in range(n):\n    for j in range(i):\n        if abs(x[i] - x[j]) <= 2 * r:\n            d = math.sqrt((2 * r) ** 2 - (x[i] - x[j]) ** 2)\n            y[i] = max(y[i], y[j] + d)\n    y[i] = max(y[i], r)\n    \nprint(*y)"
 ],
 "2149": [
  "n,k=map(int,input().split())\nans=list(map(int,input().split()))\nmod=998244353\ndp1=[0 for i in range(n+1)]\ndp2=[0 for i in range(n+1)]\nansuit=1\nfor i in range(n):\n    cnt=0\n    for j in range(i,n):\n        cnt+=(ans[i]==ans[j])\n        dp1[cnt]+=1\n    for j in range(n):\n        cnt+=(ans[i]==ans[j])\n        dp2[cnt]+=1\n    ansuit*=k\nres=0\ntemp=1\nfor i in range(n-1):\n    temp=(temp*k)%mod\nfor i in range(n):\n    for j in range(n):\n        if i==j:\n            continue\n        if (ans[i]!=ans[(j-1+n)%n]):\n            res=(res+temp-dp1[0]-dp2[0]+dp1[1]+dp2[1])%mod\n        else:\n            res=(res+temp-dp1[0]-dp2[0]+dp1[0]+dp2[0])%mod\nprint(ansuit-res)"
 ],
 "2150": [
  "n = int(input())\nb = list(map(int, input().split()))\na = [b[0]]\nfor i in range(1, n):\n    a.append(max(b[i]+a[i-1], a[i-1]))\nfor i in range(n):\n    a[i] -= (i>0) * a[i-1]\nprint(*a)"
 ],
 "2151": [
  "q = int(input())\nfor _ in range(q):\n    n = int(input())\n    s = input()\n    segments = []\n    prev = -1\n    for i in range(n):\n        num = int(s[i])\n        if prev == -1 or num <= prev:\n            segments.append(s[i])\n            prev = num\n        else:\n            segments[-1] += s[i]\n            prev = num\n    if len(segments) < 2:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(len(segments))\n        for seg in segments:\n            print(seg, end=\" \")\n        print()"
 ],
 "2152": [
  "n = int(input())\nmeat = []\ncost = []\nfor i in range(n):\n    a, p = map(int, input().split())\n    meat.append(a)\n    cost.append(p)\n\nmin_cost = cost[0]\ntotal_cost = 0\n\nfor i in range(n):\n    if cost[i] < min_cost:\n        min_cost = cost[i]\n    total_cost += min_cost * meat[i]\n\nprint(total_cost)"
 ],
 "2153": [
  "n = int(input())\nh = list(map(int, input().split()))\n\ndp = [float('inf')] * n\ndp[0] = 0\n\nfor i in range(1, n):\n    for j in range(i):\n        if h[j] < h[i]:\n            dp[i] = min(dp[i], dp[j] + (i - j >= 2))\n        else:\n            dp[i] = min(dp[i], dp[j] + 1)\n\nprint(dp[-1])"
 ],
 "2154": [
  "n = int(input())\nprices = list(map(int, input().split()))\n\nprofit = 0\nowned_shares = 0\n\nfor i in range(n-1):\n    if prices[i] < prices[i+1] and not owned_shares:\n        # buy a share if the price is going up and we don't own any shares\n        owned_shares += 1\n        profit -= prices[i]\n    elif prices[i] > prices[i+1] and owned_shares:\n        # sell a share if the price is going down and we own at least one share\n        owned_shares -= 1\n        profit += prices[i]\n        \n# sell any remaining shares at the end\nif owned_shares:\n    profit += prices[-1]\n\nprint(profit)"
 ],
 "2155": [
  "t = int(input())\ncounts = {}\nfor i in range(t):\n    x = int(input())\n    if x in counts:\n        counts[x] += 1\n    else:\n        counts[x] = 1\n\nzero_count = counts.get(0, 0)\nif zero_count != 1:\n    print(\"-1\")\nelse:\n    n = int((t - 1) ** 0.5) + 1\n    m = (t + n - 1) // n\n    zero_pos = list(counts.keys())[list(counts.values()).index(0)]\n    zero_row = (zero_pos - 1) // m + 1\n    zero_col = (zero_pos - 1) % m + 1\n\n    matrix = [[0] * m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            num = abs(i - (zero_row - 1)) + abs(j - (zero_col - 1))\n            if num in counts:\n                if counts[num] > 0:\n                    matrix[i][j] = num\n                    counts[num] -= 1\n                else:\n                    print(\"-1\")\n                    exit()\n\n    for i in range(n):\n        if sum(matrix[i]) != t:\n            print(\"-1\")\n            exit()\n\n    for j in range(m):\n        if sum(matrix[i][j] for i in range(n)) != t:\n            print(\"-1\")\n            exit()\n\n    print(\"{} {}\".format(n, m))\n    print(\"{} {}\".format(zero_row, zero_col))"
 ],
 "2156": [
  "n=int(input())\ns=list(map(int,input().split()))\nq=int(input())\nfor i in range(q):\n    l,r=map(int,input().split())\n    k=0;c=0\n    while (1<<(k+1))<=(r-l+1): k+=1\n    while k>=0:\n        x,y=l//(1<<k),(r+1)//(1<<k)\n        if y>x: c+=sum([(s[l+x*2]-s[l+x*2+1]>=0 and s[l+x*2]+s[l+x*2+1]>=10) for x in range(x,y)])\n        l//=2;r//=2;k-=1\n    print(c)"
 ],
 "2157": [
  "n, q = map(int, input().split())\na = list(map(int, input().split()))\n\nfreq = [0]*(2*10**5+1)  # frequency array to count occurrences\nfor i in a:\n    freq[i] += 1\n\nmax_sum = 0\nfreq.sort(reverse=True)  # sort the frequency array in descending order\n\nfor i in range(1, q+1):\n    l, r = map(int, input().split())\n    interval_len = r - l + 1\n    if interval_len <= len(freq):\n        sum_ = sum(freq[:interval_len]) * interval_len\n        max_sum += sum_\n\nprint(max_sum)"
 ],
 "2158": [
  "n = int(input())\nadj_list = [[] for i in range(n)]\nfor i in range(n-1):\n    u, v, c = map(int, input().split())\n    adj_list[u].append((v, c))\n    adj_list[v].append((u, c))\n\ndef dfs(node, prev, max_cost):\n    global ans\n    for nei, cost in adj_list[node]:\n        if nei != prev:\n            dfs(nei, node, max(max_cost, cost))\n    ans += max_cost\n\nans = 0\ndfs(0, -1, 0)\nprint(ans)"
 ],
 "2159": [
  "n = int(input())\ncolors = list(map(int, input().split()))\n\nfreq = [0] * (n+1)\nfor i in range(n):\n    counts = [0] * (n+1)\n    max_count, max_color = 0, 0\n    for j in range(i, n):\n        counts[colors[j]] += 1\n        if counts[colors[j]] > max_count or (counts[colors[j]] == max_count and colors[j] < max_color):\n            max_count, max_color = counts[colors[j]], colors[j]\n        freq[max_color] += 1\n\nprint(\" \".join(str(freq[i]) for i in range(1, n+1)))"
 ],
 "2160": [
  "from collections import defaultdict \n\nn, k = map(int, input().split())\nqueries = list(map(int, input().split()))\n\nadjacency_list = defaultdict(list)\nfor i in range(1, n):\n    adjacency_list[i].append(i+1)\n    adjacency_list[i+1].append(i)\n\nvisited = [False] * (n+1)\n\npossible_positions = set(range(1, n+1))\ncount = 0\n\nfor q in queries:\n    possible_positions -= set(adjacency_list[q])\n    visited[q] = True\n\nif len(possible_positions) == 0:\n    print(0)\nelse:\n    for pos in possible_positions:\n        if not visited[pos]:\n            count += 1\n            visited[pos] = True\n            for neighbor in adjacency_list[pos]:\n                visited[neighbor] = True\n\n    print(count)"
 ],
 "2161": [
  "n=int(input())\nphonebook={}\nfor i in range(n):\n    s=input().split()\n    name=s[0]\n    count=int(s[1])\n    numbers=set()\n    for j in range(count):\n        number=s[2+j]\n        for k in range(1,len(number)+1):\n            prefix=number[k-1:]\n            if prefix in phonebook:\n                for friend in phonebook[prefix]:\n                    if friend!=name:\n                        numbers.discard(friend)\n            numbers.add(number)\n    for number in numbers:\n        prefix=number\n        while len(prefix)>0:\n            if prefix in phonebook:\n                phonebook[prefix].add(name)\n                break\n            prefix=prefix[1:]\n        else:\n            phonebook[number]={name}\n            \nprint(len(phonebook))\nfor number in sorted(phonebook.keys()):\n    friends=phonebook[number]\n    print(len(friends),number,end=' ')\n    for name in sorted(friends):\n        print(name,end=' ')\n    print()"
 ],
 "2162": [
  "k1, k2, k3 = map(int, input().split())\na1 = list(map(int, input().split()))\na2 = list(map(int, input().split()))\na3 = list(map(int, input().split()))\n\nproblem_set = set(range(1, k1+k2+k3+1))\nintersection = set(a1) & set(a2) & set(a3)\na1, a2, a3 = set(a1), set(a2), set(a3)\n\nmoves = 0\n\n# move problems from a1 to a2\nfor problem in intersection:\n    if problem in a1 and problem in a2:\n        a1.remove(problem)\n        a2.add(problem)\n\n# move problems from a3 to a2\nfor problem in intersection:\n    if problem in a3 and problem in a2:\n        a3.remove(problem)\n        a2.add(problem)\n\n# move problems from a1 to a3\nfor problem in intersection:\n    if problem in a1 and problem in a3:\n        a1.remove(problem)\n        a3.add(problem)\n\n# find prefix and suffix of the problemset\nprefix = list(problem_set - a3 - a2)[:len(a1)]\nsuffix = list(problem_set - a1 - a2)[-len(a3):]\n\n# move problems from prefix to a1\nfor problem in prefix:\n    if problem in a2:\n        a2.remove(problem)\n        a1.add(problem)\n        moves += 1\n\n# move problems from suffix to a3\nfor problem in suffix:\n    if problem in a2:\n        a2.remove(problem)\n        a3.add(problem)\n        moves += 1\n\nprint(moves)"
 ],
 "2163": [
  "n, m = map(int, input().split())\nMOD = 10**9 + 7\n\nf = pow(2, n, MOD) - 1\npower = 1\nfor i in range(n):\n    power *= m - i\n    power %= MOD\n    f += pow(2, n-i-1, MOD) * power % MOD\nprint(f % MOD)"
 ],
 "2164": [
  "t = int(input())\nfor _ in range(t):\n    s = input().strip()\n    n = len(s)\n    rev = s[::-1]\n    for i in range(n):\n        if s[:n-i] == rev[i:]:\n            print(s[:n-i] + s[n-i:][::-1])\n            break"
 ],
 "2165": [
  "from bisect import bisect_left\n\nn, T = map(int, input().split())\na = list(map(int, input().split()))\nt = list(map(int, input().split()))\n\ndef possible(rate, T=T, n=n, a=a, t=t):\n    temp = 0\n    for i in range(n):\n        temp += min(rate, a[i]) * t[i]\n        if temp >= T * rate:\n            return True\n    return False\n\ndef max_flow(n=n, a=a, t=t):\n    l, r, ans = 0, max(a), 0\n    while l <= r:\n        mid = (l + r) / 2\n        if possible(mid):\n            ans = mid\n            l = mid + 10 ** (-9)\n        else:\n            r = mid - 10 ** (-9)\n    return ans\n\nprint(f\"{max_flow():.10f}\")"
 ],
 "2166": [
  "n = int(input())\na = list(map(int,input().split()))\nMOD = 10**9 + 7\ncount = 0\navail = [True] * (n+1)\nfor i in range(n):\n  if a[i] != -1:\n    avail[a[i]] = False\nfor i in range(1,n+1):\n  if avail[i]:\n    count += 1\nfor i in range(n):\n  if a[i] == -1:\n    a[i] = count\n    count -= 1\n  else:\n    if a[a[i]-1] == -1 and a[i] != -1:\n      a[a[i]-1] = a[i]\ncnt = 1\nfor i in range(n):\n  if a[i] == -1:\n    cnt = (cnt * count) % MOD\n    count -= 1\nfor i in range(n):\n  if a[i] == i+1:\n    cnt = 0\nprint(cnt)"
 ],
 "2167": [
  "n = int(input())\na = list(map(int, input().split()))\n\nsum_a = sum(a)\nmax_a = max(a)\n\nif sum_a % n == 0 and sum_a // n == max_a:\n    print(n)\nelse:\n    print(n-1)"
 ],
 "2168": [
  "n = int(input())\ncompanies = []\nincreases = 0\n\nfor i in range(n):\n    company = list(map(int, input().split()))\n    companies.append(company[1:])\n    max_salary = max(company[1:])\n    salary_diff = max_salary - min(company[1:])\n    if i == 0:\n        max_salary_diff = salary_diff\n    elif salary_diff != max_salary_diff:\n        increase = max_salary_diff - salary_diff\n        max_salary = max(company[1:])\n        num_employees = company[0]\n        extra_salary = (increase + num_employees - 1) // num_employees\n        increases += extra_salary * num_employees\n        companies[-1] = [salary + extra_salary for salary in companies[-1]]\n\nmerged_companies = sorted([salary for company in companies for salary in company])\nnum_employees = sum(len(company) for company in companies)\nmedian_index = num_employees // 2\nmedian_salary = merged_companies[median_index]\ntotal_increase = sum(max(0, median_salary - salary) for salary in merged_companies)\nprint(total_increase + increases)"
 ],
 "2169": [
  "h, w, d = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(h)]\nq = int(input())\nl_r = [list(map(int, input().split())) for _ in range(q)]\nindexes = {}\nfor i in range(h):\n    for j in range(w):\n        indexes[a[i][j]] = (i, j)\nprefix_sum = [0] * (h * w + 1)\nfor i in range(d):\n    j = i\n    while j + d <= h * w:\n        cur = j + d\n        prefix_sum[cur] = prefix_sum[cur - d] + abs(indexes[cur][0] - indexes[cur - d][0]) + abs(indexes[cur][1] - indexes[cur - d][1])\n        j += d\nfor l, r in l_r:\n    print(prefix_sum[r] - prefix_sum[l])"
 ],
 "2170": [
  "MOD = 10**9 + 7\nn, m = map(int, input().split())\nfact = [1]\nfor i in range(1, m + 1):\n    fact.append(fact[-1] * i % MOD)\ninv_fact = [1] * (m + 1)\ninv_fact[-1] = pow(fact[-1], MOD - 2, MOD)\nfor i in range(m, 0, -1):\n    inv_fact[i - 1] = inv_fact[i] * i % MOD\ndef nCk(n, k):\n    return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD\nans = 0\nfor i in range(n + 1):\n    coeff = (-1) ** i * nCk(n, i) * pow(m - i, n, MOD)\n    ans = (ans + coeff) % MOD\nprint(ans)"
 ],
 "2171": [
  "a = int(input())\nif a % 6 == 0 or a % 6 == 1 or a % 6 == 3:\n    print(\"yes\")\nelse:\n    print(\"no\")"
 ],
 "2172": [
  "n, m = map(int, input().split())\ndict1, dict2 = {}, {}\n\nfor i in range(m):\n    a, b = input().split()\n    if len(a) <= len(b):\n        dict1[a] = a\n        dict2[b] = a\n    else:\n        dict1[a] = b\n        dict2[b] = b\n\nwords = input().split()\nresult = ''\nfor i in words:\n    result += (dict1[i] + ' ')\nprint(result[:-1]) # remove the last space character"
 ],
 "2173": [
  "n = int(input())\na = list(map(int, input().split()))\ntotal = sum(a)\na.sort()\n\nif a[-1] > total - a[-1]:\n    print(2 * a[-1] - total, end=' ')\nelse:\n    print(a[-1], end=' ')\n\nfor i in range(1, n-1):\n    total -= a[i-1]\n    if a[-1] > total - a[-1]:\n        print(2 * a[-1] - total, end=' ')\n    else:\n        print(a[-1], end=' ')\n\nif n > 1:\n    print(total)"
 ],
 "2174": [
  "n = int(input())\na = list(map(int, input().split()))\na.sort()\nans = 0\nfor i in range(n):\n    ans += abs(a[i] - (i+1))\nprint(ans)"
 ],
 "2175": [
  "n = int(input())\nvolumes = list(map(int, input().split()))\nm = int(input())\n\noverflow = [0] * n\nfilled = [0] * n\nfor _ in range(m):\n    query = list(map(int, input().split()))\n    if query[0] == 1:\n        p = query[1] - 1\n        x = query[2]\n        while p < n and x > 0:\n            free_space = volumes[p] - filled[p] - overflow[p]\n            if free_space >= x:\n                filled[p] += x\n                break\n            filled[p] += free_space\n            x -= free_space\n            p += 1\n    else:\n        k = query[1] - 1\n        print(filled[k] + overflow[k])"
 ],
 "2176": [
  "mod = 998244353\nn = int(input())\na = [0]*n\nb = [0]*n\nfor i in range(n):\n    a[i], b[i] = map(int, input().split())\n\nfa = [0]*(n+1)\nfb = [0]*(n+1)\nfor i in range(n):\n    fa[a[i]] += 1\n    fb[b[i]] += 1\n\nfac = [1]*(n+1)\nfor i in range(1, n+1):\n    fac[i] = i*fac[i-1] % mod\n\ninv = [1]*(n+1)\ninvf = [1]*(n+1)\nfor i in range(2, n+1):\n    inv[i] = (mod - (mod // i) * inv[mod % i] % mod) % mod\n    invf[i] = inv[i]*invf[i-1] % mod\n\ndef C(n, m):\n    if n < m or m < 0:\n        return 0\n    return fac[n]*invf[m] % mod*invf[n-m] % mod\n\nans = n*fac[n-1] % mod\nfor i in fa:\n    ans = ans*inv[i] % mod\nfor i in fb:\n    ans = ans*inv[i] % mod\n\ncnta = cntb = 1\nfor i in range(1, n):\n    if a[i] == a[i-1]:\n        cnta += 1\n    else:\n        ans = (ans*fac[cnta]*invf[cnta-1]) % mod\n        cnta = 1\n    if b[i] == b[i-1]:\n        cntb += 1\n    else:\n        ans = (ans*fac[cntb]*invf[cntb-1]) % mod\n        cntb = 1\nans = (ans*fac[cnta]*invf[cnta-1]*fac[cntb]*invf[cntb-1]) % mod\n\nprint(ans)"
 ],
 "2177": [
  "t = int(input())\nfor _ in range(t):\n    A, B = map(int, input().split())\n    ans = 0\n    for i in range(1, 10):\n        for j in range(1, 10):\n            num = int(str(i) + str(j))\n            if num > A or num > B:\n                continue\n            if i * j + i + j == num:\n                ans += 1\n    for i in range(1, 10):\n        num = int(str(i) * 3)\n        if num > A or num > B:\n            continue\n        if i * i + i + i == num:\n            ans += 1\n    print(ans)"
 ],
 "2178": [
  "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nbooks_taken = set()\nresult = [0] * n\n\nfor i in range(n):\n    if b[i] not in books_taken:\n        books_taken.add(b[i])\n        for j in range(i, n):\n            if a[j] == b[i]:\n                result[i] = j - i + 1\n                for k in range(i, j+1):\n                    books_taken.add(a[k])\n                break\n\nprint(\" \".join(str(x) for x in result))"
 ],
 "2179": [
  "import heapq\n\nn, m = map(int, input().split())\n\ngraph = [[] for _ in range(n+1)]\nfor i in range(m):\n    u, v, w = map(int, input().split())\n    graph[u].append((v, w))\n    graph[v].append((u, w))\n\nstart = int(input())\n\ndist = [float('inf')] * (n+1)\ndist[start] = 0\n\n# Dijkstra's algorithm\npq = [(0, start)] # priority queue\nvisited = set()\n\nwhile pq:\n    d, u = heapq.heappop(pq)\n    if u in visited:\n        continue\n    visited.add(u)\n    for v, w in graph[u]:\n        if dist[v] > dist[u] + w:\n            dist[v] = dist[u] + w\n            heapq.heappush(pq, (dist[v], v))\n            # update parent of v\n            parent[v] = u\n\n# finding the edges of the shortest-path tree\nedges = []\nfor v in range(1, n+1):\n    if v == start:\n        continue\n    for u, w in graph[v]:\n        if dist[v] == dist[u] + w:\n            edges.append((u, v))\n\n# printing the result\nprint(sum([w for _, w in edges]))\nprint(\" \".join([str(i+1) for i in range(len(edges))]))"
 ],
 "2180": [
  "n = int(input())\nif n == 1:\n    print(1)\n    print('C')\nelif n == 2:\n    print(2)\n    print('C.')\n    print('.C')\nelse:\n    print((n//2)**2 + (n//2+n%2)*(n//2))\n    for i in range(n):\n        for j in range(n):\n            if (i+j)%2 == 0:\n                print('C', end='')\n            else:\n                print('.', end='')\n        print()"
 ],
 "2181": [
  "python\na, d = map(float,input().split())\nn = int(input())\nx,y = 0,0\nfor i in range(1,n+1):\n    dist = i*d%(4*a)\n    if dist<=a:\n        x = dist\n        y = 0\n    elif dist<=2*a:\n        x = a\n        y = dist-a\n    elif dist<=3*a:\n        x = 3*a-dist\n        y = a\n    else:\n        x = 0\n        y = 4*a-dist\n    print(\"{:.10f} {:.10f}\".format(x,y))"
 ],
 "2182": [
  "from collections import Counter\nn=int(input())\nfor i in range(n):\n    y=input().strip()\n    c=Counter(y)\n    if int(y)%3==0 and c['0']>0 and sum(map(int,y))%3==0 and c['1']+c['4']+c['7']==c['2']+c['5']+c['8']:\n        print(\"red\")\n    else:\n        print(\"cyan\")"
 ],
 "2183": [
  "a, b = map(int, input().split())\nif a == 1:\n    if b == 2:\n        print(3)\n    else:\n        print(2)\nelif a == 2:\n    if b == 1:\n        print(3)\n    else:\n        print(1)\nelse:\n    if b == 1:\n        print(2)\n    else:\n        print(1)"
 ],
 "2184": [
  "n = int(input())\ntruth_tables = []\nfor i in range(n):\n    truth_tables.append(list(map(int, input())))\n    \ndef get_expr(val, vars):\n    if len(vars) == 1:\n        if val[vars[0]] == 1:\n            return vars[0]\n        else:\n            return \"!\" + vars[0]\n    else:\n        mid = len(vars) // 2\n        left_val = [x & y for (x, y) in zip(truth_tables[i], [int(j in range(mid)) for j in range(8)])]\n        right_val = [x & y for (x, y) in zip(truth_tables[i], [int(j in range(mid, len(vars))) for j in range(8)])]\n        left_expr = get_expr(left_val, vars[:mid])\n        right_expr = get_expr(right_val, vars[mid:])\n        return \"(\" + left_expr + \"|\" + right_expr + \")\"\n        \nfor i in range(n):\n    vars = [\"x\", \"y\", \"z\"]\n    val = truth_tables[i]\n    print(get_expr(val, vars))"
 ],
 "2185": [
  "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    diff = [b[i]-a[i] for i in range(n)]\n    can_transform = True\n    transform_done = False\n    for i in range(n):\n        if diff[i] < 0:\n            can_transform = False\n            break\n        elif diff[i] > 0:\n            if i == 0 or diff[i-1] == 0:\n                can_transform = False\n                break\n            else:\n                l, r, k = i-1, n-1, diff[i]\n                for j in range(i, n):\n                    if diff[j] == 0 or diff[j] != k:\n                        r = j-1\n                        break\n                    else:\n                        r, k = j, diff[j]\n                transform_done = True\n                break\n    if can_transform and (not transform_done or sum(diff[l:r+1]) == 0):\n        print(\"YES\")\n    else:\n        print(\"NO\")"
 ],
 "2186": [
  "n, m = map(int, input().split())\nmem = set(input().strip() for _ in range(n))\n\nfor _ in range(m):\n    q = input().strip()\n    for i in range(len(q)):\n        for j in 'abc':\n            if q[i] != j:\n                new_s = q[:i] + j + q[i+1:]\n                if new_s in mem:\n                    print(\"YES\")\n                    break\n        else:\n            continue\n        break\n    else:\n        print(\"NO\")"
 ],
 "2187": [
  "t = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans = 0\n    for i in range(1, n):\n        if a[i] < a[i-1]:\n            ans += a[i-1]-a[i]\n            a[i] = a[i-1]\n    print(ans)"
 ],
 "2188": [
  "n = int(input())\npairs = []\nfor i in range(n):\n    a, b = map(int, input().split())\n    pairs.append((a, -b, i+1))\n    \npairs.sort()\ndp = [[-1, -1] for _ in range(n)]\nprev = [-1 for _ in range(n)]\ndp[0][0], dp[0][1] = 1, 1\n\nfor i in range(1, n):\n    for j in range(2):\n        for k in range(i):\n            if pairs[k] < pairs[i]:\n                if dp[k][1-j] + 1 > dp[i][j]:\n                    dp[i][j] = dp[k][1-j] + 1\n                    prev[i] = k\n                    \nans = 0\nv = -1\nind = -1\n\nfor i in range(n):\n    if dp[i][0] > ans:\n        ans = dp[i][0]\n        v = 0\n        ind = i\n    if dp[i][1] > ans:\n        ans = dp[i][1]\n        v = 1\n        ind = i\n        \nprint(ans)\n\nres = []\nwhile ind != -1:\n    res.append(pairs[ind][2])\n    ind = prev[ind]\nprint(*reversed(res))"
 ],
 "2189": [
  "from collections import deque\n\nn, m = map(int, input().split())\ngraph = [[] for _ in range(n+1)]\nin_degree = [0 for _ in range(n+1)]\n\nfor _ in range(m):\n    v, u = map(int, input().split())\n    graph[v].append(u)\n    in_degree[u] += 1\n\nq = deque([i for i in range(1, n+1) if in_degree[i] == 0])\nlabels = []\n\nwhile q:\n    curr = q.popleft()\n    labels.append(curr)\n\n    for neighbor in graph[curr]:\n        in_degree[neighbor] -= 1\n        if in_degree[neighbor] == 0:\n            q.append(neighbor)\n\nprint(*labels)"
 ],
 "2190": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\npair_count = 0\nnum_freq = {}\nfor i in range(n):\n    for j in range(i+1, n):\n        prod = a[i] * a[j]\n        num_freq.clear()\n        x = 2\n        while prod > 1 and x <= prod:\n            while prod % x == 0:\n                prod //= x\n                num_freq[x] = num_freq.get(x, 0) + 1\n            x += 1\n        if prod > 1:\n            num_freq[prod] = num_freq.get(prod, 0) + 1\n        if all(freq % k == 0 for freq in num_freq.values()):\n            pair_count += 1\n\nprint(pair_count)"
 ],
 "2191": [
  "n = int(input())\ns = input()\nprefixW = [0] * n\nprefixL = [0] * n\nfor i in range(n):\n    if s[i] == '0':\n        prefixW[i] = 1 if i == 0 or s[i-1] == '1' else prefixW[i-1] + 1\n        prefixL[i] = 0\n    elif s[i] == '1':\n        prefixL[i] = 1 if i == 0 or s[i-1] == '0' else prefixL[i-1] + 1\n        prefixW[i] = 0\n    else:\n        prefixW[i] = 0 if i == 0 else prefixW[i-1] + 1\n        prefixL[i] = 0 if i == 0 else prefixL[i-1] + 1\nans = [0] * n\nfor x in range(1, n+1):\n    currSets = 0\n    j = x-1\n    while j < n:\n        endSet = False\n        if prefixW[j] >= x:\n            endSet = True\n            j += prefixW[j]\n        elif prefixL[j] >= x:\n            endSet = True\n            j += prefixL[j]\n        else:\n            j = n\n        if endSet:\n            currSets += 1\n            j -= (x-1)\n    ans[x-1] = currSets\nprint(*ans)"
 ],
 "2192": [
  "from numpy import array\nn = int(input())\nW = []\nfor i in range(n):\n    W.append(list(map(int, input().split())))\n\nA = (array(W) + array(W).T)/2\nB = (array(W) - array(W).T)/2\n\nfor i in range(n):\n    print(*A[i])\nfor i in range(n):\n    print(*B[i])"
 ],
 "2193": [
  "import heapq\nn,m = map(int, input().split())\ngraph = [[] for _ in range(n + 1)]\nfor i in range(m):\n    u,v,t = map(int,input().split())\n    graph[u].append((v,t))\ndist = [[10**18]*2 for _ in range(n + 1)]\ndist[1][0] = 0\nheap = []\nheapq.heappush(heap,(0,1,0))\nwhile heap:\n    d,u,pt = heapq.heappop(heap)\n    if d > dist[u][pt]:\n        continue\n    for v,t in graph[u]:\n        if pt == t and dist[v][t] > d + 1:\n            dist[v][t] = d + 1\n            heapq.heappush(heap,(d + 1,v,t))\n        elif pt != t and dist[v][t] > d + 1:\n            dist[v][t] = d + 1\n            heapq.heappush(heap,(d + 1,v,t))\nans = \"\"\nif dist[n][0] == 10**18:\n    print(-1)\nelse:\n    u,t = n,0\n    while u != 1:\n        for v,tt in graph[u]:\n            if tt == t and dist[v][t] == dist[u][t] - 1:\n                ans += str(t)\n                u,t = v,t\n                break\n            elif tt != t and dist[v][tt] == dist[u][t] - 1:\n                ans += str(t)\n                u,t = v,tt\n                break\n    ans += \"0\"\n    print(dist[n][0])\n    print(ans[::-1])"
 ],
 "2194": [
  "n, q = map(int, input().split())\na = list(map(int, input().split()))\n\ndef reverse_range(start, length, arr):\n    end = start + length - 1\n    for i in range(start, start + length // 2):\n        j = end - (i - start)\n        arr[i], arr[j] = arr[j], arr[i]\n\ndef swap_range(start, length, arr):\n    end = start + length - 1\n    mid = start + length // 2 - 1\n    for i in range(start, mid + 1):\n        j = end - (i - start)\n        arr[i], arr[j] = arr[j], arr[i]\n\ndef sum_range(start, end, arr):\n    return sum(arr[start-1:end])\n\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    if query[0] == 1:\n        x, k = query[1:]\n        a[x-1] = k\n    elif query[0] == 2:\n        k = query[1]\n        length = 1 << k\n        for i in range(0, n-length+1, length):\n            reverse_range(i, length, a)\n    elif query[0] == 3:\n        k = query[1]\n        length = 1 << k\n        for i in range(0, n-length+1, 2*length):\n            swap_range(i, length, a)\n    elif query[0] == 4:\n        l, r = query[1:]\n        print(sum_range(l, r, a))"
 ],
 "2195": [
  "for _ in range(int(input())):\n    x, y = map(int, input().split())\n    a, b = map(int, input().split())\n    if a * 2 <= b:\n        print((x + y) * a)\n    else:\n        print(min(x, y) * b + abs(x - y) * a)"
 ],
 "2196": [
  "n = int(input())\na = list(map(int, input().split()))\n\nadded = 0\nv = 0\nfor i in range(n):\n    if 2**v - 1 < 2**(a[i]+1) - 1:\n        added += a[i]-v+1\n        v = a[i]+1\nif 2**v - 1 < 2**(a[n-1]+2) - 1:\n    added += (2**(a[n-1]+2) - 1) - (2**v - 1)\nprint(added)"
 ],
 "2197": [
  "from itertools import accumulate\n\nn, x = map(int, input().split())\nP = list(map(float, input().split()))\n\n# Pre-calculate probability of reaching each xor sum\nprob = {0: 1.0}\nfor _ in range(n):\n    new_prob = {}\n    for i in range(x+1):\n        if P[i] == 0:\n            continue\n        for xor_sum, p in prob.items():\n            new_xor_sum = xor_sum ^ i\n            new_prob[new_xor_sum] = new_prob.get(new_xor_sum, 0.0) + P[i] * p\n    prob = new_prob\n\n# Calculate probability of first player winning\nprefix_xor = list(accumulate(P, lambda x, y: x ^ y))\nwin_prob = 0.0\nfor xor_sum, p in prob.items():\n    if prefix_xor[xor_sum] == 0:\n        win_prob += p\nprint(\"{:.8f}\".format(win_prob))"
 ],
 "2198": [
  "n, m = map(int, input().split())\ns = list(input())\ndp = [0] * (n + 1)\n\nfor i in range(1, n):\n    if s[i] == \".\" and s[i-1] == \".\":\n        dp[i+1] = dp[i-1] + 1\n    else:\n        dp[i+1] = dp[i]\n\nfor j in range(m):\n    x, c = input().split()\n    x = int(x)\n    if c == \".\":\n        if s[x-1] != \".\" and x > 1 and s[x-2] == \".\":\n            dp[x] += 1\n        if s[x-1] != \".\" and x < n and s[x] == \".\":\n            dp[x+1] += 1\n    else:\n        if x > 1 and s[x-2] == \".\" and s[x-1] == \".\":\n            dp[x] -= 1\n        if x < n and s[x] == \".\" and s[x-1] == \".\":\n            dp[x+1] -= 1\n    s[x-1] = c\n    print(dp[-1])"
 ],
 "2199": [
  "import heapq\nfrom math import isclose\n\nq = int(input())\narr = []\nheapq.heappush(arr, 0)\nheapq.heappush(arr, 10 ** 9 + 1)\ntotal_sum, max_mean_diff = 0, 0\n\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    if query[0]==1:\n        val = query[1]\n        pos = bisect_left(arr, val)\n        left_gap = val - arr[pos - 1]\n        right_gap = arr[pos] - val\n        total_sum += val\n        max_mean_diff = max(max_mean_diff, right_gap * pos + total_sum - left_gap * (q - pos - 1))\n        heapq.heappush(arr,val)\n    else:\n        print('{:.10f}'.format(max_mean_diff / q))"
 ],
 "2200": [
  "n, a, b = map(int, input().split())\ntokens = list(map(int, input().split()))\nfor t in tokens:\n    print(t - (t * b // (a * b)))"
 ],
 "2201": [
  "d, n, m = map(int, input().split())\n\ngas_stations = []\nfor i in range(m):\n    pos, cost = map(int, input().split())\n    gas_stations.append((pos, cost))\n\ngas_stations.sort()\n\ncurr_pos = 0 # Current position of the truck\ncurr_gas = n # Current gas in the truck\ngas_used = 0 # Total gas used by the truck\ngas_stations.append((d, 0)) # Destination is also a gas station with 0 cost\n\ncost = 0 # Total cost of fuel\n\n# Check if it's possible to reach the destination\nfor i in range(m+1):\n    dist = gas_stations[i][0] - curr_pos\n    if curr_gas - dist < 0:\n        print(-1)\n        exit()\n    \n    # Refill gas tank\n    if curr_gas < dist:\n        cost += gas_stations[i-1][1] * (n-curr_gas)\n        curr_gas = n\n    \n    # Drive to next gas station\n    curr_gas -= dist\n    gas_used += dist\n    curr_pos = gas_stations[i][0]\n\n# Print total cost of fuel\nprint(cost)"
 ],
 "2202": [
  "n, p = map(int, input().split())\na = list(map(int, input().split()))\n\ns = sum(a) % p\nprefix_sum = [0] * (n + 1)\nmax_s = 0\n\nfor i in range(1, n+1):\n    prefix_sum[i] = prefix_sum[i-1] + a[i-1]\n    curr_s = prefix_sum[i] % p + (s - prefix_sum[i]) % p\n    max_s = max(max_s, curr_s)\n\nprint(max_s)"
 ],
 "2203": [
  "from collections import deque\n\ndef parse_query(query):\n    i, l, r, ans = query\n    return i, l, r, bool(ans)\n\nh, q = map(int, input().split())\n\nranges = [None] * (2 ** (h + 1) - 1) # To store the possible ranges for that node.\nleaves = set(range(2 ** h, 2 ** (h + 1))) # Set of leaf nodes.\n\nfor query in map(parse_query, (map(int, input().split()) for _ in range(q))):\n    i, l, r, ans = query\n    start_idx = 2 ** (i - 1) - 1 # First index of the level i nodes\n    end_idx = 2 ** i - 2         # Last index of the level i nodes\n    \n    if ans: # if answer is yes, the possible range for ancestors of the node is [start_idx, end_idx] intersection with the possible range given by the query.\n        ranges[1][start_idx:end_idx+1] = [max(l, start_idx), min(r, end_idx)] if ranges[1] else list(range(max(l, start_idx), min(r, end_idx) + 1))\n    else: # if answer is no, the possible ranges are left and right child of that ancestor\n        for idx in range(start_idx, end_idx+1):\n            ranges[2*idx], ranges[2*idx+1] = ranges[idx], ranges[idx]\n            \nn = 1\nqueue = deque([n]) # BFS traversal for checking the leaves.\nwhile queue:\n    node = queue.popleft()\n    if node in leaves:\n        idx = 2 ** h - 1 + node # Converting node index to complete binary tree index.\n        if not ranges[idx]:\n            print(\"Game cheated!\")\n            break\n        if n != 1 and ranges[idx] != ranges[1]:\n            print(\"Data not sufficient!\")\n            break\n        n = idx if n == 1 else -1 # If there is only one possible range we update n to idx else we mark n as not determined (-1).\n    else:\n        queue.extend([2*node, 2*node+1])\nelse: # This will execute if while loop completes its all iterations without an explicit break.\n    if n == -1:\n        print(\"Data not sufficient!\")\n    else:\n        print(n - 2 ** h)"
 ],
 "2204": [
  "t = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    types = []\n    for i in range(m):\n        a, b = map(int, input().split())\n        types.append((a, b))\n\n    types.sort(reverse=True, key=lambda x: x[0] + x[1] * (n - 1))\n\n    happiness = 0\n    for a, b in types:\n        if n > 0:\n            if n == 1:\n                happiness += a\n            else:\n                x = min(n, (a - b) // (2 * b) + 1)\n                happiness += a * x + b * (x - 1) * x // 2\n                n -= x\n        else:\n            break\n\n    print(happiness)"
 ],
 "2205": [
  "n = int(input())\np = list(map(int, input().split()))\n\nQ = 0\nfor i in range(n):\n    q = p[i] ^ (i % n)\n    Q ^= q\n\nprint(Q)"
 ],
 "2206": [
  "MOD = 10**9 + 7\nn = int(input())\na = [[int(x) for x in input().split()] for _ in range(n)]\ndp = [[0]*n for _ in range(n)]\n\nfor i in range(n):\n    for j in range(n):\n        if a[i][j]:\n            dp[i][j] = 1\n\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            if dp[i][k] and dp[k][j]:\n                dp[i][j] = (dp[i][j] + dp[i][k]*dp[k][j]) % MOD\n\nans = dp[0][n-1]\nfor i in range(n):\n    for j in range(i+1, n):\n        if not a[i][j]:\n            for k in range(n):\n                if dp[k][i] and dp[k][j]:\n                    ans = (ans - dp[k][i]*dp[k][j]) % MOD\n\nprint(ans % MOD)"
 ],
 "2207": [
  "r, c = map(int, input().split())\nwall = [input() for _ in range(r)]\n\nvisited = [[False for _ in range(c)] for _ in range(r)]\n\ndef dfs(i, j):\n    if i < 0 or i >= r or j < 0 or j >= c:\n        return False\n    if wall[i][j] == '.' or visited[i][j]:\n        return False\n    visited[i][j] = True\n    dfs(i+1, j)\n    dfs(i-1, j)\n    dfs(i, j+1)\n    dfs(i, j-1)\n    return True\n\nsegments = 0\nfor i in range(r):\n    for j in range(c):\n        if dfs(i, j):\n            segments += 1\n\nprint(segments)  "
 ],
 "2208": [
  "n=int(input())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\ndp=[0]*n\nm1=a[0]\nm2=b[0]\nfor i in range(n):\n    m1=max(m1,a[i])\n    m2=min(m2,b[i])\n    if(m1==m2):\n        dp[i]=1  \nfor i in range(1,n):\n    dp[i]+=dp[i-1]\nans=0\nfor i in range(n):\n    for j in range(i,n):\n        if(dp[j]-dp[i]+(1 if dp[i]==dp[j] else 0)):\n            ans+=1\nprint(ans) "
 ],
 "2209": [
  "n = int(input())\nt = []\nfor i in range(n):\n    t.append(input())\n\nsh_count = 0\ns_count = 0\nh_count = 0\n\nfor i in range(n):\n    for j in t[i]:\n        if j == 's':\n            if h_count > s_count:\n                sh_count += s_count\n                h_count -= s_count\n                s_count = 1\n            else:\n                s_count += 1\n        else:\n            h_count += 1\n\nsh_count += s_count * h_count\n\nprint(sh_count)"
 ],
 "2210": [
  "from collections import defaultdict\n\ndef dfs(node, parent):\n    # Base case - node has no children (is a leaf)\n    if len(graph[node]) == 1 and parent != -1:\n        return 1\n    \n    # Recursive case - check if Ayush can win by removing any child of the current node\n    can_win = False\n    for child in graph[node]:\n        if child != parent:\n            if dfs(child, node) == 0:\n                can_win = True\n                \n    # If Ayush can win by removing any child, return 1 (Ayush wins)\n    if can_win:\n        return 1\n    \n    # Otherwise, return 0 (Ashish wins)\n    return 0\n\n# Main code\ntest_cases = int(input())\nfor _ in range(test_cases):\n    n, x = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(n-1):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    # If x is a leaf node, Ayush wins\n    if len(graph[x]) == 1:\n        print(\"Ayush\")\n    # If there is only one node besides x, Ashish wins\n    elif len(graph) == 2:\n        print(\"Ashish\")\n    # Otherwise, Ayush wins if the starting node has more than one child\n    elif len(graph[1]) > 1:\n        print(\"Ayush\")\n    # If the starting node has only one child, Ashish wins\n    else:\n        # Check if Ayush can win by removing the child of the starting node\n        child = graph[1][0]\n        if dfs(child, 1) == 1:\n            print(\"Ayush\")\n        else:\n            print(\"Ashish\")"
 ],
 "2211": [
  "s = input()\nn = int(input())\nrules = []\nfor i in range(n):\n    p, l, r = input().split()\n    rules.append([p, int(l), int(r)])\n    \ndef complies_with_rules(string, rules):\n    for p, l, r in rules:\n        if not l <= string.count(p) <= r:\n            return False\n    return True\n\ngood_strings = set()\nfor i in range(len(s)):\n    for j in range(i+1, len(s)+1):\n        substring = s[i:j]\n        if complies_with_rules(substring, rules):\n            good_strings.add(substring)\n\nprint(len(good_strings))"
 ],
 "2212": [
  "n = int(input())\nmatrix = [[0 for j in range(n)] for i in range(n)]\n\nodd_nums = [i for i in range(1, n**2+1) if i % 2 == 1]\neven_nums = [i for i in range(1, n**2+1) if i % 2 == 0]\n\nmiddle = n // 2\n\nfor i in range(n):\n    for j in range(n):\n        if i == j == middle:\n            matrix[i][j] = odd_nums.pop()\n        elif i == middle or j == middle:\n            matrix[i][j] = odd_nums.pop()\n        else:\n            matrix[i][j] = even_nums.pop()\n\nfor row in matrix:\n    print(*row)"
 ],
 "2213": [
  "n, m, k = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\n\npairs = []\nfor j in range(m):\n    for i in range(1, j + 1):\n        for l in range(n):\n            if ((k == 0 and a[l][i-1] > a[l][j]) or (k == 1 and a[l][j] > a[l][i-1])):\n                break\n        else:\n            pairs.append((i, j+1))\n\nprint(len(pairs))\nfor i, j in pairs:\n    print(i, j)"
 ],
 "2214": [
  "n, m = map(int, input().split())\na = [list(map(int, input().strip())) for _ in range(n)]\n\nfor i in range(n-1):\n    for j in range(m-1):\n        cnt = a[i][j] + a[i+1][j] + a[i][j+1] + a[i+1][j+1]\n        if cnt % 2 == 0:\n            if a[i][j] == 1:\n                a[i][j] = 0\n            else:\n                a[i][j] = 1\n\nif any(a[i][j] + a[i+1][j] + a[i][j+1] + a[i+1][j+1] == 0 for i in range(n-1) for j in range(m-1)):\n    print(-1)\nelse:\n    cnt_changes = sum(1 for i in range(n) for j in range(m) if a[i][j] == 1)\n    if cnt_changes % 2 == 0:\n        cnt_changes += 1\n    print(cnt_changes) "
 ],
 "2215": [
  "n, m = map(int, input().split())\n\nflowers = [\"0\"] * n\n\nfor i in range(m):\n    l, r = map(int, input().split())\n    for j in range(l-1, r):\n        if (j-l+1) % 2 == 0: # if the number of flowers is even, put a lily\n            flowers[j] = \"1\"\n        else:\n            flowers[j] = \"0\"\n\nprint(\"\".join(flowers))"
 ],
 "2216": [
  "n, m, k = map(int, input().split())\n\ncells_per_tube = (n * m) // (2 * k)  # Each tube must have at least 2 cells, hence k <= n * m / 2.\n\ntubes = [[] for _ in range(k)]\ncurrent_x, current_y = 1, 1\nfor i in range(k):\n    for j in range(cells_per_tube):\n        tubes[i].extend([current_x, current_y])\n        if current_x % 2 == 1:\n            current_y += 1\n            if current_y > m:\n                current_x += 1\n                current_y = m\n        else:\n            current_y -= 1\n            if current_y < 1:\n                current_x += 1\n                current_y = 1\n\nif n % 2 == 1:\n    row = (n // 2) + 1\n    for j in range(m):\n        if j % 2 == 0:\n            tubes[j // 2].extend([row, j + 1])\n        else:\n            tubes[k - 1 - (j // 2)].extend([row, j + 1])\n\nfor i in range(k):\n    print(len(tubes[i]), *tubes[i])"
 ],
 "2217": [
  "from collections import deque,defaultdict\nfrom math import sqrt\nD = int(input())\nprime_dict = defaultdict(bool)\nfor i in range(2,int(sqrt(D))+1):\n    if not prime_dict[i]:\n        for j in range(i*i,int(D/i),i):\n            prime_dict[i*j] = True\n  \ndivisors = [i for i in range(1,int(sqrt(D))+1) if D%i == 0]\ndivisors += [int(D/i) for i in divisors[::-1] if i != int(D/i)]\n\"\"\"\nfor each divisor i of D, we prepare a list of divisors j that are multiples of i and for which j/i is prime.\n\"\"\"\nnj_dict = defaultdict(list)\nfor i in divisors:\n    for j in range(i*2,D+1,i):\n        if j//i > 1 and j//i not in prime_dict and D%j ==0:\n            nj_dict[i].append(j)\n\nMOD = 998244353\npaths_dict = defaultdict(int)\n\n\"\"\"\nwe traverse divisor from highest to lowest, and for each divisor we initialize paths_dict \nwith 1 for each of its elements, and each element itself as the path of length 0. for divisor i,\nwe then iterate over all elements of nj_dict[i] which are multiples of i, and accumulative their respective path lengths.\n\"\"\"\nfor i in divisors[::-1]:\n    paths_dict[(i,i)] = 1\n    for j in nj_dict[i]:\n        for k in paths_dict.keys():\n            if k[0] == j:\n                paths_dict[(k[1],i)] += paths_dict[k]\n        paths_dict[(j,i)] = paths_dict[(j,i)] % MOD + paths_dict[(j,j)]*paths_dict[(i,i)]  % MOD\n\nq = int(input())\nfor i in range(q):\n    v,u = map(int,input().split())\n    print(paths_dict[(v,u)]%MOD)"
 ],
 "2218": [
  "n, k = map(int, input().split())\nbeauty = list(map(int, input().split()))\nsum_beauty = []\nfor i in range(n):\n    for j in range(i, n):\n        if i == j:\n            sum_beauty.append(beauty[i])\n        else:\n            sum_beauty.append(beauty[i] + beauty[j])\n\nsum_beauty = sorted(list(set(sum_beauty)))\nfor i in range(k):\n    curr_detachment = sum_beauty[i::k]\n    print(len(curr_detachment), end=' ')\n    for soldier_beauty in curr_detachment:\n        print(beauty.index(soldier_beauty) + 1, end=' ')\n    print()"
 ],
 "2219": [
  "for _ in range(int(input())):\n    n,k = map(int,input().split())\n    cnt = 0\n    while n>0:\n        if n%k == 0:\n            n //= k\n            cnt += 1\n        else:\n            cnt += n%k\n            n -= n%k\n    print(cnt)"
 ],
 "2220": [
  "n, m, k = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort(reverse=True)\nfirst_emote_count = m // (k+1)\nsecond_emote_count = m % (k+1)\nresult = (first_emote_count * (k * a[0] + a[1])) + (second_emote_count * a[0])\nprint(result)"
 ],
 "2221": [
  "import sys\ninput = sys.stdin.readline\n\nx1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\nn = int(input())\ns = input().strip()\n\nlo, hi = 1, 10**18 # upper limit is arbitrary\n\nfor i in range(n):\n    if s[i] == \"U\":\n        dy = 1\n        dx = 0\n    elif s[i] == \"D\":\n        dy = -1\n        dx = 0\n    elif s[i] == \"L\":\n        dy = 0\n        dx = -1\n    else:\n        dy = 0\n        dx = 1\n    if i % 2 == 0:\n        x1 += dx\n        y1 += dy\n    else:\n        x1 -= dx\n        y1 -= dy\n    dist = abs(x2 - x1) + abs(y2 - y1)\n    if dist <= (i + 1) and (i + 1 - dist) % 2 == 0: # check if it is possible to get to the target in i+1 moves\n        hi = min(hi, i + 1)\n        break\n    elif dist <= i + 1: # check if the target is within i+1 steps\n        hi = min(hi, i + 1)\n    else: # if not, binary search for the required number of steps\n        lo = i + 2\n\nprint(hi if hi != 10**18 else -1)"
 ],
 "2222": [
  "from collections import deque\n\nn = int(input())\noperations = list(map(int, input().split()))\nchildren = [[] for _ in range(n)]\nfor i, parent in enumerate(map(int, input().split())):\n    children[parent-1].append(i+1)\n\nleaf_values = [1 for _ in range(n)] # initialize all leaves with 1\nqueue = deque(child for child in children[0])\nwhile queue:\n    node = queue.popleft()\n    if operations[node] == 1: # max node\n        leaf_values[node] = max(leaf_values[child] for child in children[node])\n    else: # min node\n        leaf_values[node] = min(leaf_values[child] for child in children[node])\n    queue.extend(children[node])\n\nprint(max(leaf_values))"
 ],
 "2223": [
  "n = int(input())\n\ngraph = [[] for _ in range(n + 1)]\nsize = [0] * (n + 1)\n\nfor i in range(1, n):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n    graph[v].append(u)\n\ndef dfs(node, parent=0):\n    size[node] = 1\n    for child in graph[node]:\n        if child == parent:\n            continue\n        dfs(child, node)\n        size[node] += size[child]\n\ndef remove_edges(node, parent=0):\n    removed = 0\n    for child in graph[node]:\n        if child == parent:\n            continue\n        removed += remove_edges(child, node)\n    if size[node] % 2 == 0 and parent != 0 and size[parent] % 2 == 0:\n        removed += 1\n    return removed\n\ndfs(1)\nans = remove_edges(1)\nif size[1] % 2 == 1:\n    print(\"-1\")\nelse:\n    print(ans)"
 ],
 "2224": [
  "import sys\nsys.setrecursionlimit(1000000)\n\nn, m, d = map(int, input().split())\np = list(map(int, input().split()))\nadj = [[] for _ in range(n)]\n\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    a, b = a - 1, b - 1\n    adj[a].append(b)\n    adj[b].append(a)\n\ndist = [-1] * n\ndist[p[0] - 1] = 0\n\ndef dfs(v, parent):\n    for u in adj[v]:\n        if u != parent:\n            dist[u] = dist[v] + 1\n            dfs(u, v)\n\ndfs(p[0] - 1, -1)\n\nfarthest = max(range(n), key=lambda x: dist[x])\n\ndist[farthest] = 0\ndfs(farthest, -1)\n\nprint(len([i for i in range(n) if 0 <= dist[i] <= d]))"
 ],
 "2225": [
  "n, m = map(int, input().split())\na = list(map(int, input().split()))\n\ndef calc_v(arr):\n    if len(arr) == 1:\n        return arr[0]\n    # OR of adjacent elements\n    new_arr = []\n    for i in range(0, len(arr)-1, 2):\n        new_arr.append(arr[i] | arr[i+1])\n    if len(arr) % 2 != 0:\n        new_arr.append(arr[-1])\n    # XOR of adjacent elements\n    for i in range(0, len(new_arr)-1, 2):\n        new_arr[i] = new_arr[i] ^ new_arr[i+1]\n    if len(new_arr) % 2 != 0:\n        del new_arr[-1]\n    return calc_v(new_arr)\n\nprint(calc_v(a))\nfor _ in range(m):\n    p, b = map(int, input().split())\n    a[p-1] = b\n    print(calc_v(a))"
 ],
 "2226": [
  "MOD = 10**9+7\nn,m,q = map(int,input().split())\ngraph = [[] for i in range(n)]\nfor i in range(m):\n    a,b,w = map(int,input().split())\n    graph[a-1].append((b,w))\n    graph[b-1].append((a,w))\n    \ndef solve(d):\n    q = [(0,0)]\n    dist = [10**18]*n\n    dist[0] = 0\n    while len(q):\n        v = q.pop(0)\n        if dist[v[1]]<v[0]:\n            continue\n        for j in graph[v[1]]:\n            if j[1]>d:\n                continue\n            if dist[j[0]-1]>dist[v[1]]+j[1]:\n                dist[j[0]-1]=dist[v[1]]+j[1]\n                q.append((dist[j[0]-1],j[0]-1))\n    ans = [0]*n\n    for i in range(n):\n        for j in graph[i]:\n            if dist[i]+j[1]-dist[j[0]-1]>ans[j[0]-1]:\n                ans[j[0]-1] = dist[i]+j[1]-dist[j[0]-1]\n    return ans\n\nans = [0]\ndp1 = solve(10**9)\nlast = max(dp1)\ndp2 = dp1\nsumq = min(q-1,n-1)\nfor i in range(1,sumq+1):\n    cur = last\n    dp2 = solve(cur)\n    last = max(last,dp2[0])\n    for j in range(1,n):\n        if dp2[j]>dp1[j-1]:\n            last = max(last,dp1[j-1]+dp2[j])\n    ans.append(last)\n    dp1 = dp2\nif sumq<q-1:\n    ans += [last]*(q-sumq-1)\nprint(sum(ans)%MOD)"
 ],
 "2227": [
  "s = input()\ncount = 0\ni = 0\nwhile i <= len(s) - 5:\n    if s[i:i+5] == \"heavy\":\n        j = i + 5\n        while j <= len(s) - 5:\n            if s[j:j+5] == \"metal\":\n                count += 1\n                j += 5\n            else:\n                j += 1\n        i += 1\n    else:\n        i += 1\n\nprint(count)"
 ],
 "2228": [
  "n = int(input())\nyears = []\nfor i in range(n):\n    b, d = map(int, input().split())\n    years.append((b, 1))\n    years.append((d, -1))\nyears.sort()\ncur_alive = 0\nmax_alive = 0\nmax_year = 0\nfor year, change in years:\n    cur_alive += change\n    if cur_alive > max_alive:\n        max_alive = cur_alive\n        max_year = year\nprint(max_year, max_alive)"
 ],
 "2229": [
  "from math import gcd\nn = int(input())\na = list(map(int, input().split()))\nb = [a[0]]\nfor i in range(1, n):\n    for j in range(2, a[i]+1):\n        if gcd(b[i-1], j) == 1:\n            b.append(j)\n            break\nprint(*b)"
 ],
 "2230": [
  "n = int(input())\ncandies = list(range(1, n ** 2 + 1))\nfor i in range(n):\n    for j in range(n // 2):\n        candy1 = candies.pop(0)\n        candy2 = candies.pop()\n        print(candy1, candy2, end=' ')\n    print()"
 ],
 "2231": [
  "import sys\n\ninput = sys.stdin.readline\n\ndef solve():\n    n = int(input())\n    lst = list(map(int, input().split()))\n    lst.sort()\n    ans = None\n    for i in range(1, n - 2):\n        for j in range(i + 1, n - 1):\n            ij = lst[i] * lst[j]\n            l, r = j + 1, n - 1\n            while l < r:\n                mid = (l + r + 1) // 2\n                if lst[mid] >= ij:\n                    r = mid - 1\n                else:\n                    l = mid\n            if lst[l] != ij or l <= j:\n                continue\n            perim = 2 * (lst[i] + lst[j])\n            area = lst[i] * lst[j]\n            if ans is None or perim * perim * ans[3] > area * ans[2] * ans[2]:\n                ans = (lst[i], lst[j], lst[l], lst[l])\n    print(*ans)\n\nt = int(input())\nfor _ in range(t):\n    solve()"
 ],
 "2232": [
  "import sys\nsys.setrecursionlimit(10**7)\n\ndef dfs(curr, parent):\n    global diameter_start, diameter_end, dist, G\n\n    max_depth = 0\n    max_child_depth = 0\n    max_depth_node = curr\n    for child in G[curr]:\n        if child != parent:\n            child_depth, child_end = dfs(child, curr)\n            if child_depth >= max_depth:\n                max_child_depth = max_depth\n                max_depth = child_depth\n                diameter_start, diameter_end = child_end, max_depth_node\n                max_depth_node = child\n            elif child_depth > max_child_depth:\n                max_child_depth = child_depth\n        \n    dist[curr] = max_depth + 1\n    if max_depth + max_child_depth + 2 > diameter_dist:\n        diameter_dist = max_depth + max_child_depth + 2\n        diameter_start, diameter_end = max_depth_node, diameter_start\n    \n    return dist[curr], diameter_end if diameter_end == curr else max_depth_node\n\nn = int(input())\nG = [[] for i in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    G[u].append(v)\n    G[v].append(u)\n\ndiameter_start, diameter_end, diameter_dist = 1, 1, 0\ndist = [0]*(n+1)\n\ndfs(1, 0)\nstart, end = diameter_start, diameter_end\n\ndiameter_start, diameter_end, diameter_dist = start, end, 0\ndist = [0]*(n+1)\n\ndfs(diameter_start, 0)\nmid1 = diameter_end\n\ndiameter_start, diameter_end, diameter_dist = start, end, 0\ndist = [0]*(n+1)\n\ndfs(diameter_end, 0)\nmid2 = diameter_end\n\nprint(mid1, mid2)\nprint(start, end)"
 ],
 "2233": [
  "for _ in range(int(input())):\n    n = int(input())\n    s = input()\n    t = input()\n    diff = [(s[i],t[i]) for i in range(n) if s[i]!=t[i]]\n    if len(diff)!=2:\n        print('No')\n    elif diff[0]==diff[1][::-1]:\n        print('Yes')\n    else:\n        print('No')"
 ],
 "2234": [
  "t = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    if k == 0 or n == k:\n        print(0)\n    elif n < k:\n        print(k - n)\n    else:\n        rem = n % 2\n        if rem == k % 2:\n            print(0)\n        else:\n            print(1)"
 ],
 "2235": [
  "n = int(input())\ntimes = [0] * n\nfor i in range(n):\n    times[i] = int(input())\n\ncosts = [0] * n\nfor i in range(n):\n    # one-trip ticket\n    costs[i] = costs[i-1] + 20\n    # 90-minutes ticket\n    j = i - 1\n    while j >= 0 and times[i] - times[j] < 90:\n        j -= 1\n    if j >= 0:\n        costs[i] = min(costs[i], costs[j] + 50)\n    else:\n        costs[i] = min(costs[i], 50)\n    # one-day ticket\n    j = i - 1\n    while j >= 0 and times[i] - times[j] < 1440:\n        j -= 1\n    if j >= 0:\n        costs[i] = min(costs[i], costs[j] + 120)\n    else:\n        costs[i] = min(costs[i], 120)\n\n# calculate charges\nfor i in range(n):\n    if i == 0:\n        print(costs[i])\n    else:\n        print(costs[i] - costs[i-1])"
 ],
 "2236": [
  "n = int(input())\nbalances = list(map(int, input().split()))\n\n# Calculate the prefix sum of the balances\nprefix_sum = [0] * (n + 1)\nfor i in range(n):\n    prefix_sum[i+1] = prefix_sum[i] + balances[i]\n\n# The total balance should be zero\ntotal_balance = prefix_sum[-1]\n\n# If the total balance is already zero, we don't need to do anything\nif total_balance == 0:\n    print(0)\nelse:\n    # We need to transfer money from banks with positive balances to banks with negative balances\n    num_transfers = 0\n    # Iterate through the prefix sum and look for positive and negative balances\n    for i in range(1, n + 1):\n        if prefix_sum[i] > 0 and total_balance < 0:\n            # There is a positive balance and we need to transfer money to banks with negative balances\n            # Calculate the amount of money to transfer and update the balances\n            transfer_amount = min(prefix_sum[i], -total_balance)\n            prefix_sum[i] -= transfer_amount\n            total_balance += transfer_amount\n            num_transfers += 1\n        elif prefix_sum[i] < 0 and total_balance > 0:\n            # There is a negative balance and we need to transfer money from banks with positive balances\n            # Calculate the amount of money to transfer and update the balances\n            transfer_amount = min(-prefix_sum[i], total_balance)\n            prefix_sum[i] += transfer_amount\n            total_balance -= transfer_amount\n            num_transfers += 1\n    print(num_transfers)"
 ],
 "2237": [
  "from collections import deque\n\nn = int(input())\nS = list(map(int, input().split()))\n\nS.sort()\nmax_x = S[-1].bit_length()\n\nadj_list = [[] for _ in range(2**max_x)]\nfor i in range(2**max_x):\n    for s in S:\n        if i ^ s < 2**max_x:\n            adj_list[i].append(i ^ s)\n\nvisited = [False] * (2**max_x)\nprev = [-1] * (2**max_x)\nmagical_perm = [-1] * (2**max_x)\nqueue = deque()\nfor i in range(2**max_x):\n    if not visited[i]:\n        visited[i] = True\n        magical_perm[0] = i\n        queue.append(i)\n        while queue:\n            u = queue.popleft()\n            for v in adj_list[u]:\n                if not visited[v]:\n                    visited[v] = True\n                    queue.append(v)\n                    prev[v] = u\n                    magical_perm[v] = u ^ v\n\nprint(max_x)\nprint(*magical_perm)"
 ],
 "2238": [
  "n = int(input())\n\nfor i in range(n):\n    x = abs(n//2 - i)\n    print(\"*\" * x + \"D\" * (n - 2*x) + \"*\" * x)"
 ],
 "2239": [
  "t = int(input())\nfor i in range(t):\n    x = int(input())\n    rolls = (x+6)//7\n    print(rolls)"
 ],
 "2240": [
  "s = input().strip()\nt = input().strip()\n\nif s.count('0') == len(s) or s.count('1') == len(s):\n    print(0)\nelse:\n    cnt_0_s = s.count('0')\n    cnt_1_s = len(s) - cnt_0_s\n    cnt_0_t = t.count(s.replace('1', '').replace('0', ''))\n    cnt_1_t = t.count(s.replace('0', '').replace('1', ''))\n\n    if cnt_0_t == 0 or cnt_1_t == 0:\n        print(0)\n    else:\n        print(cnt_0_t * cnt_1_t)"
 ],
 "2241": [
  "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\ntotal_joy = 0\n\nfor i in range(n):\n    x = min(a[i], b[i])\n    y = b[i] - x\n    total_joy += (x*y)\n    \n    if a[i] < b[i]:\n        if i < n-1 and (b[i]-a[i]) > a[i+1]:\n            total_joy = -1\n            break\n        elif i == n-1 and b[i] > sum(a):\n            total_joy = -1\n            break\n\nprint(total_joy)"
 ],
 "2242": [
  "s = input().strip()\ncnt = 0\nmod = 2019\nn = len(s)\nfor i in range(n):\n    val = 0\n    for j in range(i, min(n, i+4)):\n        val = (val*10 + int(s[j])) % mod\n        if val == 0:\n            cnt += 1\nprint(cnt)"
 ],
 "2243": [
  "n, k, q = map(int, input().split())\nt = list(map(int, input().split()))\nonline = set()\nfor i in range(q):\n    op, id = map(int, input().split())\n    if op == 1:\n        online.add(t[id-1])\n        if len(online) > k:\n            online.remove(min(online))\n    else:\n        print(\"YES\" if t[id-1] in online else \"NO\")"
 ],
 "2244": [
  "n, m = map(int, input().split())\ng = [[] for _ in range(n)]\nin_degree = [0] * n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    g[b].append(a)\n    in_degree[a] += 1\n\nq = []\nfor i in range(n):\n    if in_degree[i] == 0:\n        q.append(i)\n\norder = []\nwhile q:\n    v = q.pop()\n    order.append(v)\n    for to in g[v]:\n        in_degree[to] -= 1\n        if in_degree[to] == 0:\n            q.append(to)\n\nif len(order) != n:\n    print(-1)\nelse:\n    print(' '.join(str(x + 1) for x in order))"
 ],
 "2245": [
  "t = int(input())\nfor i in range(t):\n    n, k = map(int, input().split())\n    if (n % (k+1)) == 0:\n        print(\"Bob\")\n    else:\n        print(\"Alice\")"
 ],
 "2246": [
  "import sys\n\nsys.setrecursionlimit(2*10**5)\n\ndef dfs(u, p):\n    vist[u] = True\n    cnt = 1\n    for adj in graph[u]:\n        if adj != p:\n            if not vist[adj]:\n                dist[adj] = dist[u] + 1\n                cnt += dfs(adj, u)\n            else:\n                cnt += size[adj]\n    size[u] = cnt\n    return cnt\n\nn = int(input())\ngraph = [[] for i in range(n)]\nvist = [False] * n\nsize = [0] * n\ndist = [0] * n\n\nfor i in range(n - 1):\n    u, v = map(int, input().split())\n    graph[u-1].append(v-1)\n    graph[v-1].append(u-1)\n\ndfs(0, -1)\n\nexp = 0\nfor i in range(n):\n    exp += dist[i] / size[i]\n\nprint(\"{:.15f}\".format(exp))"
 ],
 "2247": [
  "t = int(input())\n\nfor i in range(t):\n    s, a, b, c = map(int, input().split())\n    chocolates = s // c\n    free_chocolates = chocolates // a * b\n    total_chocolates = chocolates + free_chocolates\n    print(total_chocolates)"
 ],
 "2248": [
  "n, m = map(int, input().split())\n\nadj_list = [[] for _ in range(n+1)]\n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    adj_list[a].append(b)\n    adj_list[b].append(a)\n\nvisited = [False] * (n+1)\ndist = [-1] * (n+1)\n\ndef dfs(node, d):\n    visited[node] = True\n    dist[node] = d\n    for neighbor in adj_list[node]:\n        if not visited[neighbor]:\n            dfs(neighbor, d+1)\n\ndfs(1, 0)\nprint(max(dist[1:]))"
 ],
 "2249": [
  "n = int(input())\na = list(map(int, input().split()))\n\nleft = [0] * n\nfor i in range(1, n):\n    if a[i-1] == a[i]:\n        left[i] = 1 + left[i-1]\n\nright = [0] * n\nfor i in range(n-2, -1, -1):\n    if a[i] == a[i+1]:\n        right[i] = 1 + right[i+1]\n\ncnt = [0] * (max(a)+1)\nfor i in range(n):\n    if left[i] == 0:\n        cnt[a[i]] += right[i]\n    elif right[i] == 0:\n        cnt[a[i]] += left[i]\n\nans = 0\nfor i in range(n):\n    if cnt[a[i]] > 0:\n        ans += cnt[a[i]] - 1\n        cnt[a[i]] = 0\n\nprint(ans)"
 ],
 "2250": [
  "for _ in range(int(input())):\n    n = int(input())\n    s = input()\n    ans = 0\n    for i in range(n):\n        if s[i] == '.':\n            continue\n        j = i + 1\n        while j < n and s[j] == '.':\n            j += 1\n        if s[i] == 'R':\n            ans += j - i - 1 - s[i:j].count('R')\n        else:\n            ans += j - i - 1 - s[i:j].count('L')\n        i = j - 1\n    print(ans)"
 ],
 "2251": [
  "from collections import defaultdict\n\ndef dfs(curr_node, target_node, visited, graph):\n    if curr_node == target_node:\n        return True\n    visited.add(curr_node)\n    for neighbour in graph[curr_node]:\n        if neighbour not in visited:\n            if dfs(neighbour, target_node, visited, graph):\n                return True\n    return False\n\nn, m = map(int, input().split())\n\ngraph_by_color = defaultdict(list)\ngraph_by_vertex = defaultdict(list)\nfor i in range(m):\n    a, b, c = map(int, input().split())\n    graph_by_color[c].append((a, b))\n    graph_by_vertex[a].append(c)\n    graph_by_vertex[b].append(c)\n\nq = int(input())\nfor i in range(q):\n    u, v = map(int, input().split())\n    common_colors = set(graph_by_vertex[u]).intersection(set(graph_by_vertex[v]))\n    for color in common_colors:\n        if dfs(u, v, set(), dict(graph_by_color[color])):\n            print(color)\n            break\n    else:\n        print(0)"
 ],
 "2252": [
  "n, m = map(int, input().split())\np = list(map(int, input().split()))\n\nfor i in range(m):\n    l, r, x = map(int, input().split())\n    x -= 1\n    s = sorted(p[l-1:r])\n    if p[x] == s.index(p[x]) + l:\n        print(\"Yes\")\n    else:\n        print(\"No\")"
 ],
 "2253": [
  "t = int(input())\n\nfor _ in range(t):\n    sentence = input()\n    if sentence.endswith(\"po\"):\n        print(\"FILIPINO\")\n    elif sentence.endswith(\"desu\") or sentence.endswith(\"masu\"):\n        print(\"JAPANESE\")\n    else:\n        print(\"KOREAN\")"
 ],
 "2254": [
  "n = int(input())\na = list(map(int, input().split()))\n\ndp = [0] * n\nprefix_xor = [0] * (n+1)\n\nfor i in range(n):\n    prefix_xor[i+1] = prefix_xor[i] ^ a[i]\n    \nlast_occurrence = {}\nlast_occurrence[0] = -1\nans = 0\n\nfor i in range(n):\n    if prefix_xor[i+1] not in last_occurrence:\n        dp[i] = 0\n    else:\n        j = last_occurrence[prefix_xor[i+1]]\n        if j == -1:\n            dp[i] = (i+1) * (i+2) // 2\n        else:\n            dp[i] = dp[j] + (j+2) * (i-j-1) + (i-j) * (i-j-1) // 2\n    ans += dp[i]\n    last_occurrence[prefix_xor[i+1]] = i\n\nprint(ans)"
 ],
 "2255": [
  "from collections import deque\n\nn, m = map(int, input().split())\n\ngraph = [[] for _ in range(n+1)]\nfor _ in range(m):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n    graph[v].append(u)\n\nvisited = set()\nvisited.add(1)\nnodes = [1]\nqueue = deque([1])\nwhile queue:\n    node = queue.popleft()\n    for neighbor in sorted(graph[node]):\n        if neighbor not in visited:\n            visited.add(neighbor)\n            nodes.append(neighbor)\n            queue.append(neighbor)\n\nprint(*nodes)"
 ],
 "2256": [
  "t = int(input())\n\nfor _ in range(t):\n    n, x, a, b = map(int, input().split())\n    if abs(a-b) + x >= n:\n        print(n-1)\n    else:\n        print(abs(a-b) + x)"
 ],
 "2257": [
  "import math\n\nn, x1, y1, x2, y2 = map(int, input().split())\nd = [list(map(int, input().split())) for i in range(n)]\n\ndef dist(a, b):\n    return (a[0]-b[0])**2 + (a[1]-b[1])**2\n\ndef sqr(x):\n    return x**2\n\nmi = math.inf\nfor i in range(n):\n    d1 = dist(d[i], (x1, y1))\n    d2 = dist(d[i], (x2, y2))\n    for j in range(n):\n        r1 = max(d1, dist(d[j], (x1, y1)))\n        r2 = max(d2, dist(d[j], (x2, y2)))\n        mi = min(mi, sqr(r1)+sqr(r2))\n\nr1 = dist((x1, y1), (x2, y2))\nfor i in range(n):\n    r1 = max(r1, dist(d[i], (x1, y1)))\n    r2 = max(dist(d[i], (x2, y2)), r1)\nprint(sqr(r1)+sqr(r2))"
 ],
 "2258": [
  "n = int(input())\na = list(map(int, input().split()))\ninv = []\nfor i in range(n):\n    for j in range(i+1, n):\n        if a[i] > a[j]:\n            inv.append((i+1,j+1))\nfor i in range(n-1):\n    if a[i] > a[i+1]:\n        for u,v in inv:\n            if (u<=i+1 and v>=i+2) or (u<=i+2 and v>=i+3):\n                break\n        else:\n            print(-1)\n            exit()\nprint(len(inv))\nfor u,v in inv:\n    print(u,v)"
 ],
 "2259": [
  "n = int(input())\na = list(map(int, input().split()))\np = [0] * n\n\nfor i in range(n):\n    p[a[i]-1] = i\n\nans = 0\nfor i in range(n):\n    if p[i] == i:\n        ans += 1\n    elif p[i-1] < p[i]:\n        continue\n    else:\n        j = i\n        while j > 0 and p[j-1] > p[j]:\n            p[j-1], p[j] = p[j], p[j-1]\n            j -= 1\n        if p[i] == i:\n            ans += 1\n            \nprint(ans)"
 ],
 "2260": [
  "n = int(input())\nprint(str(pow(5, n, 100)).zfill(2))"
 ],
 "2261": [
  "k = int(input())\nres = [['+' for x in range(2**k)] for y in range(2**k)]\nfor i in range(k):\n    l = 2**i\n    for x in range(2**k):\n        for y in range(2**k):\n            if x//l % 2 == y//l % 2:\n                res[x][y] = '*' if res[x][y] == '+' else '+'\nfor x in range(2**k):\n    print(''.join(res[x]))"
 ],
 "2262": [
  "n = int(input())\nwords = [input() for _ in range(n)]\n\nroots = []\nfor word in words:\n    root = ''.join(sorted(set(word)))\n    if root not in roots:\n        roots.append(root)\n\nprint(len(roots))"
 ],
 "2263": [
  "import sys\ninput = sys.stdin.readline\n\ndef dfs_up(v, p, d):\n    global ans, M, M2\n    ans += d * p * (n - p)\n    if d > M:\n        M2 = M\n        M = d\n    elif d > M2:\n        M2 = d\n    for (u, w) in N[v]:\n        if u != p:\n            dfs_up(u, v, d + w)\n\ndef dfs_down(v, p, d):\n    global ans, M, M2\n    ans += d * p * (n - p)\n    if d == M:\n        ans -= d * M2 * (n - p)\n    else:\n        ans -= d * M * (n - p)\n    for (u, w) in N[v]:\n        if u != p:\n            dfs_down(u, v, d + w)\n\nn = int(input())\nN = [[] for i in range(n)]\nfor i in range(n - 1):\n    (u, v, w) = map(int, input().split())\n    N[u - 1].append((v - 1, w))\n    N[v - 1].append((u - 1, w))\n\nans = M = M2 = 0\ndfs_up(0, 0, 0)\nprint(\"%.10f\" % (2 * ans / n / (n - 1) / (n - 2)))\n\nq = int(input())\nfor i in range(q):\n    (r, w) = map(int, input().split())\n    u = N[r - 1][0][0]\n    v = N[r - 1][1][0]\n    if u > v:\n        u, v = v, u\n    if M == N[r - 1][0][1] + N[r - 1][1][1]:\n        ans -= M * M2 * (n - v) * (u + 1)\n        ans += (M - w) * M2 * (n - v) * (u + 1)\n    elif M == N[r - 1][0][1]:\n        ans -= M * M2 * (n - v) * (u + 1)\n        ans += (M - w) * M2 * (n - v) * (u + 1)\n        M2 = max(M2, N[r - 1][1][1] - w)\n    else:\n        ans -= M * M2 * (n - v) * (u + 1)\n        ans += (M - w) * M2 * (n - v) * (u + 1)\n        M2 = max(M2, N[r - 1][0][1] - w)\n    N[r - 1][0] = (u, w)\n    N[r - 1][1] = (v, w)\n    if w > M:\n        M2 = M\n        M = w\n    elif w > M2:\n        M2 = w\n    print(\"%.10f\" % (2 * ans / n / (n - 1) / (n - 2)))"
 ],
 "2264": [
  "t = int(input())\n\nfor i in range(t):\n    n = int(input())\n    max_l, min_r = 1, 10**9\n    for j in range(n):\n        l, r = map(int, input().split())\n        max_l = max(max_l, l)\n        min_r = min(min_r, r)\n    print(max(0, max_l - min_r))"
 ],
 "2265": [
  "a = input()\nb = input()\nn = len(b)\ncount = 0\nfor i in range(len(a)-n+1):\n    sub = a[i:i+n]\n    diffs = sum([sub[j]!=b[j] for j in range(n)])\n    if diffs%2 == 0:\n        count += 1\nprint(count)"
 ],
 "2266": [
  "from collections import deque\n\n# Read inputs\nn, k, d = map(int, input().split())\npolice_loc = set(map(int, input().split()))\n\n# Create adjacency list for the graph\nadj_list = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    adj_list[u - 1].append(v - 1)\n    adj_list[v - 1].append(u - 1)\n\n# Initialize distances array for each police station\ndist = [[n] * n for _ in range(k)]\n\n# Find shortest distances from each police station using BFS\nfor idx, police in enumerate(police_loc):\n    dist[idx][police - 1] = 0\n    q = deque([police - 1])\n    while q:\n        node = q.popleft()\n        for neighbor in adj_list[node]:\n            if dist[idx][neighbor] == n:\n                dist[idx][neighbor] = dist[idx][node] + 1\n                q.append(neighbor)\n\n# Initialize dp array to store the number of reachable cities from each node\ndp = [0] * n\n\n# DFS to compute dp array\ndef dfs(node, parent):\n    # Initialize dp[node] to 1 if node is a police station\n    dp[node] = 1 if node in police_loc else 0\n    \n    # Recursively compute dp value for each neighbor\n    for neighbor in adj_list[node]:\n        if neighbor != parent:\n            dfs(neighbor, node)\n            # Add number of reachable cities from neighbor to dp[node] if dist from neighbor to node <= d\n            if dist[i][node] + dist[i][neighbor] <= d:\n                dp[node] += dp[neighbor]\n\n# Compute dp array for each police station and find maximum number of roads that can be shut down\nmax_roads = 0\nfor i in range(k):\n    # Compute dp array for the i-th police station\n    dfs(police_loc[i] - 1, -1)\n    \n    # Find number of roads that can be shut down for the i-th police station\n    cur_roads = sum(dp[j] == 1 for j in range(n))\n    max_roads = max(max_roads, cur_roads - 1)\n\n# Find the indices of the roads to be shut down\nroads_to_remove = []\nfor i in range(n - 1):\n    u, v = i + 1, adj_list[i][0] + 1\n    if dp[u - 1] == 0 or dp[v - 1] == 0:\n        roads_to_remove.append(i + 1)\n\n# Print output\nprint(len(roads_to_remove))\nprint(*roads_to_remove)"
 ],
 "2267": [
  "n = int(input())\nstrings = []\nfor i in range(n):\n    strings.append(input())\nstrings.sort(key=lambda s: s * 2)\nprint(\"\".join(strings))"
 ],
 "2268": [
  "n,m=map(int,input().split())\ns=input()\nfor i in range(m):\n    x,y=map(str,input().split())\n    s=s.replace(x,\".\").replace(y,x).replace(\".\",y)\nprint(s)"
 ],
 "2269": [
  "t = int(input())\nfor _ in range(t):\n    s = input()\n    n = len(s)\n    one, two, three = False, False, False # flags to check if 1, 2 and 3 are present in current window\n    l, r = 0, -1 # pointers for current window\n    ans = float('inf') # initialize answer as infinite\n    while True:\n        if (not one or not two or not three) and r+1<n:\n            r += 1\n            if s[r] == '1':\n                one = True\n            elif s[r] == '2':\n                two = True\n            else:\n                three = True\n        else:\n            if one and two and three:\n                ans = min(ans, r-l+1) # update answer if current window contains all 3 characters\n            if s[l] == '1':\n                one = False\n            elif s[l] == '2':\n                two = False\n            else:\n                three = False\n            l += 1\n        if r == n-1 and (not one or not two or not three):\n            break\n    print(0 if ans == float('inf') else ans)"
 ],
 "2270": [
  "from collections import defaultdict\n\nn = int(input())\nplanks = defaultdict(int)\nfor i in input().split():\n    planks[int(i)] += 1\n\nrect_possible = square_possible = False\n\ndef check_if_rect_possible():\n    global rect_possible\n    for i in planks:\n        if planks[i] >= 4:\n            rect_possible = True\n            return\n        \n        if planks[i] >= 2:\n            for x in planks:\n                if x != i and planks[x] >= 2:\n                    rect_possible = True\n                    return\n\ndef check_if_square_possible():\n    global square_possible\n    for i in planks:\n        if planks[i] >= 4:\n            square_possible = True\n            return\n\nfor i in range(int(input())):\n    op, size = input().split()\n    size = int(size)\n    if op == '+':\n        planks[size] += 1\n    else:\n        planks[size] -= 1\n        \n    if not rect_possible:\n        check_if_rect_possible()\n\n    if not square_possible:\n        check_if_square_possible()\n\n    if rect_possible and square_possible:\n        print(\"YES\")\n    else:\n        print(\"NO\")    "
 ],
 "2271": [
  "n = int(input())\nedges = [list(map(int, input().split())) for _ in range(n-1)]\nadj_list = [[] for _ in range(n+1)]\nfor a, b in edges:\n    adj_list[a].append(b)\n    adj_list[b].append(a)\n\nlifelines = 0\nfor node in range(1, n+1):\n    for neighbor in adj_list[node]:\n        lifelines += len(adj_list[neighbor]) - 1\n\nprint(lifelines // 2)"
 ],
 "2272": [
  "from collections import deque\n\ndef can_reach(graph, start, end):\n    queue = deque([start])\n    visited = set([start])\n    while queue:\n        node = queue.popleft()\n        if node == end:\n            return \"YES\"\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    return \"NO\"\n                \n\nn = int(input())\nintervals = []\ngraph = {}\nfor i in range(1, n+1):\n    query = input().split()\n    if query[0] == '1':\n        interval = (int(query[1]), int(query[2]))\n        intervals.append(interval)\n        graph[i] = []\n        for j in range(i-1):\n            if (interval[0] < intervals[j][0] < interval[1]) or (interval[0] < intervals[j][1] < interval[1]):\n                graph[i].append(j+1)\n            elif (intervals[j][0] < interval[0] < intervals[j][1]) or (intervals[j][0] < interval[1] < intervals[j][1]):\n                graph[j+1].append(i)\n    elif query[0] == '2':\n        start, end = int(query[1]), int(query[2])\n        print(can_reach(graph, start, end))"
 ],
 "2273": [
  "from collections import defaultdict\n\nn, m = map(int, input().split())\n\n# Initialize adjacency list of graph\ngraph = defaultdict(list)  \nfor i in range(m):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\n# Assign each vertex to vertex set 1\nvertex_set = [1] * (n + 1)\n\n# Check if there exists an edge with both endpoints in any vertex set\nfor i in range(1, n + 1):\n    for j in graph[i]:\n        if vertex_set[i] == vertex_set[j]:\n            print(-1)\n            exit()\n\n# Find a vertex i connected to a vertex j that is connected to a vertex k that is not connected to i\nfor i in range(1, n + 1):\n    for j in graph[i]:\n        for k in graph[j]:\n            if k != i and k not in graph[i]:\n                # Assign i to vertex set 1, j to vertex set 2, and k to vertex set 3\n                vertex_set[i] = 1\n                vertex_set[j] = 2\n                vertex_set[k] = 3\n                # Assign all vertices connected to i to vertex set 2\n                for x in graph[i]:\n                    vertex_set[x] = 2\n                # Assign all vertices connected to k to vertex set 1\n                for x in graph[k]:\n                    vertex_set[x] = 1\n                # Print the resulting vertex set\n                print(*vertex_set[1:])\n                exit()\n\n# If we reach this line, it means it is impossible to create the vertex sets\nprint(-1)"
 ],
 "2274": [
  "t=int(input())\nfor _ in range(t):\n    n,m=map(int,input().split())\n    arr=[]\n    for i in range(n):\n        arr.append(input())\n    cnt=0\n    for i in range(n-1):\n        if arr[i][m-1]=='R':\n            cnt+=1\n    for j in range(m-1): \n        if arr[n-1][j]=='D':\n            cnt+=1\n    print(cnt)"
 ],
 "2275": [
  "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input().strip()\n    last_angry = -1\n    time_to_angry = 0\n    for i in range(n):\n        if s[i] == \"A\":\n            if last_angry == -1:\n                last_angry = i\n            else:\n                time_to_angry = max(time_to_angry, i-last_angry-1)\n                last_angry = i\n    print(time_to_angry)"
 ],
 "2276": [
  "n = int(input())\ns = input().strip()\n\na = list(map(int, input().strip().split()))\n\ndp = [[0] * (n+1) for _ in range(n+1)]\n\nfor length in range(1, n+1):\n    for i in range(n-length+1):\n        j = i + length - 1\n        if length == 1:\n            dp[i][j] = a[length-1]  # base case\n        else:\n            dp[i][j] = max(dp[i][k] + dp[k+1][j] for k in range(i, j))\n            if s[i] == s[j]:\n                dp[i][j] = max(dp[i][j], a[length-1], dp[i+1][j-1])\n\nprint(dp[0][n-1])"
 ],
 "2277": [
  "n=int(input())\nnums=list(map(int,input().split()))\nm=int(input())\n\ninversions=0\nfor i in range(n):\n    for j in range(i+1,n):\n        if nums[i]>nums[j]:\n            inversions+=1\n            \nfor q in range(m):\n    l,r=map(int,input().split())\n\n    segment=nums[l-1:r]\n    segment.reverse()\n    nums[l-1:r]=segment\n\n    if (r-l+1)%2==0:\n        print(\"even\" if inversions%2==0 else \"odd\")\n    else:\n        inversions+=r-l\n        print(\"even\" if inversions%2==0 else \"odd\")"
 ],
 "2278": [
  "from math import log2, ceil\n\n# Helper function to check if a sequence is m-cute\ndef is_cute_seq(a, b, m, seq):\n    n = len(seq)\n    if seq[0] != a or seq[-1] != b:\n        return False\n    for i in range(2, n+1):\n        r_i = seq[i-1] - sum(seq[:i-1])\n        if not 1 <= r_i <= m:\n            return False\n    return True\n\nq = int(input())\n\nfor _ in range(q):\n    a, b, m = map(int, input().split())\n\n    # Check if a single term sequence satisfies the condition\n    if a == b:\n        print(\"1\", a)\n        continue\n\n    # Check if a 2 term sequence satisfies the condition\n    if b <= 2*a:\n        print(\"2\", a, b)\n        continue\n\n    # Compute the maximum possible length of the sequence\n    max_len = ceil(log2((b-a)/(a-1) + 1))\n\n    # Binary search for the length of the sequence\n    left, right = 3, max_len\n    seq_found = False\n    while left <= right:\n        mid = (left + right) // 2\n        seq = [a]\n        for i in range(2, mid+1):\n            # Compute the sum of the first i-1 terms of the sequence\n            # and use it to determine r_i\n            sum_prev = sum(seq[:i-1])\n            r_i = b - sum_prev\n            for j in range(1, i):\n                r_i -= seq[-j]\n            r_i = max(r_i, 1)\n            if r_i > m:\n                break\n            seq.append(sum_prev + r_i)\n        else:\n            if is_cute_seq(a, b, m, seq):\n                seq_found = True\n                break\n            else:\n                left = mid + 1\n\n    if not seq_found:\n        print(\"-1\")\n    else:\n        print(len(seq), *seq)"
 ],
 "2279": [
  "n = int(input())\nstrengths = []\nfor i in range(n):\n    strengths.append(list(map(int, input().split())))\n\nteam_strengths = []\nfor i in range(n):\n    for j in range(i):\n        team_strengths.append((strengths[i][j], i, j))\n\nteam_strengths.sort(reverse=True)\n\npaired = [False]*n\nmatchups = [-1]*n\n\nfor strength, i, j in team_strengths:\n    if not paired[i] and not paired[j]:\n        matchups[i] = j+1\n        matchups[j] = i+1\n        paired[i] = True\n        paired[j] = True\n\nprint(*matchups)"
 ],
 "2280": [
  "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    if n <= 2 or a[-1] >= sum(a[:-2]):\n        print(0)\n    else:\n        left, right = 0, n - 2\n        while left < right:\n            mid = (left + right) // 2\n            if a[mid] >= sum(a[:mid]):\n                right = mid - 1\n            else:\n                left = mid + 1\n        print(left)"
 ],
 "2281": [
  "n = int(input())\na = [i for i in range(1, n + 1)] * 2\nfor i in range(n):\n    a[2 * i], a[2 * i + 1] = a[n + i], a[i]\nprint(*a)"
 ],
 "2282": [
  "n = int(input())\ns = input()\n\nprint(abs(s.count('L') - s.count('R')) + 1)"
 ],
 "2283": [
  "n, m = map(int, input().split())\na = list(map(int, input().split()))\n\n# create a list of edges\nedges = []\nfor i in range(m):\n    v, u, w = map(int, input().split())\n    edges.append((v, u, w))\n\nmax_weight = 0\n# iterate over all possible subsets of vertices\nfor subset in range(1, (1 << n)):\n    # calculate the weight of the subset\n    subset_weight = sum(a[i] for i in range(n) if (subset & (1 << i)) != 0)\n    # iterate over all edges and add their weights if both endpoints\n    # are in the subset\n    for v, u, w in edges:\n        if (subset & (1 << (v-1))) != 0 and (subset & (1 << (u-1))) != 0:\n            subset_weight += w\n    # update max_weight if this subset has a higher weight\n    max_weight = max(max_weight, subset_weight)\n\nprint(max_weight)"
 ],
 "2284": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nINF = int(1e18) # set a large value for infinite cases\n\n# binary search function to find minimum cost\ndef binary_search(mid):\n    # initialize variables\n    dp = [INF]*(n+1) # dp[i] stores the minimum cost for printing i problems\n    dp[0] = 0\n    for i in range(1, n+1):\n        for j in range(-(k-1), 0):\n            if i+j >= 0:\n                dp[i] = min(dp[i], dp[i+j] + b[i-1] + mid*a[i+j-1])\n    return dp[n]\n\n# initialize variables for binary search\nlow, high = 0, int(1e18)\n\n# do binary search\nwhile low<high:\n    mid = (low+high)//2\n    if binary_search(mid) <= binary_search(mid+1):\n        high = mid\n    else:\n        low = mid+1\n\n# output the minimum cost\nprint(binary_search(low))"
 ],
 "2285": [
  "import re\n\nn = int(input())\nfor i in range(n):\n    s = input().strip()\n    full = \"0000:0000:0000:0000:0000:0000:0000:0000\"\n    if s == \"::\":\n        full = s + full\n    elif s[0] == \":\":\n        s = \"0\" + s\n    elif s[-1] == \":\":\n        s += \"0\"\n\n    blocks = s.split(\":\")\n    blocks_len = len(blocks)\n    zero_idx = [idx for idx, value in enumerate(blocks) if value == \"\"]\n    if zero_idx:\n        if len(zero_idx) == 1:\n            zero_len = blocks_len - 1\n            zero_idx = zero_idx[0]\n        else:\n            zero_len = blocks_len - len(blocks[zero_idx[0]:zero_idx[-1]+1])\n    else:\n        zero_len = 0\n\n    full_blocks = []\n    for b in blocks:\n        if b == \"\":\n            full_blocks += [\"0000\"] * (8 - blocks_len + 1)\n        else:\n            full_blocks.append(b.zfill(4))\n\n    full = \":\".join(full_blocks)\n    full = full.replace(\":0000:\", \"::\", 1)\n    full = full.replace(\":0000:\", \":0\" * (7 - zero_len) + \":\", 1)\n    full = full.replace(\"0000:\", \"0\" * (4 - len(str(zero_len))) + str(zero_len), 1)\n    print(full)"
 ],
 "2286": [
  "n = int(input())\nknows = [input() for _ in range(n)]\nknows_set = [set(j for j in range(n) if knows[i][j] == '1') for i in range(n)]\nans = [0] * (1 << (n - 1))\n\nfor i in range(1 << (n - 1)):\n    perms = [set() for _ in range(n)]\n    curr_bit = 1\n    for j in range(n - 1):\n        if i & curr_bit:\n            curr_pair = (j, j + 1)\n        else:\n            curr_pair = (j + 1, j)\n        perms[curr_pair[0]].add(curr_pair[1])\n        curr_bit <<= 1\n    fact = 1\n    for j in range(1, n + 1):\n        fact *= j\n    for j in range(n):\n        no_contra_pairs = fact\n        for k in range(j + 1, n):\n            if k in perms[j]:\n                no_contra_pairs //= 2\n        for k in range(j, n):\n            if j in perms[k]:\n                no_contra_pairs //= 2\n        if len(perms[j]) > len(knows_set[j]):\n            no_contra_pairs = 0\n        ans[i] += no_contra_pairs\n\nprint(*ans)"
 ],
 "2287": [
  "t = int(input())\n\nfor _ in range(t):\n    s = input().strip()\n    ones = s.count('1')\n    if ones == 0:\n        print(0)\n    else:\n        max_len = 0\n        consecutive = 0\n        for c in s:\n            if c == '1':\n                consecutive += 1\n            else:\n                max_len = max(max_len, consecutive)\n                consecutive = 0\n        max_len = max(max_len, consecutive)\n        print(ones - max_len)"
 ],
 "2288": [
  "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    count1 = b.count(1)\n    count0 = b.count(0)\n\n    if count1 > 0 and count0 > 0:\n        a.sort()\n        print(\"Yes\")\n    else:\n        print(\"Yes\" if a == sorted(a) else \"No\")"
 ],
 "2289": [
  "import bisect\n\nn, q = map(int, input().split())\na = list(map(int, input().split()))\np = [0] * n\nfor i in range(n):\n    p[i] = p[i - 1] + a[i]\n\nfor i in range(q):\n    k = int(input())\n    lo, hi = 0, n\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if p[mid] >= k:\n            hi = mid\n        else:\n            lo = mid + 1\n    ans = n - lo\n    print(ans)"
 ],
 "2290": [
  "from collections import defaultdict\n\nn, m = map(int, input().split())\ngraph = defaultdict(set)\n\nfor i in range(m):\n    u, v = map(int, input().split())\n    graph[u].add(v)\n    graph[v].add(u)\n\nparent = [i for i in range(n + 1)]\ncount = 0\n\ndef find(u):\n    if parent[u] == u:\n        return u\n    parent[u] = find(parent[u])\n    return parent[u]\n\nfor i in range(1, n + 1):\n    p = find(i)\n    for j in range(i + 1, n + 1):\n        if find(j) != p:\n            if j not in graph[i] and i not in graph[j]:\n                parent[find(j)] = p\n                count += 1\n\nprint(count)"
 ],
 "2291": [
  "n = int(input())\na = list(map(int, input().split()))\n\nans = 0\nfor i in range(30):\n    cnt = 0\n    for j in range(n):\n        if a[j] & (1 << i):\n            cnt += 1\n    if cnt > n // 2:\n        ans |= (1 << i)\n\nres = 0\nfor i in range(n):\n    res = max(res, a[i] ^ ans)\n\nprint(ans, end=\"\")"
 ],
 "2292": [
  "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    a_odd = sum([1 for i in a if i%2==1])\n    b_odd = sum([1 for i in b if i%2==1])\n    if a_odd != b_odd:\n        print(\"NO\")\n        continue\n    a_even = n - a_odd\n    b_even = n - b_odd\n    if a_even != b_even:\n        print(\"NO\")\n        continue\n    a_sorted = sorted(a)\n    b_sorted = sorted(b)\n    if a_sorted != b_sorted:\n        print(\"NO\")\n        continue\n    print(\"YES\")"
 ],
 "2293": [
  "from math import gcd\nfrom itertools import product\nm, n = map(int, input().split())\ndora = []\nfor _ in range(m):\n    dora.append(set(map(int, input().split()[1:])))\nfor c in product(range(1, n+1), repeat=m):\n    swiper = set(range(1, n+1))\n    for i, d in enumerate(dora):\n        if len(d) == 0:\n            continue\n        if set(c[i] for i in d) != d:\n            break\n        swiper -= d\n    else:\n        dora_lcm = 1\n        swiper_lcm = 1\n        for i, a in enumerate(c, 1):\n            if i in dora:\n                dora_lcm = dora_lcm * a // gcd(dora_lcm, a)\n            else:\n                swiper_lcm = swiper_lcm * a // gcd(swiper_lcm, a)\n        if dora_lcm > swiper_lcm:\n            print(\"possible\")\n            break\nelse:\n    print(\"impossible\")"
 ],
 "2294": [
  "from collections import defaultdict\n\nmultiset = defaultdict(list) #initialize a defaultdict to store the multiset elements\ntimes = [] #initialize a list to store all the query times\n\nn = int(input())\nfor i in range(n):\n    a, t, x = map(int, input().split())\n    times.append(t)\n    if a == 1:\n        multiset[x].append(t)\n    elif a == 2:\n        multiset[x].pop() #remove the last occurrence of x in the multiset\n    else:\n        count = 0\n        for j in multiset[x]:\n            if j <= t:\n                count += 1 #increment count only for occurrences before or at time t\n        print(count)"
 ],
 "2295": [
  "n = int(input())\na = list(map(int, input().split()))\n\nfreq = [0] * (10**6 + 1)\nunique = 0\nans = 0\n\nfor r in range(n):\n    freq[a[r]] += 1\n    if freq[a[r]] == 1:\n        unique += 1\n    while unique > r + 1:\n        freq[a[l]] -= 1\n        if freq[a[l]] == 0:\n            unique -= 1\n        l += 1\n    ans += (r - l + 2) * (r - l + 1) / 2\n\nprint(\"{:.6f}\".format(ans / (n * (n + 1) / 2)))"
 ],
 "2296": [
  "import math\nfrom itertools import cycle\n\nn, q = map(int, input().split())\nvertices = [tuple(map(int, input().split())) for _ in range(n)]\npins = list(range(2))\n\ndef orientation(p, q, r):\n    return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n\ndef tangent(p, q, r):\n    if orientation(p, q, r) > 0:\n        return 1\n    elif orientation(p, q, r) < 0:\n        return -1\n    else:\n        return 0\n\ntangents = [(i-1, i, i+1) for i in range(n)]\n\nfor t in tangents:\n    if orientation(vertices[t[0]], vertices[t[1]], vertices[t[2]]) < 0:\n        t = t[::-1]\n    for p, q, r in [(pins[0], t[1], pins[1]), (pins[1], t[1], pins[0])]:\n        if tangent(vertices[p], vertices[q], vertices[r]) > 0:\n            pins[0], pins[1] = p, r\n            break\n\nangles = [0] * n\nfor i, p in enumerate(vertices):\n    x, y = vertices[pins[0]], vertices[pins[1]]\n    px, py = p[0] - x[0], p[1] - x[1]\n    vx, vy = x[0] - y[0], x[1] - y[1]\n    dot = px * vx + py * vy\n    det = px * vy - py * vx\n    angles[i] = math.atan2(det, dot)\n\ncycle_angles = cycle(angles)\ndef get_angle(p):\n    nonlocal cycle_angles\n    next(cycle_angles)\n    return angles[p]\n\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    if query[0] == 1:\n        pins[query[1] - 1] = query[2] - 1\n    if query[0] == 2:\n        angle = get_angle(query[1] - 1)\n        x, y = vertices[pins[0]], vertices[pins[1]]\n        xp, yp = vertices[query[1] - 1]\n        s, c = math.sin(angle), math.cos(angle)\n        xr = c * (xp - x[0]) - s * (yp - x[1]) + x[0]\n        yr = s * (xp - x[0]) + c * (yp - x[1]) + x[1]\n        print(\"{:.10f} {:.10f}\".format(xr, yr))"
 ],
 "2297": [
  "q = int(input())\nfor i in range(q):\n    l, r = map(int, input().split())\n    n = (r - l + 1) // 2\n    if n % 2 == 0:\n        print(n)\n    else:\n        if r % 2 == 0:\n            print(-n)\n        else:\n            print(n-r)"
 ],
 "2298": [
  "for _ in range(int(input())):\n    a,b,q = map(int, input().split())\n    for i in range(q):\n        l,r = map(int,input().split())\n        lcm = (a*b)//(gcd(a,b))\n        c1 = r//lcm * (lcm - max(a,b)) \n        c1 += (r%lcm+1 - max(0,r%lcm+1-lcm) - max(0,r%lcm+1-min(a,b))) if r%lcm >= max(a,b) else 0\n        c1 -= (l-1)//lcm * (lcm - max(a,b))\n        c1 -= (l-1)%lcm + 1 - max(0,(l-1)%lcm+1 - max(a,b)) - max(0,(l-1)%lcm+1 - min(a,b)) if (l-1)%lcm >= max(a,b) else 0\n        print(r-l+1-c1, end=\" \")\n    print()"
 ],
 "2299": [
  "n, m = map(int, input().split())\ntable = [list(map(int, input().split())) for _ in range(n)]\nk = int(input())\n \n# Create a list of sets, where each set is the set of all columns\n# that are sorted in non-decreasing order in the corresponding range of rows.\nsorted_cols = [set(range(m)) for _ in range(n)]\nfor j in range(m):\n    for i in range(n - 1):\n        if table[i][j] > table[i + 1][j]:\n            # If the j-th column is not sorted in non-decreasing order\n            # we remove it from the set of all sorted columns for the corresponding rows.\n            for r in range(i + 1):\n                sorted_cols[r].discard(j)\n \n# Check each task\nfor _ in range(k):\n    l, r = map(int, input().split())\n    # Check if there is at least one column that is sorted in non-decreasing order\n    # for all rows in the given range.\n    if any(sorted_cols[i] for i in range(l - 1, r)):\n        print(\"Yes\")\n    else:\n        print(\"No\")"
 ],
 "2300": [
  "def fib(n):\n    if n == 0:\n        return 1\n    if n == 1:\n        return 1\n    return fib(n-1) + fib(n-2)\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\nfor _ in range(m):\n    query = list(map(int, input().split()))\n    if query[0] == 1:\n        x, v = query[1], query[2]\n        a[x-1] = v\n    elif query[0] == 2:\n        l, r = query[1], query[2]\n        result = 0\n        f0, f1 = 1, 1\n        for i in range(r-l+1):\n            result += fib(i) * a[l+i-1]\n            if i >= 2:\n                f0, f1 = f1, f0 + f1 - 1\n        print(result % 1000000000)\n    else:\n        l, r, d = query[1], query[2], query[3]\n        for i in range(l-1, r):\n            a[i] += d"
 ],
 "2301": [
  "n = int(input())\na = list(map(int, input().split()))\n\nb = sorted(a)\nnew_a = [0] * n\n\nfor i in range(1, n, 2):\n    new_a[i] = b.pop()\n\nfor i in range(0, n, 2):\n    new_a[i] = b.pop()\n\ncount = 0\nfor i in range(1, n-1):\n    if new_a[i] < new_a[i-1] and new_a[i] < new_a[i+1]:\n        count += 1\n\nprint(count)\nprint(*new_a)"
 ],
 "2302": [
  "import heapq\n\nn = int(input())\na = list(map(int, input().split()))\nq = int(input())\n\nrewards = [[] for _ in range(n)]\nmilestone_count = 0\nmilestones = []\n\ndef add_milestone(s, t, u):\n    heapq.heappush(milestones, (t, milestone_count, s, u))\n    milestone_count += 1\n\ndef remove_milestones(s, t):\n    rewards[s - 1] = [reward for reward in rewards[s - 1] if reward[0] != t]\n\ndef produce(resource, produced):\n    produced[resource - 1] += 1\n    for reward in rewards[resource - 1]:\n        if produced[reward[2] - 1] >= reward[1]:\n            produced[reward[2] - 1] -= reward[1]\n            produced[reward[0] - 1] += 1\n    \n    return produced\n\ndef is_goal_achieved(produced):\n    for i in range(n):\n        if produced[i] < a[i]:\n            return False\n    return True\n\nproduced = [0] * n\nturns = 0\n\nfor _ in range(q):\n    s, t, u = map(int, input().split())\n    remove_milestones(s, t)\n    if u != 0:\n        rewards[s - 1].append((t, u, s))\n    heapq.heappush(milestones, (t, milestone_count, s, 0))\n    milestone_count += 1\n\n    while milestones:\n        milestone = heapq.heappop(milestones)\n        if milestone[3] == 0:\n            turns += 1\n            produced = produce(milestone[2], produced)\n            if is_goal_achieved(produced):\n                print(turns)\n                break\n        else:\n            rewards[milestone[2] - 1].append((milestone[0], milestone[3], s))\n"
 ],
 "2303": [
  "class Solution:\n    def reverseWords(self, s: str) -> str:\n        words = s.split()\n        words.reverse()\n        return \" \".join(words)"
 ],
 "2304": [
  "n, m = map(int, input().split())\np = list(range(n + 1))\ndef find(x):\n    if p[x] != x:\n        p[x] = find(p[x])\n    return p[x]\nfor i in range(m):\n    l, r, d = map(int, input().split())\n    if find(l) == find(r):\n        if d != (p[l] - p[r]):\n            print(\"No\")\n            exit()\n    else:\n        p[find(l)] = find(r)\n        p[l] = p[r] + d\nprint(\"Yes\")"
 ],
 "2305": [
  "from collections import defaultdict\n\nn = int(input())\nc = list(map(int, input().split()))\n\n# build adjacency list\nadj_list = defaultdict(list)\nfor _ in range(n-1):\n    a,b = map(int, input().split())\n    adj_list[a].append(b)\n    adj_list[b].append(a)\n\n# dfs to count simple paths that visit each color\ncolor_count = [0]*n\npath_count = [0]*n\n\ndef dfs(node, parent):\n    color_count[c[node-1]-1] += 1\n    for neighbor in adj_list[node]:\n        if neighbor != parent:\n            dfs(neighbor, node)\n            # update path count\n            path_count[node-1] += path_count[neighbor-1]\n    # update path count for node\n    path_count[node-1] += color_count[c[node-1]-1]\n\ndfs(1,0)\n\n# print the answer\nfor k in range(1,n+1):\n    ans = sum(path_count[i] for i in range(n) if c[i] == k)\n    print(ans)"
 ],
 "2306": [
  "n=int(input())\nt=list(map(int,input().split()))\nv=list(map(int,input().split()))\n\nd=[0]*(sum(t)*2+1)\ndist=0\n\n#Section 1\ntime=0\nfor i in range(n):\n    for j in range(t[i]*2):\n        if j%2==0:\n            time+=0.5\n        else:\n            time+=0.1*v[i]\n        d[int(time*10)] = min(d[int(time*10)],dist)\n    dist=d[int(time*10)]\n\n#Section 2\ntime=0\nv_max=0\nfor i in range(2*sum(t)):\n    if i%20==0:\n        v_max = min(v_max+0.5, v[i//20])\n    d[i+1] = min(d[i+1],dist+v_max*0.1)\n    dist=d[i+1]\n\n#Section 3\ntime=0\nfor i in range(n-1,-1,-1):\n    for j in range(t[i]*2):\n        if j%2==0:\n            time+=0.5\n        else:\n            time+=0.1*v[i]\n        d[int(time*10)] = min(d[int(time*10)], dist)\n    dist=d[int(time*10)]\n\nprint(\"{:.10f}\".format(sum(d)/20))"
 ],
 "2307": [
  "n = int(input())\na = list(map(int,input().split()))\nc = 0\nfor i in a:\n    if i%2 == 0:\n        c += 1\nif c > n//2:\n    print(\"READY FOR BATTLE\")\nelse:\n    print(\"NOT READY\")"
 ],
 "2308": [
  "from math import log2\nT = int(input())\nfor t in range(T):\n    x = input().strip()\n    y = input().strip()\n    k = len(x)-len(y)\n    y += '0'*k\n    rev_k = bin(int(x,base=2) + int(y,base=2)*(2**k))[2:][::-1]\n    ans = 0\n    for i in range(len(rev_k)):\n        if rev_k[i] == '1':\n            ans = max(ans,i)\n    print(ans)"
 ],
 "2309": [
  "from collections import defaultdict\n\nn = int(input())\nwords = [input().strip() for _ in range(n)]\n\n# group the words based on the number of vowels and the last vowel\ngrouped_words = defaultdict(list)\nfor word in words:\n    last_vowel = ''\n    vowel_count = 0\n    for i in range(len(word)-1, -1, -1):\n        if word[i] in {'a', 'e', 'i', 'o', 'u'}:\n            vowel_count += 1\n            if not last_vowel:\n                last_vowel = word[i]\n    grouped_words[(vowel_count, last_vowel)].append(word)\n    \n# form beautiful lyrics\nlyrics = []\nfor k, v in grouped_words.items():\n    for i in range(0, len(v), 2):\n        if i+1 < len(v):\n            lyrics.append((v[i], v[i+1]))\n            \n# output\nprint(len(lyrics))\nfor line in lyrics:\n    print(line[0], line[1])"
 ],
 "2310": [
  "for _ in range(int(input())):\n    input()\n    portions = list(map(int, input().split()))\n    taken = [0] * len(portions)\n    for i in range(int(input()[0])-1):\n        d, d_t = map(int, input().split())\n        if d != 0:\n            portions[d-1] -= 1\n            if d_t == 1:\n                taken[d-1] = 1\n    res = ''\n    for i in range(len(portions)):\n        if portions[i]-taken[i] > int(input()[0])-1-len(taken):\n            res += 'Y'\n        else:\n            res += 'N'\n    print(res)"
 ],
 "2311": [
  "n,m,k=map(int,input().split())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\nif n<m:\n    n,m,a,b=m,n,b,a #making rows n\nans=0\nfor i in range(n):\n    if a[i]==0:\n        continue\n    l=0\n    for j in range(m):\n        if b[j]==0:\n            l=j+1\n            continue\n        while l<j and ((j-l+1)*(i+1))-(sum(a[i-l+1:i+1]))>k:\n            l+=1\n        if ((j-l+1)*(i+1))-(sum(a[i-l+1:i+1]))==k:\n            ans+=1\nprint(ans)"
 ],
 "2312": [
  "t = int(input())\nfor _ in range(t):\n    n = int(input()) \n    b = list(map(int, input().split()))\n    pow_of_2 = []\n    sums = set()\n    for i in range(n):\n        for j in range(i, n):\n            pow_of_2.append(2**b[i])\n            if i != j:\n                pow_of_2[-1] += 2**b[j]\n            sums.add(pow_of_2[-1])\n    if len(sums) != len(pow_of_2):\n        print(\"YES\")\n    else:\n        print(\"NO\")"
 ],
 "2313": [
  "MOD = 998244353\n\nn = int(input())\nc = list(map(int, input().split()))\nc.sort(reverse=True)\n\npre = [0] * (n + 1)\nfor i in range(n):\n    pre[i+1] = pre[i] + c[i]\n\nans = [0] * n\nfor k in range(1, n+1):\n    dp = [0] * k\n    for j in range(n):\n        p = (j + 1) % n\n        for i in range(k-1, -1, -1):\n            if c[p] >= c[i]:\n                dp[i] = dp[i] + (pre[k] - pre[i]) / k\n            else:\n                dp[i] = dp[i] + (dp[i+1] - dp[i]) * (c[p] / c[i])\n    ans[k-1] = dp[0]\n\nres = []\ninv_q = pow(n, MOD-2, MOD)\nfor i in range(n):\n    val = (ans[i] % MOD) * inv_q % MOD\n    res.append(str(val))\n\nprint(' '.join(res))"
 ],
 "2314": [
  "n,m,q=map(int,input().split())\ngrid=[input() for i in range(n)]\n\ndef check(x1,y1,x2,y2):\n    red,green,yellow,blue=False,False,False,False\n    for i in range(x1,x2+1):\n        for j in range(y1,y2+1):\n            if grid[i][j]=='R':\n                red=True\n            if grid[i][j]=='G':\n                green=True\n            if grid[i][j]=='Y':\n                yellow=True\n            if grid[i][j]=='B':\n                blue=True\n    if red and blue and green and yellow:\n        return True\n    else:\n        return False\n\ndef binary_search(left,right,row):\n    low=left\n    high=right\n    val=-1\n    while low<=high:\n        middle=(low+high)//2\n        if check(row,middle,row+middle-left,middle+row-left):\n            val=middle-left+1\n            low=middle+1\n        else:\n            high=middle-1\n    return val\n\nfor i in range(q):\n    r1,c1,r2,c2=map(int,input().split())\n    ans=0\n    for j in range(r1-1,r2):\n        val=binary_search(c1-1,c2-1,j)\n        ans=max(ans,val*(val+2*(j-r1+c1)+1))\n    print(ans)"
 ],
 "2315": [
  "for _ in range(int(input())):\n    l, r = map(int, input().split())\n    print(l, l*2)"
 ],
 "2316": [
  "t = int(input())\nfor i in range(t):\n    x, n, m = map(int, input().split())\n    while n and x > 20:\n        x = x // 2 + 10\n        n -= 1\n    x -= 10 * m\n    print(\"YES\" if x <= 0 else \"NO\")"
 ],
 "2317": [
  "import heapq\n\nn, m, a, b = map(int, input().split())\nai = list(map(int, input().split()))\nbi = list(map(int, input().split()))\nli = list(map(int, input().split()))\n\nheap = []\nans_x, ans_y = 1, 1\nans_d = 1e18\n\nfor i in range(n):\n    x = ai[i]\n    j = ans_y - 1\n    if j >= 0:\n        y = bi[j] - l[j]\n        d = ((x - a) ** 2 + y ** 2) ** 0.5 + l[j] + b - a\n        if d < ans_d:\n            ans_d = d\n            ans_x, ans_y = i + 1, j + 1\n    while j < m and bi[j] < x:\n        j += 1\n    if j < m:\n        y = bi[j] - l[j]\n        d = ((x - a) ** 2 + y ** 2) ** 0.5 + l[j] + b - a\n        if d < ans_d:\n            ans_d = d\n            ans_x, ans_y = i + 1, j + 1\n    if j > 0:\n        j -= 1\n        y = bi[j] - l[j]\n        d = ((x - a) ** 2 + y ** 2) ** 0.5 + l[j] + b - a\n        if d < ans_d:\n            ans_d = d\n            ans_x, ans_y = i + 1, j + 1\n\nprint(ans_x, ans_y)"
 ],
 "2318": [
  "n = int(input())\nfor i in range(n):\n    s = input().rstrip()\n    t = input().rstrip()\n    j = 0\n    for ch in t:\n        if j == len(s):\n            print(\"NO\")\n            break\n        if s[j] == ch:\n            j += 1\n    else:\n        if j == len(s):\n            print(\"YES\")\n        else:\n            print(\"NO\")"
 ],
 "2319": [
  "from collections import defaultdict\ndef equal_strings(n,s,t):\n    if sorted(s)!=sorted(t):\n        return -1\n    for i in range(n):\n        if s[i:]+s[:i]==t:\n            return n-i\n    return 0\n\nfor _ in range(int(input())):\n    n = int(input())\n    s = input().strip()\n    t = input().strip()\n    print(equal_strings(n,s,t))"
 ],
 "2320": [
  "for _ in range(int(input())):\n    n = int(input())\n    s = input()\n    t = input()\n    if sorted(s) != sorted(t):\n        print(-1)\n    else:\n        ans = []\n        for i in range(n):\n            if s[i] != t[i]:\n                j = i\n                while j < n and s[j] != t[i]:\n                    j += 1\n                ans += list(range(i, j))[::-1]\n                s = s[:i] + s[i:j][::-1] + s[j:]\n        print(len(ans))"
 ],
 "2321": [
  "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input()\n    l_gt = s.find('>')\n    r_lt = s.rfind('<')\n    if l_gt == -1 or r_lt == -1:\n        print('0')\n    else:\n        print(min(l_gt, n - 1 - r_lt))"
 ],
 "2322": [
  "n, m = map(int, input().split())\nfield = [input() for _ in range(n)]\n\nstart_pos = None\nfor i in range(n):\n    for j in range(m):\n        if field[i][j] == \"S\":\n            start_pos = (i, j)\n\ndirections = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up\nopposite_directions = {0: 2, 1: 3, 2: 0, 3: 1} # opposite of each direction\n\ndef next_pos(pos, direction):\n    return (pos[0] + directions[direction][0], pos[1] + directions[direction][1])\n\ndef find_next_direction(pos, curr_dir):\n    for i in range(4):\n        next_dir = (curr_dir + i) % 4\n        next_pos_val = field[next_pos(pos, next_dir)[0]][next_pos(pos, next_dir)[1]]\n        if next_pos_val == \"*\":\n            return next_dir\n    return opposite_directions[curr_dir]\n\nvisited = set()\nvisited.add(start_pos)\ncurr_pos = start_pos\ncurr_direction = 0 # start with right direction\n\ncommands = \"\"\n\nwhile True:\n    next_direction = find_next_direction(curr_pos, curr_direction)\n    if next_direction == curr_direction:\n        break\n    commands += \"UDLR\"[next_direction]\n    curr_direction = next_direction\n    curr_pos = next_pos(curr_pos, curr_direction)\n    visited.add(curr_pos)\n\nprint(commands)"
 ],
 "2323": [
  "n = int(input())\ns = list(map(int, input().split()))\nq = int(input())\nfor i in range(q):\n    l, r = map(int, input().split())\n    pitches = set()\n    for j in range(n):\n        for k in range(l, r+1):\n            pitches.add(s[j]+k)\n    print(len(pitches))"
 ],
 "2324": [
  "s = input().strip()\nn = len(s)\np = [[0]*n for i in range(n)]\nfor l in range(1, n+1):\n    for i in range(n-l+1):\n        j = i+l-1\n        if (l == 1):\n            p[i][j] = 1\n        elif (l == 2):\n            p[i][j] = (s[i] == s[j])\n        else:\n            p[i][j] = (s[i] == s[j] and p[i+1][j-1])\n    for i in range(n):\n        for j in range(i, n):\n            k = j - i + 1\n            if p[i][j]:\n                k //= 2\n                pal_cnt[k] += 1\nprint(*pal_cnt[1:n+1])"
 ],
 "2325": [
  "MOD = 10 ** 9 + 7\n\ndef factorize(x, y):\n    factors = []\n    for i in range(2, int(x ** 0.5) + 1):\n        if x % i == 0:\n            cnt = 0\n            while x % i == 0:\n                cnt += 1\n                x //= i\n            factors.append(cnt)\n    if x > 1:\n        factors.append(1)\n    if len(factors) < y:\n        return 0\n    num_factors = len(factors)\n    dp = [[0] * (y + 1) for _ in range(num_factors + 1)]\n    dp[0][0] = 1\n    for i in range(1, num_factors + 1):\n        dp[i][0] = 1\n        for j in range(1, y + 1):\n            dp[i][j] = (dp[i - 1][j] + factors[i - 1] * dp[i - 1][j - 1]) % MOD\n    return dp[num_factors][y]\n\nq = int(input())\nfor _ in range(q):\n    x, y = map(int, input().split())\n    print(factorize(x, y))"
 ],
 "2326": [
  "MOD = 998244353\n\nn = int(input())\na = list(map(int, input().split()))\n\ndp = [[0] * n for _ in range(n)]\nans = 0\n\nfor i in range(n):\n    if a[i] > 0:\n        dp[i][i] = 1\n        ans += 1\n\nfor l in range(2, n+1):\n    for i in range(n-l+1):\n        j = i + l - 1\n        if a[j] == l-1:\n            dp[i][j] = 1\n            for k in range(i, j):\n                dp[i][j] += dp[i][k] * dp[k+1][j]\n                dp[i][j] %= MOD\n            ans += dp[i][j]\n            ans %= MOD\n\nprint(ans % MOD)"
 ],
 "2327": [
  "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    ans = n*(n+1)//2\n    bit = 0\n    while (1<<bit) <= n:\n        cnt = (n+1)//(1<<(bit+1)) * (1<<bit)\n        rem = (n+1)%(1<<(bit+1))\n        cnt += max(0, rem-(1<<bit))\n        ans -= cnt*2\n        bit += 1\n    print(ans)"
 ],
 "2328": [
  "from bisect import bisect_left\n\nt=int(input())\n\nfor _ in range(t):\n    n,k=map(int,input().split())\n    a=list(map(int,input().split()))\n\n    ans=1e18\n\n    r=a[n-1]\n\n    for i in range(n):\n        l=a[i]\n        while True:\n            pos1=bisect_left(a,l)\n            pos2=pos1-1\n            cnt1=pos1-i-1\n            cnt2=i-cnt1-1\n            if cnt1<k and cnt2<=k:\n                break\n            if cnt1>=k:\n                ans=min(ans,l-a[i+max(0,k-cnt2)])\n            if cnt2>k:\n                ans=min(ans,a[i+1+min(cnt1,k)])\n            l+=1\n    if n==1:\n        print(a[0])\n    else:\n        print(int(ans))"
 ],
 "2329": [
  "from collections import defaultdict\nfrom math import log2\n\ndef merge(u, v):\n    pu, pv = find(u), find(v)\n    if rank[pu] < rank[pv]:\n        pu, pv = pv, pu\n    ans = max(height[pu] + 1, height[pv])\n    height[pu] = ans\n    fa[pv] = pu\n    rank[pu] += rank[pu] == rank[pv]\n    return ans\n    \n    \ndef find(x):\n    if fa[x] == x:\n        return x\n    fa[x] = find(fa[x])\n    return fa[x]\n\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\nmax_log_n = int(log2(n)) + 2 \nanc_arr = [[0] * max_log_n for _ in range(n + 1)]\nheight = [0] * (n + 1)\nrank = [1] * (n + 1)\nfa = list(range(n + 1))\ncnt_towers = defaultdict(list)\nfor i, x in enumerate(a):\n    cnt_towers[x].append(i + 1)\n\nfor i in range(1, n + 1):\n    anc_arr[i][0] = i\n    height[i] = 1\n\nans = []\nfor i in range(m - 1):\n    u, v = map(int, input().split())\n    \n    u, v = cnt_towers[u], cnt_towers[v]\n    if len(u) < len(v):\n        u, v = v, u\n    for j, p in enumerate(v):\n        new_p = u[j]\n        ans.append(merge(new_p, p))\n        anc_arr[new_p][0] = p\n        if rank[new_p] > 1:\n            continue\n        \n        for k in range(1, max_log_n):\n            anc_arr[new_p][k] = anc_arr[anc_arr[new_p][k - 1]][k - 1]\n            \n            if anc_arr[new_p][k] == 0:\n                break\n                \n    cnt_towers[u[0]].extend(cnt_towers.pop(v[0]))\n        \nprint('\\n'.join(map(str, ans)))"
 ],
 "2330": [
  "from heapq import heapify, heappop, heappush\nfrom collections import defaultdict\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    if m < n or n == 2:\n        print(-1)\n    else:\n        chain_weights = []\n        for i in range(n):\n            for j in range(i+1, n):\n                w = a[i]+a[j]\n                chain_weights.append((w, i, j))\n        heapify(chain_weights)\n        private_fridges = [i for i in range(n)]\n        connections = defaultdict(list)\n        chain_count = 0\n        cost = 0\n        while chain_count < n-1 and chain_count < m:\n            w, u, v = heappop(chain_weights)\n            # check if u and v already connected\n            p1, p2 = u, v\n            while private_fridges[p1] != p1:\n                p1 = private_fridges[p1]\n            while private_fridges[p2] != p2:\n                p2 = private_fridges[p2]\n            if p1 == p2:\n                continue\n            # connect u and v\n            if len(connections[u]) < 2 and len(connections[v]) < 2:\n                chain_count += 1\n                cost += w\n                connections[u].append(v)\n                connections[v].append(u)\n            # ensure u and v are private fridges\n            u_ = u\n            while private_fridges[u_] != u_:\n                u_ = private_fridges[u_]\n            v_ = v\n            while private_fridges[v_] != v_:\n                v_ = private_fridges[v_]\n            if u_ != v_:\n                private_fridges[v_] = u_\n                private_fridges[p2] = p1\n        \n        if chain_count < n-1:\n            print(-1)\n        else:\n            print(cost)\n            for u, vs in connections.items():\n                for v in vs:\n                    print(u+1, v+1)"
 ],
 "2331": [
  "t=int(input())\nfor i in range(t):\n    a,b=map(int,input().split())\n    if a==b:\n        print(\"Infinite\")\n    elif a>b:\n        if a%(a-b)==0:\n            print(\"Infinite\")\n        else:\n            print(\"Finite\")\n    else:\n        if b%(b-a)==0:\n            print(\"Infinite\")\n        else:\n            print(\"Finite\")"
 ],
 "2332": [
  "n, k, m = map(int, input().split())\nwords = input().split()\ncosts = list(map(int, input().split()))\nparent = list(range(n))\nsize = [1] * n\n\ndef find(x):\n    if x == parent[x]:\n        return x\n    parent[x] = find(parent[x])\n    return parent[x]\n\ndef unite(x, y):\n    x = find(x)\n    y = find(y)\n    if x == y:\n        return\n    if size[x] < size[y]:\n        x, y = y, x\n    parent[y] = x\n    size[x] += size[y]\n\nfor i in range(k):\n    group = list(map(int, input().split()))\n    for j in range(1, len(group)):\n        unite(group[j]-1, group[1]-1)\n\nmessage = input().split()\nans = 0\nfor word in message:\n    idx_list = [i for i in range(n) if find(i) == find(words.index(word))]\n    min_cost = float('inf')\n    for idx in idx_list:\n        min_cost = min(min_cost, costs[idx])\n    ans += min_cost\nprint(ans)"
 ],
 "2333": [
  "n = int(input())\na = list(map(int, input().split()))\n\nans = 0\nfor i in range(n):\n    s = set()\n    for j in range(i, n):\n        if a[j] in s:\n            break\n        s.add(a[j])\n        if len(s) == j - i + 1:\n            ans += 1\nprint(ans)"
 ],
 "2334": [
  "# Reading input values\nn = int(input())\na = list(map(int, input().split()))\nx, f = map(int, input().split())\n\n# Calculating total fee required\ntotal_fee = 0\nfor amount in a:\n    num_tx = amount // x\n    if amount % x != 0:\n        num_tx += 1\n    total_fee += (num_tx - 1) * f\n\n# Printing output\nprint(total_fee)"
 ],
 "2335": [
  "n = int(input())\nred_points = []\ngreen_points = []\nblue_points = []\nfor i in range(n):\n    p, c = input().split()\n    p = int(p)\n    if c == \"R\":\n        red_points.append(p)\n    elif c == \"G\":\n        green_points.append(p)\n    else:\n        blue_points.append(p)\n\nred_size, green_size, blue_size = len(red_points), len(green_points), len(blue_points)\n\n# create adjacency list for green points\ngreen_adj = [[] for _ in range(green_size)]\n\n# connect green points to their nearest blue neighbors\nfor i in range(green_size):\n    min_dist = float('inf')\n    for j in range(blue_size):\n        dist = abs(green_points[i] - blue_points[j])\n        if dist < min_dist:\n            min_dist = dist\n            nearest_blue = j\n    green_adj[i].append((nearest_blue, min_dist))\n\n# sort green points by distance to nearest blue neighbor\nsorted_green = sorted([(i, green_adj[i][0][1]) for i in range(green_size)], key=lambda x: x[1])\n\n# find minimum spanning tree for green points\nparent = [-1] * green_size\nrank = [0] * green_size\n\ndef find(i):\n    if parent[i] != i:\n        parent[i] = find(parent[i])\n    return parent[i]\n\ndef union(i, j):\n    root_i = find(i)\n    root_j = find(j)\n    if root_i == root_j:\n        return False\n    if rank[root_i] < rank[root_j]:\n        root_i, root_j = root_j, root_i\n    parent[root_j] = root_i\n    if rank[root_i] == rank[root_j]:\n        rank[root_i] += 1\n    return True\n\nmst_cost = 0\nfor i, dist in sorted_green:\n    mst_cost += dist\n    u, _ = green_adj[i][0]\n    for j in range(len(green_adj)):\n        if i == j:\n            continue\n        v, d = green_adj[j][0]\n        if u == v and d < dist:\n            union(i, j)\n\n# add edges between red/blue points and nearest green neighbor if they are connected to the same component in mst\nred_sum = 0\nconnected_to_green = [False] * (green_size)\nfor i in range(red_size):\n    min_dist = float('inf')\n    for j in range(green_size):\n        dist = abs(red_points[i] - green_points[j])\n        if dist < min_dist:\n            min_dist = dist\n            nearest_green = j\n    if connected_to_green[find(nearest_green)]:\n        red_sum += min_dist\n    elif find(nearest_green) != -1:\n        connected_to_green[find(nearest_green)] = True\n\nblue_sum = 0\nconnected_to_green = [False] * (green_size)\nfor i in range(blue_size):\n    min_dist = float('inf')\n    for j in range(green_size):\n        dist = abs(blue_points[i] - green_points[j])\n        if dist < min_dist:\n            min_dist = dist\n            nearest_green = j\n    if connected_to_green[find(nearest_green)]:\n        blue_sum += min_dist\n    elif find(nearest_green) != -1:\n        connected_to_green[find(nearest_green)] = True\n\nprint(mst_cost + red_sum + blue_sum)"
 ],
 "2336": [
  "n, k, q = map(int, input().split())\n\nrecipes = []\nfor i in range(n):\n    l_i, r_i = map(int, input().split())\n    recipes.append((l_i, r_i))\n\nqueries = []\nfor i in range(q):\n    a, b = map(int, input().split())\n    queries.append((a, b))\n\ncounts = [0] * (200001)\nfor l_i, r_i in recipes:\n    counts[l_i] += 1\n    counts[r_i+1] -= 1\n\nfor i in range(1, len(counts)):\n    counts[i] += counts[i-1]\n\nfor a, b in queries:\n    ans = sum([1 for i in range(a, b+1) if counts[i] >= k])\n    print(ans)"
 ],
 "2337": [
  "n,m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\ni = j = ans = 0\n\nwhile i<n and j<m:\n    if a[i]<=b[j]:\n        ans += 1\n        i += 1\n        j += 1\n    else:\n        j += 1\n\nprint(n-ans)"
 ],
 "2338": [
  "n = int(input())\nbombs = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    bombs.append((x, y))\n\nbombs.sort(key=lambda x: abs(x[0]) + abs(x[1]))\n\nans = []\nfor x, y in bombs:\n    if x > 0:\n        ans.append((1, x, 'R'))\n    else:\n        ans.append((1, abs(x), 'L'))\n    if y > 0:\n        ans.append((1, y, 'U'))\n    else:\n        ans.append((1, abs(y), 'D'))\n    ans.append((2,))\n    if y > 0:\n        ans.append((1, y, 'D'))\n    else:\n        ans.append((1, abs(y), 'U'))\n    if x > 0:\n        ans.append((1, x, 'L'))\n    else:\n        ans.append((1, abs(x), 'R'))\n    ans.append((3,))\n\nprint(len(ans))\nfor op in ans:\n    if op[0] == 1:\n        print(op[0], op[1], op[2])\n    else:\n        print(op[0])"
 ],
 "2339": [
  "import math\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = [0] * n\n    b[0] = max(a)\n    a.remove(b[0])\n    pos = 1\n    for i in range(n-1):\n        gcd = 0\n        for j in range(len(a)):\n            tempGcd = math.gcd(b[i], a[j])\n            if tempGcd > gcd:\n                gcd = tempGcd\n                pos = j\n        b[i+1] = a[pos]\n        a.remove(b[i+1])\n    print(*b)"
 ],
 "2340": [
  "for _ in range(int(input())):\n    h,n=map(int,input().split())\n    arr=list(map(int,input().split()))\n    ans,prev,i=0,h,0\n    while i<n:\n        while i<n and prev-arr[i]==1:i,prev=i+1,arr[i]\n        if i==n:break\n        ans,prev,j=ans+1,arr[i],i\n        while j<n and prev-arr[j]==1:j,prev=j+1,arr[j]\n        if j==n:ans+=1;break\n        i=j\n    print(ans)"
 ],
 "2341": [
  "n, m = map(int, input().split())\ngrid = []\nfor i in range(n):\n    grid.append(list(input().strip()))\n\ndef get_diagonal(topleft, bottomright):\n    i, j = topleft\n    while i <= bottomright[0] and j <= bottomright[1]:\n        yield (i, j)\n        i += 1\n        j += 1\n\ndef is_valid(topleft, bottomright):\n    color = grid[topleft[0]][topleft[1]]\n    for i, j in get_diagonal(topleft, bottomright):\n        if grid[i][j] != color:\n            return False\n    for i in range(topleft[0], bottomright[0]+1):\n        for j in range(topleft[1], bottomright[1]+1):\n            if grid[i][j] == color and (i, j) not in get_diagonal(topleft, bottomright):\n                return False\n    return True\n\nans = 0\nfor i in range(n):\n    for j in range(m):\n        for k in range(1, min(n-i, m-j)+1):\n            if is_valid((i, j), (i+k-1, j+k-1)):\n                ans += 1\nprint(ans)"
 ],
 "2342": [
  "for _ in range(int(input())):\n    n,m = map(int,input().split())\n    maze = []\n    for i in range(n):\n        maze.append(list(input().strip()))\n\n    good=0    #stores the number of good persons\n    bad=0     #stores the number of bad persons\n    walls=0   #stores the number of walls\n    empties=0 #stores the number of empty cells\n\n    # loop through every cell in the maze\n    for x in range(n):\n        for y in range(m):\n            if maze[x][y]==\"G\":\n                good+=1\n            elif maze[x][y]==\"B\" :\n                bad+=1\n                \n            if maze[x][y]==\".\":\n                empties+=1\n                # check if an empty cell has a bad person as neighbour\n                if (x>0 and maze[x-1][y]==\"B\") or (x<n-1 and maze[x+1][y]==\"B\") or \\\n                    (y>0 and maze[x][y-1]==\"B\") or (y<m-1 and maze[x][y+1]==\"B\"):\n                    print(\"No\")\n                    break\n\n    # if there are no bad persons then it is already safe to go.\n    if bad==0:\n        print(\"Yes\")\n    # if there are bad persons but no empty cells then there is no way to make an escape.\n    elif empties==0:\n        print(\"No\")\n    else:\n        # block empty cells that have bad persons as neighbours\n        for x in range(n):\n            for y in range(m):\n                if maze[x][y]==\".\":\n                    if (x>0 and maze[x-1][y]==\"B\") or (x<n-1 and maze[x+1][y]==\"B\") \\\n                        or (y>0 and maze[x][y-1]==\"B\") or (y<m-1 and maze[x][y+1]==\"B\"):\n                        maze[x][y]=\"#\"\n                        walls+=1\n\n        # check if all good persons can escape\n        visited = [[False]*m for _ in range(n)]\n        def dfs(x,y):\n            visited[x][y]=True\n            if x==n-1 and y==m-1:\n                return\n            if x>0 and maze[x-1][y]!=\"#\" and not visited[x-1][y]: dfs(x-1,y)\n            if x<n-1 and maze[x+1][y]!=\"#\" and not visited[x+1][y]: dfs(x+1,y)\n            if y>0 and maze[x][y-1]!=\"#\" and not visited[x][y-1]: dfs(x,y-1)\n            if y<m-1 and maze[x][y+1]!=\"#\" and not visited[x][y+1]: dfs(x,y+1)\n\n        dfs(0,0)\n        if visited[n-1][m-1]:\n            print(\"Yes\")\n        else:\n            print(\"No\")"
 ],
 "2343": [
  "t = int(input())\n\nfor i in range(t):\n    n, k = map(int, input().split())\n    upper_bound = (2 ** (n + 1)) - 2\n    lower_bound = 2 ** n - 1\n    if k > upper_bound:\n        print('NO')\n    elif k == upper_bound:\n        print('YES', n)\n    else:\n        x = k - lower_bound\n        if x % 2 == 1:\n            print('YES', int(n - 1))\n        else:\n            print('YES', n - (bin(x)[2:].count('0') - 1))"
 ],
 "2344": [
  "n = int(input())\noffers = []\nfor i in range(n):\n    a, b, k = map(int, input().split())\n    offers.append((a, b, k))\n\noffers.sort(key=lambda x: x[1])  # sort by b_i in increasing order\n\nans = 0\nmoney = 0\nfor a, b, k in offers:\n    max_months = (money + a) // b  # maximum number of months this offer can be used\n    remaining_months = k - max_months  # number of months after which Vasya can buy the car\n    ans = max(ans, money + max_months * a)  # update answer\n    money += max_months * a - max(0, max_months - k) * b  # Vasya takes the offer for max_months months, and pays b_i for the remaining months\nprint(ans + money)  # add remaining money to answer"
 ],
 "2345": [
  "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i+1] = prefix_sum[i] + a[i]\n    indices = {}\n    for i in range(n + 1):\n        if prefix_sum[i] in indices:\n            subset = list(range(indices[prefix_sum[i]] + 1, i + 1))\n            print(len(subset))\n            print(\" \".join(str(x) for x in subset))\n            break\n        else:\n            indices[prefix_sum[i]] = i"
 ],
 "2346": [
  "from collections import deque\nn=int(input())\np=list(map(int,input().split()))\nc=list(map(int,input().split()))\n\nans=[]\nq=deque()\nfor i in range(n):\n    if c[i]:\n        q.append(i)\nwhile q:\n    v=q.popleft()\n    if p[v]==-1:\n        print(-1)\n        exit()\n    ans.append(v+1)\n    u=p[v]-1\n    c[u]=0\n    ok=True\n    for i in range(n):\n        if p[i]==u+1 and c[i]:\n            ok=False\n            break\n    if ok:\n        q.append(u)\nprint(*ans)"
 ],
 "2347": [
  "t=int(input())\nfor i in range(t):\n    p=input()\n    h=input()\n    flag=False\n    for j in range(len(h)-len(p)+1):\n        s1=h[:j]\n        s2=h[j+len(p):]\n        p_dash=''.join(sorted(p))\n        h_dash=s1+p_dash+s2\n        if ''.join(sorted(h))==h_dash:\n            flag=True\n            break\n    if flag:\n        print(\"YES\")\n    else:\n        print(\"NO\")"
 ],
 "2348": [
  "n = int(input(), 16)\nprint(n % 2)"
 ],
 "2349": [
  "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    increments = set()\n    for k in range(1, int(n**0.5)+1):\n        increment = n // k - k\n        if increment > 0:\n            increments.add(increment)\n        if increment == 1:\n            break\n    increment_list = sorted(list(increments))\n    print(len(increment_list))\n    print(*increment_list)"
 ],
 "2350": [
  "import math\n\nt=int(input().strip())\nfor i in range(t):\n    x1, y1, x2, y2= map(int, input().split())\n    distx= x2-x1\n    disty= y2-y1\n    print(math.comb(distx+disty, distx))"
 ],
 "2351": [
  "MOD = 998244353\nn, k, l = map(int, input().split())\na = list(map(int, input().split()))\n\ndp0 = [0] * n\ndp1 = [0] * n\nsum0 = [0] * (n + 1)\nsum1 = [0] * (n + 1)\n\nif a[0] == -1:\n    for j in range(1, k + 1):\n        dp0[0] = 1\n        sum0[1] = 1\nelse:\n    dp0[0] = 1\n    sum0[1] = 1\n\nfor i in range(1, n):\n    if a[i] == -1:\n        for j in range(1, k + 1):\n            if i - l >= 0:\n                dp0[i] += sum1[i - l] - sum1[i - l] * (a[i - l] == j) % MOD\n            else:\n                dp0[i] += sum1[i - l]\n            dp0[i] %= MOD\n\n        dp1[i] = sum0[i - 1]\n    else:\n        j = a[i]\n        if i - l >= 0:\n            dp0[i] = sum1[i - l] - sum1[i - l] * (a[i - l] == j) % MOD\n        else:\n            dp0[i] = 0\n        \n        dp1[i] = dp0[i - 1]\n\n    sum0[i + 1] = sum0[i] + dp0[i]\n    sum1[i + 1] = sum1[i] + dp1[i]\n\nprint(sum0[-1] % MOD)\n"
 ],
 "2352": [
  "t = int(input())\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    grid = []\n    for i in range(n):\n        grid.append(input().strip())\n\n    # Find all the snakes, starting with 'a', then 'b', etc.\n    snakes = []\n    for snake_letter in range(97, 123):\n        for i in range(n):\n            for j in range(m):\n                # If this cell hasn't already been used by a previous snake\n                if grid[i][j] == chr(snake_letter):\n                    # Find the right end of the snake\n                    x, y = i, j\n                    while x < n and grid[x][j] == chr(snake_letter):\n                        x += 1\n                    while y < m and grid[i][y] == chr(snake_letter):\n                        y += 1\n                    # Mark all cells in the snake as used\n                    snakes.append((i+1, j+1, x, y))\n                    for a in range(i, x):\n                        for b in range(j, y):\n                            grid[a] = grid[a][:b] + '.' + grid[a][b+1:]\n                    break\n            else:\n                continue\n            break\n        else:\n            # If we didn't find any cells with this letter, stop\n            break\n\n    # Check if all cells are now empty\n    empty = True\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] != '.':\n                empty = False\n                break\n        if not empty:\n            break\n\n    if empty:\n        print(\"YES\")\n        print(len(snakes))\n        for s in snakes:\n            print(*s)\n    else:\n        print(\"NO\")"
 ],
 "2353": [
  "t = int(input())\nfor _ in range(t):\n    a, b, c, d = map(int, input().split())\n    if b >= a:\n        print(b)\n    elif c <= d:\n        print(-1)\n    else:\n        n = ((a-b) + (c-d-1))//(c-d)\n        ans = b + n*c\n        print(ans)"
 ],
 "2354": [
  "n, q = map(int, input().split())\nfor i in range(q):\n    x, y = map(int, input().split())\n    ans = (n*n+1)//2\n    ans += (x-1)*(n//2)\n    if n%2==1 and x%2==1:\n        ans += (y+1)//2\n    elif n%2==1 and x%2==0:\n        ans += n//2 + (y+1)//2\n    elif n%2==0 and x%2==1:\n        ans += (y+1)//2 + (n//2)*((x+1)//2)\n    else:\n        ans += n//2 + (y+1)//2 + (n//2)*((x+1)//2)\n    print(ans - 1)"
 ],
 "2355": [
  "from itertools import combinations\n\nt = int(input())\n\nfor _ in range(t):\n    n, p = map(int, input().split())\n    edges = set()\n    \n    # create a star graph with n vertices\n    for i in range(2, n+1):\n        edges.add((1, i))\n    \n    # add additional edges to fulfill the conditions\n    counter = 0\n    for pair in combinations(range(2, n+1), 2):\n        if counter == p:\n            break\n        edges.add(pair)\n        counter += 1\n    \n    for edge in edges:\n        print(edge[0], edge[1])"
 ],
 "2356": [
  "t = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    odd = [a[i] for i in range(n) if (i+1)%2==1]\n    even = [a[i] for i in range(n) if (i+1)%2==0]\n\n    odd.sort()\n    even.sort()\n\n    ans = []\n    for i in range(n):\n        if (i+1)%2==1:\n            ans.append(odd.pop(0))\n        else:\n            ans.append(even.pop(0))\n\n    print(*ans)"
 ],
 "2357": [
  "T = int(input())\nfor i in range(T):\n    n = int(input())\n    a = list(map(int, input().split()))\n    occ = {}\n    ans = n+1\n    for j in range(n):\n        if a[j] in occ:\n            ans = min(ans, j-occ[a[j]]+1)\n            occ[a[j]] = j\n        else:\n            occ[a[j]] = j\n    print(-1 if ans > n else ans)"
 ],
 "2358": [
  "s = input()\nt = ''\nans = []\nfor i in s:\n    if i == ')':\n        if t and t[-1] == '(':\n            t = t[:-1]\n        else:\n            ans.append(2)\n            if len(t) > 1 and t[0] == '(':\n                ans.append(len(t))\n                for j in range(1, len(t)):\n                    if t[j] == ')':\n                        ans[-1] += 1\n                    else:\n                        ans.append(1)\n                        ans.append(j+1)\n                t = ''\n            else:\n                t += i\n    else:\n        t += i\n\nans.append(0)\nif t:\n    ans.append(len(t))\n    for i in range(len(t)):\n        ans.append(i+1)\n\nprint(len(ans)-1)\nfor i in range(1, len(ans)):\n    print(ans[i])\n    if ans[i]:\n        print(*ans[i+1:i+1+ans[i]])\n"
 ],
 "2359": [
  "import math\nfor _ in range(int(input())):\n    h,c,t = map(int, input().split())\n    if t <= (h + c) / 2:\n        print(2)\n    else:\n        k = math.ceil( (t - h)/(2*t - h - c) )\n        ans1 = abs((k * h) + (k-1)*c - t) * (2*k+1)\n        ans2 = abs((k+1)*h + k*c - t) * (2*k+3)\n        print(2*k+1 if ans1 <= ans2 else 2*k+3)"
 ],
 "2360": [
  "#parse input\ntest_cases = int(input())\nfor i in range(test_cases):\n    n = int(input())\n    queue = [] #list to store queue positions\n    for j in range(n):\n        l, r = map(int, input().split())\n        queue.append((l, r, j)) #append tuple with start time, end time and student index\n    \n    queue.sort() #sort queue based on start time\n    \n    time = 0 #initialize time variable\n    result = [0] * n #initialize result list\n    \n    for l, r, j in queue:\n        time = max(time, l) #update time based on when previous student left\n        if time <= r: \n            #student gets tea\n            result[j] = time \n            time += 1 #update time for next student\n    print(*result) #print result for current test case"
 ],
 "2361": [
  "t = int(input())\nfor i in range(t):\n    n,m,k = map(int,input().split())\n    if m >= (n//k):\n        if m <= (n-n//k):\n            print(n//k-1)\n        else:\n            print(n//k - (m-(n-n//k)))\n    else:\n        print(m)"
 ],
 "2362": [
  "import math\n\ndef gcd(a, b):\n    if b ==0:\n        return a\n    return gcd(b, a%b)\n\nn = int(input())\na = list(map(int, input().split()))\ntree = [[] for _ in range(n)]\nfor i in range(n-1):\n    x,y = map(int, input().split())\n    tree[x-1].append(y-1)\n    tree[y-1].append(x-1)\n\nvisited = [False] * n\ndepth = [0] * n\ndiameter = 0\n\ndef dfs(v, parent, dist):\n    global diameter\n    visited[v] = True\n    depth[v] = dist\n    for u in tree[v]:\n        if not visited[u]:\n            g = gcd(a[v], a[u])\n            if g > 1:\n                dfs(u, v, dist+1)\n            else:\n                dfs(u, v, 1)\n    diameter = max(diameter, depth[v] - depth[parent])\n    return\n\nfor i in range(n):\n    if not visited[i]:\n        dfs(i, i, 0)\n\nif diameter == 0:\n    print(0)\nelse:\n    print(diameter+1)"
 ],
 "2363": [
  "n = int(input())\nfor i in range(n):\n    a, b = map(int, input().split())\n    count = 0\n    while a != 0 and b != 0:\n        if a > b:\n            count += a // b\n            a %= b\n        else:\n            count += b // a\n            b %= a\n    count += abs(a-b)\n    print(count)"
 ],
 "2364": [
  "n = int(input())\na = list(map(int,input().split()))\ndp = [0]*n\ns = [0]*(n+1)\ndp_total = 0\nMOD = 998244353\nfor i in range(n):\n    dp[i] = (2*s[i] - s[n] + MOD)*a[i]\n    s[i+1] = s[i] + dp[i]\n    dp_total = (dp_total + dp[i])%MOD\n\nprint((dp_total*pow(2,n-1,MOD))%MOD)"
 ],
 "2365": [
  "def parseBoolExpr(expression: str) -> bool:\n    stack = []\n    for c in expression:\n        if c == ')':\n            seen = set()\n            while stack[-1] != '(':\n                seen.add(stack.pop())\n            stack.pop() # Pop the '('\n            operator = stack.pop()\n            if operator == '!':\n                stack.append(str(not eval(seen.pop())))\n            elif operator == '&':\n                stack.append(str(all(eval(s) for s in seen)))\n            elif operator == '|':\n                stack.append(str(any(eval(s) for s in seen)))\n        elif c != ',':\n            stack.append(c)\n    return eval(stack[-1])"
 ],
 "2366": [
  "n = int(input())\na = [int(x) for x in input().split()]\n\nfreq = [0] * (n+1)\nfor x in a:\n    freq[x] += 1\n\nans = [(freq[i] * (freq[i]-1)) // 2 for i in range(1, n+1)]\n\nfor x in a:\n    print(ans[x-1])"
 ],
 "2367": [
  "MOD = 10**9 + 7\n\ndef create_factorial_table(n):\n    fact = [1] * (n+1)\n    for i in range(1, n+1):\n        fact[i] = (i * fact[i-1]) % MOD\n    return fact\n\ndef calc_modinv(x):\n    return pow(x, MOD-2, MOD)\n\ndef create_invfactorial_table(n):\n    invfact = [1] * (n+1)\n    for i in range(2, n+1):\n        invfact[i] = (calc_modinv(i) * invfact[i-1]) % MOD\n    return invfact\n\ndef calc_comb(n, k, fact, invfact):\n    if k < 0 or k > n:\n        return 0\n    return fact[n] * invfact[n-k] * invfact[k] % MOD\n\ndef main():\n    h, w, a, b = map(int, input().split())\n    fact = create_factorial_table(h+w)\n    invfact = create_invfactorial_table(h+w)\n    ans = 0\n    for i in range(b, w):\n        ans = (ans + calc_comb(h-a+i-1, i, fact, invfact) * calc_comb(a+w-i-2, w-i-1, fact, invfact)) % MOD\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()"
 ],
 "2368": [
  "from collections import deque\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\ng = [[] for _ in range(n)]\nfor _ in range(m):\n    c, d = map(int, input().split())\n    g[c-1].append(d-1)\n    g[d-1].append(c-1)\n\nq = deque([0])\nvisited = [False] * n\ndif = [b[0] - a[0]]\n\nwhile len(q) > 0:\n    v = q.popleft()\n    if visited[v]:\n        continue\n    visited[v] = True\n\n    for u in g[v]:\n        dif.append(b[u] - a[u])\n        if not visited[u]:\n            q.append(u)\n\nif sum(dif) == 0:\n    print(\"Yes\")\nelse:\n    print(\"No\")"
 ],
 "2369": [
  "n,k=map(int,input().split())\na=list(map(int,input().split()))\n\nMOD=10**9+7\n\na.sort()\n\ndef comb(n,k):\n    res =1\n    for i in range(k):\n        res*=(n-i)\n        res//=(i+1)\n    return res\n\nans=0\n\nfor i in range(k-1,n):\n    ans+=a[i]*comb(i,k-1)\n    ans-=a[i]*(comb(n-i-1,k-1))\n    ans%=MOD\n\nprint(ans%MOD)"
 ],
 "2370": [
  "import numpy as np\n\nn = int(input())\na = np.array([input().split() for _ in range(n)], dtype=int)\n\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            if a[i,j] > a[i,k] + a[k,j]:\n                print(-1)\n                exit()\nans = 0\nfor i in range(n):\n    for j in range(i+1,n):\n        is_shortest = True\n        for k in range(n):\n            if k == i or k == j:\n                continue\n            if a[i, j] == a[i, k] + a[k, j]:\n                is_shortest = False\n                break\n        if is_shortest:\n            ans += a[i,j]\nprint(ans)"
 ],
 "2371": [
  "n, z, w = map(int, input().split())\ncards = list(map(int, input().split()))\n\nif n == 1:\n    print(abs(cards[0]-w))\nelse:\n    print(max(abs(cards[-1]-w), abs(cards[-2]-cards[-1])))"
 ],
 "2372": [
  "from collections import deque\n\nh, w = map(int, input().split())\nstart_h, start_w = map(int, input().split())\nend_h, end_w = map(int, input().split())\ngrid = [input() for _ in range(h)]\n\n# Convert starting and ending positions to 0-indexed integers\nstart_h -= 1\nstart_w -= 1\nend_h -= 1\nend_w -= 1\n\n# Initialize the queue for BFS\nqueue = deque([(start_h, start_w)])\ndistances = [[float('inf')] * w for _ in range(h)]\ndistances[start_h][start_w] = 0\n\n# Run BFS\nwhile queue:\n    current_h, current_w = queue.popleft()\n    for dh, dw in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        next_h, next_w = current_h + dh, current_w + dw\n        if not 0 <= next_h < h or not 0 <= next_w < w:\n            continue\n        if grid[next_h][next_w] == '#':\n            continue\n        if distances[next_h][next_w] > distances[current_h][current_w]:\n            distances[next_h][next_w] = distances[current_h][current_w]\n            queue.appendleft((next_h, next_w))\n    for dh in range(-2, 3):\n        for dw in range(-2, 3):\n            next_h, next_w = current_h + dh, current_w + dw\n            if not 0 <= next_h < h or not 0 <= next_w < w:\n                continue\n            if grid[next_h][next_w] == '#':\n                continue\n            if distances[next_h][next_w] > distances[current_h][current_w] + 1:\n                distances[next_h][next_w] = distances[current_h][current_w] + 1\n                queue.append((next_h, next_w))\n\n# Check if we were able to reach the end position and print the solution accordingly\nif distances[end_h][end_w] == float('inf'):\n    print(-1)\nelse:\n    print(distances[end_h][end_w])"
 ],
 "2373": [
  "n = int(input())\np = list(map(int, input().split()))\n\ncount = 0\nfor i in range(n):\n    if p[i] == i+1:\n        if i < n-1:\n            p[i], p[i+1] = p[i+1], p[i]\n        else:\n            p[i], p[i-1] = p[i-1], p[i]\n        count += 1\n\nprint(count)"
 ],
 "2374": [
  "n, m = map(int, input().split())\nbombs = []\nfor _ in range(n):\n  a, b = map(int, input().split())\n  bombs.append((a, b))\nbombs.sort()\nevents = []\nfor i in range(m):\n  l, r = map(int, input().split())\n  events.append((l, r, i))\nevents.sort(key=lambda x: x[1])\nans = []\nj = 0\nactive_bombs = set()\nimport heapq\nswitched = []\nfor l, r, i in events:\n  while j < n and bombs[j][0] <= r:\n    a, b = bombs[j]\n    if b == 1:\n      active_bombs.add(a)\n    else:\n      active_bombs.discard(a)\n    j += 1\n  if not active_bombs:\n    print(len(ans))\n    print(\" \".join(str(x + 1) for x in ans))\n    break\n  if not (active_bombs & set(range(l, r+1))):\n    ans.append(i)\n    switched.append((l, r))\n    active_bombs ^= set(range(l, r+1))\nelse:\n  print(-1)"
 ],
 "2375": [
  "x, y = map(int, input().split())\nif abs(x - y) > 1:\n    print(\"Alice\")\nelse:\n    print(\"Brown\")"
 ],
 "2376": [
  "n, W = map(int, input().split())\n\nw = [0] * n\nv = [0] * n\n\nfor i in range(n):\n    w[i], v[i] = map(int, input().split())\n\ndp = [[0] * (W + 1) for _ in range(n + 1)]\n\nfor i in range(n):\n    for j in range(W + 1):\n        if j - w[i] < 0:\n            dp[i + 1][j] = dp[i][j]\n        else:\n            dp[i + 1][j] = max(dp[i][j], dp[i][j - w[i]] + v[i])\n\nprint(dp[n][W])"
 ],
 "2377": [
  "n, h = map(int, input().split())\ndamage = []\nfor i in range(n):\n    a, b = map(int, input().split())\n    damage.append((a, True))\n    damage.append((b, False))\n\ndamage.sort(reverse=True)\ncount = 0\nfor d, is_wield in damage:\n    if is_wield:\n        if d >= h:\n            count += 1\n            break\n        else:\n            count += (h + d - 1) // d\n    else:\n        h -= d\n        if h <= 0:\n            count += 1\n            break\n        else:\n            count += 1\n\nprint(count)"
 ],
 "2378": [
  "MOD = 10 ** 9 + 7\n\ndef dfs(node, parent):\n    black_count = 1\n    white_count = 1\n    for child in tree[node]:\n        if child == parent:\n            continue\n        sub_black, sub_white = dfs(child, node)\n        black_count += sub_black\n        white_count += sub_white\n    holeyness = pow(2, black_count-1, MOD) * (pow(2, white_count, MOD) - 1) % MOD\n    return black_count, white_count\n\nn = int(input())\ntree = [[] for _ in range(n+1)]\nfor _ in range(n-1):\n    a, b = map(int, input().split())\n    tree[a].append(b)\n    tree[b].append(a)\n\nprint(dfs(1, 0)[1] - 1)"
 ],
 "2379": [
  "n,k,c = map(int, input().split())\ns = input()\n\nlast_worked = 0\nwork_dates = []\n\nfor i in range(n):\n    if s[i] == 'x':\n        continue\n    elif i - last_worked >= c + 1:\n        work_dates.append(i+1)\n        last_worked = i\n        \nlast_worked = n-1\n\nfor i in range(n-1, -1, -1):\n    if s[i] == 'x':\n        continue\n    elif last_worked - i >= c + 1:\n        work_dates.append(i+1)\n        last_worked = i\n        \nwork_dates.reverse()\n\nfor wd in work_dates:\n    print(wd)"
 ],
 "2380": [
  "n, m = map(int, input().split())\na = list(map(int, input().split()))\nbc = [list(map(int, input().split())) for _ in range(m)]\nbc.sort(key=lambda x: x[1], reverse=True)\nfor b, c in bc:\n    a.sort(reverse=True)\n    for i in range(b):\n        if i >= n or c <= a[i]:\n            break\n        a[i] = c\nprint(sum(a))"
 ],
 "2381": [
  "MOD = 10**9 + 7\n\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\nA.sort()\n\npos = []\nneg = []\n\nfor a in A:\n    if a >= 0:\n        pos.append(a)\n    else:\n        neg.append(a)\n\nn_pos = len(pos)\nn_neg = len(neg)\n\nans = 1\n\nif K == N:\n    for a in A:\n        ans *= a\n        ans %= MOD\n\nelif n_pos == 0 and K % 2 == 1:\n    neg.sort(reverse=True)\n    for k in range(K):\n        ans *= neg[k]\n        ans %= MOD\n\nelse:\n    if K % 2 == 1:\n        ans *= pos[-1]\n        pos.pop()\n\n    pairs = []\n    while len(pos) >= 2:\n        x = pos.pop()\n        y = pos.pop()\n        pairs.append(x * y)\n\n    while len(neg) >= 2:\n        x = neg.pop()\n        y = neg.pop()\n        pairs.append(x * y)\n\n    pairs.sort(reverse=True)\n    for k in range(K//2):\n        ans *= pairs[k]\n        ans %= MOD\n\nprint(ans)"
 ],
 "2382": [
  "from itertools import product\n\nn, *s = map(int, input().split())\npossible = False\n\nfor hp in product(range(2), repeat=n):\n    cur_hp = [s[i] for i in range(2 ** n)]\n    for i in range(n):\n        if hp[i] == 0:\n            a = cur_hp[:2**(n-i-1)]\n            b = cur_hp[2**(n-i-1):]\n        else:\n            a = cur_hp[2**(n-i-1):]\n            b = cur_hp[:2**(n-i-1)]\n        cur_hp = []\n        for j in range(2**(n-i-1)):\n            if len(a) > j:\n                cur_hp.append(a[j])\n            if len(b) > j:\n                cur_hp.append(b[j])\n    if sorted(cur_hp) == s:\n        possible = True\n        break\n\nprint(\"Yes\" if possible else \"No\")"
 ],
 "2383": [
  "n = int(input())\nbricks = list(map(int, input().split()))\n\nfor i in range(1, n+1):\n    if i not in bricks:\n        print(-1)\n        break\nelse:\n    count = 0\n    for i in range(n-1):\n        if bricks[i] != i+1:\n            count += 1\n    print(count)"
 ],
 "2384": [
  "n = int(input())\na = list(map(int, input().split()))\n\ndp = [0] * n\ndp[0] = a[0]\ndp[1] = max(a[0], a[1])\n\nfor i in range(2, n):\n    dp[i] = max(dp[i-1], dp[i-2] + a[i])\n\nprint(dp[(n-1)//2])"
 ],
 "2385": [
  "import sys\nsys.setrecursionlimit(10**7)\nMOD = 10**9 + 7\n\ndef dfs(v, p=-1):\n    ans = 1\n    for u in to[v]:\n        if u == p:\n            continue\n        ans *= dfs(u, v)\n        ans %= MOD\n    ans *= fact[size[v]-1]\n    ans %= MOD\n    return ans\n\nN = int(input())\nto = [[] for _ in range(N)]\nfor i in range(N-1):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    to[a].append(b)\n    to[b].append(a)\n\nfact = [1] * N\nfor i in range(1, N):\n    fact[i] = fact[i-1] * i % MOD\n\nsize = [0] * N\ndef get_size(v, p=-1):\n    res = 1\n    for u in to[v]:\n        if u == p:\n            continue\n        res += get_size(u, v)\n    size[v] = res\n    return res\n\nget_size(0)\nfor i in range(N):\n    print(dfs(i))"
 ],
 "2386": [
  "n = int(input())\na = list(map(int, input().split()))\ns = sum(a)\nans = float('inf')\nfor b in range(-100, 101):\n    tmp = 0\n    for i in range(n):\n        tmp += abs(a[i] - (b+i+1))\n    ans = min(ans, tmp)\nprint(ans)"
 ],
 "2387": [
  "n = int(input())\nseqs = [input().strip() for _ in range(n)]\n\nstack = []\nfor seq in seqs:\n    for s in seq:\n        if s == \"(\":\n            stack.append(s)\n        else:\n            if stack:\n                stack.pop()\n            else:\n                stack.append(s)\n                break\nprint(\"No\" if stack else \"Yes\")"
 ],
 "2388": [
  "MOD = 998244353\nn = int(input())\nrobots = []\nfor i in range(n):\n    x, d = map(int, input().split())\n    robots.append((x, x+d))\n\nrobots.sort(key=lambda x: x[1])\n\ndp = [0] * (n+1)\ndp[0] = 1\nfor i in range(n):\n    dp[i+1] = dp[i] * 2 % MOD\n    j = i-1\n    while j >= 0 and robots[j][1] > robots[i][0]:\n        dp[i+1] = (dp[i+1] - dp[j+1]) % MOD\n        j -= 1\n\nprint(dp[n])"
 ],
 "2389": [
  "n, a, b, c = map(int, input().split())\ns = [input() for _ in range(n)]\n\ncnt = [0] * 3\nans = []\nfor i in range(n):\n    if s[i] == \"AB\":\n        if a > b:\n            cnt[0] += 1\n            a -= 1\n            cnt[1] -= 1\n            b += 1\n            ans.append(\"A\")\n        else:\n            cnt[1] += 1\n            b -= 1\n            cnt[0] -= 1\n            a += 1\n            ans.append(\"B\")\n    elif s[i] == \"BC\":\n        if b > c:\n            cnt[1] += 1\n            b -= 1\n            cnt[2] -= 1\n            c += 1\n            ans.append(\"B\")\n        else:\n            cnt[2] += 1\n            c -= 1\n            cnt[1] -= 1\n            b += 1\n            ans.append(\"C\")\n    else:\n        if a > c:\n            cnt[0] += 1\n            a -= 1\n            cnt[2] -= 1\n            c += 1\n            ans.append(\"A\")\n        else:\n            cnt[2] += 1\n            c -= 1\n            cnt[0] -= 1\n            a += 1\n            ans.append(\"C\")\n\n    if a < 0 or b < 0 or c < 0:\n        print(\"No\")\n        break\nelse:\n    print(\"Yes\")\n    for i in range(n):\n        print(ans[i])"
 ],
 "2390": [
  "n, c = map(int, input().split())\n\nxv1, yv1, c1 = [], [], []\nxv2, yv2, c2 = [], [], []\n\nfor i in range(n):\n    x, v = map(int, input().split())\n    xv1.append(x)\n    yv1.append(v)\n    \nfor i in range(n-1, -1, -1):\n    x, v = map(int, input().split())\n    xv2.append(c - x)\n    yv2.append(v)\n    \nc1.append(yv1[0])\nc2.append(yv2[0])\n\nfor i in range(1, n):\n    c1.append(c1[i-1] + yv1[i] - (xv1[i] - xv1[i-1]))\n    c2.append(c2[i-1] + yv2[i] - (xv2[i] - xv2[i-1]))\n\nans = max(c1+ c2 + [0])\n\nfor i in range(n):\n    ans = max(ans, c1[i] + c2[n-i-2] - xv1[i])\n    \nprint(ans) "
 ],
 "2391": [
  "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nfor k in range(n):\n    x = a[k] ^ b[0]\n    for i in range(n):\n        if a[(i+k)%n] ^ x != b[i]:\n            break\n    else:\n        print(k, x)"
 ],
 "2392": [
  "MOD = 1000000007\nn = int(input())\nif n%2==1:\n    print(0)\nelse:\n    n//=2\n    dp = [[0]*8 for i in range(n+1)]\n    dp[0][0] = 1\n    for i in range(1,n+1):\n        for j in range(8):\n            dp[i][j] = (dp[i-1][j-1] + dp[i-1][j+1])%MOD\n    print(dp[n][0])"
 ],
 "2393": [
  "for _ in range(int(input())):\n    s = input().strip()\n    n = len(s)\n    ones = [i for i in range(n-2) if s[i:i+3]==\"one\" and (i==0 or s[i-1]!=\"w\" or s[i+3]!=\"o\") ]\n    twos = [i for i in range(n-2) if s[i:i+3]==\"two\" and (i==0 or s[i-1]!=\"o\" or s[i+3]!=\"e\")]\n    ans = []\n    while ones or twos:\n        if ones and (not twos or ones[0]<twos[0]):\n            ans.append(ones[0]+2)\n            ones = ones[1:]\n        else:\n            ans.append(twos[0]+2)\n            twos = twos[1:]\n    print(len(ans))\n    print(*ans)"
 ],
 "2394": [
  "import sys\n\nsys.setrecursionlimit(2 * 10 ** 5 + 5)\n\n\ndef dfs2(cur, par, d, dp):\n    for child in tree[cur]:\n        if child != par:\n            dfs2(child, cur, d + 1, dp)\n            for i in range(1, k + 1):\n                dp[cur][i] += dp[child][i - 1]\n    dp[cur][0] = 1\n    for i in range(1, k + 1):\n        dp[cur][i] += dp[cur][i - 1]\n    ans = dp[cur][0] - 1\n    for i in range(1, k + 1):\n        ans += (dp[cur][i] - dp[cur][i - 1] - 1) * (i + 1)\n    subtreesize[cur] = ans\n\n\ndef dfs(cur, par):\n    global res\n    for child in tree[cur]:\n        if child != par:\n            # remove contribution of child subtree from res\n            res -= subtreesize[child] * (n - subtreesize[child])\n            dfs(child, cur)\n            # add contribution of child subtree to res\n            res += subtreesize[child] * (n - subtreesize[child])\n\n\n# Read input\nn, k = map(int, input().split())\ntree = {i: [] for i in range(1, n + 1)}\nsubtreesize = [0] * (n + 1)\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    tree[a].append(b)\n    tree[b].append(a)\n\n# DP on tree\ndp = [[0] * (k + 1) for _ in range(n + 1)]\ndfs2(1, 0, 0, dp)\n\n# Calculate answer\nres = 0\ndfs(1, 0)\nprint(res)"
 ],
 "2395": [
  "for _ in range(int(input())):\n    t = input()\n    n = len(t)\n    ans = \"\"\n    for i in range(n):\n        ans += t[i]\n        if i < n-1 and t[i] == t[i+1]:\n            ans += \"0\"\n    print(ans)"
 ],
 "2396": [
  "m = int(input())\ncoordinates = [input() for _ in range(m)]\nnum_ships = []\nfor i in range(m):\n    coord_i = coordinates[i]\n    num_i = 1\n    for j in range(i + 1, m):\n        if coordinates[j] == coord_i:\n            num_i += 1\n    num_ships.append(num_i)\nprint(*num_ships)"
 ],
 "2397": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\nl, r = max(a), sum(a)\n\nwhile l < r:\n    mid = (l + r + 1) // 2\n    current_sum = cnt = 0\n\n    for x in a:\n        current_sum += x\n        if current_sum > mid:\n            cnt += 1\n            current_sum = x\n\n    cnt += 1\n    if cnt <= k:\n        r = mid - 1\n    else:\n        l = mid\n\nans = sum(i * ai for i, ai in enumerate(a, start=1))\ncnt = k\nfor i in range(n - 1, -1, -1):\n    if cnt == 1:\n        break\n    if ans - (n - i) * a[i] <= l:\n        ans -= (n - i) * a[i]\n        cnt -= 1\n\nprint(ans - l * cnt)"
 ],
 "2398": [
  "t = int(input())\nfor i in range(t):\n    a,b,c,d = map(int,input().split())\n    x,y,x1,y1,x2,y2 = map(int,input().split())\n    leftDiff = x - x1\n    rightDiff = x2 - x\n    upDiff = y2 - y\n    downDiff = y - y1\n    if ((a+b <= 0 or leftDiff <= a-b) and (c+d <= 0 or downDiff <= c-d) and (a-b <= rightDiff or a+b == 0) and (c-d <= upDiff or c+d == 0)):\n        print(\"YES\")\n    else:\n        print(\"NO\")"
 ],
 "2399": [
  "from sys import stdin, stdout\n\ndef can_win(a, b, s):\n    n = len(s)\n    prefix_dots = [0] * (n+1)\n    for i in range(1, n+1):\n        prefix_dots[i] = prefix_dots[i-1] + (s[i-1] == '.')\n    max_suffix_dots = [0] * (n+1)\n    for i in range(n, 0, -1):\n        max_suffix_dots[i-1] = max(max_suffix_dots[i], (s[i-1] == '.') * (n - i + 1))\n    max_gap = 0\n    for i in range(1, n+1):\n        if s[i-1] == 'X':\n            max_gap = 0\n        else:\n            max_gap = max(max_gap, max_suffix_dots[i-1])\n        if max_gap >= b:\n            if prefix_dots[min(n, i+a-1)] - prefix_dots[i-1] > 0:\n                return \"YES\"\n    return \"NO\"\n\ndef main():\n    q = int(stdin.readline())\n    for _ in range(q):\n        a, b = map(int, stdin.readline().split())\n        s = stdin.readline().strip()\n        stdout.write(can_win(a, b, s) + \"\\n\")\n\nmain()"
 ],
 "2400": [
  "from collections import defaultdict\n\nt = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    dls = list(map(int, input().split()))\n    m = int(input())\n    jls = list(map(int, input().split()))\n\n    dls_dict = defaultdict(int)\n    jls_dict = defaultdict(int)\n    for d in dls:\n        for j in jls:\n            intersect = (j - d) / 2\n            if intersect.is_integer():\n                dls_dict[d] += 1\n                jls_dict[j] += 1\n\n    count = 0\n    for d in dls:\n        count += jls_dict[-2 * d]\n    for j in jls:\n        count += dls_dict[j]\n\n    print(count)"
 ],
 "2401": [
  "for _ in range(int(input())):\n    n, r = map(int, input().split())\n    nums = list(map(int, input().split()))\n    total = sum(nums)\n    if total % (n-1) == r-1:\n        print((total//(n-1)))\n    else:\n        print((total//(n-1))+1)"
 ],
 "2402": [
  "for _ in range(int(input())):\n    n, x, y = map(int, input().split())\n    # Finding minimum place\n    min_place = max(1, x+y-n+1)\n    # Finding maximum place\n    if x+y-1 <= n:\n        max_place = x+y-1\n    else:\n        max_place = n\n    print(min_place, max_place)"
 ],
 "2403": [
  "import sys\nsys.setrecursionlimit(10**6)\n\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nans = 0\n\n# Create a graph\ngraph = [[] for i in range(n)]\nfor i in range(n):\n    if b[i]!=-1:\n        graph[b[i]-1].append(i)\n\n# DFS to find the order of operations\norder = []\nvisited = [False for i in range(n)]\ndef dfs(i):\n    visited[i] = True\n    order.append(i+1)\n    for j in graph[i]:\n        if not visited[j]:\n            dfs(j)\n    for j in range(n):\n        if a[i]>0 and b[j]==i+1 and not visited[j]:\n            dfs(j)\n            a[j] += a[i]\n    return\n\nfor i in range(n):\n    if not visited[i]:\n        dfs(i)\n\n# Calculate the maximum ans\nsums = [0 for i in range(n)]\nfor i in range(n):\n    sums[order[i]-1] += a[order[i]-1]\n    if b[order[i]-1]!=-1:\n        sums[b[order[i]-1]-1] += sums[order[i]-1]\n    ans += sums[order[i]-1]\n\nprint(ans)\nfor i in order:\n    print(i, end=' ')"
 ],
 "2404": [
  "a = int(input())\nprint((a*a-3)//2)"
 ],
 "2405": [
  "n, k, a, b, q = map(int, input().split())\n\norders = [0] * n   # to store the total orders for each day\nfilled = [0] * n   # to store the total orders that can be filled for each day\npre_filled = [0] * n   # to store the sum of filled orders up to the current day\n\nfor i in range(q):\n    query = input().split()\n    if query[0] == '1':\n        orders[int(query[1]) - 1] += int(query[2])\n    else:\n        p_i = int(query[1]) - 1  # 0-indexed\n        for j in range(n):\n            if j >= k:\n                filled[j] = max(filled[j - 1] - orders[j - k] * (a - b),\n                                 pre_filled[j - k] + min(orders[j - k], a))\n            else:\n                filled[j] = min(a, orders[j])\n            filled[j] = max(filled[j], filled[j - 1] - (a - b))\n            pre_filled[j] = filled[j] if j == 0 else pre_filled[j - 1] + filled[j]\n        print(max(pre_filled[p_i:]))  # print the maximum filled orders for the given period"
 ],
 "2406": [
  "from bisect import bisect_right\n\nn = int(input())\nheights = list(map(int, input().split()))\n\nwhile True:\n    updated = False\n    for i in range(n - 1):\n        if heights[i] + 2 <= heights[i + 1]:\n            heights[i] += 1\n            heights[i + 1] -= 1\n            updated = True\n    if not updated:\n        break\n\nprint(*heights)"
 ],
 "2407": [
  "for _ in range(int(input())):\n    n, r = map(int,input().split())\n    a = sorted(list(map(int,input().split())))\n    ans, i = 0, n-1\n    while i >= 0 and a[i]-r > 0:\n        ans += 1\n        while i >= 0 and a[i]-r == a[i-1]: i -= 1\n        i -= 1\n    while i >= 0:\n        ans += 1\n        while i >= 0 and a[i] == a[i-1]: i -= 1\n        i -= 1\n    print(ans)"
 ],
 "2408": [
  "n = int(input())\npoints = []\nfor i in range(n):\n    points.append(tuple(map(int, input().split())))\n\ncount = 0\nfor i in range(n):\n    for j in range(i+1, n):\n        for k in range(j+1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            x3, y3 = points[k]\n            if (x1 - x3)*(y2 - y3) == (x2 - x3)*(y1 - y3): # points i, j, k are collinear\n                continue\n            for l in range(k+1, n):\n                x4, y4 = points[l]\n                if (x1 - x2)*(y3 - y4) == (y1 - y2)*(x3 - x4): # wires i-j and k-l intersect\n                    count += 1\n\nprint(count)"
 ],
 "2409": [
  "t = int(input())\nfor _ in range(t):\n    n, k, l = map(int, input().split())\n    d = list(map(int, input().split()))\n    p = [0, 1, 2, *[k - i for i in range(2, k)], *[i for i in range(k)]]\n    visited = [False] * (n + 1)  # denote if current pos already checked\n    q = [(0, 0)]  # (pos, time_taken)\n    found = False\n    while q:\n        cur, time = q.pop(0)\n        if cur == n + 1:\n            found = True\n            break\n        if visited[cur]:\n            continue\n        visited[cur] = True\n        if cur > 0 and d[cur - 1] + p[time % (2 * k)] > l:\n            continue\n        if cur < n and d[cur] + p[time % (2 * k)] > l:\n            continue\n        q.append((cur + 1, time + 1))\n        q.append((cur, time + 1))\n        q.append((cur - 1, time + 1))\n    print(\"Yes\" if found else \"No\")"
 ],
 "2410": [
  "t = int(input())\n\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    pref = [0]*(n+1)\n    for i in range(1, n+1):\n        pref[i] = pref[i-1] + a[i-1]\n    min_pref = [0]*(n+1)\n    min_pref[0] = pref[0]\n    for i in range(1, n+1):\n        min_pref[i] = min(min_pref[i-1], pref[i])\n    suf = [0]*(n+1)\n    for i in range(n-1, -1, -1):\n        suf[i] = suf[i+1] + a[i]\n    max_suf = [0]*(n+1)\n    max_suf[n] = suf[n]\n    for i in range(n-1, -1, -1):\n        max_suf[i] = max(max_suf[i+1], suf[i])\n    sum_t = pref[n]\n    happy = False\n    for i in range(1, n):\n        if sum_t - min_pref[i-1] > max_suf[i]:\n            happy = True\n            break\n    if happy:\n        print(\"YES\")\n    else:\n        print(\"NO\")"
 ],
 "2411": [
  "n = int(input())\npoints = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    points.append((x, y))\n\ncnt = 0\nfor i in range(n):\n    for j in range(i+1, n):\n        for k in range(j+1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            x3, y3 = points[k]\n            if (x2-x1)*(y3-y1) == (y2-y1)*(x3-x1):\n                cnt += 1\n\nprint(cnt)"
 ],
 "2412": [
  "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input()\n    if s.count('8') > 0 and n - s.index('8') >= 11:\n        print('YES')\n    else:\n        print('NO')"
 ],
 "2413": [
  "t = int(input())\nfor i in range(t):\n    n = int(input())\n    s = input()\n    ans = 1  # initial answer, Nikolay can always visit at least one room\n    pos = [-1, -1]  # positions of staircases\n    for j in range(n):\n        if s[j] == '1':\n            if pos[0] == -1:\n                pos[0] = j\n            else:\n                pos[1] = j\n                if pos[0] != -1 and pos[1] != -1:  # if we found two staircases\n                    # try all possible starting rooms, and calculate the maximum number of rooms Nikolay can visit\n                    for st in range(2):\n                        a, b = pos[st], pos[st]  # starting positions\n                        cnt = 1  # number of visited rooms\n                        vis = [False] * (2 * n + 5)  # mark visited rooms\n                        vis[pos[0] + 1] = vis[n + pos[1] + 1] = True  # mark staircases as visited\n                        vis[a + 1] = vis[n + b + 1] = True\n                        while True:\n                            ok = False\n                            # try moving to the left, and update variables if possible\n                            if a > 0 and not vis[a] and (not st or s[a - 1] == '1') and (st or s[n + a - 1] == '1'):\n                                a -= 1\n                                cnt += 1\n                                vis[a + 1] = vis[n + a + 1] = True\n                                ok = True\n                            # try moving to the right, and update variables if possible\n                            if b < n - 1 and not vis[n + b + 2] and (not st or s[n + b + 1] == '1') and (st or s[b + 1] == '1'):\n                                b += 1\n                                cnt += 1\n                                vis[n + b + 2] = vis[b + 1] = True\n                                ok = True\n                            # if Nikolay can't move anywhere, stop\n                            if not ok:\n                                break\n                        # update the answer\n                        ans = max(ans, cnt)\n                    # reset positions of staircases\n                    pos = [-1, -1]\n    print(ans)"
 ],
 "2414": [
  "t = int(input())\nfor i in range(t):\n    a, b = map(int, input().split())\n    print(a + b)"
 ],
 "2415": [
  "letters = input()\nunique_letters = set(letters)\nif len(unique_letters) == len(letters):\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "2416": [
  "n = int(input())\na = list(map(int, input().split()))\n\nans = []\nfor i in range(30, -1, -1):\n    idx = -1\n    for j in range(n):\n        if (a[j] >> i) & 1:\n            if idx == -1:\n                idx = j\n            else:\n                ans.append((idx, j, (idx ^ j)))\n                a[idx] = a[idx] ^ a[j] ^ a[idx ^ j]\n                idx = -1\n    if idx != -1:\n        for j in range(n):\n            if j != idx:\n                ans.append((j, idx, (j ^ idx)))\n        break\n\ntmp = a[0]\nfor aa in a:\n    tmp ^= aa\nif tmp != 0:\n    print(\"NO\")\nelse:\n    print(\"YES\\n{}\".format(len(ans)))\n    for aa in ans:\n        print(aa[0] + 1, aa[1] + 1, aa[2] + 1)"
 ],
 "2417": [
  "n = int(input())\nenter = list(map(int, input().split()))\nexit = list(map(int, input().split()))\n\nfines = 0\nmax_exit = 0\n\nfor i in range(n):\n    if exit[i] > max_exit:\n        max_exit = exit[i]\n    else:\n        fines += 1\n\nprint(fines)"
 ],
 "2418": [
  "from sys import stdin, stdout\ninput = stdin.readline\nprint = stdout.write\n\nn = int(input())\na = list(map(int, input().split()))\n\nb = [a[0]]\nc = [0] * (n-1)\nfor i in range(1,n):\n    b.append(max(b[-1], a[i]-c[i-1]))\nfor i in range(n-2,-1,-1):\n    c[i] = max(a[i+1]-b[i], c[i+1])\n\nm = max(max(b), max(c))\nprint(f\"{m}\\n\")\n\nfor _ in range(int(input())):\n    l,r,x = map(int, input().split())\n    for i in range(l-1,r):\n        a[i] += x\n        \n    b = [a[0]]\n    c = [0] * (n-1)\n    for i in range(1,n):\n        b.append(max(b[-1], a[i]-c[i-1]))\n    for i in range(n-2,-1,-1):\n        c[i] = max(a[i+1]-b[i], c[i+1])\n\n    m = max(max(b), max(c))\n    print(f\"{m}\\n\")"
 ],
 "2419": [
  "from math import ceil\n\nt = int(input())\n\nfor _ in range(t):\n    a, b = map(int, input().split())\n    dist = abs(a - b)\n    # formula to calculate the minimum number of operations required\n    # ceil is used to round up the result to the nearest integer\n    # m is the number of operations required for the smaller distance\n    # n is the number of operations required for the larger distance\n    m = ceil((3 * ((dist) ** 0.5) - 1) / 2)\n    n = ceil(((-1 + (8 * dist + 1) ** 0.5) / 2))\n    # we choose the minimum of the two distances\n    print(min(m, n))"
 ],
 "2420": [
  "from collections import defaultdict\n\nn, r = map(int, input().split())\nd = defaultdict(int)\n\nfor i in range(n):\n    x, y = map(int, input().split())\n    d[x + y] += 1\n    d[x - y] += 1\n\nans = 0\nfor k in d:\n    cnt = 0\n    for i in range(-r, r + 1):\n        if k + i in d:\n            cnt += d[k + i]\n    ans = max(ans, cnt)\n\nprint(ans)"
 ],
 "2421": [
  "from math import inf\n\nt = int(input())\n\nfor _ in range(t):\n    x, y = map(int, input().split())\n    c1, c2, c3, c4, c5, c6 = map(int, input().split())\n\n    # the minimum cost of moving in any direction\n    min_cost = min(c1, c2, c3, c4, c5, c6)\n\n    # check if moving diagonally is cheaper than moving straight\n    diagonal_cost = min(c1 + c6, c2 + c5, c3 + c4)\n\n    if x == 0 and y == 0:\n        print(0)  # already at the origin\n    elif x == y == -1 or x == y == 1 or x + y == 0:\n        print(min_cost * abs(x + y))\n    else:\n        if x * y > 0:\n            print(min_cost * abs(x - y) + diagonal_cost * min(abs(x), abs(y)))\n        else:\n            print(min_cost * (abs(x) + abs(y)))   "
 ],
 "2422": [
  "t = int(input())\nfor i in range(t):\n    n = int(input())\n    if n < 3 or n == 4 or n == 6:\n        print(-1)\n    elif n % 3 == 0:\n        print(n//3, 0, 0)\n    elif n % 3 == 1:\n        print((n-7)//3, 0, 1)\n    else:\n        print((n-5)//3, 1, 0)"
 ],
 "2423": [
  "from collections import defaultdict\n\nn = int(input())\ngraph = defaultdict(list)\n\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n    graph[v].append(u)\n    \nremote_count = 0\n\nfor i in range(1, n+1):\n    if len(graph[i]) == 1:\n        remote_count += 1\n\nprint(remote_count)"
 ],
 "2424": [
  "MOD = 998244353\n\nn = int(input())\nkids = []\ntotal_items = set()\n\nfor i in range(n):\n    items = list(map(int, input().split()[1:]))\n    kids.append(items)\n    total_items |= set(items)\n\ncount_valid = 0\nfor _ in range(10**4):\n    x = kids[random.randint(0, n-1)]\n    y = random.choice(x)\n    z = kids[random.randint(0, n-1)]\n    if z == x:\n        continue\n    if random.random() < 1/len(z) and y in z:\n        count_valid += 1\n\ninv_y = pow(len(total_items) * n, MOD-2, MOD)\nresult = (count_valid * inv_y) % MOD\nprint(result)"
 ],
 "2425": [
  "import math\n\nq = int(input())\nfor i in range(q):\n    a = int(input())\n    max_gcd = 1\n    max_j = 0\n    for j in range(1, a):\n        gcd = math.gcd(a ^ j, a & j)\n        if gcd > max_gcd:\n            max_gcd = gcd\n            max_j = j\n    print(max_gcd)"
 ],
 "2426": [
  "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    odd = []\n    even = []\n    for i in range(n):\n        if a[i] % 2 == 0:\n            print(1)\n            print(i+1)\n            break\n        else:\n            odd.append(i+1)\n    else:\n        if len(odd) > 1:\n            print(2)\n            print(odd[0], odd[1])\n        else:\n            print(-1)"
 ],
 "2427": [
  "n = int(input())\na = list(map(int, input().split()))\n\nans = 0\nfor i in range(n):\n    xor_sum, sum_so_far = 0, 0\n    for j in range(i+1, n):\n        xor_sum ^= a[j]\n        sum_so_far += a[j-1]\n        if xor_sum == sum_so_far:\n            ans += 1\n\nprint(ans)"
 ],
 "2428": [
  "for _ in range(int(input())):\n    s = input().strip()\n    t = input().strip()\n    dp = [[False]*(len(s)+1) for _ in range(len(t)+1)]\n    dp[0] = [True]*(len(s)+1)\n    for i in range(1,len(t)+1):\n        for j in range(1,len(s)+1):\n            if t[i-1] == s[j-1]:\n                dp[i][j] = dp[i][j-1] or dp[i-1][j-1]\n            else:\n                dp[i][j] = dp[i][j-1]\n    if dp[-1][-1]:\n        print(\"YES\")\n    else:\n        print(\"NO\")"
 ],
 "2429": [
  "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    weights = [2**i for i in range(1, n+1)]\n    target_weight = sum(weights)//2\n    possible_weights = set([0])\n    for weight in weights:\n        new_weights = set()\n        for possible_weight in possible_weights:\n            new_weights.add(possible_weight)\n            new_weights.add(possible_weight+weight)\n        possible_weights = new_weights\n    min_difference = float('inf')\n    for possible_weight in possible_weights:\n        min_difference = min(min_difference, abs(target_weight-possible_weight-possible_weight))\n    print(min_difference)"
 ],
 "2430": [
  "n = int(input())\nheights = list(map(int, input().split()))\n\ntotal_time = heights[0] + 2*n - 2\n\nfor i in range(1, n):\n    climb = heights[i] - heights[i-1]\n    if climb >= 0:\n        total_time += climb + 1\n    else:\n        total_time += abs(climb) + 1\n\nprint(total_time)"
 ],
 "2431": [
  "for i in range(int(input())):\n    n, x, y, z = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = [1] * n\n    last = None\n    for j in range(n):\n        if a[j] - x >= 0:\n            if last != 'a':\n                b[j] = 0\n            elif j + 1 < n and a[j+1] - y >= 0:\n                b[j] = 0\n            elif j + 2 < n and a[j+2] - z >= 0:\n                b[j] = 0\n        elif a[j] - y >= 0:\n            if last != 'b':\n                b[j] = 0\n            elif j + 1 < n and a[j+1] - z >= 0:\n                b[j] = 0\n            elif j - 1 >= 0 and a[j-1] - x >= 0:\n                b[j] = 0\n        elif a[j] - z >= 0:\n            if last != 'c':\n                b[j] = 0\n            elif j - 1 >= 0 and a[j-1] - y >= 0:\n                b[j] = 0\n            elif j - 2 >= 0 and a[j-2] - x >= 0:\n                b[j] = 0\n        else:\n            b[j] = 0\n        if b[j]:\n            last = 'abc'[[a[j]-x>=0, a[j]-y>=0, a[j]-z>=0].index(True)]\n    print(sum(b))"
 ],
 "2432": [
  "a=int(input())\nprint([0,1,2,2,4,2,6,4,6,4][(a%10)+2*(a//10)])"
 ],
 "2433": [
  "t = int(input())\nfor i in range(t):\n    b, p, f = map(int, input().split())\n    h, c = map(int, input().split())\n    max_profit = 0\n    for j in range(p+1):\n        for k in range(f+1):\n            if j*2 + k*2 <= b:\n                profit = j*h + k*c\n                if profit > max_profit:\n                    max_profit = profit\n    print(max_profit)"
 ],
 "2434": [
  "import math\n\nt = int(input())\n\nfor i in range(t):\n    n, m = map(int, input().split())\n    if n % m == 0 and (n // m) % 2 == 0:\n        print(\"NO\")\n    else:\n        print(\"YES\")"
 ],
 "2435": [
  "t = int(input())\nfor _ in range(t):\n    n, x, m = map(int, input().split())\n    left = right = x\n    for i in range(m):\n        l, r = map(int, input().split())\n        if l <= left <= r or l <= right <= r:\n            left = min(left, l)\n            right = max(right, r)\n    print(right - left + 1)"
 ],
 "2436": [
  "input_ = lambda: map(int, input().split())\nfor _ in range(int(input())):\n    n = int(input())\n    a = sorted(list(input_()), reverse=True)\n    ans, cnt = 1, 1\n    for i in range(n):\n        if cnt >= a[i]:\n            ans += 1\n            cnt += 1\n        else:\n            break\n    print(ans)"
 ],
 "2437": [
  "from math import gcd\nn = int(input())\na = list(map(int,input().split()))\ng = min(a)\nfor i in range(1,n):\n    g = gcd(g,a[i])\nif g!=1:\n    print(0)\nelse:\n    cnt = 0\n    for i in range(n):\n        cnt += a[i]-1\n    if cnt % 2 == 0:\n        print(1)\n    else:\n        print(2)"
 ],
 "2438": [
  "n = int(input())\ns = input()\nans = 0\nfor i in range(1, n):\n    cnt_a, cnt_b = 0, 0\n    for j in range(i, -1, -1):\n        if s[j] == \"A\":\n            cnt_a += 1\n        else:\n            cnt_b += 1\n        if cnt_a == cnt_b:\n            ans += 1\n            break\n    cnt_a, cnt_b = 0, 0\n    for j in range(i, n):\n        if s[j] == \"A\":\n            cnt_a += 1\n        else:\n            cnt_b += 1\n        if cnt_a == cnt_b:\n            ans += 1\n            break\nprint(ans)"
 ],
 "2439": [
  "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    if sum(a) == 0:\n        print(\"NO\")\n    else:\n        a.sort()\n        if a[0] >= 0:\n            b = list(reversed(a))\n        elif a[-1] <= 0:\n            b = a\n        else:\n            neg = [x for x in a if x < 0]\n            pos = [x for x in a if x > 0]\n            b = neg + pos\n        print(\"YES\")\n        print(*b)"
 ],
 "2440": [
  "from collections import defaultdict, deque\n\nn = int(input())\ngraph = defaultdict(list)\n\n# Build an undirected graph\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n    graph[v].append(u)\n\nq = int(input())\n\nfor i in range(q):\n    x, y, a, b, k = map(int, input().split())\n\n    # Breadth-first search on the modified graph\n    dist = [-1] * (n+1)\n    dist[x] = 0\n    dist[y] = 0\n    visited = set([x, y])\n    frontier = deque([x, y])\n\n    while frontier:\n        node = frontier.popleft()\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                dist[neighbor] = dist[node] + 1\n                frontier.append(neighbor)\n    \n    # Check if there is a valid path from a to b with k edges\n    if dist[a] + dist[b] <= k and (k - dist[a] - dist[b]) % 2 == 0:\n        print(\"YES\")\n    else:\n        print(\"NO\")"
 ],
 "2441": [
  "MOD = 1000000007\n\nn = int(input())\ncosts = list(map(int, input().split()))\n\n# Make adjacency list for the graph\nadj_list = [[] for _ in range(n)]\nrev_adj_list = [[] for _ in range(n)]\nfor _ in range(int(input())):\n    u, v = map(int, input().split())\n    u -= 1\n    v -= 1\n    adj_list[u].append(v)\n    rev_adj_list[v].append(u)\n\n# Find all SCCs using Kosaraju's algorithm\nstack = []\nvisited = [False] * n\nfor i in range(n):\n    if not visited[i]:\n        stack.append(i)\n        visited[i] = True\n        while stack:\n            node = stack[-1]\n            found_unvisited = False\n            for neighbor in adj_list[node]:\n                if not visited[neighbor]:\n                    stack.append(neighbor)\n                    visited[neighbor] = True\n                    found_unvisited = True\n                    break\n            if not found_unvisited:\n                stack.pop()\n\n                # Do reverse DFS to mark SCC\n                scc_nodes = [node]\n                scc_cost = costs[node]\n                visited[node] = False\n                for back_neighbor in rev_adj_list[node]:\n                    if visited[back_neighbor]:\n                        stack.append(back_neighbor)\n                        visited[back_neighbor] = False\n                        scc_nodes.append(back_neighbor)\n                        scc_cost += costs[back_neighbor]\n                for scc_node in scc_nodes:\n                    scc[scc_node] = (scc_nodes, scc_cost)\n\n# Calculate the minimum cost of securing all junctions\nmin_cost = 0\nfor scc_nodes, scc_cost in scc.values():\n    min_cost += min(scc_cost, sum(costs[node] for node in scc_nodes))\n\n# Calculate the number of ways to secure all junctions with minimum cost\nnum_ways = 1\nfor scc_nodes, scc_cost in scc.values():\n    if scc_cost == min(scc_cost, sum(costs[node] for node in scc_nodes)):\n        num_ways *= sum(costs[node] for node in scc_nodes) == scc_cost\n        num_ways %= MOD\n    else:\n        num_ways *= sum(costs[node] for node in scc_nodes if costs[node] == min(costs[node] for node in scc_nodes))\n        num_ways %= MOD\n\nprint(min_cost, num_ways)"
 ],
 "2442": [
  "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int,input().split()))\n    a.sort()\n    mexA = 0\n    mexB = 0\n    for i in a:\n        if i==mexA:\n            mexA += 1\n        elif i==mexB:\n            mexB += 1\n        else:\n            mexA += 1\n            mexB += 1\n    print(mexA+mexB)"
 ],
 "2443": [
  "from random import randint\n\ndef gcd(x, y):\n    return y if x == 0 else gcd(y % x, x)\n\ndef lcm(x, y):\n    return (x*y)//gcd(x, y)\n\nn, m = map(int, input().split())\nif n == 0:\n    print(m)\n    print(\" \".join(str(i) for i in range(m)))\nelse:\n    forbids = set(map(int, input().split()))\n    primes = []\n    for i in range(2, int(m**0.5)+1):\n        if m % i == 0:\n            primes.append(i)\n            while m % i == 0:\n                m //= i\n    if m > 1:\n        primes.append(m)\n\n    ans = []\n    max_len = 0\n    for i in range(30):\n        seq = []\n        for j in range(len(primes)):\n            seq.append(randint(1, m-1))\n        ll = 1\n        for j in range(len(seq)):\n            ll = lcm(ll, primes[j])\n            if ll > m:\n                break\n            if ll not in forbids:\n                continue\n            ll = primes[j]\n            if i == 29:\n                seq[j] += randint(1, 20)*primes[j]\n                seq[j] %= m\n        for j in range(len(primes)):\n            ll = lcm(ll, primes[j])\n            if ll > m or ll in forbids:\n                break\n        else:\n            if len(seq) > max_len:\n                max_len = len(seq)\n                ans = seq\n    print(max_len)\n    print(\" \".join(str(i) for i in ans))"
 ],
 "2444": [
  "n, p = map(int, input().split())\nt = list(map(int, input().split()))\n\nq = []\nans = [0] * n\nfor i in range(n):\n    while q and q[0][0] + p < t[i]:\n        _, l = q.pop(0)\n        ans[l] = q[0][0] + p if q else l + p\n    if not q:\n        ans[i] = t[i]\n    else:\n        ans[i] = q[-1][0] + p\n    q.append((ans[i], i))\n\nprint(*ans)"
 ],
 "2445": [
  "t = int(input())\nfor i in range(t):\n    n = int(input())\n    if n == 1:\n        print(1)\n    elif n == 2:\n        print(2)\n    else:\n        print(3)"
 ],
 "2446": [
  "from functools import reduce\nfrom math import gcd\n\nn = int(input())\na = list(map(int, input().split()))\nq = int(input())\n\n# precompute gcd values for each pair (l, r)\ngcd_precomputed = [[0 for j in range(n)] for i in range(n)]\nfor i in range(n):\n    gcd_precomputed[i][i] = a[i]\n    for j in range(i+1, n):\n        gcd_precomputed[i][j] = gcd(gcd_precomputed[i][j-1], a[j])\n\nfor i in range(q):\n    x = int(input())\n    cnt = 0\n    for l in range(n):\n        for r in range(l, n):\n            if reduce(gcd, gcd_precomputed[l][r:l+1], x) == x:\n                cnt += 1\n    print(cnt)"
 ],
 "2447": [
  "def make_good_string(s):\n    n = len(s)\n    if \"10\" not in s and \"01\" not in s:\n        return 0\n    if \"0\" not in s or \"1\" not in s:\n        return 0\n    cnt = 0\n    for i in range(n):\n        if i+2 < n and s[i:i+3] in [\"101\", \"010\"]:\n            cnt += 1\n    return cnt + 1\n\nt = int(input())\nfor i in range(t):\n    s = input().strip()\n    print(make_good_string(s))"
 ],
 "2448": [
  "def can_win(n,a,b,c,s):\n    beats = {'R': 'S', 'P': 'R', 'S': 'P'}\n    cnt = {'R': 0, 'P': 0, 'S': 0}\n    for i in s:\n        cnt[i] += 1\n    ans = ''\n    win = 0\n    for i in s:\n        if cnt[beats[i]] > 0 and b > 0:\n            ans += beats[i]\n            b -= 1\n            cnt[beats[i]] -= 1\n            win += 1\n        elif cnt[beats[beats[i]]] > 0 and c > 0:\n            ans += beats[beats[i]]\n            c -= 1\n            cnt[beats[beats[i]]] -= 1\n            win += 1\n        elif cnt[i] > 0 and a > 0:\n            ans += i\n            a -= 1\n            cnt[i] -= 1\n            win += 1\n        else:\n            ans = ''\n            break\n    if win >= (n + 1) // 2:\n        print('YES')\n        print(ans)\n    else:\n        print('NO')\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a,b,c = map(int,input().split())\n    s = input()\n    can_win(n,a,b,c,s)"
 ],
 "2449": [
  "MOD = 10**9 + 7\n\nm, n = map(int, input().split())\nt = [int(input(), 2) for _ in range(n)]\nmax_S = 2**m - 1\n\ncount = [0]*(max_S+1)\nfor x in t:\n    count[x] = 1\n\n    # Find all valid subsets of S containing x\n    for i in range(x, max_S+1):\n        i_xor_x = i ^ x\n        if i_xor_x < x:\n            continue\n\n        if i_xor_x == x:\n            count[i] += 1\n        else:\n            count[i] += count[i_xor_x]\n\n# Find the answer using inclusion-exclusion principle\nans = 0\nfor i in range(max_S+1):\n    if bin(i).count('1') % 2 == 0:\n        ans = (ans + pow(2, count[i], MOD)) % MOD\n    else:\n        ans = (ans - pow(2, count[i], MOD)) % MOD\n\nprint(ans)"
 ],
 "2450": [
  "t = int(input())\nfor _ in range(t):\n    n, m, x, y = map(int, input().split())\n    tiles = []\n    for i in range(n):\n        row = input().strip()\n        j = 0\n        while j < m:\n            if row[j] == '*':\n                j += 1\n            else:\n                if j+1 < m and row[j+1] == '.':\n                    tiles.append(y)\n                    j += 2\n                else:\n                    tiles.append(x)\n                    j += 1\n    print(sum(tiles))"
 ],
 "2451": [
  "n, h, a, b, k = map(int, input().split())\nfor i in range(k):\n    ta, fa, tb, fb = map(int, input().split())\n    if ta == tb:\n        print(abs(fa - fb))\n    else:\n        if fa <= b and fb <= b and fa >= a and fb >= a:\n            print(abs(ta - tb) + abs(fa - fb))\n        elif fa > b and fb > b:\n            print(abs(fa - fb) + abs(ta - tb))\n        elif fa < a and fb < a:\n            print(abs(fa - fb) + abs(ta - tb))\n        else:\n            if fa < a:\n                print(abs(a - fa) + abs(a - fb) + abs(ta - tb))\n            elif fa > b:\n                print(abs(fa - b) + abs(fb - b) + abs(ta - tb))\n            elif fb < a:\n                print(abs(a - fb) + abs(a - fa) + abs(ta - tb))\n            elif fb > b:\n                print(abs(fb - b) + abs(fa - b) + abs(ta - tb))"
 ],
 "2452": [
  "for _ in range(int(input())):\n    n = int(input())\n    for i in range(n, 0, -1):\n        print(i, end=' ')\n    print()"
 ],
 "2453": [
  "from itertools import accumulate\nfrom collections import defaultdict\n\nn = int(input())\nintervals = [tuple(map(int, input().split())) for _ in range(n)]\n\n# get all potential point coordinate\npoints = set()\nfor l, r in intervals:\n    points.add(l)\n    points.add(r)\nfor l, r in intervals:\n    points |= set(range(l + 1, r))\n\n# create dict to store number of interval each point occur\ncnt_points = defaultdict(int)\nfor l, r in intervals:\n    cnt_points[l] += 1\n    cnt_points[r] -= 1\nfor point in sorted(points):\n    cnt_points[point] += cnt_points[point-1]\n\n# count number of points according to interval they occur in\nnum_points = [0] * n\nfor point in cnt_points.values():\n    num_points[point-1] += 1\n\nprint(*num_points)"
 ],
 "2454": [
  "MOD = 10**9 + 7\n\ndef dfs1(cur, p=-1):\n    size[cur] = 1\n    for nxt in adj[cur]:\n        if nxt != p:\n            dfs1(nxt, cur)\n            size[cur] += size[nxt]\n            dp1[cur] = (dp1[cur] + dp1[nxt] + size[nxt]) % MOD\n\ndef dfs2(cur, p=-1):\n    for nxt in adj[cur]:\n        if nxt != p:\n            dp2[nxt] = (dp2[cur] + dp1[cur] - dp1[nxt] - size[nxt] + N) % MOD\n            dfs2(nxt, cur)\n\nN = int(input())\nadj = [[] for _ in range(N)]\nfor _ in range(N-1):\n    a, b = map(int, input().split())\n    a, b = a-1, b-1\n    adj[a].append(b)\n    adj[b].append(a)\n\ndp1 = [0] * N\ndp2 = [0] * N\nsize = [0] * N\ndfs1(0)\ndp2[0] = dp1[0]\n\ndfs2(0)\nans = 0\nfor i in range(N):\n    ans = (ans + pow(2, N-1-dp2[i], MOD)) % MOD\nprint(ans)"
 ],
 "2455": [
  "for _ in range(int(input())):\n    s = input().strip()\n    dots = s.count(\"O\")\n    x_cols = set()\n    for i in range(12):\n        if s[i] == 'X':\n            x_cols.add(i % 4)\n    \n    count = 0\n    res = \"\"\n    for i in range(1, 13):\n        if dots % i != 0:\n            continue\n        else:\n            j = dots // i\n            found = True\n            for c in x_cols:\n                if all(s[c + 4*k] == 'X' for k in range(j)):\n                    continue\n                else:\n                    found = False\n                    break\n            if found:\n                count += 1\n                res += f\"{i}x{j} \"\n    print(count, res)"
 ],
 "2456": [
  "import math\nt = int(input())\nfor i in range(t):\n    n, r = map(int, input().split())\n    k = min(n, r)\n    ans = ((k - 1) * k // 2) + min(k, n - 1)\n    print(ans)"
 ],
 "2457": [
  "import sys\n\nfor line in sys.stdin.readlines()[1:]:\n    n, a, b, c, d = map(int, line.split())\n    min_weight = (a - b) * n\n    max_weight = (a + b) * n\n    if max(min_weight, c - d) <= min(max_weight, c + d):\n        print(\"Yes\")\n    else:\n        print(\"No\")"
 ],
 "2458": [
  "MOD = 10 ** 9 + 7\n\nt, k = map(int, input().split())\n\n# construct the dp array\ndp = [0] * (10 ** 5 + 1)\ndp[0] = 1\nfor i in range(1, k):\n    dp[i] = 1\nfor i in range(k, 10 ** 5 + 1):\n    dp[i] = (dp[i - 1] + dp[i - k]) % MOD\n\n# calculate the answer for each test case\nfor _ in range(t):\n    a, b = map(int, input().split())\n    print((dp[b] - dp[a - 1]) % MOD)"
 ],
 "2459": [
  "n, q, m = map(int, input().split())\na = list(map(int, input().split()))\nfor i in range(q):\n    t, l, r = map(int, input().split())\n    if t == 1:\n        a[l-1:r] = [a[r-1]] + a[l-1:r-1]\n    else:\n        a[l-1:r] = a[l-1:r][::-1]\nb = list(map(int, input().split()))\nfor i in b:\n    print(a[i-1])"
 ],
 "2460": [
  "n, m = map(int, input().split())\nx = list(map(int, input().split()))\nt = list(map(int, input().split()))\n\ntaxi_index = [i for i in range(n+m) if t[i] == 1]\nnum_riders = [0]*m\n\nfor i in range(n+m):\n    if t[i] == 0:\n        idx = max([j for j in range(m)], key=lambda j: min(abs(x[i] - x[taxi_index[j]]), 1))\n        num_riders[idx] += 1\n\nprint(' '.join(map(str, num_riders)))"
 ],
 "2461": [
  "from math import gcd\nn = int(input())\na = list(map(int, input().split()))\ntree = [[] for i in range(n + 1)]\nfor i in range(n - 1):\n    x,y = map(int, input().split())\n    tree[x].append(y)\n    tree[y].append(x)\n\ndef dfs(node, par, curgcd):\n    global ans\n    ans[node] = gcd(curgcd,a[node-1])\n    for child in tree[node]:\n        if child != par:\n            dfs(child,node,ans[node])\n\nans = [0] * (n + 1)\ndfs(1,0,a[0])\nprint(' '.join(map(str,ans[1:])))"
 ],
 "2462": [
  "from math import sqrt\n\n\ndef is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(sqrt(n))+1):\n        if n % i == 0:\n            return False\n    return True\n\n\ndef calculate_nearly_primes(n):\n    nearly_primes = []\n    for i in range(2, n):\n        if is_prime(i):\n            for j in range(i+1, n):\n                if is_prime(j) and i*j <= n:\n                    nearly_primes.append(i*j)\n    return nearly_primes\n\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    nearly_primes = calculate_nearly_primes(n)\n    if len(nearly_primes) < 3:\n        print(\"NO\")\n    else:\n        a, b, c = nearly_primes[:3]\n        remainder = n - a - b - c\n        if remainder not in nearly_primes:\n            d = nearly_primes[3]\n        else:\n            d = remainder\n        print(\"YES\", a, b, c, d)"
 ],
 "2463": [
  "n = int(input())\na = list(map(int, input().split()))\nb = sorted(range(n), key = lambda i:a[i])\nans = [0] * n\nfor i in range(n):\n    ans[b[i]] = a[b[(i+1)%n]] if i%2==0 else a[b[(i-1)%n]]\ncnt = sum([1 for i in range(1,n-1) if ans[i] < ans[i-1] and ans[i] < ans[i+1]])\nprint(cnt)\nprint(*ans)"
 ],
 "2464": [
  "n = int(input())\ngraph = [[] for i in range(n + 1)]\nfor i in range(n - 1):\n  x, y, c = map(int, input().split())\n  graph[x].append((y, c))\n  graph[y].append((x, c))\n\nans = 0\n\ndef dfs(v, p, cnt0, cnt1):\n  global ans\n  ans += cnt0 * cnt1\n  for u, c in graph[v]:\n    if u == p:\n      continue\n    if c == 0:\n      dfs(u, v, cnt0 + 1, cnt1)\n    else:\n      dfs(u, v, cnt0, cnt1 + 1)\n      \ndfs(1, 0, 0, 0)\nprint(ans)"
 ],
 "2465": [
  "import math\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        ang = int(input())\n        d = math.gcd(ang, 180)\n        k = 180 // d\n        if ang * k == 180 * (k-2):\n            print(k)\n        else:\n            print(-1)\n\nif __name__ == '__main__':\n    main()"
 ],
 "2466": [
  "class Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        if len(nums) == 0:\n            return []\n        if len(nums) == 1:\n            return [nums]\n        res = []\n        for i in range(len(nums)):\n            curr_num = nums[i]\n            rem_nums = nums[:i] + nums[i+1:]\n            for perm in self.permute(rem_nums):\n                res.append([curr_num] + perm)\n        return res"
 ],
 "2467": [
  "Sorry, as a language model AI, I can't use Call-Based formats. However, here's the solution to the problem:\n\nclass Solution:\n    def combinationSum3(self, k, n):\n        def backtrack(start, k, n, path, res):\n            if k == 0 and n == 0:\n                res.append(path)\n                return\n            if k == 0 or n == 0:\n                return\n            for i in range(start, 10):\n                if i > n:\n                    return\n                backtrack(i+1, k-1, n-i, path+[i], res)\n        \n        res = []\n        backtrack(1, k, n, [], res)\n        return res"
 ],
 "2468": [
  "class Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        stack = [-1]\n        length = 0\n        \n        for i in range(len(s)):\n            if s[i] == \"(\":\n                stack.append(i)\n            else:\n                stack.pop()\n                if not stack:\n                    stack.append(i)\n                else:\n                    length = max(length, i - stack[-1])\n        \n        return length"
 ],
 "2469": [
  "class Solution:\n    def majorityElement(self, nums: List[int]) -> List[int]:\n        result = []\n        if not nums:\n            return result\n        num1, num2, count1, count2 = 0, 1, 0, 0\n        for num in nums:\n            if num == num1:\n                count1 += 1\n            elif num == num2:\n                count2 += 1\n            elif count1 == 0:\n                num1, count1 = num, 1\n            elif count2 == 0:\n                num2, count2 = num, 1\n            else:\n                count1 -= 1\n                count2 -= 1\n        count1, count2 = 0, 0\n        for num in nums:\n            if num == num1:\n                count1 += 1\n            elif num == num2:\n                count2 += 1\n        if count1 > len(nums) // 3:\n            result.append(num1)\n        if count2 > len(nums) // 3:\n            result.append(num2)\n        return result"
 ],
 "2470": [
  "Sorry, as an AI language model, I don't have the capability to follow specific formats such as Call-Based format. However, here's the solution to the problem in Python:\n\nclass Solution:\n    def makeArrayIncreasing(self, arr1, arr2):\n        arr2.sort()\n        memo = {-1: 0}\n        \n        def dp(i, prev):\n            if i == len(arr1):\n                return 0\n            if (i, prev) in memo:\n                return memo[(i, prev)]\n            \n            op1 = float('inf')\n            if arr1[i] > prev:\n                op1 = dp(i + 1, arr1[i])\n            \n            op2 = float('inf')\n            j = bisect_right(arr2, prev)\n            if j < len(arr2):\n                op2 = dp(i + 1, arr2[j]) + 1\n                \n            memo[(i, prev)] = min(op1, op2)\n            return memo[(i, prev)]\n        \n        res = dp(0, -1)\n        return res if res < float('inf') else -1"
 ],
 "2471": [
  "from collections import defaultdict\n\nH, W, N = map(int, input().split())\n\npaint = defaultdict(int)\nfor i in range(N):\n    a, b = map(int, input().split())\n    for x in range(max(a-2, 1), min(a+1, H)):\n        for y in range(max(b-2, 1), min(b+1, W)):\n            paint[(x, y)] += 1\n\nans = [0] * 10\nfor v in paint.values():\n    ans[v-1] += 1\n    \nfor a in ans:\n    print(a)"
 ],
 "2472": [
  "n = int(input())\nx = []\nfor i in range(n):\n  a, b = map(int, input().split())\n  x.append((b, a))\nx.sort()\ntime = 0\nfor i in range(n):\n  time += x[i][1]\n  if time > x[i][0]:\n    print(\"No\")\n    break\nelse:\n  print(\"Yes\")"
 ],
 "2473": [
  "import itertools\nn,k = map(int,input().split())\ncoord = [list(map(int, input().split())) for _ in range(n)]\n\nmin_area = float('inf')\nfor x1,x2 in itertools.combinations(sorted(coord), 2):\n    for y1,y2 in itertools.combinations(sorted(coord, key=lambda coord:coord[1]), 2):\n        count = sum(x1[0] <= x[0] <= x2[0] and y1[1] <= x[1] <= y2[1] for x in coord)\n        if count >= k:\n            min_area = min(min_area, (x2[0]-x1[0])*(y2[1]-y1[1]))\nprint(min_area)"
 ],
 "2474": [
  "n = int(input())\nc = list(map(int, input().split()))\n\nMOD = 10**9 + 7\n\nans = 0\nfor i in range(n):\n    cnt0, cnt1 = 0, 0\n    for j in range(n):\n        if c[j] < c[i]:\n            cnt0 += 1\n        elif c[j] > c[i]:\n            cnt1 += 1\n    ans += pow(2, cnt0, MOD) * pow(2, cnt1, MOD) * c[i]\n    ans %= MOD\n\nfor i in range(1, n+1):\n    ans *= i\n    ans %= MOD\n\nprint(ans)"
 ],
 "2475": [
  "n = int(input())\ns = list(map(int, input().split()))\ninf = 10**100\ndp = [[-inf]*(n+1) for i in range(n+1)]\ndp[0][0] = 0\n\nfor i in range(n):\n    for a in range(n):\n        b = i-a\n        if b < 0 or b > n-1:\n            continue\n        if a >= 1:\n            dp[a][b] = max(dp[a][b], dp[a-1][b]+s[i])\n        if b >= 1:\n            dp[a][b] = max(dp[a][b], dp[a][b-1]+s[i])\n\nans = max(dp[a][n-1-a] for a in range(n))\nprint(ans)"
 ],
 "2476": [
  "n=int(input())\na=[int(x)for x in input().split()]\ncnt=[0]*(n+1)\nfor i in range(n):\n    cnt[a[i]]+=1\nans=[0]*(n+1)\nfor i in range(1,n+1):\n    for j in range(i,n+1,i):\n        ans[i]+=cnt[j]\nprint(*ans[1:],sep='\\n')"
 ],
 "2477": [
  "import math\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nleft, right = 1, max(a)\nwhile left < right:\n    mid = (left+right)//2\n    cnt = 0\n    for i in a:\n        cnt += math.ceil(i/mid)-1\n    if cnt <= k:\n        right = mid\n    else:\n        left = mid+1\nprint(left)"
 ],
 "2478": [
  "n=int(input())\ns=input()\nbal=0\nans=\"\"\nfor i in range(n):\n    if s[i]==\"(\":\n        bal+=1\n        ans+=\"(\"\n    else:\n        bal-=1\n        ans+=\")\"\n    if bal<0:\n        ans=\"(\"+ans\n        bal+=1\nif bal>0:\n    ans=ans+\")\"*bal\nprint(ans)"
 ],
 "2479": [
  "n, q = map(int, input().split())\nrow = [0] * (n + 1)\ncol = [0] * (n + 1)\nd1 = [0] * (2*n + 1)  # diagonal from top-left to bottom-right\nd2 = [0] * (2*n + 1)  # diagonal from bottom-left to top-right\nblacks = (n-2) * (n-2)\n\nfor i in range(2*n + 1):\n    d1[i] = d2[i] = col[i] = row[i] = 1\n\nfor i in range(q):\n    query = list(map(int, input().split()))\n    if query[0] == 1:\n        x = query[1]\n        for j in range(x+1, n+1):\n            if row[j] == 0:\n                row[j] = 1\n                blacks -= col[x] - col[x-2]\n                break\n    else:\n        x = query[1]\n        for j in range(x+1, n+1):\n            if col[j] == 0:\n                col[j] = 1\n                blacks -= row[x] - row[x-2]\n                break\n\nprint(blacks)"
 ],
 "2480": [
  "n,k=map(int,input().split())\na=list(map(int,input().split()))\ns=[0]*(n+1)\nfor i in range(n):\n    s[i+1]=s[i]+a[i]\nr=[0]*k\nans=0\nfor i in range(n+1):\n    ans+=r[s[i]%k]\n    r[s[i]%k]+=1\n    if i>=k-1:\n        r[s[i-(k-1)]%k]-=1\nprint(ans)"
 ],
 "2481": [
  "H, W = map(int, input().split())\nc = [list(map(int, input().split())) for _ in range(10)]\nA = [list(map(int, input().split())) for _ in range(H)]\n\nfor k in range(10):\n    for i in range(10):\n        for j in range(10):\n            c[i][j] = min(c[i][j], c[i][k]+c[k][j])\n\nans = 0\nfor i in range(H):\n    for j in range(W):\n        if A[i][j] != -1:\n            ans += c[A[i][j]][1]\n\nprint(ans)"
 ],
 "2482": [
  "from collections import defaultdict\n\nn, k, l = map(int, input().split())\n\nroad_graph = defaultdict(list)\nrailway_graph = defaultdict(list)\n\nfor _ in range(k):\n    p, q = map(int, input().split())\n    road_graph[p].append(q)\n    road_graph[q].append(p)\n    \nfor _ in range(l):\n    r, s = map(int, input().split())\n    railway_graph[r].append(s)\n    railway_graph[s].append(r)\n    \n# DFS to find all cities connected by road/railway for each city\ndef dfs(graph, start, visited):\n    visited.add(start)\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            dfs(graph, neighbor, visited)\n    return visited\n\n# Find all cities connected by road and railway for each city\nroad_connections = {}\nfor city in range(1, n+1):\n    road_connections[city] = dfs(road_graph, city, set())\n    \nrailway_connections = {}\nfor city in range(1, n+1):\n    railway_connections[city] = dfs(railway_graph, city, set())\n\n# Find number of cities connected by both road and railway for each city\nfor city in range(1, n+1):\n    common_connections = road_connections[city].intersection(railway_connections[city])\n    print(len(common_connections), end=' ')"
 ],
 "2483": [
  "n, c = map(int, input().split())\ntimings = []\nfor _ in range(n):\n    s, t, c = map(int, input().split())\n    timings.append((s, t, c))\n\ntimings.sort()\noccupied = []\nfor i in range(n):\n    s, t, c = timings[i]\n    for o in occupied:\n        if o[1] <= s:\n            occupied.remove(o)\n    for o in occupied:\n        if o[0] == c:\n            break\n    else:\n        occupied.append((c, s+0.5, t))\n\nprint(len(occupied))"
 ],
 "2484": [
  "n=int(input())\na=list(map(int,input().split()))\nx=0\ns=0\nc={0:1}\nfor r in range(n):\n    x^=a[r]\n    s+=a[r]\n    c.setdefault(x,0)\n    c[x]+=1\nans=0\nfor k in c:\n    v=c[k]\n    ans+=v*(v-1)//2\nprint(ans)"
 ],
 "2485": [
  "h, w, m = map(int, input().split())\nrow = [0] * (h + 1)  # Number of targets in each row\ncol = [0] * (w + 1)  # Number of targets in each column\ntargets = []  # List of tuples representing target positions\n\nfor i in range(m):\n    x, y = map(int, input().split())\n    row[x] += 1\n    col[y] += 1\n    targets.append((x, y))\n\nmax_row = max(row)  # Maximum number of targets in a row\nmax_col = max(col)  # Maximum number of targets in a column\n\nmax_row_count = row.count(max_row)  # Number of rows with maximum number of targets\nmax_col_count = col.count(max_col)  # Number of columns with maximum number of targets\n\nmax_targets = max_row + max_col  # Maximum number of targets that can be destroyed\n\nfor i in range(m):\n    if row[targets[i][0]] == max_row and col[targets[i][1]] == max_col:\n        max_targets -= 1  # Subtract 1 if both row and column have maximum targets\n\nprint(max_targets)"
 ],
 "2486": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\nans = n\nfor i in range(n):\n    s = 0\n    for j in range(i, n):\n        s += a[j]\n        if s >= k:\n            ans -= 1\n            break\n\nprint(ans)"
 ],
 "2487": [
  "from collections import defaultdict\nfrom sys import stdin, stdout\ninput = stdin.readline\n\nn = int(input())\ngraph = defaultdict(list)\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n    graph[v].append(u)\n\nsub_tree_size = [0] * (n+1)\n\ndef dfs(node, parent):\n    sub_tree_size[node] = 1\n    for child in graph[node]:\n        if child == parent:\n            continue\n        dfs(child, node)\n        sub_tree_size[node] += sub_tree_size[child]\n\ndfs(1, 0)\n\nans = 0\nfor i in range(1, n+1):\n    for j in range(i, n+1):\n        nodes_in_range = sub_tree_size[i:j+1]\n        ans += sum(1 for size in nodes_in_range if size % 2 != 0)\n\nprint(ans)"
 ],
 "2488": [
  "from collections import deque\n\nN,D,A = map(int, input().split())\nmonsters = []\nfor i in range(N):\n    monsters.append(tuple(map(int, input().split())))    \n\nmonsters.sort()\n\nque = deque()\nans = 0\ndamage = 0\nfor i in range(N):\n    x,h = monsters[i]\n    while que and que[0][0] < x:\n        damage -= que.popleft()[1]\n    h -= damage\n    if h > 0:\n        cnt = (h + A - 1) // A\n        ans += cnt\n        b_damage = cnt * A\n        damage += b_damage\n        que.append((x + 2*D, b_damage))\n\nprint(ans)"
 ],
 "2489": [
  "n = int(input())\na = list(map(int, input().split()))\ncount = 0\nfor i in range(n):\n    flag = True\n    for j in range(n):\n        if i != j and a[j] % a[i] == 0:\n            flag = False\n            break\n    if flag:\n        count += 1\nprint(count)"
 ],
 "2490": [
  "import math\nn = int(input())\nnums = []\nd = 0\nwhile 10**d <= n:\n    nums.append(10**d)\n    d += 1\n\ndp = [float('inf')] * (n+1)\ndp[0] = 0\nfor i in range(1, n+1):\n    for num in nums:\n        if i >= num:\n            dp[i] = min(dp[i], dp[i-num]+1)\nprint(dp[n])"
 ],
 "2491": [
  "import sys\ninput = sys.stdin.readline\n\nINF = 10**18\n\nn, m = map(int, input().split())\ngraph = [[] for _ in range(n)]\nfor i in range(m):\n    a, b, c = map(int, input().split())\n    graph[a-1].append((b-1, c))\n\ndist = [-INF]*n\ndist[0] = 0\nfor _ in range(n-1):\n    for v in range(n):\n        for nv, cost in graph[v]:\n            dist[nv] = max(dist[nv], dist[v]+cost)\n\nans = dist[-1]\nfor _ in range(n):\n    for v in range(n):\n        for nv, cost in graph[v]:\n            if dist[nv] < dist[v]+cost:\n                dist[nv] = INF\nif dist[-1] == INF:\n    print(\"inf\")\nelse:\n    print(dist[-1])"
 ],
 "2492": [
  "from itertools import combinations\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nlst = []\nfor pair in combinations(a, 2):\n    lst.append(pair[0] * pair[1])\n\nlst = sorted(lst)\nprint(lst[k-1])"
 ],
 "2493": [
  "n = int(input())\na = list(map(int, input().split()))\nMOD = 10**9 + 7\n\npos = [-1] * (n+1)\nfor i in range(n+1):\n    if pos[a[i]] == -1:\n        pos[a[i]] = i\n    else:\n        l = pos[a[i]]\n        r = i\n        break\n\nans = [0] * (n+2)\nfor k in range(1, n+2):\n    if k == 1:\n        ans[k] = n\n    else:\n        ans[k] = (ans[k-1] * (n-k+2) * pow(k-1, MOD-2, MOD)) % MOD\n        \n    if k == l+1:\n        ans[k] -= (ans[l] * (n-r+1) * pow(l, MOD-2, MOD)) % MOD\n        ans[k] %= MOD\n    elif k > l+1:\n        ans[k] = 0\n    \n    print(ans[k])"
 ],
 "2494": [
  "K = int(input())\nif K % 2 == 0 or K % 5 == 0:\n    print(-1)\nelse:\n    x = 7 % K\n    for i in range(2, K+1):\n        if x == 0:\n            print(i)\n            break\n        x = (10 * x + 7) % K"
 ],
 "2495": [
  "n = int(input())\na = list(map(int, input().split()))\n\n# Initializing variables\npos_sum = 0\nneg_sum = 0\npos_needed = False\nneg_needed = False\nans = 0\n\nfor i in range(n):\n    # Checking condition 1\n    pos_sum += a[i]\n    neg_sum -= a[i]\n    if pos_sum <= 0:\n        pos_needed = True\n        ans += pos_sum * -1\n        pos_sum = 1\n    if neg_sum <= 0:\n        neg_needed = True\n        ans += neg_sum * -1\n        neg_sum = 1\n    \n    # Checking condition 2\n    if i%2 == 1 and pos_sum <= 0:\n        pos_needed = True\n        ans += 1 - pos_sum\n        pos_sum = 1\n    elif i%2 == 0 and neg_sum <= 0:\n        neg_needed = True\n        ans += 1 - neg_sum\n        neg_sum = 1\n        \nif pos_needed and neg_needed:\n    print(ans+2*(n//2))\nelse:\n    print(ans)"
 ],
 "2496": [
  "from math import gcd\nfrom collections import Counter\n\nn = int(input())\na = list(map(int, input().split()))\n\ncnt = Counter(a)\nif max(cnt.values()) > 1:\n    print(\"not coprime\")\nelse:\n    max_a = max(a)\n    prime_div = [0] * (max_a+1)\n    for i in range(2, max_a+1):\n        if prime_div[i] == 0:\n            for j in range(i, max_a+1, i):\n                prime_div[j] += 1\n    \n    gcd_set = set()\n    for i in range(n):\n        if a[i] in gcd_set:\n            print(\"setwise coprime\")\n            break\n        else:\n            gcd_set.add(a[i])\n    else:\n        for i in range(2, max_a+1):\n            lcm_cnt = 0\n            for j in range(i, max_a+1, i):\n                lcm_cnt += cnt[j]\n            if lcm_cnt > 1:\n                print(\"setwise coprime\")\n                break\n        else:\n            print(\"pairwise coprime\")"
 ],
 "2497": [
  "n=int(input())\nx_min=-10**8\nx_max=10**8\ny_min=-10**8\ny_max=10**8\nfor i in range(n):\n    x,y,d=input().split()\n    x=int(x)\n    y=int(y)\n    if d==\"R\":\n        x_min=max(x_min,x)\n    elif d==\"L\":\n        x_max=min(x_max,x)\n    elif d==\"U\":\n        y_min=max(y_min,y)\n    else:\n        y_max=min(y_max,y)\nprint(max(0,(x_max-x_min)*(y_max-y_min)))"
 ],
 "2498": [
  "n, m = map(int, input().split())\na = list(map(int, input().split()))\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\nlcm = a[0]\nfor i in range(1, n):\n    lcm = lcm * a[i] // gcd(lcm, a[i])\n\nfor i in range(n):\n    if (lcm // a[i]) % 2 == 0:\n        print(0)\n        exit()\n\nres = (m // lcm + 1) // 2\nprint(res)"
 ],
 "2499": [
  "n = int(input())\na = list(map(int, input().split()))\nans = 0\nfor i in range(60):\n    cnt_0 = 0\n    cnt_1 = 0\n    mask = 1 << i\n    for ai in a:\n        if ai & mask:\n            cnt_1 += 1\n        else:\n            cnt_0 += 1\n    contribution = mask * (cnt_0 * cnt_1)\n    ans += contribution\nprint(ans)"
 ]
}