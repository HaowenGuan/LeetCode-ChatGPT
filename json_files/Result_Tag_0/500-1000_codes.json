{
 "500": [
  "n = int(input())\n\nif n == 1:\n    print(\"YES\\n0 0\")\nelif n == 2:\n    print(\"YES\\n0 0\\n0 1\")\nelse:\n    adj_list = [[] for _ in range(n)]\n    for i in range(n-1):\n        u, v = map(int, input().split())\n        adj_list[u-1].append(v-1)\n        adj_list[v-1].append(u-1)\n    \n    x, y = [0]*n, [0]*n\n    curr_x, curr_y = 0, 0\n    \n    def dfs(node, parent):\n        nonlocal curr_x, curr_y\n        for neighbor in adj_list[node]:\n            if neighbor != parent:\n                curr_x += 1\n                x[neighbor] = curr_x\n                y[neighbor] = curr_y\n                dfs(neighbor, node)\n                \n        curr_y += 1\n        for neighbor in adj_list[node]:\n            if neighbor != parent and x[neighbor] == curr_x:\n                x[neighbor] = curr_x + 1\n    \n    root = adj_list[0][0] # choose arbitrary root\n    x[root] = curr_x\n    dfs(root, -1)\n    \n    if max(x) - min(x) > 1000000000 or max(y) - min(y) > 1000000000:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        for i in range(n):\n            print(x[i], y[i])"
 ],
 "501": [
  "MOD=10**9+7\ndef sum(n):\n    return (n%MOD *(n%MOD+1)//2)%MOD\n\ndef ans(l,r):\n    ans=0\n    a=[2,1]\n    u=[1,0]\n    p=3\n    while p<=r:\n        a=[2*a[0]-a[1],2*a[1]]\n        u=[2*(u[0]+u[1])-u[1],2*(u[0]+u[1])]\n        for i in range(2):\n            if l<=p<=r:\n                ans+=(u[i]*(sum(p-p//2)+MOD-sum(p//2-a[i])+MOD))%MOD\n                ans%=MOD\n            p+=a[i]\n    return ans\n\nl,r=map(int,input().split())\nprint(ans(l,r))"
 ],
 "502": [
  "import math\n\nax, ay, bx, by, cx, cy = map(int, input().split())\n\nab_x = bx - ax\nab_y = by - ay\nac_x = cx - ax\nac_y = cy - ay\n\nif ab_x * ac_x + ab_y * ac_y == 0:\n    print(\"No\")\nelse:\n    bc_x = cx - bx\n    bc_y = cy - by\n    if ab_x * bc_x + ab_y * bc_y == 0:\n        print(\"No\")\n    else:\n        # calculate coordinates of point\n        p_x = (ax + bx)/2\n        p_y = (ay + by)/2\n        # calculate angle\n        angle_radians = math.atan2(ab_y, ab_x) - math.atan2(ac_y, ac_x)\n        if angle_radians < 0:\n            angle_radians += 2*math.pi\n        angle_degrees = math.degrees(angle_radians)\n        print(\"Yes\")"
 ],
 "503": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\ncount = 0\nfreq = {}\nfreq_pairs = {}\n\nfor num in a:\n    if num % k == 0:\n        prev = num // k\n        prev_freq_pairs = freq_pairs.get(prev, 0)\n        count += prev_freq_pairs\n        freq_pairs[num] = freq_pairs.get(num, 0) + freq.get(prev, 0)\n    freq[num] = freq.get(num, 0) + 1\n\nprint(count)"
 ],
 "504": [
  "n, a, b = map(int, input().split())\ncreatures = []\nfor i in range(n):\n    hp, dmg = map(int, input().split())\n    creatures.append((hp, dmg))\n\ntotal_damage = 0\nfor hp, dmg in sorted(creatures, key=lambda x: x[1], reverse=True):\n    if b > 0 and hp <= dmg:\n        total_damage += hp\n        b -= 1\n    elif a > 0:\n        total_damage += dmg*2\n        a -= 1\n    else:\n        total_damage += dmg\n        \nprint(total_damage)"
 ],
 "505": [
  "#dfs function\ndef dfs(i,j,step):\n    #if path length is k and Robot is on initial position at the end of path then return path\n    if step==k and i==x[0] and j==x[1]: \n        return path \n    #if steps more than k or Robot is out of maze of on obstacle,return\n    if step>k or i<0 or i>=n or j<0 or j>=m or a[i][j]=='*':\n        return None \n    #find the lexicographically minimal lexicographically path\n    if step==k-1:#one step before the end\n        #if one of the next four steps is the final position then append that step to path\n        #if more than one step is possible then keep the lexicographically(most left upper) first step among them\n        if dfs(i-1,j,step+1):return path+'U'\n        if dfs(i+1,j,step+1):return path+'D'\n        if dfs(i,j-1,step+1):return path+'L'\n        if dfs(i,j+1,step+1):return path+'R'\n    else: #if path length is not k-1\n        #similarly if one of the next four steps is possible then append that step to path\n        #if more than one step is possible then keep the lexicographically(most left upper) first step among them\n        if dfs(i+1,j,step+1):return path+'D'\n        if dfs(i-1,j,step+1):return path+'U'\n        if dfs(i,j+1,step+1):return path+'R'\n        if dfs(i,j-1,step+1):return path+'L'\n#take input n,m,k values\nn,m,k=map(int,input().split())\n#take input a values while keeping record of initial position of Robot('X')\na=[]\nfor i in range(n):\n    row=input()\n    if 'X' in row:\n        x=(i,row.index('X'))\n        row=row.replace('X',\".\")\n    a.append(row)\n#initialize variables and call dfs function\nflag=False\nfor i in range(n):\n    if flag:break #if path previously found, then break loop\n    for j in range(m):\n        if a[i][j]=='.':\n            path=''\n            #if dfs function return value not None, then current path is the answer\n            if dfs(i,j,0):\n                print(path)\n                flag=True #path found, flag set as True\n                break\n#if flag is False means, no such path exists of length k\nif flag==False:print('IMPOSSIBLE')"
 ],
 "506": [
  "a, b = map(int, input().split())\ncount = 0\nwhile a%b != 0:\n    count += (a//b)\n    a, b = b, a%b\ncount += a//b\nprint(count)"
 ],
 "507": [
  "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\np = [0] * n\n\nfor i in range(n):\n    if a[i] == b[i]:\n        p[i] = a[i]\n\nfor i in range(n):\n    if p[i] == 0:\n        temp = set([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n        temp.discard(a[i])\n        temp.discard(b[i])\n        for j in range(n):\n            if p[j] in temp:\n                temp.discard(p[j])\n        p[i] = temp.pop()\n\nprint(*p)"
 ],
 "508": [
  "n, a = map(int, input().split())\n\nif n == 3:\n    print(1, 2, 3)\nelse:\n    min_diff = float('inf')\n    best_v2 = -1\n    \n    for i in range(1, n+1):\n        j = i % n + 1\n        k = j % n + 1\n        angle = (n-2) * 180 / n\n        for multiple in range(1, n-1):\n            cur_angle = angle - (180 - angle) / n * multiple\n            diff = abs(cur_angle - a)\n            if diff < min_diff:\n                min_diff = diff\n                best_v2 = j\n    \n        angle -= 360 / n\n    \n    print(i, best_v2, k)"
 ],
 "509": [
  "n = int(input())\na = []\nfor i in range(n):\n    a.append(int(input()))\n\nfor mask in range(1<<n):\n    sum = 0\n    for i in range(n):\n        if (mask>>i)&1:\n            sum += a[i]\n        else:\n            sum -= a[i]\n    \n    if sum%360 == 0:\n        print(\"YES\")\n        exit()\n\nprint(\"NO\")"
 ],
 "510": [
  "a, b, c, d = map(int, input().split())\ndistances = [0, abs(a - b), abs(a - c), abs(b - c)]\ndistances.sort()\nif distances[3] < d:\n    print(d - distances[3])\nelif distances[2] < d:\n    print(d - distances[2])\nelif distances[1] < d:\n    print(d - distances[1])\nelse:\n    print(0)"
 ],
 "511": [
  "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef f(a, b):\n    if b == 0:\n        return 0\n    return 1 + f(a, b - gcd(a, b))\n\nx, y = map(int, input().split())\nprint(f(x, y))"
 ],
 "512": [
  "n = int(input())\nab_list = [tuple(map(int, input().split())) for _ in range(n)]\nfloor_cnt = [0] * (2*n + 1)\n\nfor a, b in ab_list:\n    if a != -1:\n        floor_cnt[a] += 1\n    if b != -1:\n        floor_cnt[b] -= 1\n\ncnt = 0\nfor i in range(1, 2*n+1):\n    cnt += floor_cnt[i]\n    if cnt > 1:\n        print(\"No\")\n        exit()\n\nfor i in range(n):\n    a, b = ab_list[i]\n    if a == -1:\n        a = b - (i+1)\n    if b == -1:\n        b = a + (i+1)\n    if a >= b:\n        print(\"No\")\n        exit()\n    c = b - a - 1\n    if sum(1 for ai, bi in ab_list if a < ai < b or a < bi < b) != c:\n        print(\"No\")\n        exit()\n\nprint(\"Yes\")"
 ],
 "513": [
  "points = []\nfor i in range(8):\n    x,y = map(int, input().split())\n    points.append((x,y))\n\npoints.sort()\n\nif points[0][0] == points[1][0] == points[2][0] and points[3][0] == points[4][0] == points[5][0] and points[6][0] == points[7][0]:\n    if points[0][1] == points[3][1] == points[6][1] and points[1][1] == points[4][1] == points[7][1] and points[2][1] == points[5][1]:\n        if points[0][1] < points[1][1] < points[2][1] and points[0][0] < points[3][0] < points[6][0]:\n            if points[0][1] != points[4][1] and points[1][1] != points[4][1] and points[1][1] != points[5][1] and points[2][1] != points[4][1]:\n                print(\"respectable\")\n                exit()\n\nprint(\"ugly\")"
 ],
 "514": [
  "t = int(input())\nfor i in range(t):\n    n, d = map(int, input().split())\n    flag = False\n    if d <= n:\n        print(\"YES\")\n        continue\n    left, right = 1, d-1\n    while left <= right:\n        mid = (left + right) // 2\n        if mid + ((d+mid)//(mid+1)) <= n:\n            flag = True\n            break\n        elif mid + ((d+mid)//(mid+1)) > n:\n            right = mid - 1\n        else:\n            left = mid + 1\n    if flag:\n        print(\"YES\")\n    else:\n        print(\"NO\")"
 ],
 "515": [
  "k = int(input())\nif k%2 != 0:\n    print(-1)\nelse:\n    loops = k//2\n    nines = loops//7\n    loops %= 7\n    eights = loops//2\n    fives = loops%2\n    res = \"8\"*eights + \"5\"*fives + \"9\"*nines\n    print(\"-1\" if not res else res + \"0\"*(loops+nines))"
 ],
 "516": [
  "n,m=map(int,input().split())\ns=input()\nt=input()\nans=n\npos=-1\nfor i in range(n):\n    for j in range(m-n+1):\n        cnt=0\n        for k in range(n):\n            if s[k]!=t[j+k] and s[k]!='?':\n                cnt+=1\n        if cnt<ans:\n            ans=cnt\n            pos=i\nprint(ans)\nfor j in range(m-n+1):\n    cnt=0\n    for k in range(n):\n        if s[k]!=t[j+k] and s[k]!='?':\n            cnt+=1\n    if cnt==ans:\n        res=[str(i+1) for i in range(n) if i!=pos or s[i]=='?']\n        print(' '.join(res))\n        break"
 ],
 "517": [
  "n, d, h = map(int, input().split())\nif d > 2*h or d == 1 and n > 2:\n    print(-1)\nelse:\n    for i in range(2, h + 2):\n        print(i - 1, i)\n    if d > h:\n        print(1, h + 2)\n        p = h + 2\n        for i in range(h + 3, d + 2):\n            print(p, i)\n            p = i\n        p += 1\n        for i in range(p, n + 1):\n            print(2, i)"
 ],
 "518": [
  "from math import cos, sin, pi\n\nn, r = map(int, input().split())\n\nl = 0\nr = 10 ** 9\n\nwhile r - l > 1e-7:\n    mid = (l + r) / 2\n    alpha = 2*pi / n\n    R = (r + mid) / (1 - cos(alpha/2))\n    if R < mid:\n        r = mid\n    else:\n        l = mid\n\nprint(\"{:.7f}\".format((l + r) / 2))"
 ],
 "519": [
  "l = int(input())\np = int(input())\nq = int(input())\n\ndistance = (p*l)/(p+q)\nprint(distance)"
 ],
 "520": [
  "n = int(input())\nyears = sorted(list(map(int, input().split())))\nprint(years[(n-1)//2])"
 ],
 "521": [
  "n=int(input())\ns=input()\nif '??' in s or 'C?C' in s or 'M?M' in s or 'Y?Y' in s or ('C' not in s) or ('M' not in s) or ('Y' not in s):\n    print('Yes')\nelse:\n    print('No')"
 ],
 "522": [
  "n, f1, f2, f3, c = map(int, input().split())\nmod = int(1e9+7)\n\nif n == 4:\n    print(f1)\nelif n == 5:\n    print(f2)\nelif n == 6:\n    print(f3)\nelse:\n    mat = [[c, 1, 0, 0],\n           [0, 1, 1, 0],\n           [0, 1, 0, 1],\n           [0, 1, 0, 0]]\n    res = [[f3], [f2], [f1], [1]]\n    n -= 3\n    while n > 0:\n        if n & 1:\n            res = [[sum((mat[i][j] * res[j][0]) % mod for j in range(4))] for i in range(4)]\n        mat = [[sum((mat[i][k] * mat[k][j]) % mod for k in range(4)) for j in range(4)] for i in range(4)]\n        n >>= 1\n    print(res[0][0] % mod)"
 ],
 "523": [
  "n, m = map(int, input().split())\nstrings = [input() for _ in range(n)]\n\npalindrome = ''\nremaining = []\nfor s in strings:\n    if s == s[::-1]:\n        palindrome += s\n    else:\n        if s[::-1] in strings:\n            palindrome += s\n            strings.remove(s[::-1])\n        else:\n            remaining.append(s)\n\nresult = palindrome + ''.join(remaining) + palindrome[::-1]\nprint(len(result))\nprint(result)"
 ],
 "524": [
  "n = int(input())\na = list(map(int, input().split()))\n\n#a is sorted\na.sort()\n\n#Initialise an answer\nans = float(\"inf\")\n\n\n#Checking all values of c, from the lowest to the highest can be c-1, c, or c+1.\nfor i in range(-1, 2):\n    for j in range(n):\n        #Calculate the value of c\n        c = int(pow(a[j]+i,n-j-1))\n\n        #Initialise the cost\n        cost = 0\n\n        #Calculate the cost of transforming a into a power sequence with c\n        for k in range(j):\n            cost += abs(int(pow(c, k))-a[k])\n\n        for k in range(j, n):\n            cost += abs(int(pow(c, k))-a[k])\n\n        ans = min(ans, cost)\n\nprint(ans) "
 ],
 "525": [
  "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    res = 1\n    for i in range(1, n):\n        if a[i] != a[i-1]:\n            res += 1\n    if res == 2 and a[0] == a[-1]:\n        res = 1\n    print(min(res, 2))"
 ],
 "526": [
  "n, m = map(int, input().split())\na = []\nfor i in range(n):\n    a.append(list(map(int, input().split())))\n\ns = set()\nfor i in range(n):\n    for j in range(m):\n        if a[i][j] != 0:\n            s.add(j)\n            break\n\nif len(s) == 0:\n    print(\"NIE\")\nelse:\n    print(\"TAK\")\n    for i in range(n):\n        for j in s:\n            if a[i][j] != 0:\n                print(j+1, end=\" \")\n                break"
 ],
 "527": [
  "s = input().strip()\nt = input().strip()\ns_len = len(s)\nt_len = len(t)\n\nreps = (10**100 + t_len - 1) // t_len\ns_10 = s * reps\n\ni = 0\nj = 0\nwhile i < len(s_10) and j < t_len:\n    if s_10[i] == t[j]:\n        j += 1\n    i += 1\n\nif j == t_len:\n    print(i)\nelse:\n    print(-1)"
 ],
 "528": [
  "n, m = map(int,input().split())\n\n#build the set to find every friend of a member\nfriendships = {}\nfor i in range(n):\n    friendships[i+1] = set()\n\n#add any friendships to the set\nfor i in range(m):\n    a,b = map(int,input().split())\n    friendships[a].add(b)\n    friendships[b].add(a)\n    \n#check if the network is reasonable\nfor i in range(1,n+1):\n    #friendships of friend i\n    fi = friendships[i]\n    for j in fi:\n        #friendships of friend j\n        fj = friendships[j]\n        intersection = fi & fj\n        for k in intersection:\n            #if friend i is not friends with friend k\n            if k not in fi:\n                print(\"NO\")\n                exit()\nprint(\"YES\")"
 ],
 "529": [
  "s = input()\nk = int(input())\nprint(s[:k].lower() + s[k:].upper())"
 ],
 "530": [
  "n = int(input())\ns = input()\nt = input()\n\ns_count = s.count('1')\nt_count = t.count('1')\ncommon_count = 0\n\nfor i in range(2*n):\n    if s[i] == '1' and t[i] == '1':\n        common_count += 1\n\nif s_count > t_count:\n    winning_score = s_count\n    losing_score = t_count\nelse:\n    winning_score = t_count\n    losing_score = s_count\n    \nif common_count % 2 == 1:\n    common_count -= 1\n    winning_score += 1\n    \nif common_count >= (winning_score - losing_score) * 2:\n    print(\"Draw\")\nelse:\n    if winning_score > losing_score:\n        print(\"First\")\n    else:\n        print(\"Second\")"
 ],
 "531": [
  "n = int(input())\nx = list(map(int, input().split()))\nmin_x = min(x)\nmax_x = max(x)\ncount_min = x.count(min_x)\ncount_max = x.count(max_x)\nif count_min > n - count_max:\n    ans = [min_x] * n\n    ans_idx = count_min - (n - count_max)\n    for i in range(ans_idx):\n        ans[i] = max_x\nelse:\n    ans = [max_x] * n\n    ans_idx = count_max - (n - count_min)\n    for i in range(ans_idx):\n        ans[i] = min_x\nprint(n - ans_idx)\nprint(*ans)"
 ],
 "532": [
  "exhibit = input()\nstart = 'a'\ncount_cw = count_ccw = 0\nfor i in exhibit:\n    distance_cw = ord(i) - ord(start)\n    distance_ccw = ord(start) - ord(i)\n    if distance_ccw < 0:\n        distance_ccw += 26\n    if distance_cw < 0:\n        distance_cw += 26\n    count_cw += distance_cw\n    count_ccw += distance_ccw\n    start = i\nprint(min(count_cw, count_ccw))"
 ],
 "533": [
  "a1 = int(input())\na2 = int(input())\nk1 = int(input())\nk2 = int(input())\nn = int(input())\n\nmax_out = 0\nif k1 > k2:\n    a1, a2 = a2, a1\n    k1, k2 = k2, k1\n\nif n >= (a1 * (k1 - 1) + a2 * (k2 - 1)):\n    max_out = a1 + a2 - (n - a1 * (k1 - 1) - a2 * (k2 - 1)) // k2\nif max_out < 0:\n    max_out = 0\nif n < a1 + a2:\n    min_out = max(0, n - (a1 + a2))\nelse:\n    min_out = max(0, n - (a1 * (k1 - 1) + a2 * (k2 - 1)))\nprint(min_out, max_out)"
 ],
 "534": [
  "n, t = map(int, input().split())\ns = input()\n\nfor i in range(t):\n    j = 0\n    while j < n - 1:\n        if s[j] == \"B\" and s[j + 1] == \"G\":\n            s = s[:j] + \"G\" + \"B\" + s[j + 2:]\n            j += 2\n        else:\n            j += 1\n\nprint(s)"
 ],
 "535": [
  "n, k = map(int, input().split())\n\nMOD = 10**9 + 7\n\ndef get_divisors(num):\n    divisors = []\n    for i in range(1, int(num**0.5)+1):\n        if num % i == 0:\n            divisors.append(i)\n            if i != num//i:\n                divisors.append(num//i)\n    return divisors\n\nans = 0\nfor i in range(1, n+1):\n    divisors = get_divisors(i)\n    p = len(divisors)\n    inv_p = pow(p, MOD-2, MOD) # multiplicative inverse of p\n    \n    expected_val = 0\n    for d in divisors:\n        expected_val += d\n    \n    expected_val *= inv_p\n    ans += expected_val\n    \n    ans %= MOD\n\nprint(ans * pow(n, MOD * k - 2, MOD) % MOD)"
 ],
 "536": [
  "n, m = map(int, input().split())\n\nif m < n-1 or m > 2*(n+1):\n    print(-1)\nelse:\n    if m == n-1:\n        print(\"1\" + \"0\"*n + \"1\"*m)\n    elif m == n:\n        print(\"10\"*n + \"1\")\n    else:\n        q, r = divmod(m-n, 2)\n        print(\"110\"*q + \"10\"*r + \"0\"*(n-r-q))"
 ],
 "537": [
  "n, k = map(int, input().split())\n\nif 2*k >= n:\n    print(0, 0, n)\nelse:\n    x = n // (2*k+1)\n    y = k*x\n    z = n - x - y\n    print(x, y, z)"
 ],
 "538": [
  "x = input().strip()\nwhile x[0] == '0':\n    x = x[1:]\nif x == x[::-1]:\n    print(\"YES\")\nelse:\n    for i in range(1, len(x)):\n        if x[i:] == x[i:][::-1]:\n            print(\"YES\")\n            break\n    else:\n        print(\"NO\")"
 ],
 "539": [
  "n = int(input())\ncount = 0\n\nfor a in range(1, n+1):\n    for b in range(a, n+1):\n        c = a ^ b\n        if b <= c <= n and a + b > c:\n            count += 1\n\nprint(count)"
 ],
 "540": [
  "n, m = map(int, input().split())\n\ngrid = [input() for _ in range(n)]\n\nr1, c1 = map(int, input().split())\nr2, c2 = map(int, input().split())\n\nvisited = [[False]*m for _ in range(n)]\n\ndef dfs(r, c):\n    if r==r2 and c==c2:\n        return True\n    visited[r-1][c-1] = True\n    for dx, dy in [(1,0), (-1,0), (0,1), (0,-1)]:\n        nr, nc = r+dx, c+dy\n        if 1<=nr<=n and 1<=nc<=m and not visited[nr-1][nc-1] and grid[nr-1][nc-1]=='.':\n            if dfs(nr, nc):\n                return True\n    return False\n\nif dfs(r1, c1):\n    print('YES')\nelse:\n    print('NO')"
 ],
 "541": [
  "n, m = map(int, input().split())\nedges = [set() for _ in range(n)]\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edges[a-1].add(b-1)\n    edges[b-1].add(a-1)\n\nvisited = set()\ndef dfs(node):\n    visited.add(node)\n    for neighbor in edges[node]:\n        if neighbor not in visited:\n            dfs(neighbor)\n\ncount = 0\nfor i in range(n):\n    if i not in visited:\n        dfs(i)\n        count += 1\n\nprint(count - 1)"
 ],
 "542": [
  "n = int(input())\npoints = [int(input()) for i in range(n)]\nwinner = None\n\nif sum(points) > 0:\n    winner = \"first\"\nelif sum(points) < 0:\n    winner = \"second\"\nelse:\n    for i in range(n):\n        if points[i] > 0:\n            winner = \"first\"\n            break\n        elif points[i] < 0:\n            winner = \"second\"\n            break\n\nprint(winner)"
 ],
 "543": [
  "n = int(input())\na = list(map(int,input().split()))\n\nif n == 1:\n    print(\"YES\")\nelif n == 2:\n    if a[0] == 0 or a[1] == 0 or (sum(a) % 2 != 0):\n        print(\"NO\")\n    else:\n        print(\"YES\")\nelse:\n    if a[0] == 0 and a[-1] == 0:\n        print(\"YES\")\n    elif a[0] == 0 or a[-1] == 0 or (sum(a) % 2 != 0):\n        print(\"NO\")\n    else:\n        left = right = False\n        for i in range(1, n - 1):\n            if a[i] == 0:\n                continue\n            if left and right:\n                break\n            if not left and a[i-1] % 2 == 1:\n                left = True\n            if not right and a[i] % 2 == 1:\n                right = True\n\n        if left and right:\n            print(\"YES\")\n        else:\n            print(\"NO\")"
 ],
 "544": [
  "t = int(input())\nfor i in range(t):\n    n = int(input())\n    s = input()\n    if s == s[::-1]: \n        print(\"YES\")\n        continue\n    cnt = 0\n    for j in range(n//2):\n        if abs(ord(s[j]) - ord(s[n-j-1])) == 2 or abs(ord(s[j]) - ord(s[n-j-1])) == 0: \n            continue\n        else:\n            cnt += 1\n    if cnt > 0:\n        print(\"NO\")\n    else:\n        print(\"YES\")"
 ],
 "545": [
  "n, t = map(int, input().split())\ns1 = input()\ns2 = input()\n\ndiff_indices = [i for i in range(n) if s1[i] != s2[i]]\n\nif t > len(diff_indices) or t < (len(diff_indices) - ((n - t) // 2)):\n    print(-1)\nelse:\n    s3 = list(s1)\n    for i in range(t):\n        j = diff_indices[i]\n        for c in 'abcdefghijklmnopqrstuvwxyz':\n            if s1[j] != c and s2[j] != c:\n                s3[j] = c\n                break\n    for i in range(n):\n        if s3[i] == s1[i] or s3[i] == s2[i]:\n            for c in 'abcdefghijklmnopqrstuvwxyz':\n                if c != s1[i] and c != s2[i]:\n                    s3[i] = c\n                    break\n    print(''.join(s3))"
 ],
 "546": [
  "good_letters = input()\npattern = input()\n\nif \"*\" in pattern:\n    index_star = pattern.index(\"*\")\n    pattern_orign = pattern[:index_star] + pattern[index_star+1:]\n    for _ in range(int(input())):\n        query = input()\n        if len(query) < len(pattern_orign):\n            print(\"NO\")\n            continue\n        query_slice1 = query[:index_star]\n        query_slice2 = query[-(len(pattern)-index_star-1):]\n        query_slice = query_slice1 + query_slice2\n        if len(query_slice) < len(pattern_orign):\n            print(\"NO\")\n            continue\n        query_orign = query_slice[:index_star] + query_slice[index_star+len(pattern_orign):]\n        for i in range(len(query_slice)-len(pattern_orign)+1):\n            if query_orign == query_slice[i:i+len(pattern_orign)]:\n                print(\"YES\")\n                break\n        else:\n            print(\"NO\")\nelse:\n    for _ in range(int(input())):\n        query = input()\n        if len(query) != len(pattern):\n            print(\"NO\")\n        else:\n            for q, p in zip(query, pattern):\n                if p == \"?\" or p == q or q in good_letters:\n                    continue\n                else:\n                    print(\"NO\")\n                    break\n            else:\n                print(\"YES\")"
 ],
 "547": [
  "n, k = map(int, input().split())\n\npasswords = []\nfor i in range(n):\n    passwords.append(input())\n    \ncorrect_password = input()\n\npasswords.sort(key=len)\n\nbest_case_time = 1\nfor password in passwords:\n    if len(password) < len(correct_password):\n        best_case_time += 1\n    elif password == correct_password:\n        break\n\nworst_case_time = best_case_time + (best_case_time-1) // k * 5\n\nprint(best_case_time, worst_case_time)"
 ],
 "548": [
  "n = int(input())\na = list(map(int, input().split()))\n\nodd_count = even_count = 0\nfor i in range(n):\n    if a[i] % 2 == 0:\n        even_count += 1\n    else:\n        odd_count += 1\n\nif odd_count == 0:\n    print(\"Second\")\nelif even_count == 0:\n    print(\"First\")\nelse:\n    print(\"First\" if odd_count % 2 != 0 else \"Second\")"
 ],
 "549": [
  "n = int(input())\na = int(n**(1/2))\nwhile(n%a != 0):\n    a -= 1\nprint(a, n//a)"
 ],
 "550": [
  "def is_similar(s,t):\n    if len(s) != len(t):\n        return False\n\n    for i in range(len(s)):\n        if s[i] == t[i]:\n            continue\n        if s[i].lower() != t[i].lower():\n            return False\n        if s[i].isdigit() or t[i].isdigit():\n            if s[i].isdigit() and t[i].isdigit():\n                continue\n            elif s[i] == 'O' and t[i] == '0' or s[i] == '0' and t[i] == 'O':\n                continue\n            elif s[i] in '1li' and t[i] in '1li':\n                continue\n            else:\n                return False\n    return True\n\n\nlogin = input().strip()\nn = int(input())\n\nlogins = [input().strip() for i in range(n)]\n\nfor existing_login in logins:\n    if is_similar(login, existing_login):\n        print(\"No\")\n        break\nelse:\n    print(\"Yes\")"
 ],
 "551": [
  "n = int(input())\ny = list(map(int, input().split()))\nif n == 3:\n    print(\"Yes\")\nelse:\n    parallel = False\n    for i in range(1, n):\n        if y[i] != y[i-1]:\n            x = (y[2]-y[1])*(i-1) - (y[i]-y[i-1])*2\n            if x % 2 == 0:\n                x //= 2\n                if y[i] > y[i-1]:\n                    y1 = y[i-1] + x\n                else:\n                    y1 = y[i] + x\n                for j in range(1, n):\n                    if y[j] != y[j-1]:\n                        if (y[j-1] == y1 and y[j] == y1+x) or (y[j-1] == y1+x and y[j] == y1):\n                            parallel = True\n                            break\n                if parallel:\n                    break\n    if parallel:\n        print(\"Yes\")\n    else:\n        print(\"No\")"
 ],
 "552": [
  "n, m = map(int, input().split())\na = input()\nb = input()\ns = input()\n\nhash_a = [0] * (n + 1)\nhash_b = [0] * (n + 1)\nhash_s = [0] * (m + 1)\nbase = 31\nmod = 10 ** 9 + 7\n\npow_base = [1] * (max(n, m) + 1)\nfor i in range(1, max(n, m) + 1):\n    pow_base[i] = pow_base[i - 1] * base % mod\n\nfor i in range(1, n + 1):\n    hash_a[i] = (hash_a[i - 1] * base + ord(a[i - 1]) - ord('a') + 1) % mod\n    hash_b[i] = (hash_b[i - 1] * base + ord(b[i - 1]) - ord('a') + 1) % mod\n\nfor i in range(1, m + 1):\n    hash_s[i] = (hash_s[i - 1] * base + ord(s[i - 1]) - ord('a') + 1) % mod\n\nans = 0\nfor len_a in range(1, n + 1):\n    len_b = m - len_a\n    if len_b < 1 or len_b > n:\n        continue\n    hash1 = []\n    for i in range(len_a, n + 1):\n        hash1.append((hash_a[i] - hash_a[i - len_a] * pow_base[len_a]) % mod)\n    hash2 = []\n    for i in range(len_b, 0, -1):\n        hash2.append((hash_b[i] - hash_b[i - len_b] * pow_base[len_b]) % mod)\n    hash2 = hash2[::-1]\n    for i in range(m - 1):\n        if hash_s[i + 1] in hash1 and hash_s[m] - hash_s[i + 1] * pow_base[m - i - 1] in hash2:\n            ans += hash1.count(hash_s[i + 1]) * hash2.count(hash_s[m] - hash_s[i + 1] * pow_base[m - i - 1])\nprint(ans)"
 ],
 "553": [
  "from itertools import combinations\n\nn = int(input())\npromocodes = [input() for _ in range(n)]\n\ndef count_errors(code1, code2):\n    return sum([1 for i in range(6) if code1[i] != code2[i]])\n\nmax_k = 0\nfor pair in combinations(promocodes, 2):\n    k = count_errors(pair[0], pair[1]) // 2\n    if k > max_k:\n        max_k = k\n\nprint(max_k)"
 ],
 "554": [
  "n, m = map(int, input().split())\na = list(map(int, input().split()))\n\nans = 0\n\nfor i in range(m):\n    l, r = map(int, input().split())\n    s = sum(a[l - 1:r])\n    if s > 0:\n        ans += s\n\nprint(ans)"
 ],
 "555": [
  "x = input().strip()\nans = \"\"\nfor i in x:\n    num = int(i)\n    if num > 4:\n        num = 9 - num\n    ans += str(num)\nif ans[0] == '0':\n    ans = '9' + ans[1:]\nprint(ans)"
 ],
 "556": [
  "l, r, k = map(int, input().split())\n\nfound = False\ni = 0\nwhile True:\n    val = k ** i\n    if l <= val <= r:\n        found = True\n        print(val, end=' ')\n    elif val > r:\n        break\n    i += 1\n\nif not found:\n    print(\"-1\")"
 ],
 "557": [
  "n, m = map(int, input().split())\n\nteleports = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    teleports.append((a, b))\n\nteleports = sorted(teleports)\n\ncurr_pos = 0\nreachable_limit = 0\n\nfor i in range(n):\n    if teleports[i][0] > reachable_limit:\n        print(\"NO\")\n        break\n    reachable_limit = max(reachable_limit, teleports[i][1])\nelse:\n    if reachable_limit >= m:\n        print(\"YES\")\n    else:\n        print(\"NO\")"
 ],
 "558": [
  "MOD = 998244353\n\nn, m, k = map(int, input().split())\n\ndp = [0] * (n + 1)\ndp[0] = 1\n\nacc = [0] * (n + 1)\nacc[1] = 1\n\nfor i in range(2, n + 1):\n    acc[i] = acc[i - 1] + dp[i - 1]\n    if i > k:\n        acc[i] -= dp[i - k - 1]\n    acc[i] %= MOD\n    \n    dp[i] = acc[i - 1] * (m - 1)\n    dp[i] %= MOD\n\nprint(dp[n])"
 ],
 "559": [
  "from sympy import *\np = int(input())\na = list(map(int, input().split()))\nx, b = symbols('x b:{}'.format(p))\nf = sum([b[i] * x**(p-1-i) for i in range(p)])\nsystem = []\nfor i in range(p):\n    system.append(f.subs(x, i) % p == a[i])\nsol = solve(system, b)\nprint(*[int(sol[b_i]) % p for b_i in b])"
 ],
 "560": [
  "r, c = map(int, input().split())\ncake = []\nfor i in range(r):\n    cake.append(input())\nrow_eaten = [False]*r\ncol_eaten = [False]*c\ntotal_eaten = 0\nfor i in range(r):\n    for j in range(c):\n        if cake[i][j] == 'S':\n            row_eaten[i] = True\n            col_eaten[j] = True\nfor i in range(r):\n    if not row_eaten[i]:\n        total_eaten += c\nfor j in range(c):\n    if not col_eaten[j]:\n        for i in range(r):\n            if cake[i][j] == '.':\n                total_eaten += 1\nprint(total_eaten)"
 ],
 "561": [
  "n = int(input())\nnums = list(map(int, input().split()))\nnums.sort()\n\nif n == 1:\n    print('-1')\nelif nums[-1] == nums[0]:\n    print('1')\n    print(nums[0])\nelse:\n    if len(set([nums[i+1] - nums[i] for i in range(n-1)])) > 1:\n        print('0')\n    else:\n        diff = nums[1] - nums[0]\n        if nums[-1] + diff == nums[-2]:\n            print('1')\n            print(nums[-1] + diff)\n        else:\n            print('2')\n            print(nums[0] - diff, nums[-1] + diff)"
 ],
 "562": [
  "n = int(input())\nshows = []\nfor i in range(n):\n    start, end = map(int, input().split())\n    shows.append((start, end))\n\nshows.sort()   # sorting the shows by their start time\nend_times_tv1 = end_times_tv2 = 0   # tracking end times of the current shows on each TV\n\nfor start_time, end_time in shows:\n    if start_time >= end_times_tv1:\n        end_times_tv1 = end_time   # assign new show to TV1\n    elif start_time >= end_times_tv2:\n        end_times_tv2 = end_time   # assign new show to TV2\n    else:\n        print(\"NO\")\n        break\nelse:\n    print(\"YES\")"
 ],
 "563": [
  "l, r = map(int, input().split())\n\nfor a in range(l, r - 1):\n    for b in range(a + 1, r):\n        for c in range(b + 1, r + 1):\n            if (a, b) != (b, c) and (a, c) != (a, b) and (a, c) != (b, c) and \\\n                    all(a % i != 0 or b % i != 0 for i in range(2, int(a ** 0.5) + 1)) and \\\n                    all(b % i != 0 or c % i != 0 for i in range(2, int(b ** 0.5) + 1)) and \\\n                    any(a % i == 0 and b % i == 0 for i in range(2, int(a ** 0.5) + 1)):\n                print(a, b, c)\n                exit()\n\nprint(-1)"
 ],
 "564": [
  "n, s = map(int, input().split())\na = list(map(int, input().split()))\nif sum(a) - max(a) <= s:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "565": [
  "y, b, r = map(int, input().split())\nb -= 1\nr -= 2\nmax_ornaments = min(y, b, r)\nprint(max_ornaments * 3 + 3)"
 ],
 "566": [
  "r, g, b = sorted(map(int, input().split()))\nprint(min((r+g+b)//3, r+g))"
 ],
 "567": [
  "n = int(input())\nprizes = list(map(int, input().split()))\n\ntotal_time = 0\n\ni = 0\nj = n-1\n\nwhile i < j:\n    if prizes[i] <= 10**6 - prizes[j]:\n        total_time += prizes[i] - 1\n        i += 1\n    else:\n        total_time += 10**6 - prizes[j]\n        j -= 1\n\ntotal_time += abs(prizes[i] - 1)\n\nprint(total_time)"
 ],
 "568": [
  "n = int(input())\nmod = 10**9 + 7\nans = pow(27, n, mod) - pow(7, n, mod)\nif ans < 0:\n    ans += mod\nprint(ans)"
 ],
 "569": [
  "n = int(input())\ns = input()\nans = 0\nd = {}\nfor i, ch in enumerate(s):\n    if ch in d:\n        if i - d[ch] > 1:\n            d[ch] = i\n        else:\n            ans += 1\n            d[ch] = i\n    else:\n        d[ch] = i\nprint(ans)"
 ],
 "570": [
  "a, b = map(int, input().split())\nturn = 1\nwhile True:\n    if turn % 2 == 1:\n        if turn == 1:\n            a -= 1\n        else:\n            a -= turn // 2 + 1\n        if a < 0:\n            print(\"Valera\")\n            break\n    else:\n        if turn == 2:\n            b -= 1\n        else:\n            b -= turn // 2 + 1\n        if b < 0:\n            print(\"Vladik\")\n            break\n    turn += 1"
 ],
 "571": [
  "n = int(input())\ns = input()\n\nleft_needed = n // 2\nleft_remaining = s.count(\"(\")\nquestion_marks = s.count(\"?\")\n\nright_needed = n // 2\nright_remaining = s.count(\")\")\nquestion_marks = s.count(\"?\")\n\nif n % 2 != 0:\n    print(\":(\")\nelse:\n    for i in range(n):\n        if s[i] == \"(\":\n            left_remaining -= 1\n        elif s[i] == \")\":\n            right_remaining -= 1\n        else:\n            if left_remaining < left_needed:\n                s = s[:i] + \"(\" + s[i+1:]\n                left_remaining += 1\n                question_marks -= 1\n            else:\n                s = s[:i] + \")\" + s[i+1:]\n                right_remaining += 1\n                question_marks -= 1\n\n        if left_remaining < right_needed or right_remaining < left_needed:\n            print(\":(\")\n            break\n    else:\n        print(s)"
 ],
 "572": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\np = 0\nc = 1\nfor i in range(n + 1):\n    p += c * a[i]\n    c *= 2\nc //= 2\n\nans = 0\nfor i in range(n + 1):\n    mask = c\n    for j in range(2):\n        if j != 0:\n            mask = -c\n        if i < n:\n            ans += (p - (a[i] * c) + mask) % (c * 2) == 0 and abs(p - (a[i] * c) + mask) // c <= k\n        else:\n            ans += a[i] + mask != 0 and abs(a[i] + mask) <= k\n\nprint(ans)"
 ],
 "573": [
  "n = int(input())\ngroups = list(map(int, input().split()))\n\nones = groups.count(1)\ntwos = groups.count(2)\n\nteams = 0\n# Form teams of three with two members from groups of two and one member from groups of one\nif twos >= ones:\n    teams += ones\n    twos -= ones\n    ones = 0\nelse:\n    teams += twos\n    ones -= twos//2\n    twos -= twos//2\n    \n# Form remaining teams of three with remaining groups of two\nteams += twos//3\n\nprint(teams)"
 ],
 "574": [
  "x1, y1, x2, y2 = map(int, input().split())\n\ndelta_x = abs(x2 - x1)\ndelta_y = abs(y2 - y1)\ndist_y = delta_y // 2\n\nif delta_x < dist_y:\n    ans = delta_x + delta_y\nelse:\n    ans = delta_x - dist_y + delta_y\n\nprint(ans + 1)"
 ],
 "575": [
  "n = int(input())\nq_x, q_y = map(int, input().split())\nk_x, k_y = map(int, input().split())\nt_x, t_y = map(int, input().split())\n\nif q_x == k_x:\n    if (t_x == k_x and (t_y - k_y) * (q_y - k_y) < 0) or abs(k_y - q_y) > abs(t_y - q_y):\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelif q_y == k_y:\n    if (t_y == k_y and (t_x - k_x) * (q_x - k_x) < 0) or abs(k_x - q_x) > abs(t_x - q_x):\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelif abs(q_x - k_x) == abs(q_y - k_y):\n    if (abs(t_x - k_x) == abs(t_y - k_y) and (t_x - k_x) * (q_x - k_x) < 0) or abs(k_x - q_x) > abs(t_x - q_x):\n        print(\"YES\")\n    else:\n        print (\"NO\")\nelse:\n    print(\"YES\")"
 ],
 "576": [
  "from math import gcd\n\nn = int(input())\na = list(map(int, input().split()))\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\nmx = 0\nfor i in range(n):\n    for j in range(i+1, n):\n        mx = max(mx, lcm(a[i], a[j]))\n\nprint(mx)"
 ],
 "577": [
  "n, k = map(int, input().split())\nshrub_info = [tuple(map(int, input().split())) for _ in range(n)]\n\nans = 0\n\n# counting baskets that can be filled with berries from the same shrub\nfor a, b in shrub_info:\n    ans += (a // k) + (b // k)\n\n# counting baskets that can be filled with berries of the same color\nred = sum(a for a, b in shrub_info)\nblue = sum(b for a, b in shrub_info)\nans += (red // k) + (blue // k)\n\n# if there are enough berries of one color to fill a basket, we can take any excess from the other color\nif red >= k and blue >= k:\n    ans += max(((red // k) + (blue // k)) - ((red // k) + ((blue - k) // k)), 0)\n    \nprint(ans)"
 ],
 "578": [
  "distance = float(input())\nprint(format(distance, 'g'))"
 ],
 "579": [
  "n,k = map(int, input().split())\np = list(map(int, input().split()))\nc = list(map(int, input().split()))\n\nans = -float('inf') # negative infinity\nfor i in range(n):\n    s = [0] # the sum of the scores in a cycle\n    v = [i] # the visited squares in a cycle\n    while p[v[-1]-1] != v[0]:\n        v.append(p[v[-1]-1])\n        s.append(s[-1]+c[v[-1]-1])\n    \n    l = len(s)\n    t = min(l, k) # the number of moves to take in one cycle\n    if s[0] > 0: # if the cycle has positive score\n        ans = max(ans, s[0]*(k//l) + max(s[1:t+1]))\n    else: # if the cycle has non-positive score\n        ans = max(ans, max(s[:t+1]))\n\nprint(ans)"
 ],
 "580": [
  "import heapq\n\n\ndef dijkstra(n, s, adj):\n    inf = 10 ** 18\n    dist = [inf] * (n + 1)\n    dist[s] = 0\n    heap = [(0, s)]\n    while heap:\n        d, u = heapq.heappop(heap)\n        if d != dist[u]:\n            continue\n        for v, w in adj[u]:\n            if dist[u] + w < dist[v]:\n                dist[v] = dist[u] + w\n                heapq.heappush(heap, (dist[v], v))\n    return dist\n\n\ndef reconstruct_paths(n, s, t, dist, adj):\n    paths = [[] for _ in range(n + 1)]\n    for u in range(1, n+1):\n        for v, w in adj[u]:\n            if dist[u] + w == dist[v]:\n                paths[v].append(u)\n            \n    visited = [False] * (n + 1)\n    visited[t] = True\n    queue = [t]\n    while queue:\n        u = queue.pop()\n        for v in paths[u]:\n            if not visited[v]:\n                visited[v] = True\n                queue.append(v)\n    \n    return visited\n\n\nn, m, s, t = map(int, input().split())\nadj = [[] for _ in range(n + 1)]\nrev_adj = [[] for _ in range(n + 1)]\nedges = []\nfor i in range(m):\n    a, b, l = map(int, input().split())\n    adj[a].append((b, l))\n    rev_adj[b].append((a, l))\n    edges.append((a, b, l))\n\ndist_s = dijkstra(n, s, adj)\ndist_t = dijkstra(n, t, rev_adj)\npassed = reconstruct_paths(n, s, t, dist_s, adj)\nfor a, b, l in edges:\n    if dist_s[a] + l + dist_t[b] != dist_s[t] or not passed[a] or not passed[b]:\n        print(\"NO\")\n        continue\n    if dist_s[a] + l == dist_s[b]:\n        print(\"YES\")\n    else:\n        print(\"CAN\", l-(dist_s[b]-1+dist_t[b]-1))        "
 ],
 "581": [
  "import sys\nsys.setrecursionlimit(200005)\n\n#function to perform dfs on tree and return farthest node and its distance from src\ndef dfs(graph,vertex,visited):\n    visited[vertex]=True\n    farthest=vertex\n    max_dist=0\n    for ind in range(len(graph[vertex])):\n        test=graph[vertex][ind]\n        if visited[test[0]]==False:\n            node,dist=dfs(graph,test[0],visited)\n            if dist+test[1]>max_dist:\n                farthest=node\n                max_dist=dist+test[1]\n    return farthest,max_dist\n\n#takes input\nn=int(input())\ngraph=[[] for i in range(n+1)]\nfor ind in range(n-1):\n    u,v=[int(x) for x in input().split()]\n    graph[u].append([v,1])\n    graph[v].append([u,1])\n    \n#Stores the distance of farthest node os DFS from a node    \nfarthest=[0]*(n+1)\nvisited=[False]*(n+1)\n\n#dfs to store distance from all nodes to the farthest node\n_,_=dfs(graph,1,visited)\nvisited=[False]*(n+1)\nf,node=dfs(graph,1,visited)\nvisited=[False]*(n+1)\nf,s_node=dfs(graph,node,visited)\nfor i in range(1,n+1):\n    farthest[i]=f\n    \n#list to store the output strings\noutput_strings=[]\nanswer=n-1\nwhile answer>=1:\n    #Perform the operation between the two farthest nodes of the tree \n    output_string=\"{} {} {}\".format(node,s_node,node)\n    edge_weight=1\n    node_weight=0\n\n    #The nodes are removed and edge weights are added to the answer till the tree becomes a single node\n    while node!=s_node:\n        max_node=None\n        max_distance=0\n        for ind in range(len(graph[node])):\n            test=graph[node][ind]\n            if farthest[test[0]]==farthest[node]-1:\n                if test[1]+node_weight>=max_distance:\n                    max_node=test[0]\n                    max_distance=test[1]+node_weight\n        if max_node!=None:\n            output_string=\"{} {} {}\".format(node,max_node,node)\n            edge_weight+=1\n            node_weight+=max_distance\n            node=max_node\n        else:\n            break\n\n    while s_node!=node:\n        max_node=None\n        max_distance=0\n        for ind in range(len(graph[s_node])):\n            test=graph[s_node][ind]\n            if farthest[test[0]]==farthest[s_node]-1:\n                if test[1]+node_weight>=max_distance:\n                    max_node=test[0]\n                    max_distance=test[1]+node_weight\n        if max_node!=None:\n            output_string=\"{} {} {}\".format(s_node,max_node,s_node)\n            edge_weight+=1\n            node_weight+=max_distance\n            s_node=max_node\n        else:\n            break\n    output_strings.append(output_string)\n    answer-=1\n\nprint(node_weight)\nfor out_str in output_strings[::-1]:\n    print(out_str)"
 ],
 "582": [
  "n = int(input())\na = list(map(int, input().split()))\nt = list(map(int, input().split()))\n\n# Create a list of tuples with category index and number of publications\ncat_list = [(i, a[i]) for i in range(n)]\n# Sort the list by number of publications in descending order\ncat_list.sort(key=lambda x: x[1], reverse=True)\n\n# Starting from the category with the highest number of publications\nmin_time = 0\nprev_pub = float('inf')\nfor i, num_pub in cat_list:\n    # If there are more publications than the previous category, no need to add new ones\n    if num_pub >= prev_pub:\n        continue\n    # Otherwise, find the minimum time to add new publications to make the category unique\n    target_pub = prev_pub - 1\n    target_time = float('inf')\n    for j, time in enumerate(t):\n        # If the category already has enough publications, move on to the next category\n        if a[j] > target_pub:\n            continue\n        # Otherwise, calculate the time to add enough publications to make the category unique\n        needed = target_pub - a[j]\n        add_time = needed * time\n        target_time = min(target_time, add_time)\n    # Update the minimum time needed\n    min_time += target_time\n    prev_pub = num_pub\n\nprint(min_time)"
 ],
 "583": [
  "n = int(input())\ns = input()\n\ndef get_min(s):\n    cnt = 0\n    mn = 0\n    for i in range(n):\n        cnt += (s[i] == '(') - (s[i] == ')')\n        mn = min(mn, cnt)\n\n    return mn\n\ndef count(s):\n    cnt = 0\n    mn = 0\n    for i in range(n):\n        cnt += (s[i] == '(') - (s[i] == ')')\n        if cnt == mn:\n            cnt = 0\n            mn = 0\n            c = 1\n        else:\n            c = 0\n        if cnt == 0 and mn <= 0:\n            cnt = mn = 0\n            c = 1\n        cnts = set([(0, 0, 0)])\n        hist = (0, 0, 0)\n        for j in range(n):\n            if j == i:\n                hist = (cnt, mn, c)\n            else:\n                cnt += (s[j] == '(') - (s[j] == ')')\n                mn = min(mn, cnt)\n            cnts.add(hist)\n\n        yield len(cnts)\n\na = max(count(s))\nb = 0\nc = 0\nfor i in range(n):\n    for j in range(i, n):\n        t = list(s)\n        t[i], t[j] = t[j], t[i]\n        x = max(count(t))\n        if x > a:\n            a = x\n            b, c = i, j\n\nprint(a)\nprint(b + 1, c + 1)"
 ],
 "584": [
  "n = int(input())\ns = input()\n\nwords_out = [] # list of longest words outside the parentheses\nwords_in = [] # list of words inside the parentheses\nparenthesis_level = 0 # the current nesting level of parentheses\ncurr_word = \"\" # the current word being constructed\n\nfor i in range(n):\n    if s[i] == \"(\":\n        if curr_word != \"\":\n            words_out.append(curr_word) # add the current word to the list of words outside the parentheses\n            curr_word = \"\" # reset current word\n        parenthesis_level += 1 # increase the nesting level\n    elif s[i] == \")\":\n        if curr_word != \"\":\n            words_in.append(curr_word) # add the current word to the list of words inside the parentheses\n            curr_word = \"\" # reset current word\n        parenthesis_level -= 1 # decrease the nesting level\n    elif s[i] == \"_\":\n        if curr_word != \"\":\n            words_out.append(curr_word) # add the current word to the list of words outside the parentheses\n            curr_word = \"\" # reset current word\n    else:\n        curr_word += s[i] # add the current character to the current word\n        \nif curr_word != \"\":\n    words_out.append(curr_word) # add the final word to the list of words outside the parentheses\n    \nmax_len = max([len(word) for word in words_out]) # find the length of the longest word outside the parentheses\nnum_words_in = len(words_in) # count the number of words inside the parentheses\n\nprint(max_len, num_words_in)"
 ],
 "585": [
  "MOD = 998244353\nn, m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nj = 0\ns = []\nfor i in range(n):\n    if a[i] == b[j]:\n        s += [i]\n        j += 1\n    if j == m:\n        break\n\nif j != m:\n    print(0)\nelse:\n    dp = [0] * (m + 1)\n    dp[0] = 1\n    for i in range(1, m + 1):\n        for k in range(dp[i - 1], dp[i - 2] - 1, -1):\n            if k == 0 or s[k - 1] < s[i - 1]:\n                dp[i] = (dp[i] + dp[k]) % MOD\n    print(dp[-1])"
 ],
 "586": [
  "MOD = 998244353\n\nn, k = map(int, input().split())\n\nif k == 1:\n    print(2 % MOD)\nelif n == 1:\n    print(pow(2, k, MOD))\nelse:\n    dp = [[[0] * 2 for _ in range(k + 1)] for _ in range(n + 1)]\n    for i in range(2):\n        for j in range(k + 1):\n            dp[1][j][i] = 1\n    for i in range(2, n + 1):\n        for j in range(k + 1):\n            dp[i][j][0] = (dp[i - 1][j][0] + dp[i - 1][j][1]) % MOD\n            if j > i:\n                dp[i][j][1] = dp[i - 1][j - i][0]\n            dp[i][j][1] = (dp[i][j][1] + dp[i - 1][j][1]) % MOD\n    ans = 0\n    for i in range(k + 1):\n        for j in range(2):\n            ans = (ans + dp[n][i][j]) % MOD\n    print(ans)"
 ],
 "587": [
  "n, k = map(int, input().split())\n\nsushi = []\nfor i in range(n):\n    t, d = map(int, input().split())\n    sushi.append((t,d))\n\nsushi.sort(key=lambda x:-x[1])\n\nkind = set()\nd_sum = 0\nsatisfaction = 0\n\nfor i in range(k):\n    kind.add(sushi[i][0])\n    d_sum += sushi[i][1]\n\nsatisfaction = d_sum + len(kind) * len(kind)\n\nfor i in range(k, n):\n    if sushi[i][0] not in kind:\n        kind.add(sushi[i][0])\n        d_sum += sushi[i][1]\n        if len(kind) == k:\n            break\n\nsatisfaction += d_sum + len(kind) * len(kind)\n\nprint(satisfaction)"
 ],
 "588": [
  "n = int(input())\nengines = []\nfor _ in range(n):\n    x, y = map(int, input().split())\n    engines.append((x, y))\n\nmax_distance = 0\nfor i in range(n):\n    for j in range(i+1, n):\n        dx = engines[i][0] - engines[j][0]\n        dy = engines[i][1] - engines[j][1]\n        distance = (dx**2 + dy**2)**0.5\n        max_distance = max(max_distance, distance)\n\nprint(max_distance)"
 ],
 "589": [
  "import itertools\n\ns = input()\n\ndigits = [str(i) for i in range(10)]\noptions = {char: digits for char in s}\n\nfor i in range(10):\n    if str(i) in s:\n        options[s.index(str(i))] = [str(i)]\n\nfor char in options:\n    if char.isalpha():\n        options[char] = list(set(digits) - set(options[letter] for letter in options if letter != char))\n\nvariants = itertools.product(*options.values())\nprint(len(list(variants)))"
 ],
 "590": [
  "n = int(input())\na = list(map(int,input().split()))\n\nfreq = [0]*n    # to check frequency of each element\nans = list(a)   # copies a list for reference\n\nfor i in range(n):\n    if a[i]>n or freq[a[i]-1]!=0:\n        freq[ans[i]-1] = 0    # unmarking the previously marked\n        for j in range(n):\n            if freq[j]==0:\n                ans[i] = j+1\n                freq[j] = 1      # marking the new element\n                break\n\nprint(sum([1 for i in range(n) if ans[i]!=a[i]])) \nprint(*ans)"
 ],
 "591": [
  "n, k = map(int, input().split())\nlight_levels = list(map(int, input().split()))\n\nindices = list(range(n))\nindices.sort(key=lambda i: light_levels[i], reverse=True)\n\nreading_hours = sorted(indices[:k])\n\nminimum_light_level = light_levels[reading_hours[-1]]\n\nprint(minimum_light_level)\nprint(\" \".join(str(i+1) for i in reading_hours))"
 ],
 "592": [
  "n = int(input())\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n\nscore = 0\n\nfor i in range(2, n+1):\n    for j in range(i*2, n+1, i):\n        if gcd(i, j//i) == 1:\n            score += 1\n\nprint(score*4)"
 ],
 "593": [
  "n, m = map(int, input().split())\n\nvotes = []\nfor i in range(m):\n    votes.append(list(map(int, input().split())))\n\ncity_winners = []\nfor city_votes in votes:\n    max_votes = max(city_votes)\n    city_winner = city_votes.index(max_votes) + 1\n    city_winners.append(city_winner)\n\ncandidate_votes = [0] * n\nfor winner in city_winners:\n    candidate_votes[winner - 1] += 1\n\nmax_votes = max(candidate_votes)\nwinner = candidate_votes.index(max_votes) + 1\n\nprint(winner)"
 ],
 "594": [
  "n, m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nif max(a) >= min(b):\n    print(-1)\nelse:\n    v = max(2*min(a), max(a))\n    if v >= min(b):\n        print(-1)\n    else:\n        print(v)"
 ],
 "595": [
  "y = int(input())\nwhile True:\n    y += 1\n    if ((y % 4 == 0 and y % 100 != 0) or y % 400 == 0):\n        if (sum([31,29,31,30,31,30,31,31,30,31,30,31]) % 7 == 0):\n            break\n    else:\n        if (sum([31,28,31,30,31,30,31,31,30,31,30,31]) % 7 == 0):\n            break\nprint(y)"
 ],
 "596": [
  "import datetime\n\n# Read the input dates\ndate1 = datetime.datetime.strptime(input(), '%Y:%m:%d')\ndate2 = datetime.datetime.strptime(input(), '%Y:%m:%d')\n\n# Calculate the difference in days\ndifference = abs((date2-date1).days)\n\n# Print the answer\nprint(difference)"
 ],
 "597": [
  "from collections import defaultdict\n\nn, m = map(int, input().split())\n\ngraph = defaultdict(list)\nfor _ in range(n-1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n    graph[v].append(u)\n\nattack = set(map(int, input().split()))\n\nans_node = -1\nans_dist = float('inf')\n\ndef dfs(node, parent):\n    global ans_node, ans_dist\n    attack_count = 0\n    max_child_time = 0 # time taken to reach farthest attack node from a child\n    for child in graph[node]:\n        if child == parent:\n            continue\n        child_attack_count, child_max_child_time = dfs(child, node)\n        attack_count += child_attack_count\n        max_child_time = max(max_child_time, child_max_child_time)\n    if node in attack:\n        attack_count += 1\n    if attack_count == m:\n        ans_node = node\n        ans_dist = max_child_time\n    return attack_count, max_child_time + 1\n\ndfs(1, -1)\nprint(ans_node)\nprint(ans_dist)"
 ],
 "598": [
  "n, x = map(int, input().split())\nvouchers = []\nfor i in range(n):\n    l, r, cost = map(int, input().split())\n    vouchers.append((l, r, cost))\nvouchers.sort()\n\nmin_cost = float('inf')\nfor i in range(n):\n    for j in range(i+1, n):\n        duration1 = vouchers[i][1] - vouchers[i][0] + 1\n        duration2 = vouchers[j][1] - vouchers[j][0] + 1\n        if duration1 + duration2 == x and vouchers[i][1] < vouchers[j][0]:\n            total_cost = vouchers[i][2] + vouchers[j][2]\n            min_cost = min(min_cost, total_cost)\nif min_cost == float('inf'):\n    print(-1)\nelse:\n    print(min_cost)"
 ],
 "599": [
  "s = input()\nfor i in range(26):\n    c = chr(ord('a')+i)\n    for j in range(len(s)+1):\n        new_s = s[:j] + c + s[j:]\n        if new_s == new_s[::-1]:\n            print(new_s)\n            exit()\nprint(\"NA\")"
 ],
 "600": [
  "a = int(input())\nb = int(input())\n\ndist = abs(a-b)\ntotal_tiredness = 0\nfor i in range(dist//2):\n    total_tiredness += (i+1)*2\n    \nif dist%2 == 1:\n    total_tiredness += dist//2 + 1\n    \nprint(total_tiredness)"
 ],
 "601": [
  "from math import ceil\n\nt = int(input())\n\nfor i in range(t):\n    p, f = map(int, input().split())\n    cnt_s, cnt_w = map(int, input().split())\n    s, w = map(int, input().split())\n    \n    if s > w:\n        s, w = w, s\n        cnt_s, cnt_w = cnt_w, cnt_s\n    \n    ans = 0\n    \n    for j in range(min(cnt_s, p // s) + 1):\n        r = min(cnt_w, (p - j * s) // w)\n        k = min(cnt_s - j, f // s)\n        q = min(cnt_w - r, (f - k * s) // w)\n        ans = max(ans, j + k + r + q)\n    \n    print(ans)"
 ],
 "602": [
  "a = int(input())\npresidents = [\"Washington\", \"Adams\", \"Jefferson\", \"Madison\", \"Monroe\", \"Adams\", \"Jackson\", \"Van Buren\", \"Harrison\", \"Tyler\", \"Polk\", \"Taylor\", \"Fillmore\", \"Pierce\", \"Buchanan\", \"Lincoln\", \"Johnson\", \"Grant\", \"Hayes\", \"Garfield\", \"Arthur\", \"Cleveland\", \"Harrison\", \"Cleveland\", \"McKinley\", \"Roosevelt\", \"Taft\", \"Wilson\", \"Harding\", \"Coolidge\", \"Hoover\", \"Roosevelt\", \"Truman\", \"Eisenhower\", \"Kennedy\", \"Johnson\", \"Nixon\", \"Ford\", \"Carter\", \"Reagan\"]\nprint(presidents[a-1])"
 ],
 "603": [
  "r, g, b = sorted(map(int, input().split()))\nmix_bouquets = min(r, g, b)\nr -= mix_bouquets\ng -= mix_bouquets\nb -= mix_bouquets\nmix_bouquets += min(2, r) + min(2, g) + min(2, b)\nprint(mix_bouquets)"
 ],
 "604": [
  "n = int(input())\na = list(map(int, input().split()))\n\npos = [i for i in a if i > 0]\nneg = [i for i in a if i < 0]\nzeros = [i for i in a if i == 0]\n\nif len(neg) > len(pos):\n    neg, pos = pos, neg\n\nneg_sum = sum(neg)\npos_sum = sum(pos)\n\nif neg_sum % 2 == 0:\n    print(neg_sum + pos_sum + len(zeros))\nelse:\n    print(neg_sum + pos_sum + len(zeros) - 1)"
 ],
 "605": [
  "a, b, c, d = map(int, input().split())\n\nmisha_points = max((3*a)/10, a - (a/250)*c)\nvasya_points = max((3*b)/10, b - (b/250)*d)\n\nif misha_points > vasya_points:\n    print(\"Misha\")\nelif misha_points < vasya_points:\n    print(\"Vasya\")\nelse:\n    print(\"Tie\")"
 ],
 "606": [
  "import math\n\nR, x1, y1, x2, y2 = map(int, input().split())\n\nd = math.sqrt((x1-x2)**2 + (y1-y2)**2)\n\nif d >= R:\n    print(x1, y1, R)\nelse:\n    r = (R+d)/2\n    x_ap = x1 + (x2 - x1) * r / d\n    y_ap = y1 + (y2 - y1) * r / d\n    print(x_ap, y_ap, r)"
 ],
 "607": [
  "n, m = map(int, input().split())\n\ndef fact(n):\n    res = 1\n    for i in range(2, n + 1):\n        res = (res * i) % m\n    return res\n\ndef power(a, b):\n    if b == 0:\n        return 1\n    temp = power(a, b // 2)\n    if b % 2 == 0:\n        return (temp * temp) % m\n    else:\n        return (temp * temp * a) % m\n\ninv2 = power(2, m - 2)\n\nC1 = pow(2, n - 1, m)\nC2 = fact(n - 2) * pow(2, n - 2, m) % m\nC3 = n * pow(2, n - 3, m) % m\nC4 = pow(2, n, m)\nC5 = pow(2, n - 1, m) * (n - 2) % m\nC6 = pow(2, n - 1, m) * inv2 % m\n\nres = (C1 + C2 - C3 + C4 - C5 + C6) % m\nprint(res)"
 ],
 "608": [
  "n = int(input())\na = list(map(int,input().split()))\ncount = 0\nstreak = 0\nfor i in range(n):\n    if a[i] > 3:\n        streak += 1\n    else:\n        streak = 0\n    if streak == 3:\n        count += 1\n        streak = 0\nprint(count)"
 ],
 "609": [
  "n = int(input())\nletters = []\nfor i in range(n):\n    letters.append(input())\n\ndiagonal1 = letters[0][0]\ndiagonal2 = letters[0][-1]\nothers = set()\n\nfor i in range(n):\n    for j in range(n):\n        if i == j or i+j == n-1:\n            if letters[i][j] != diagonal1 and i == j:\n                print(\"NO\")\n                exit()\n            elif letters[i][j] != diagonal2 and i + j == n-1:\n                print(\"NO\")\n                exit()\n        else:\n            others.add(letters[i][j])\nif len(others) == 1:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "610": [
  "n, m = map(int,input().split())\nif n > m:\n    n, m = m, n\nprint(n+min(n+1, m)-1, m-n)"
 ],
 "611": [
  "n,m=map(int,input().split())\na=[0]*n\nans=0\nfor i in range(m):\n    x,d=map(int,input().split())\n    ans+=x*n\n    if d>=0:\n        ans+=d*(n-1)*n//2\n    else:\n        if n%2==0:\n            ans+=d*n//2*(n-1)\n        else:\n            ans+=d*n*(n-1)//2\n    a=list(map(lambda i,j:j+d*abs(i-(n+1)//2), range(n), a))\n\na.sort()\nif n%2==0:\n    ans+=sum(a[n//2-1:n//2+1])/2*n\nelse:\n    ans+=a[n//2]*n\n\nprint(\"%.10f\"%(ans/n))"
 ],
 "612": [
  "n, k, p = map(int, input().split())\na = list(map(int, input().split()))\n\nevens = []\nodds = []\nfor num in a:\n    if num % 2 == 0:\n        evens.append(num)\n    else:\n        odds.append(num)\n\nif len(evens) < k - p or (len(evens) - k + p) % 2 != 0 or len(evens) + len(odds) < k:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    pos = 0\n    for i in range(k - p):\n        print(\"1\", evens[pos])\n        pos += 1\n    for i in range(p):\n        if pos == len(evens):\n            print(len(odds), *odds)\n            continue\n        if pos == len(evens) - 1:\n            print(len(odds) - 1, *odds)\n            continue\n        if len(odds) > 1 and pos < len(evens) - 1:\n            print(\"2\", evens[pos], odds.pop())\n            pos += 1\n        else:\n            print(\"1\", evens[pos])\n            pos += 1\n        for _ in range(p - 1):\n            print(\"1\", odds.pop())\n    for i in range(k - len(evens) - p):\n        print(len(odds), *odds)"
 ],
 "613": [
  "MOD = 10**9 + 7\n\ndef powmod(a, b, m):\n    res = 1\n    while b > 0:\n        if b & 1:\n            res = res * a % m\n        a = a * a % m\n        b >>= 1\n    return res\n\nt, a, b = map(int, input().split())\n\nif a == 0 or b == 0:\n    ans = int(t == 0 and a == b)\nelse:\n    if t == 0:\n        ans = int(a == b)\n    elif a == b:\n        ans = powmod(a, powmod(2, MOD-2, MOD)*t % (MOD-1), MOD)\n    elif a > b:\n        ans = 0\n    else:\n        n = ((b-a)*(b-a)+a-a*b)//(a*a-b)\n        if (a*n-b) % (n*n-a) != 0:\n            ans = 0\n        else:\n            x = (a*n-b) // (n*n-a)\n            if x >= 0:\n                ans = powmod(n+1, t, MOD)\n            else:\n                ans = 0\n\nprint(\"inf\" if ans == 0 else ans)"
 ],
 "614": [
  "n, m = map(int, input().split())\nsouvenirs = []\nfor i in range(n):\n    w, c = map(int, input().split())\n    souvenirs.append((w, c))\nsouvenirs.sort(key=lambda x: x[1]/x[0], reverse=True)\n\ntotal_cost = 0\nfor w, c in souvenirs:\n    if m == 0:\n        break\n    amount = min(w, m)\n    total_cost += amount * (c/w)\n    m -= amount\n\nprint(total_cost)"
 ],
 "615": [
  "n = int(input())\na = list(map(int, input().split()))\n\nprefix_sum = [0]*(n+1)\nfor i in range(n):\n    prefix_sum[i+1] = prefix_sum[i] + a[i]\n\nINF = float('inf')\nans = INF\nfor i in range(1, n-2):\n    for j in range(i+1, n-1):\n        b = prefix_sum[i]\n        c = prefix_sum[j] - prefix_sum[i]\n        d = prefix_sum[n] - prefix_sum[j]\n        e = prefix_sum[n] - prefix_sum[j]\n        diff = max(b, c, d, e) - min(b, c, d, e)\n        ans = min(ans, diff)\n\nprint(ans)"
 ],
 "616": [
  "n, m = map(int, input().split())\nkeys = []\nfor i in range(m):\n    a, b = map(int, input().split())\n    c = list(map(int, input().split()))\n    bitmask = 0\n    for j in c:\n        bitmask |= (1 << (j-1))\n    keys.append((a, bitmask))\n\nINF = 10**9\ndp = [INF] * (1 << n)\ndp[0] = 0\n\nfor i in range(m):\n    cost, bitmask = keys[i]\n    for j in range(1 << n):\n        dp[j | bitmask] = min(dp[j | bitmask], dp[j] + cost)\n\nif dp[-1] == INF:\n    print(-1)\nelse:\n    print(dp[-1])"
 ],
 "617": [
  "s = input()\nn = len(s)\nnums = []\nops = []\ncurr_num = 0\n\nfor i in range(n):\n    if i%2==0:\n        nums.append(int(s[i]))\n    else:\n        ops.append(s[i])\n        \nm = len(ops)\ndp = [[0]*m for i in range(m)]\n\nfor l in range(1, m+1):\n    for i in range(m-l+1):\n        j = i+l-1\n        if l==1:\n            dp[i][j] = nums[i]\n        else:\n            for k in range(i, j):\n                if ops[k] == '*':\n                    dp[i][j] = max(dp[i][j], dp[i][k]*dp[k+1][j])\n                else:\n                    dp[i][j] = max(dp[i][j], dp[i][k]+dp[k+1][j])\n                    \nprint(dp[0][m-1])"
 ],
 "618": [
  "scales = input()\nweights = input()\n\nleft_pan = scales.split('|')[0]\nright_pan = scales.split('|')[1]\n\nfor weight in weights:\n    if len(left_pan) <= len(right_pan):\n        left_pan += weight\n    else:\n        right_pan += weight\n\nif len(left_pan) == len(right_pan):\n    print(left_pan + '|' + right_pan)\nelse:\n    print(\"Impossible\")"
 ],
 "619": [
  "x, y, z = map(int, input().split())\nmax_coconuts = (x+y)//z\n\nif x%z + y%z < z:\n    min_chizhik = 0\nelse:\n    min_chizhik = z - x%z - y%z\n    if min(x%z, y%z) < min_chizhik:\n        min_chizhik = min(x%z, y%z)\n\nprint(max_coconuts, min_chizhik)"
 ],
 "620": [
  "x1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\nx3, y3 = map(int, input().split())\n\ndx = x2 - x1\ndy = y2 - y1\n\nif dx == 0:\n    x4 = x3 + dy\n    y4 = y3\n    print(1)\n    print(x4, y4)\nelif dy == 0:\n    x4 = x3\n    y4 = y3 + dx\n    print(1)\n    print(x4, y4)\nelse:\n    if abs(dx) == abs(dy):\n        x4 = x3 + dx\n        y4 = y3 + dy\n        print(1)\n        print(x4, y4)\n    else:\n        dx2 = x3 - x1\n        dy2 = y3 - y1\n        x4 = x3 + dx - dx2\n        y4 = y3 + dy - dy2\n        print(3)\n        print(x4, y4)\n        x4 = x3 - dx2\n        y4 = y3 - dy2\n        print(x4, y4)\n        x4 = x2 + dx2\n        y4 = y2 + dy2\n        print(x4, y4)"
 ],
 "621": [
  "n = int(input())\na = list(map(int, input().split()))\n\ncnt = 0\nfolders = []\n\nfor i in range(n):\n    if i == 0 or a[i] * a[i-1] < 0:\n        cnt += 1\n        folders.append(1)\n    else:\n        folders[-1] += 1\n        if folders[-1] > 2:\n            cnt += 1\n            folders[-1] = 2\n\nprint(cnt)\nprint(*folders)"
 ],
 "622": [
  "n, k = map(int, input().split())\narr = [1]\nfor i in range(n - 1):\n    arr = arr + [i+2] + arr\nprint(arr[k-1])"
 ],
 "623": [
  "a1, a2 = map(int, input().split())\ntime = 0\nwhile a1 > 0 and a2 > 0:\n    if a1 < a2:\n        a1 += 1\n        a2 -= 2\n    else:\n        a2 += 1\n        a1 -= 2\n    time += 1\nprint(time)"
 ],
 "624": [
  "n, k, m = map(int, input().split())\na = list(map(int, input().split()))\na.sort(reverse=True)\n\ndp = [[0 for _ in range(m+1)] for _ in range(n+1)]\ndp[0][0] = sum(a)\n\nfor i in range(1, n+1):\n    for j in range(m+1):\n        if j == 0:\n            dp[i][j] = dp[i-1][j]\n        else:\n            dp[i][j] = dp[i-1][j-1] + a[i-1] # operation 1 (increase power)\n            if j <= i*k:\n                dp[i][j] = max(dp[i][j], dp[i-1][j] + a[i-1]) # operation 2 (remove superhero)\n        dp[i][j] = max(dp[i][j], dp[i-1][j])\n\nans = 0\nfor i in range(n+1):\n    if m-i <= (n-i)*k: # at least i superheroes need to be removed for i operations\n        ans = max(ans, (dp[i][m-i])/min(n-i, m-i+k))\n\nprint(\"{:.10f}\".format(ans))"
 ],
 "625": [
  "n = int(input())\nif n%2==0:\n    print(n//2)\nelse:\n    print(-(n+1)//2)"
 ],
 "626": [
  "n = int(input())\na = list(map(int, input().split()))\n\ncurrent_pos = 0\ndirection_changes = 0\n\nwhile sum(a) > 0:\n    # move in the current direction and collect information\n    collected = a[current_pos]\n    a[current_pos] = 0\n    \n    # update position and direction if necessary\n    if current_pos == 0:\n        current_pos += collected\n    elif current_pos == n-1:\n        current_pos -= collected\n    elif a[current_pos-1] > a[current_pos+1]:\n        current_pos -= collected\n    else:\n        current_pos += collected\n        \n    # update direction change counter\n    if collected > 0 and (current_pos == 0 or current_pos == n-1):\n        direction_changes += 1\n        \nprint(direction_changes)"
 ],
 "627": [
  "n = int(input())\ns = input()\n\nfor i in range(n-1):\n    if s[i] > s[i+1]:\n        print(s[:i] + s[i+1:])\n        break\nelse:\n    print(s[:-1])"
 ],
 "628": [
  "n, k = map(int, input().split())\nprices = list(map(int, input().split()))\n\ndp = [[-1 for _ in range(k)] for _ in range(n)]\n\ndef solve(idx, shelves_left, cur_and):\n    if idx == n:\n        if shelves_left == 0:\n            return cur_and\n        return -1\n    \n    if shelves_left == 0:\n        return -1\n    \n    if dp[idx][shelves_left-1] != -1:\n        return dp[idx][shelves_left-1]\n    \n    shelf_and = 2**60-1 # set all bits to 1\n    \n    for i in range(idx, n):\n        shelf_and &= prices[i]\n        subans = solve(i+1, shelves_left-1, shelf_and)\n        if subans != -1:\n            dp[idx][shelves_left-1] = max(dp[idx][shelves_left-1], shelf_and | subans)\n    \n    return dp[idx][shelves_left-1]\n\nprint(solve(0, k, 2**60-1))"
 ],
 "629": [
  "n = int(input())\na = [list(map(int, input().split())) for _ in range(2)]\nb = list(map(int, input().split()))\n\nmin_time = float('inf')\n\nfor i in range(n):\n    for j in range(n):\n        if i == 0 and j == 0:\n            continue\n        time = 0\n        # crossing the avenue for the first time\n        time += sum(b[:j]) + sum(a[0][j:i:-1]) + sum(a[1][i:j:-1])\n        # crossing the avenue for the second time\n        time += sum(b[j:]) + sum(a[1][j:i]) + sum(a[0][i:j])\n        min_time = min(min_time, time)\n\nprint(min_time)"
 ],
 "630": [
  "n,k=map(int,input().split())\na=list(map(int,input().split()))\n\ndef bfs(x):\n    l=max(1,x-k)\n    r=min(n,x+k)\n    cnt=1\n    vis[x]=1\n    q=[x]\n\n    while q:\n        x=q.pop(0)\n        if not a[x]:continue\n        y=a[x] #message x is a reply to message y\n        if vis[y]:continue #if we've already read message y\n        vis[y]=1\n        cnt+=1\n        if l<=y and y<=r:q.append(y)\n    return cnt\n\nfor i in range(1,n+1):\n    vis=[0]*(n+1)\n    print(bfs(i),end=' ')"
 ],
 "631": [
  "import math\nfor _ in range(int(input())):\n    n,m = map(int,input().split())\n    a = sorted(list(map(int,input().split())))\n    s=0\n    f=0\n    for i in range(n):\n        s+=a[i]/(i+1)\n        if s>m:\n            print(\"NO\")\n            f=1\n            break\n    if f==0:\n        if math.isclose(s,m,rel_tol=1e-9,abs_tol=1e-9):\n            print(\"YES\")\n        else:\n            print(\"NO\")"
 ],
 "632": [
  "def smallest_divisor(n):\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return i\n    return n\n\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    for i in range(k):\n        n += smallest_divisor(n)\n        if n == 2:\n            n += smallest_divisor(n)\n            k -= (i + 1)\n            break\n    print(n)"
 ],
 "633": [
  "from math import gcd\n\nn, m = map(int, input().split())\n\nif m < n-1:\n    print(\"Impossible\")\nelse:\n    print(\"Possible\")\n    edges = []\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if gcd(i, j) == 1:\n                edges.append((i, j))\n    \n    for i in range(m):\n        print(edges[i][0], edges[i][1])"
 ],
 "634": [
  "n, m = map(int, input().split())\n\nrows = set(range(1, n+1))\ncols = set(range(1, 3))\n\nreclaimed = set()\n\nfor i in range(m):\n    r, c = map(int, input().split())\n    rows.remove(r)\n    cols.remove(c)\n    reclaimed.add((r, c))\n\n# check if there are any cells left to reclaim\nif not rows:\n    print(\"LOSE\")\nelse:\n    # check if both cities can still reclaim cells\n    if len(rows) == 1:\n        print(\"WIN\")\n    else:\n        # check if one city can reclaim all remaining cells\n        can_win = False\n        for r in rows:\n            if (r-1, 1) not in reclaimed and (r-1, 2) not in reclaimed and (r+1, 1) not in reclaimed and (r+1, 2) not in reclaimed:\n                can_win = True\n                break\n        if can_win:\n            print(\"WIN\")\n        else:\n            print(\"LOSE\")"
 ],
 "635": [
  "n, s = map(int, input().split())\nforward = list(map(int, input().split()))\nbackward = list(map(int, input().split()))\n\nif not forward[0] or not backward[0]:\n    print(\"NO\")\nelif forward[s-1] == 1:\n    print(\"YES\")\nelse:\n    f = False\n    for i in range(s, n):\n        if forward[i] and backward[i]:\n            f = True\n            break\n    if f:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n```\n\nAlternatively, you can use this shorter code:\n\n```python\nn, s = map(int, input().split())\nforward = list(map(int, input().split()))\nbackward = list(map(int, input().split()))\n\nif (forward[0] == 0) or (forward[s-1] == 0 and backward[s-1] == 0):\n    print(\"NO\")\nelse:\n    print(\"YES\")"
 ],
 "636": [
  "n, k = map(int, input().split())\ninstruments = list(map(int, input().split()))\nlst = [(instruments[i], i+1) for i in range(n)]\nlst.sort()\n\nans, indices = 0, []\nfor x in lst:\n    if k >= x[0]:\n        k -= x[0]\n        ans += 1\n        indices.append(x[1])\n    else:\n        break\n\nprint(ans)\nprint(*indices)"
 ],
 "637": [
  "n=int(input())\na=list(map(int,input().split()))\nif a[0]==a[-1]:print(\"NO\")\nelse:\n    for i in range(1,n):\n        if a[i]!=a[i-1]:\n            w=i\n            break\n    else:\n        print(\"YES\")\n        exit()\n    for i in range(w,n):\n        if a[i]!=a[i-w]:\n            print(\"NO\")\n            break\n    else:\n        if n%w!=0:print(\"NO\")\n        else:print(\"YES\")"
 ],
 "638": [
  "n, M = map(int, input().split())\nt = list(map(int, input().split()))\n\nres = []\nfor i in range(n):\n    s = t[:i + 1]\n    s.sort()\n    time = 0\n    count = 0\n    for j in range(i + 1):\n        time += s[j]\n        if time <= M:\n            continue\n        count = i - j\n        break\n    res.append(count)\n\nprint(' '.join(map(str, res)))"
 ],
 "639": [
  "n, x = map(int, input().split())\na = set(map(int, input().split()))\n\nans = 0\nfor i in range(x):\n    if i not in a:\n        ans += 1\n    elif len(a) == n:\n        a.discard(min(a))\n        ans += 1\n    else:\n        pass\n\nprint(ans)"
 ],
 "640": [
  "a, b = map(int, input().split())\n\nwin = 0\ndraw = 0\nlose = 0\n\nfor i in range(1, 7):\n    if abs(a-i) < abs(b-i):\n        win += 1\n    elif abs(a-i) > abs(b-i):\n        lose += 1\n    else:\n        draw += 1\n        \nprint(win, draw, lose)"
 ],
 "641": [
  "day = input().split()\nif day[1] == 'week':\n    if day[0] in ['1', '7']:\n        print(52)\n    else:\n        print(52 if int(day[0]) <= 2 else 53)\nelse:\n    if day[0] in ['1', '3', '5', '7', '8', '10', '12']:\n        print(12)\n    elif day[0] == '2':\n        print(12 - 1)\n    else:\n        print(12 - 2)"
 ],
 "642": [
  "python\nn, m = map(int, input().split())\ndirty_stairs = set(map(int, input().split()))\nif 1 in dirty_stairs or n in dirty_stairs:\n    print(\"NO\")\nelse:\n    for i in range(1, n-1):\n        if i in dirty_stairs:\n            if i+1 in dirty_stairs or i+2 in dirty_stairs:\n                print(\"NO\")\n                break\n    else:\n        print(\"YES\") "
 ],
 "643": [
  "from math import ceil, floor\n\nfor _ in range(int(input())):\n    x, y, p, q = map(int, input().split())\n    k1 = (x + q - 1) // q\n    k2 = (y - x + q - p - 1) // (q - p)\n    if p == 0: \n        print(0 if x == 0 else -1)\n    elif k1 > k2:\n        print(-1)\n    else:\n        print(q * k1 - x)"
 ],
 "644": [
  "l=int(input())\nstack=[]\nflag=False\nans=0\nfor i in range(l):\n    s=input()\n    if s[:3]==\"add\":\n        if flag:\n            continue\n        else:\n            ans+=1\n    else:\n        n=int(s.split()[1])\n        if ans+n*len(stack)>2**32-1:\n            flag=True\n        stack.append(n)\nif flag:\n    print(\"OVERFLOW!!!\")\nelse:\n    print(ans)"
 ],
 "645": [
  "cards = input()\nvowels = \"aeiou\"\ncount = 0\nfor card in cards:\n    if card in vowels and int(cards[-cards.index(card)-1]) % 2 == 1:\n        count += 1\nif count == 0:\n    print(0)\nelse:\n    print(count)"
 ],
 "646": [
  "n = int(input())\ncoordinates = [list(map(int, input().split())) for i in range(n)]\n\ndef check(t):\n    graph = [[] for i in range(n+1)]\n    for i in range(n):\n        x1, y1 = coordinates[i]\n        for j in range(n):\n            x2, y2 = coordinates[j]\n            dist = abs(x2-x1)+abs(y2-y1)\n            if dist <= t:\n                graph[i].append(j)\n                graph[j].append(i)\n    visited = [False]*(n+1)\n    def dfs(u):\n        visited[u] = True\n        for v in graph[u]:\n            if not visited[v]:\n                dfs(v)\n    count = 0\n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n            count += 1\n    if count > 2:\n        return False\n    if count == 1:\n        return True\n    for i in range(n):\n        if len(graph[i]) == 0:\n            flag = False\n            for j in range(n):\n                if i == j:\n                    continue\n                x1, y1 = coordinates[i]\n                x2, y2 = coordinates[j]\n                if abs(x2-x1)+abs(y2-y1) <= 2*t:\n                    flag = True\n                    break\n            if not flag:\n                return False\n            break\n    return True\n\nl = 0\nr = int(2e9)\nans = -1\nwhile l <= r:\n    mid = (l+r)//2\n    if check(mid):\n        ans = mid\n        r = mid-1\n    else:\n        l = mid+1\nprint(ans)"
 ],
 "647": [
  "n = int(input())\nstudents = input()\n\nleft = []\nright = []\n\nfor i in range(n):\n    if students[i] == \"L\":\n        left.append(i+1)\n    else:\n        right.append(i+1)\n\nfor i in range(n//2):\n    print(left[i], right[i])"
 ],
 "648": [
  "m, b = map(int, input().split())\nans = 0\nfor y in range(b+1):\n    x = m*(b-y)\n    ans = max(ans, (x+y)*(x+y+1)//2 + (x+y)*y*(2*y+1)//6)\nprint(ans)"
 ],
 "649": [
  "def dfs(l, x, y): \n    global ans, vis\n    \n    if l == n + 1: \n        ans += 1\n        return\n    \n    vis[x][y] = 1 \n    dx1, dy1, dx2, dy2 = dy[x][y], dx[x][y], dy[x][y] - 1, dx[x][y] \n    dfs(l + 1, x + dx1, y + dy1) \n    dfs(l + 1, x + dx2, y + dy2) \n    vis[x][y] = 0 \n    \nn = int(input()) \nt = list(map(int, input().split()))\nmaxn = (1 << (n + 1)) - 1 \ndx = [[0] * maxn for _ in range(maxn)] \ndy = [[0] * maxn for _ in range(maxn)] \nvis = [[0] * maxn for _ in range(maxn)] \nans = 0\n\ntot = 1 \ndx[1][tot], dy[1][tot] = -1, 0 \nfor i in range(1, n + 1): \n    p = tot \n    for j in range(1, 1 << i): \n        tot += 1 \n        dx[tot][0], dy[tot][0] = dx[p][0], dy[p][0] \n        dx[tot][p], dy[tot][p] = dx[p][0] - dy[p][0], dx[p][0] + dy[p][0] \n        p = p - 1 \n    \ndfs(1, (1 << n) - 1, (1 << n) - 1) \nprint(ans)"
 ],
 "650": [
  "string = input().strip()\nvowels = \"AEIOUY\"\nif string[-1] in vowels:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "651": [
  "from itertools import permutations\n\nn, m = map(int, input().split())\nmaze = [input() for i in range(n)]\nmoves = list(map(int, input()))\n\nsx, sy, ex, ey = -1, -1, -1, -1\n\nfor i in range(n):\n    for j in range(m):\n        if maze[i][j] == \"S\":\n            sx, sy = i, j\n        elif maze[i][j] == \"E\":\n            ex, ey = i, j\ndirs = {\"U\": (-1, 0), \"D\": (1, 0), \"L\": (0, -1), \"R\": (0, 1)}\npossible_moves = set(permutations(dirs.values()))\n\ncount = 0\nfor perm in possible_moves:\n    currx, curry = sx, sy\n    for mv in moves:\n        dx, dy = perm[mv]\n        newx, newy = currx + dx, curry + dy\n        if not 0 <= newx < n or not 0 <= newy < m or maze[newx][newy] == \"#\":\n            break\n        if (newx, newy) == (ex, ey):\n            count += 1\n            break\n        currx, curry = newx, newy\n\nprint(count)\n"
 ],
 "652": [
  "from collections import defaultdict\n\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\npoint_dict = defaultdict(int)\nfor i in range(n):\n    for j in range(i+1, n):\n        x1, y1 = points[i]\n        x2, y2 = points[j]\n        point_dict[(x2-x1, y2-y1)] += 1\ncount = 0\nfor cnt in point_dict.values():\n    count += cnt*(cnt-1)//2\nprint(count)"
 ],
 "653": [
  "n = int(input())\nevents = input()\n\nrooms = ['0'] * 10\n\nfor i in range(n):\n    if events[i] == 'L':\n        j = 0\n        while rooms[j] != '0':\n            j += 1\n        rooms[j] = '1'\n    elif events[i] == 'R':\n        j = 9\n        while rooms[j] != '0':\n            j -= 1\n        rooms[j] = '1'\n    else:\n        rooms[int(events[i])] = '0'\n\nprint(''.join(rooms))"
 ],
 "654": [
  "n = int(input())\nmod = 10 ** 9 + 7\ndp = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\ndp[0][0] = 1\nfor i in range(n + 1):\n    for j in range(n + 1):\n        if i > 0:\n            dp[i][j] += dp[i - 1][j]\n        if j > 0:\n            dp[i][j] += dp[i][j - 1]\n        dp[i][j] %= mod\nans = dp[n][n] - dp[n][n - 1]\nprint(ans % mod)"
 ],
 "655": [
  "n = int(input())\nx, y = map(int, input().split())\ndist_w = x+y-2\ndist_b = (n-x)+(n-y)\nif dist_w <= dist_b:\n    print(\"White\")\nelse:\n    print(\"Black\")"
 ],
 "656": [
  "n, k = map(int, input().split()) \nt = list(map(int, input().split()))\n\ntemp_days, ans = [], 0\nfor i, temp in enumerate(t):\n    if temp < 0:\n        if i == 0 or t[i-1] >= 0:\n            temp_days.append(i)\n        if i == n-1 or t[i+1] >= 0:\n            temp_days.append(i)\n\nif len(temp_days) > 2*k:\n    print(-1)\nelse:\n    for i in range(1, len(temp_days)-1, 2):\n        s, e = temp_days[i-1], temp_days[i+1]\n        if e-s-1 > 2*k:\n            ans += (e-s-1)//(k+1)\n    print(ans+1) "
 ],
 "657": [
  "a, b = map(int, input().split())\nx, y, z = map(int, input().split())\nprint(max(2*x-a,0)+max(y+x*1-a,0)+max(3*z-b,0))"
 ],
 "658": [
  "n, w, v, u = map(int, input().split())\nbus = [list(map(int, input().split())) for _ in range(n)]\nprev_point = bus[0]  # starting point of the bus\nfor point in bus[1:]:\n    if (point[1] - prev_point[1]) / (point[0] - prev_point[0]) < -v / u:\n        print(w / u)\n        exit()\n    prev_point = point\nprint((w - prev_point[1]) / u + prev_point[0] / v)"
 ],
 "659": [
  "n = int(input())\na = list(map(int, input().split()))\n\nasc_sorted_idx = sorted(range(n), key=lambda i: a[i]) \ndesc_sorted_idx = sorted(range(n), key=lambda i: -a[i])\n\nif asc_sorted_idx != list(range(n)) and desc_sorted_idx != list(range(n)):\n    for i in range(n-1):\n        if a[asc_sorted_idx[i]] != a[asc_sorted_idx[i+1]]:\n            x = asc_sorted_idx[i] + 1\n            y = asc_sorted_idx[i+1] + 1\n            print(x, y)           \n            break\nelse:\n    print(-1)"
 ],
 "660": [
  "n, b, p = map(int, input().split())\nmatches = n-1\nbottles = matches*(2*b+1)\ntowels = n*p\nprint(bottles, towels)"
 ],
 "661": [
  "M, K = map(int, input().split())\nN = 2 ** (M + 1)\nif K >= N:\n    print(-1)\nelse:\n    ans = []\n    for i in range(N):\n        if i != K:\n            ans.append(i)\n    for i in reversed(range(N)):\n        if i != K:\n            ans.append(i)\n    ans.append(K)\n    for i in range(N):\n        if i != K:\n            ans.append(i)\n    for i in reversed(ans):\n        print(i, end=' ')"
 ],
 "662": [
  "n = int(input())\ngames = [int(input()) for i in range(n)]\nspectator = 3 # Carl is the initial spectator\nwinners = {1:2, 2:1} # dictionary to determine who plays next based on winner\n\nfor winner in games:\n    if winner == spectator:\n        print(\"NO\")\n        break\n    else:\n        spectator = winners[winner]\nelse:\n    print(\"YES\")"
 ],
 "663": [
  "import math\n\nr, x, y, x_s, y_s = map(int, input().split())\n\ndist = math.sqrt((x_s - x) ** 2 + (y_s - y) ** 2)\n\nif dist == 0:\n    print(0)\nelif dist <= 2 * r:\n    print(1)\nelse:\n    print(math.ceil(dist / (2 * r)))"
 ],
 "664": [
  "n = int(input())\na = list(map(int, input().split()))\n\nsorted_a = sorted(a)\nif a == sorted_a:\n    print(0)\nelse:\n    for i in range(n):\n        if a[i:] + a[:i] == sorted_a:\n            print(n-i)\n            break\n    else:\n        print(-1)"
 ],
 "665": [
  "t = int(input())\n\nfor i in range(t):\n    n, s = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    ans = 0\n    max_time = 0\n    total_time = 0\n\n    # calculate total time and maximum time without skipping any part\n    for j in range(n):\n        total_time += a[j]\n        if a[j] > max_time:\n            max_time = a[j]\n            ans = j+1\n\n    # if the total time is less than or equal to s, Vasya can recite the whole verse\n    if total_time <= s:\n        print(0)\n        continue\n\n    # determine which part to skip to obtain maximum number of gifts\n    for j in range(n):\n        if j == ans-1:\n            continue\n        if total_time - a[j] <= s:\n            print(ans)\n            break\n    else:\n        print(ans)"
 ],
 "666": [
  "n = int(input())\ncurr = 0\ni = 1\nwhile n > curr:\n    i += 1\n    curr += i * (i + 1) // 2\nprint(i - 1 - (curr - n))"
 ],
 "667": [
  "import heapq\nn=int(input())\nd=[list(map(int,input().split())) for _ in range(n)]\nq=[]\nfor i in range(n):\n    v=[]\n    for j in range(n):\n        if i!=j:\n            heapq.heappush(v,(d[i][j],j))\n    heapq.heappush(q,(d[i][i],i,v))\nans=0\nwhile q:\n    x=i,v=heapq.heappop(q)\n    if x!=float('inf'):\n        ans=max(ans,x)\n    if not v:\n        continue\n    y,j=heapq.heappop(v)\n    heapq.heappush(q,(x+y,i,v))\n    heapq.heappush(q,(y,j,[]))\nprint(ans)"
 ],
 "668": [
  "n = int(input())\na = list(map(int, input().split()))\n\nif sum(a) < n-1:\n    print(\"-1\")\nelse:\n    print(n-1)\n    for i in range(2, n+1):\n        for j in range(1, min(a[i-1]+1, i)):\n            print(i, i-j)\n            a[i-j-1] -= 1\n            if a[i-j-1] == 0:\n                break"
 ],
 "669": [
  "n, m = map(int, input().split())\na = list(map(int, input().split()))\n\nmid = n // 2\nleft = a[:mid]\nright = a[mid:]\nsum_left = [sum(left[i:j]) % m for i in range(1<<len(left)) for j in range(i, 1<<len(left))]\nsum_right = [sum(right[i:j]) % m for i in range(1<<len(right)) for j in range(i, 1<<len(right))]\n\nsum_left.sort()\nmax_sum = 0\nfor sr in sum_right:\n    index = bisect.bisect_left(sum_left, m-sr)\n    if index > 0:\n        max_sum = max(max_sum, sr + sum_left[index-1])\n\nprint(max_sum)"
 ],
 "670": [
  "from math import sqrt\n\na, b, c = map(int, input().split())\nx1, y1, x2, y2 = map(int, input().split())\n\nif a == 0 or b == 0:   # Avinguda Diagonal is a coordinate axis\n    distance = abs(x1 - x2) + abs(y1 - y2)\nelse:\n    p1 = (-a*x1-c)/b if b != 0 else 0  # Finding point of intersection of Avinguda Diagonal with line x=x1\n    p2 = (-a*x2-c)/b if b != 0 else 0  # Finding point of intersection of Avinguda Diagonal with line x=x2\n    q1 = (-b*y1-c)/a if a != 0 else 0  # Finding point of intersection of Avinguda Diagonal with line y=y1\n    q2 = (-b*y2-c)/a if a != 0 else 0  # Finding point of intersection of Avinguda Diagonal with line y=y2\n    distance = abs(x1-p1)+abs(p1-p2)+abs(x2-p2) if q1*y1 >= 0 and q2*y2 >= 0 else abs(y1-q1)+abs(q1-q2)+abs(y2-q2)  # Four cases to be handled considering the direction of end points w.r.t. Avinguda Diagonal \n\nprint(\"{:.10f}\".format(distance))   # Formatting output upto 10 decimal places"
 ],
 "671": [
  "n = int(input())\ni = 1\nwhile n > len(str(i)):\n    n -= len(str(i))\n    i += 1\nprint(str(i)[n-1])"
 ],
 "672": [
  "a, b = map(int, input().split())\n\nif a < b:\n    print(0)\nelif a == b:\n    print(\"infinity\")\nelse:\n    count = 0\n    for i in range(1, int(a**0.5) + 1):\n        if a % i == 0:\n            if i > b:\n                count += 1\n            if a // i > b and i != a // i:\n                count += 1\n    print(count)"
 ],
 "673": [
  "n, k = map(int, input().split())\nx = (n // k + 1) * k\nprint(x)"
 ],
 "674": [
  "n = int(input())\nstrings = [input() for i in range(n)]\n\nsuffix = {}\n\nfor i in range(n):\n    for j in range(len(strings[i])):\n        if strings[i][j:] in suffix:\n            suffix[strings[i][j:]][i] = True\n        else:\n            suffix[strings[i][j:]] = {i: True}\n\nans = []\ns = \"\"\nfor i in range(n):\n    flag = True\n    for j in range(len(strings[i])):\n        s += strings[i][j]\n        if suffix.get(s):\n            count = 0\n            curr = None\n            for k in suffix[s]:\n                if not curr:\n                    curr = strings[k]\n                    count += 1\n                else:\n                    temp = strings[k]\n                    if curr == temp:\n                        count += 1\n                    elif curr in temp:\n                        curr = temp\n                        count = 1\n                    elif temp in curr:\n                        count = 1\n                    else:\n                        flag = False\n                        break\n            if not flag:\n                break\n            if count == n:\n                ans.append(s)\n                s = \"\"\n                break\n        else:\n            suffix[s] = {}\n    if s:\n        ans.append(s)\n        s = \"\"\n\nif ans:\n    ans.sort()\n    print(ans[0])\nelse:\n    print(\"NO\")"
 ],
 "675": [
  "m, t, r = map(int, input().split())\nvisits = list(map(int, input().split()))\n\ncandles = [0] * (m + 1)\nlit_candles = 0\nneeded_candles = [0] * (m + 1)\nresult = 0\n\nfor i in range(1, m + 1):\n    diff = max(0, needed_candles[i] - lit_candles)\n    result += diff\n    for j in range(i, m + 1):\n        if visits[j - 1] - visits[i - 1] < t:\n            needed_candles[j] += (t - (visits[j - 1] - visits[i - 1])) - diff\n    lit_candles += diff\n    candles[i:i + t] = [1] * t\n    if sum(candles[max(0, i - t + 1):i + 1]) < r:\n        print(-1)\n        break\nelse:\n    print(result)"
 ],
 "676": [
  "python\nn = int(input())\nboxes = []\nfor i in range(n):\n    boxes.append(int(input()))\nboxes.sort()\nif n == 0:\n    print(\"YES\")\n    print(\"1\\n1\\n3\\n3\")\nelif n == 1:\n    print(\"YES\")\n    print(boxes[0])\n    print(3 * boxes[0])\n    print(3 * boxes[0])\nelif n == 2:\n    if 3 * boxes[0] == boxes[1]:\n        print(\"YES\")\n        print(4 * boxes[0] - boxes[1])\n        print(3 * boxes[0])\n    else:\n        print(\"NO\")\nelif n == 3:\n    if boxes[0] + boxes[2] == 2 * boxes[1]:\n        print(\"YES\")\n        print(boxes[0] + boxes[2] - boxes[1])\n    else:\n        print(\"NO\")\nelse:\n    if boxes[0] + boxes[3] == 2 * boxes[1] + 2 * boxes[2]:\n        print(\"YES\")\n        print(boxes[3] - 3 * (boxes[2] - boxes[1]) - boxes[0])\n    else:\n        print(\"NO\")"
 ],
 "677": [
  "import math\n\nq = int(input())\nfor i in range(q):\n    l, r, d = map(int, input().split())\n    if d < l or d > r:\n        print(d)\n    else:\n        x = math.ceil(r / d) * d\n        print(x)"
 ],
 "678": [
  "HAI\nI HAS A TUX\nGIMMEH TUX\nI HAS A FOO ITS 0\nI HAS A BAR ITS 0\nI HAS A BAZ ITS 0\nI HAS A QUZ ITS 1\nTUX IS NOW A NUMBR\nIM IN YR LOOP NERFIN YR TUX TIL BOTH SAEM TUX AN 0\n   I HAS A PUR\n   GIMMEH PUR\n   PUR IS NOW A NUMBR\n   FOO R SUM OF FOO AN PUR\n   BAR R SUM OF BAR AN 1\n   BOTH SAEM BIGGR OF PRODUKT OF FOO AN QUZ AN PRODUKT OF BAR BAZ AN PRODUKT OF FOO AN QUZ\n   O RLY?\n      YA RLY\n         BAZ R FOO\n         QUZ R BAR\n      OIC\nIM OUTTA YR LOOP\nBAZ IS NOW A NUMBAR\nVISIBLE SMOOSH QUOSHUNT OF BAZ QUZ\nKTHXBYE"
 ],
 "679": [
  "s = input().strip('.')\nif 'A' in s and 'B' in s and 'C' in s:\n    print(\"Yes\")\nelif 'AB' in s or 'AC' in s or 'BC' in s:\n    print(\"Yes\")\nelif 'A' in s and 'BC' in s or 'B' in s and 'AC' in s or 'C' in s and 'AB' in s:\n    print(\"Yes\")\nelse:\n    print(\"No\")"
 ],
 "680": [
  "xa, ya = map(int, input().split())\nxb, yb = map(int, input().split())\nxc, yc = map(int, input().split())\n\nif xb > xc:  # sort B and C based on x\n    xb, xc = xc, xb\n    yb, yc = yc, yb\nif xa > xb:  # sort A and B based on x\n    xa, xb = xb, xa\n    ya, yb = yb, ya\nif xb > xc:  # re-sort B and C based on x\n    xb, xc = xc, xb\n    yb, yc = yc, yb\n\nif xa == xb: # if all on same vertical line\n    res = abs(ya - yb) + abs(yb - yc) + 2\n    print(res)\n    for y in range(min(ya, yb), max(ya, yb) + 1):\n        print(xa, y)\n    for y in range(min(yb, yc), max(yb, yc) + 1):\n        print(xb, y)\n\nelif xb == xc: # if B and C on the same vertical line\n    res = abs(ya - yb) + abs(ya - yc) + 2\n    print(res)\n    for y in range(min(ya, yb), max(ya, yb) + 1):\n        print(xa, y)\n    for y in range(min(ya, yc), max(ya, yc) + 1):\n        print(xb, y)\n\nelse: # if no vertical lines\n    res = (xb - xa) + (yc - yb) + ((xb - xc) if ya < yb < yc or yc < yb < ya else (xc - xb))\n    print(res)\n    for x in range(xa, xb + 1):\n        print(x, ya)\n    if ya < yb:\n        for y in range(ya, yb):\n            print(xb, y)\n        for y in range(yb, yc + 1):\n            print(xc, y)\n    else:\n        for y in range(yb, ya):\n            print(xb, y)\n        for y in range(yc, yb - 1, -1):\n            print(xc, y)"
 ],
 "681": [
  "MOD = 1000000007\ndef matmul(a, b):\n    n = len(a)\n    k = len(b)\n    m = len(b[0])\n    c = [[0] * m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            for h in range(k):\n                c[i][j] = (c[i][j] + a[i][h] * b[h][j]) % MOD\n    return c\n    \nn, m = map(int, input().split())\n\nf = [[1, 1, 0]]\nt = [[1, 1, 1], [1, 0, 0], [0, m, 1]]\n\nwhile n:\n    if n % 2:\n        f = matmul(f, t)\n    t = matmul(t, t)\n    n //= 2\n\nans = f[0][0]\nprint(ans)"
 ],
 "682": [
  "r1, c1, r2, c2 = map(int, input().split())\n\n# rook moves horizontally or vertically\nif r1 == r2 or c1 == c2:\n    rook_moves = 1\nelse:\n    rook_moves = 2\n\n# bishop moves diagonally - same color squares\nif (r1 + c1) % 2 != (r2 + c2) % 2:\n    bishop_moves = 0\nelif abs(r1 - r2) == abs(c1 - c2):\n    bishop_moves = 1\nelse:\n    bishop_moves = 2\n\n# king moves one square in any direction\nking_moves = max(abs(r1 - r2), abs(c1 - c2))\n\nprint(rook_moves, bishop_moves, king_moves)"
 ],
 "683": [
  "a = int(input())\nprint(2**a)"
 ],
 "684": [
  "for _ in range(int(input())):\n    a,b,c,d=map(int,input().split())\n    print(b,c,c)"
 ],
 "685": [
  "import bisect\n\nn, h = map(int, input().split())\n\nascending = []\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    ascending.append([a, b])\n\nmax_distance = 0\n\nfor i in range(n):\n    start = ascending[i][0]\n    end = ascending[i][1]\n    left = bisect.bisect_left(ascending, [start - h, -1])\n    right = bisect.bisect_left(ascending, [end - h, -1])\n    if ascending[right][0] > end - h:\n        right -= 1\n    if ascending[left][1] > start - h:\n        left -= 1\n    max_distance = max(max_distance, end - start + h + ascending[right][0] - ascending[left][1])\n\nprint(max_distance)"
 ],
 "686": [
  "import math\n\ndef is_prime(n):\n    if n == 1:\n        return False\n    for i in range(2, int(math.sqrt(n))+1):\n        if n % i == 0:\n            return False\n    return True\n\nt = int(input())\nfor _ in range(t):\n    x, y = map(int, input().split())\n    if x - y > 1 and is_prime(x-y):\n        print(\"YES\")\n    else:\n        print(\"NO\")"
 ],
 "687": [
  "da, db = input().split()\nda = int(da)\ndb = int(db)\n\nif da + 1 == db:\n    print(da*10+9, db*10)\nelif da == db:\n    print(da*10, db*10+1)\nelse:\n    print(-1)"
 ],
 "688": [
  "t = input()\nsequence = input()\n\ndigits_count = [0] * 10\nfor digit in sequence:\n    if digit == '6':\n        digits_count[9] += 1\n    elif digit == '9':\n        digits_count[6] += 1\n    elif digit == '2':\n        digits_count[5] += 1\n    elif digit == '5':\n        digits_count[2] += 1\n    else:\n        digits_count[int(digit)] += 1\n\nmax_t_count = 0\nfor i in range(1, len(sequence)):\n    curr_t_count = 0\n    curr_digits_count = list(digits_count)\n    for digit in str(t):\n        digit = int(digit)\n        if curr_digits_count[digit] == 0:\n            break\n        curr_digits_count[digit] -= 1\n        curr_t_count += 1\n    else:\n        for digit_count in curr_digits_count:\n            if digit_count < 0:\n                break\n        else:\n            max_t_count = max(max_t_count, curr_t_count)\n\nprint(max_t_count)"
 ],
 "689": [
  "for _ in range(int(input())):\n    n = int(input())\n    cnt = [0]*26\n    for i in range(n):\n        s = input().strip()\n        for ch in s:\n            cnt[ord(ch)-ord('a')] += 1\n    flag = True\n    for i in range(26):\n        if cnt[i] % n != 0:\n            flag = False\n            break\n    print(\"YES\" if flag else \"NO\")"
 ],
 "690": [
  "n = input()[::-1]\nfor i in range(len(n)):\n    digit = int(n[i])\n    print(\"{}|\".format(\"O\" if digit in [5,6,7,8,9] else \" \"), end=\"\")\n    print(\"{}O{}\".format(\"-\"*4 if digit in [4,5,6], \"-\"*3 if digit in [2,3], \"-\"*2 if digit==1 else \" \" if digit==0 else \"\", \"\\n\" if i!=len(n)-1 else \"\"), end=\"\")"
 ],
 "691": [
  "n, x = map(int, input().split())\n\nif n == 1 and x > 0:\n    print(\"NO\")\nelif n == 1 and x == 0:\n    print(\"YES\")\n    print(\"0\")\nelif n == 2:\n    print(\"YES\")\n    print(\"0 \" + str(x))\nelif n >= 3:\n    xor_sum = 0\n    ans = []\n    for i in range(1, n):\n        ans.append(i)\n        xor_sum ^= i\n    if xor_sum == x:\n        ans.append(2**17-x)\n        print(\"YES\")\n        print(*ans)\n    else:\n        ans.append(2**18-x^xor_sum)\n        print(\"YES\")\n        print(*ans)"
 ],
 "692": [
  "from itertools import product\n\nn = int(input())\nm = list(map(int, input().split()))\nr = list(map(int, input().split()))\n\ntotal = 0\ncount = 0\n\nfor x in product(*[range(-m[i]+1, m[i]) for i in range(n)]):\n    d_mod_m = [sum(r[i]*x[i] for i in range(n)) % m[i] for i in range(n)]\n    if all(d_mod_m[i] == 0 for i in range(n)):\n        total += sum(1/(2**abs(x[i])) for i in range(n))\n        count += 1\n        \nprint(total/count)"
 ],
 "693": [
  "n,m=map(int,input().split())\na=list(map(int,input().split()))\nk=list(map(int,input().split()))\n\nl,r,kn,ans=0,0,sum(k),float(\"inf\")\ncnt=[0]*m\n\nwhile r<n:\n    while r<n and kn>0:\n        cnt[a[r]-1]+=1\n        if cnt[a[r]-1]<=k[a[r]-1]:\n            kn-=1\n        r+=1\n        \n    if kn==0:\n        while l<=r and (cnt[a[l]-1]>k[a[l]-1] or k[a[l]-1]==0):\n            cnt[a[l]-1]-=1\n            l+=1\n        ans=min(ans,r-l)\n\n    cnt[a[l]-1]-=1\n    kn+=1\n    l+=1\n\nif ans==float(\"inf\"):\n    print(-1)\nelse:\n    print(ans)"
 ],
 "694": [
  "public_key = input()\na, b = map(int, input().split())\n\nfor i in range(1, len(public_key)):\n    left = int(public_key[:i])\n    right = int(public_key[i:])\n    \n    if left % a == 0 and right % b == 0:\n        print(\"YES\")\n        print(left)\n        print(right)\n        break\n\nelse:\n    print(\"NO\")"
 ],
 "695": [
  "a_1, a_2 = map(int, input().split())\nprint((a_1 & 1) ^ (a_2 & 1))"
 ],
 "696": [
  "p = int(input())\nphi = p - 1\nfactorization = set()\nfor i in range(2, phi + 1):\n    if i * i > phi:\n        break\n    if phi % i == 0:\n        factorization.add(i)\n        while phi % i == 0:\n            phi //= i\nif phi > 1:\n    factorization.add(phi)\n\nfor x in range(1, p):\n    ok = True\n    for factor in factorization:\n        if pow(x, phi // factor, p) == 1:\n            ok = False\n            break\n    if ok:\n        print(len(factorization))\n        break"
 ],
 "697": [
  "MOD = 998244853\n\ndef comb(n: int, r: int) -> int:\n    res = 1\n    for i in range(r):\n        res = res * (n - i) * pow(i + 1, MOD - 2, MOD) % MOD\n    return res\n\ndef solve(n: int, m: int) -> int:\n    ans = 0\n    for i in range(n + 1):\n        c1 = comb(n, i)\n        c2 = comb(m, n - i)\n        ans += (i - (n - i)) * c1 % MOD * c2 % MOD\n    return ans % MOD\n\nn, m = map(int, input().split())\nprint(solve(n, m))"
 ],
 "698": [
  "from itertools import chain\n\nx, k = map(int, input().split())\ntaken_div2 = set()\nmax_missed = min(x - k - 1, k)\n\nfor i in range(k):\n    line = input().split()\n    if line[0] == '2':\n        taken_div2.add(int(line[1]))\n    else:\n        taken_div2.add(int(line[1]))\n        taken_div2.add(int(line[2]))\n\npossible_div2 = set(range(1, x)) - taken_div2\nmin_missed = sum(1 for a, b in zip(sorted(possible_div2), sorted(possible_div2)[1:]) if a + 1 != b)\n\nprint(min_missed, max_missed)"
 ],
 "699": [
  "y, k, n = map(int, input().split())\nstart = ((y // k) + 1) * k\nfound = False\n\nwhile start <= n:\n    found = True\n    print(start - y, end=\" \")\n    start += k\n\nif not found:\n    print(\"-1\")"
 ],
 "700": [
  "n = int(input())\nmap1 = []\nmap2 = []\n\nfor i in range(n):\n    row = input().strip()\n    map1.append(row)\n\nfor i in range(n):\n    row = input().strip()\n    map2.append(row)\n\ndef rotate(map):\n    # helper function to rotate the map 90 degrees clockwise\n    rotated_map = [''.join(row) for row in zip(*map[::-1])]\n    return rotated_map\n\ndef flip(map):\n    # helper function to flip the map along the vertical axis\n    flipped_map = []\n    for row in map:\n        flipped_map.append(row[::-1])\n    return flipped_map\n\n# check if the maps are identical after any combination of rotations and flips\nif map1 == map2:\n    print(\"Yes\")\nelif rotate(map1) == map2 or rotate(rotate(map1)) == map2 or rotate(rotate(rotate(map1))) == map2:\n    print(\"Yes\")\nelif flip(map1) == map2 or rotate(flip(map1)) == map2 or rotate(rotate(flip(map1))) == map2 or rotate(rotate(rotate(flip(map1)))) == map2:\n    print(\"Yes\")\nelse:\n    print(\"No\")"
 ],
 "701": [
  "from collections import Counter\n\ns = input()\nt = input()\n\nif Counter(t) - Counter(s):\n    print(\"need tree\")\nelse:\n    s_pointer = t_pointer = 0\n    while s_pointer < len(s) and t_pointer < len(t):\n        if s[s_pointer] == t[t_pointer]:\n            s_pointer += 1\n            t_pointer += 1\n        else:\n            s_pointer += 1\n    if t_pointer == len(t):\n        print(\"automaton\" if len(s) != len(t) else \"array\" if sorted(s) == sorted(t) else \"both\")\n    else:\n        print(\"need tree\")"
 ],
 "702": [
  "n = int(input())\nboard = []\nfor i in range(n):\n    row = input().strip()\n    board.append(row)\n    \ndef fill_board(board):\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == '.':\n                if i+2 >= n or j+2 >= n:\n                    return \"NO\"\n                if board[i+1][j] == '.' and board[i+2][j] == '.' \\\n                and board[i+1][j+1] == '.' and board[i+1][j-1] == '.' and board[i+2][j] == '.':\n                    board[i] = board[i][:j] + '#' + board[i][j+1:]\n                    board[i+1] = board[i+1][:j-1] + '#' + board[i+1][j:j+2] + '#' + \\\n                    board[i+1][j+2:]\n                    board[i+2] = board[i+2][:j] + '#' + board[i+2][j+1:]\n                else:\n                    return \"NO\"\n    return \"YES\"\n\nprint(fill_board(board))"
 ],
 "703": [
  "k, a, b, v = map(int, input().split())\nn_sections = k - 1\nn_boxes = (a + v - 1) // v\n\nif n_boxes >= b:\n    print(1)\nelse:\n    nuts_per_box = n_sections * v\n    remaining_nuts = a - nuts_per_box\n    nuts_per_section = v\n    sections_per_box = n_sections\n    max_nuts_per_box = v * k\n    boxes_with_div = min(b, remaining_nuts // max_nuts_per_box + 1)\n    boxes_without_div = n_boxes - boxes_with_div\n    nuts_left = max(0, a - boxes_with_div * max_nuts_per_box)\n    sections_left = nuts_left // v\n    boxes_left = (sections_left + n_sections) // k\n    total_boxes = boxes_with_div + boxes_without_div + boxes_left\n    print(total_boxes)"
 ],
 "704": [
  "n = int(input())\na = list(map(int, input().split()))\nr1, c1, r2, c2 = map(int, input().split())\n\n# If the start and end positions are in the same line\nif r1 == r2:\n    print(abs(c1 - c2))\nelse:\n    # Move to the start or end of the start line\n    if c1 == 1:\n        moves = abs(r1 - r2)\n    elif c1 == a[r1 - 1] + 1:\n        moves = abs(r1 - r2) + 1\n    else:\n        moves = min(abs(r1 - r2) + abs(c1 - c2), abs(r1 - r2) + 2 + c2 - 1)\n\n    print(moves)"
 ],
 "705": [
  "n = int(input())\nx = list(map(int, input().split()))\ny = list(map(int, input().split()))\ncnt = 0\nfor i in range(n):\n    for j in range(n):\n        if (x[i] ^ y[j]) in x+y:\n            cnt += 1\nif cnt % 2 == 0:\n    print(\"Karen\")\nelse:\n    print(\"Koyomi\")"
 ],
 "706": [
  "A, B, n, x = map(int, input().split())\nMOD = 10**9 + 7\n\ndef matrix_mult(A, B):\n    C = [[0] * len(B[0]) for _ in range(len(A))]\n    for i in range(len(A)):\n        for j in range(len(B[0])):\n            for k in range(len(B)):\n                C[i][j] = (C[i][j] + A[i][k] * B[k][j]) % MOD\n    return C\n\nF = [[A, B], [0, 1]]\nres = [[1, 0], [0, 1]]\nn_bin = bin(n)[2:]\nfor i in range(len(n_bin)):\n    res = matrix_mult(res, res)\n    if n_bin[i] == \"1\":\n        res = matrix_mult(res, F)\nprint((res[0][0] * x + res[0][1]) % MOD)"
 ],
 "707": [
  "n, m = map(int, input().split())\nx = list(map(int, input().split()))\np = list(map(int, input().split()))\n\nfor j in range(m):\n    if all((x[i] - x[i - 1]) % p[j] == 0 for i in range(1, n)):\n        print(\"YES\")\n        print(x[0], j + 1)\n        break\nelse:\n    print(\"NO\")"
 ],
 "708": [
  "n,k=map(int,input().split())\na,b,c,d=map(int,input().split())\nif n<=4 or k<2*n-2:print(-1)\nelse:\n    ans_v=[a,c,1,4]\n    ans_u=[c,a,4,1]\n    vis=[a,c,1,4]\n    for i in range(1,n+1):\n        if i not in vis:ans_v.append(i);vis.append(i)         \n    vis=[c,a,4,1]\n    for i in range(1,n+1):\n        if i not in vis:ans_u.append(i);vis.append(i)\n    for i in range(1,n-1):\n        if len(ans_v)==k:break\n        ans_v.append(ans_v[-2]+1);ans_v.append(ans_v[-2]-1)\n    for i in range(1,n-1):\n        if len(ans_u)==k:break\n        ans_u.append(ans_u[-2]+1);ans_u.append(ans_u[-2]-1)\n    if b not in ans_v or d not in ans_u:print(-1)\n    else:\n        print(' '.join(map(str,ans_v)))\n        print(' '.join(map(str,ans_u)))"
 ],
 "709": [
  "x = int(input())\nans = bin(x)[2:]\nprint(ans.count('1'))"
 ],
 "710": [
  "n = int(input())\ns = input()\n\ngen = \"ACTG\"\nmin_ops = float('inf')\n\nfor i in range(n-3):\n    substr = s[i:i+4]\n    ops = 0\n    for j in range(4):\n        char_op1 = abs(ord(gen[j]) - ord(substr[j]))\n        char_op2 = 26 - char_op1\n        ops += min(char_op1, char_op2)\n    min_ops = min(ops, min_ops)\n\nprint(min_ops)"
 ],
 "711": [
  "mod = 10**9 + 7\nN, M = map(int, input().split())\n\n# Find all prime factors of M\nprimes = []\nfor i in range(2, int(M**0.5) + 1):\n    if M % i == 0:\n        primes.append(i)\n        while M % i == 0:\n            M //= i\nif M > 1:\n    primes.append(M)\n\n# Calculate the number of sequences\ncounts = [0]*(N+1)\ncounts[0] = 1\nfor p in primes:\n    for i in range(N, 0, -1):\n        counts[i] = (counts[i] + counts[i-1]) % mod\n\nans = 0\nfor i in range(1, N+1):\n    ans = (ans + counts[i]) % mod\nprint(ans)"
 ],
 "712": [
  "n, p, t = map(float, input().split())\nn = int(n)\ndp = [[0]*(n+1) for i in range(n+1)]\ndp[0][0] = 1\nfor i in range(1, int(t)+1):\n    for j in range(0, n+1):\n        if j == 0:\n            dp[i][j] = dp[i-1][j]*(1-p)\n        else:\n            dp[i][j] = dp[i-1][j]*(1-p) + dp[i-1][j-1]*p\nans = 0\nfor i in range(1, n+1):\n    ans += i*dp[int(t)][i]\nprint('{:.8f}'.format(ans))"
 ],
 "713": [
  "from math import sqrt\n\nn, m = map(int, input().split())\n\npoints = []\n\nfor x in range(n+1):\n    for y in range(m+1):\n        if x+y > 0 and sqrt(x**2 + y**2) % 1 != 0: # checking if distance between two points is non-integer\n            points.append((x, y))\n\nprint(len(points))\nfor point in points:\n    print(point[0], point[1])"
 ],
 "714": [
  "n = int(input())\ncards = list(map(int, input().split()))\n\ncards_with_index = [(cards[i], i+1) for i in range(n)]\ncards_with_index.sort()\n\nfor i in range(n//2):\n    print(cards_with_index[i][1], cards_with_index[n-i-1][1])"
 ],
 "715": [
  "choices = []\nfor i in range(4):\n    choice = input().split('.')[1]\n    choices.append(choice)\n\nmin_len = min([len(c) for c in choices])\nmax_len = max([len(c) for c in choices])\n\ngreat_choice = \"\"\nfor i, choice in enumerate(choices):\n    if len(choice) == min_len * 2 or len(choice) == max_len * 2:\n        if great_choice:\n            great_choice = \"\"\n            break\n        else:\n            great_choice = chr(i + 65)\n\nif great_choice:\n    print(great_choice)\nelse:\n    print(\"C\")"
 ],
 "716": [
  "n, a, b = map(int, input().split())\ns = input()\nif s[a-1] != s[b-1]:\n    print(1)\nelse:\n    print(0)"
 ],
 "717": [
  "n = int(input())\nschedule = []\nfor i in range(n):\n    s, d = map(int, input().split())\n    schedule.append((s, d))\n\ncurrent_day = schedule[0][0]\nfor s, d in schedule[1:]:\n    while current_day < s:\n        current_day += 1\n    current_day += max(0, ((d - (current_day - s)) // d + (d - (current_day - s)) % d // d)) * d\n\nprint(current_day)"
 ],
 "718": [
  "a = abs(int(input()))\nb = 1\nwhile '8' not in str(a + b):\n    b += 1\nprint(b)"
 ],
 "719": [
  "def is_perfect(num):\n    return sum(int(digit) for digit in str(num)) == 10\n\nk = int(input())\ncount = 0\nnum = 1\nwhile count < k:\n    if is_perfect(num):\n        count += 1\n    num += 1\n\nprint(num-1)"
 ],
 "720": [
  "n = int(input())\nscores = [(0, 0)]\nfor i in range(n):\n    scores.append(tuple(map(int, input().split())))\n    \ndraws = 0\nfor i in range(n + 1):\n    diff1 = scores[i][0] - scores[i][1]\n    diff2 = scores[-1][0] - scores[-1][1]\n    if diff1 == diff2:\n        draws += 1\n    if diff1 == diff2 + 1 and any(scores[j][0] - scores[j][1] == diff2 for j in range(i)):\n        draws += 1\n\nprint(draws)"
 ],
 "721": [
  "n, d = map(int, input().split())\nhooks = list(map(int, input().split()))\nm = int(input())\n\nhooks.sort()\n\nif n >= m:\n    print(sum(hooks[:m]))\nelse:\n    print(sum(hooks) - (m - n) * d)"
 ],
 "722": [
  "n = int(input())\nfor i in range(n):\n    s = input().strip()[4:]\n    while s in seen:\n        s+='0'\n    seen.add(s)\n    year = int('1'+s)\n    while year <= 1988+i or year % 100 != int(s):\n        year+=100\n    print(year)"
 ],
 "723": [
  "n = int(input())\nfriends = []\nfor i in range(n):\n    w, h = map(int, input().split())\n    friends.append((w, h))\n\nmin_area = float('inf')\nfor i in range(n):\n    for j in range(n):\n        if i == j:\n            area = friends[i][0] * friends[i][1]\n        else:\n            if friends[i][0] > friends[j][1]:\n                area = friends[i][0] * max(friends[i][1], friends[j][0])\n            else:\n                area = max(friends[i][0], friends[j][1]) * max(friends[i][1], friends[j][0])\n        min_area = min(min_area, area)\nprint(min_area)"
 ],
 "724": [
  "n, d = map(int, input().split())\npoints = sorted(list(map(int, input().split())))\n\ncount = 0\nfor i in range(1, n):\n    if points[i] - points[i-1] > 2*d:\n        count += 2\n    elif points[i] - points[i-1] == 2*d:\n        count += 1\n        \nprint(count if n>1 else 0)"
 ],
 "725": [
  "n, m = map(int, input().split())\npixels = [input().split() for i in range(n)]\ncolors = set('CMY')\n\nif any(c in colors for row in pixels for c in row):\n    print(\"#Color\")\nelse:\n    print(\"#Black&White\")"
 ],
 "726": [
  "n, d = map(int, input().split())\nhotels = list(map(int, input().split()))\n\ncount = 2\n\nfor i in range(1, n):\n    distance = hotels[i] - hotels[i-1]\n    if distance > 2*d:\n        count += 2\n    elif distance == 2*d:\n        count += 1\n\nprint(count)"
 ],
 "727": [
  "n=int(input())\na=list(map(int,input().split()))\ncount=0\ni=0\nwhile i<n:\n    j=i\n    while j<n and a[j]==a[i]:\n        j+=1\n    count+=1\n    i=j\nprint(count)"
 ],
 "728": [
  "n = int(input())\nvotes = list(map(int, input().split()))\nlimak_votes = votes[0]\nnum_bribes = 0\n\nwhile max(votes) >= limak_votes:\n    max_index = votes.index(max(votes))\n    if max_index == 0:\n        limak_votes += 1\n    else:\n        votes[max_index] -= 1\n        limak_votes += 1\n        num_bribes += 1\n\nprint(num_bribes)"
 ],
 "729": [
  "n = int(input())\ns = input()\n\nfor i in range(n):\n    for j in range(i+1, n+1):\n        substring = s[i:j]\n        unique_chars = set(substring)\n        if len(unique_chars) <= len(substring)//2:\n            continue\n        else:\n            print(\"YES\")\n            print(substring)\n            exit()\n\nprint(\"NO\")"
 ],
 "730": [
  "k = int(input())\nprint('+' + '-'*24 + '+')\nprint('|O.O.O.O.O.O.O.#.#.#.#.|D|)')\nprint('|O.O.O.O.O.O.#.#.#.#.#.|.|')\nprint('|O.......................|')\nif k == 0:\n    print('|#.#.#.#.#.#.#.#.#.#.#.|.|)')\nelif k <= 3:\n    print('|O.#.#.#.#.#.#.#.#.#.#.|.|)')\nelif k <= 6:\n    print('|O.O.#.#.#.#.#.#.#.#.#.|.|)')\nelif k <= 9:\n    print('|O.O.O.#.#.#.#.#.#.#.#.|.|)')\nelif k <= 12:\n    print('|O.O.O.O.#.#.#.#.#.#.#.|.|)')\nelif k <= 15:\n    print('|O.O.O.O.O.#.#.#.#.#.#.|.|)')\nelif k <= 18:\n    print('|O.O.O.O.O.O.#.#.#.#.#.|.|)')\nelif k <= 21:\n    print('|O.O.O.O.O.O.O.#.#.#.#.|.|)')\nelif k <= 24:\n    print('|O.O.O.O.O.O.O.O.#.#.#.|.|)')\nelif k <= 27:\n    print('|O.O.O.O.O.O.O.O.O.#.#.|.|)')\nelif k <= 29:\n    print('|O.O.O.O.O.O.O.O.O.O.#.|.|)')\nelse:\n    print('|O.O.O.O.O.O.O.O.O.O.O.|.|)')\nprint('+' + '-'*24 + '+')"
 ],
 "731": [
  "w, m, k = map(int, input().split())\n\ndef S(n):\n    return len(str(n))\n\ndef check_len(x):\n    tot_cost = 0\n    curr_num = m\n    while tot_cost <= w:\n        next_num = curr_num + 1\n        cost = (S(curr_num) * k)\n        if tot_cost + cost > w:\n            break\n        if next_num > x:\n            break\n        tot_cost += cost\n        curr_num = next_num\n    return curr_num - m\n\nlo, hi = m, 10**18\nwhile lo < hi:\n    mid = (lo + hi + 1)//2\n    if check_len(mid) == mid - m:\n        lo = mid\n    else:\n        hi = mid - 1\n\nprint(lo - m)"
 ],
 "732": [
  "n = int(input())\n\ncount = 0\n\nfor i in range(1, n+1):\n    i_str = str(i)\n    if len(set(i_str)) <= 2:\n        count += 1\n\n        if len(set(i_str)) == 2 and '0' not in set(i_str):\n            x, y = list(set(i_str))\n            while i <= n:\n                i *= 10\n                if i_str.count(x) > i_str.count(y):\n                    i += int(y)\n                else:\n                    i += int(x)\n                count += 1\n            break\n\nprint(count)"
 ],
 "733": [
  "x, y, a, b = map(int, input().split())\nlcm = x * y // math.gcd(x, y)\nprint((b // lcm - (a - 1) // lcm))"
 ],
 "734": [
  "n, m = map(int, input().split())\na = list(map(int, input().split()))\n\nl, r = 0, sum(a)\nans = 0\nfor i in range(n):\n    r = min(r, l+a[i])\n    ans += max(0, a[i]-(m-r))\n    l += a[i]\n\nprint(ans)"
 ],
 "735": [
  "n = int(input())\na = list(map(int, input().split()))\n\nsorted_a = sorted(a)\n\nif a == sorted_a:\n    print(\"yes\")\n    print(\"1 1\")\nelse:\n    left, right = 0, 0\n    for i in range(n):\n        if a[i] != sorted_a[i]:\n            left = i\n            break\n    for j in range(n-1, -1, -1):\n        if a[j] != sorted_a[j]:\n            right = j\n            break\n    reversed_segment = a[left:right+1][::-1]\n    if reversed_segment == sorted_a[left:right+1]:\n        print(\"yes\")\n        print(left+1, right+1)\n    else:\n        print(\"no\")"
 ],
 "736": [
  "n, m = map(int, input().split())\nif n < m or (n % m != 0 and n % m != 1):\n    print(-1)\nelse:\n    # calculate the number of 2 steps needed\n    twos = (n - 2 * (n // 2)) // 2\n    # calculate the number of 1 steps needed\n    ones = (n // 2) - twos\n    # check if the total number of moves is already a multiple of m\n    if (ones + twos) % m == 0:\n        print(ones + twos)\n    else:\n        # add extra 1 step until the total number of moves is a multiple of m\n        print(ones + twos + 1)"
 ],
 "737": [
  "import math\n\nn = int(input())\n\nroot = math.ceil(math.sqrt(n))\n\nif n <= root * (root - 1):\n    print((root * 2) - 2)\nelse:\n    print((root * 2) - 1)"
 ],
 "738": [
  "A, B, C, D = map(int, input().split())\n\ndef count_triangles(l, r): \n    res = 0\n    for i in range(l, r+1):\n        for j in range(i+1, r+1):\n            kmin = j+1\n            kmax = min(r, i+j-1)\n            if kmin <= kmax:\n                res += kmax-kmin+1\n    return res\n\nans = count_triangles(A, B) + count_triangles(B+1, C) + count_triangles(C+1, D)\nprint(ans)"
 ],
 "739": [
  "L, A, B, M = map(int, input().split())\n\nres = str(A % M)\nd = str(B % M)\nfor i in range(1, L):\n    res += str((A + i*B) % M).rjust(len(d),'0')\nprint(int(res) % M)"
 ],
 "740": [
  "k, n1, n2, n3, t1, t2, t3 = map(int, input().split())\nwash_time = k * t1\ndrying_queue = min(k, n1*n2)\ndrying_time = drying_queue * t2\nremaining = k - drying_queue\nfolding_queue = min(remaining, n2*n3)\nfolding_time = folding_queue * t3\ntotal_time = wash_time + drying_time + folding_time\nprint(total_time)"
 ],
 "741": [
  "n, M = map(int, input().split())\na = list(map(int, input().split()))\n\ntime_lamp_lit = a[0]\nmax_diff = 0\nfor i in range(1, n):\n    max_diff = max(max_diff, a[i] - a[i-1])\n    time_lamp_lit += max_diff\n\n# checking time period after last element and at the beginning\ntime_lamp_lit += max(0, M - a[n-1] - max_diff)\n\n# checking time period before first element\ntime_lamp_lit += a[0]\n\n# calculating maximum possible duration by inserting any value from range [0, M]\nans = time_lamp_lit\nfor i in range(n):\n    # checking time period between current and next element\n    diff = a[i+1] - a[i] if i < n - 1 else M - a[i]\n    # checking duration by inserting a value before current element\n    duration = time_lamp_lit - max_diff + diff\n    ans = max(ans, duration)\n    # checking duration by inserting a value after current element\n    if i < n - 1:\n        duration = time_lamp_lit + min(a[i] - a[i-1], a[i+2] - a[i+1]) - diff\n        ans = max(ans, duration)\n\nprint(ans) "
 ],
 "742": [
  "from heapq import heappop, heappush\n\nfor _ in range(int(input())):\n    n=int(input())\n    b=list(map(int, input().split()))\n    ans = [-1]*(2*n)\n    heap = [i for i in range(1, 2*n+1)]\n    for i in range(n):\n        if ans[2*i] == -1:\n            ans[2*i] = b[i]\n            heap.remove(b[i])\n        else:\n            ans[2*i+1] = b[i]\n            heap.remove(b[i])\n        if i != n-1 and ans[2*i+1] > ans[2*(i+1)]:\n            ans = [-1]*(2*n)\n            break\n    if ans[2*n-1] == -1:\n        for i in range(n):\n            if ans[2*i] == -1:\n                ans[2*i] = heappop(heap)\n            if ans[2*i+1] == -1:\n                ans[2*i+1] = heappop(heap)\n    print(*ans)"
 ],
 "743": [
  "python\nn = int(input())\na = list(map(int, input().split()))\n\nwhile True:\n    a.sort()\n    if a[0] == a[-1]:\n        break\n    diff = a[-1] - a[0]\n    for i in range(n-1):\n        a[i] += diff // (n-1)\n    a[-1] -= diff // (n-1) * (n-1)\n\nprint(sum(a))"
 ],
 "744": [
  "n = int(input())\ncities = input()\n\nseattle_to_sf = 0\nsf_to_seattle = 0\n\nfor i in range(n-1):\n    if cities[i] == 'S' and cities[i+1] == 'F':\n        seattle_to_sf += 1\n    elif cities[i] == 'F' and cities[i+1] == 'S':\n        sf_to_seattle += 1\n\nif seattle_to_sf > sf_to_seattle:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "745": [
  "MOD = 998244353\n\ndef inv(n):\n    return pow(n, MOD-2, MOD)\n\nn, k = map(int, input().split())\n\nfact = [1]*(n+1)\nfor i in range(1,n+1):\n    fact[i] = fact[i-1] * i % MOD\n\nans = 0\n\nfor i in range(k+1):\n    comb1 = fact[n]\n    comb2 = inv(fact[i]) * inv(fact[n-i]) % MOD\n    comb3 = fact[n-i]\n    comb4 = inv(fact[k-i]) * inv(fact[i]) % MOD\n    comb5 = fact[k-i]\n    if i % 2 == 0:\n        ans += comb1 * comb2 % MOD * comb3 % MOD * comb4 % MOD * comb5 % MOD\n    else:\n        ans -= comb1 * comb2 % MOD * comb3 % MOD * comb4 % MOD * comb5 % MOD\n\nprint((ans % MOD + MOD) % MOD)"
 ],
 "746": [
  "from math import sqrt\n\na, b = map(int, input().split())\nn = int(input())\n\nmin_time = float('inf')\n\nfor i in range(n):\n    x, y, v = map(int, input().split())\n    dist = sqrt((x-a)**2 + (y-b)**2)\n    time = dist / v\n    if time < min_time:\n        min_time = time\n\nprint('{:.10f}'.format(min_time))"
 ],
 "747": [
  "n, x = map(int, input().split())\n\ncandies = []\n\nfor i in range(n):\n    t, h, m = map(int, input().split())\n    candies.append((t, h, m))\n\ncandies.sort(key=lambda x: x[1])\n\neaten = 0\nelevation = x\n\nwhile candies:\n    i = 0\n\n    while i < len(candies):\n        if candies[i][1] <= elevation:\n            if eaten == 0 or candies[i][0] != last_type:\n                eaten += 1\n                elevation += candies[i][2]\n                last_type = candies[i][0]\n                candies.pop(i)\n                break\n        else:\n            break\n    else:\n        break\n\nprint(eaten)"
 ],
 "748": [
  "n = int(input())\na = list(map(int, input().split()))\n\none = []\ntwo = []\nfour = []\nsix = []\n\nfor i in a:\n    if i == 1:\n        one.append(i)\n    elif i == 2:\n        two.append(i)\n    elif i == 4:\n        four.append(i)\n    else:\n        six.append(i)\n\nif len(two) > 0:\n    groups = []\n    for i in range(len(four)):\n        groups.append([1,2,4])\n        two.pop()\n        \n    for i in range(len(six)):\n        if len(two) == 0:\n            break\n        groups.append([1,2,6])\n        two.pop()\n        \n    for i in range(len(six)):\n        groups.append([1,3,6])\n\n    if len(two) == 0 and len(six) == 0:\n        for i in groups:\n            print(*i)\n    else:\n        print(-1)\n        \nelse:\n    print(-1)"
 ],
 "749": [
  "s = input()\nn = len(s)\nans = n\nfor c in set(s):\n    lo = 0\n    hi = n\n    while lo < hi:\n        mid = (lo+hi)//2\n        found = False\n        for i in range(n-mid+1):\n            if s[i:i+mid].count(c) == 0:\n                found = True\n                break\n        if found:\n            lo = mid+1\n        else:\n            hi = mid\n    ans = min(ans, lo)\nprint(ans)"
 ],
 "750": [
  "n, k = map(int, input().split())\nprint(-(-2*n//k)*-(-5*n//k)*-(-8*n//k))"
 ],
 "751": [
  "n,m=map(int,input().split())\na=list(map(int,input().split()))\nbus=0\nwhile sum(a)>0:\n    space=m\n    while space>0:\n        if a[0]<=space:\n            space-=a[0]\n            a.pop(0)\n            if sum(a)==0:\n                break\n        else:\n            a[0]-=space\n            space=0\n    bus+=1\nprint(bus)"
 ],
 "752": [
  "n = int(input())\na = [input() for i in range(n)]\nb = [input() for i in range(n)]\n\nd = {}  # keep count of all sizes present in a\n\nfor s in a:\n    if s not in d:\n        d[s] = 1\n    else:\n        d[s] += 1\n\nans = 0\n\nfor s in b:\n    if s in d and d[s] > 0:\n        d[s] -= 1\n    else:\n        ans += 1\n\nprint(ans)"
 ],
 "753": [
  "a, b, c, d = map(int, input().split())\nif a*d < b*c:\n    p = (b*c - a*d)\n    q = b*c\nelse:\n    p = (a*d - b*c)\n    q = a*d\ngcd = 1\nfor i in range(2, min(p,q)+1):\n    if p%i==0 and q%i==0:\n        gcd = i\nif gcd==1:\n    print(\"{}/{}\".format(p,q))\nelse:\n    print(\"{}/{}\".format(p//gcd, q//gcd))"
 ],
 "754": [
  "n = int(input())\ns = input()\ncount = 0\nfor i in range(1,n):\n    if s[i] == s[i-1]:\n        count += 1\nprint(count)"
 ],
 "755": [
  "import math\nx = int(input())\nsteps = math.ceil(x/5)\nprint(steps)"
 ],
 "756": [
  "n = int(input())\ninteresting_minutes = list(map(int,input().split()))\n\ntime_watched = 0\ntime_since_last_interest = 0\n\nfor i in range(1,91):\n    if i in interesting_minutes:\n        time_watched += 1\n        time_since_last_interest = 0\n    else:\n        time_since_last_interest += 1\n        if time_since_last_interest == 15:\n            break\n        time_watched += 1\n\nprint(time_watched)"
 ],
 "757": [
  "n, m, k = map(int, input().split())\na = sorted(list(map(int, input().split())), reverse=True)\ntotal_sockets = k\ncount = 0\ni = 0\nwhile i < n and total_sockets < m:\n    if total_sockets + a[i] - 1 >= m:\n        count += 1\n        break\n    total_sockets += a[i] - 1\n    count += 1\n    i += 1\nprint(count if total_sockets >= m else -1)"
 ],
 "758": [
  "n = int(input())\nstack = input()\n\ncount = 0\ntop_red = True\nfor ball in stack:\n    if ball == 'B':\n        top_red = False\n    elif not top_red:\n        count += 1\n    top_red = True\n\nprint(count)"
 ],
 "759": [
  "hh, mm = map(int, input().split())\nH, D, C, N = map(int, input().split())\n\nif hh >= 20:\n    H += (60-hh)*D + (60-mm)*D\n    total_cost = (H+N-1)//N * C * 0.8\nelse:\n    remaining_time = (20-hh)*60 - mm\n    H += remaining_time * D\n    regular_cost = (H+N-1)//N * C\n    H += (60-20)*D\n    discount_cost = (H+N-1)//N * C * 0.8\n    total_cost = min(regular_cost, discount_cost)\n\nprint(\"{:.4f}\".format(total_cost))"
 ],
 "760": [
  "s = input()\nk = int(input())\n\nmax_len = 0\n\nfor i in range(len(s)):\n    for j in range(i, len(s)):\n        if s[i:j+1] == s[j+1:j+1+j-i+1]:\n            tandem_len = j-i+1\n            if j+tandem_len+(k//2)*tandem_len <= len(s)+k:\n                max_len = max(max_len, tandem_len*2)\n                \nprint(max_len)"
 ],
 "761": [
  "n = int(input())\nslimes = list(map(int, input().split()))\n\nprefix_sum = [0]\nfor slime in slimes:\n    prefix_sum.append(prefix_sum[-1] + slime)\n\nmax_val = -float('inf')\nfor i in range(n):\n    for j in range(i+1, n+1):\n        max_val = max(max_val, prefix_sum[j]-prefix_sum[i])\n\nprint(max_val)"
 ],
 "762": [
  "n, B = map(int, input().split())\na = list(map(int, input().split()))\n\n# initialize variables\ndp = [[float('inf') for _ in range(n+1)] for _ in range(n+1)]\ndp[0][0] = 0\ncount = 0\n\n# dynamic programming approach\nfor i in range(1,n+1):\n    for j in range(1,i):\n        if (a[i-1] % 2 != a[j-1] % 2) and (abs(i-j) % 2 == 0):\n            for k in range(1,i):\n                dp[i][k] = min(dp[i][k], dp[j][k-1] + abs(i-j))\n                \n# count maximum number of cuts possible within budget B\nfor i in range(1,n):\n    for j in range(n+1):\n        if dp[n][i] <= B:\n            count = max(count, i)\n            \nprint(count)"
 ],
 "763": [
  "n = int(input())\na = list(map(int, input().split()))\n\nans = float('inf')\nfor i in range(n):\n    cur_ans = 0\n    for j in range(n):\n        cur_ans += a[j] * (2 * (abs(j-i) + j + i))\n    ans = min(ans, cur_ans)\nprint(ans)"
 ],
 "764": [
  "n = int(input())\ny = input().strip()\n\ndef gcd(a,b):\n    while b:\n        a,b = b,a%b\n    return a\n\nans = 0\nfor k in range(1,n):\n    if n % k == 0 and gcd(k,n) == 1: # checks if k is a primitive root of n\n        works = True\n        for i in range(n):\n            if y[i] != y[(i+k)%n] ^ y[i-1]:\n                works = False\n                break\n        if works:\n            ans += 1\n\nif y == '0'*n: # if y is all zeros, add n to answer\n    ans += n\n\nprint(ans)"
 ],
 "765": [
  "T, S, q = map(int, input().split())\ncnt = 0\nwhile S < T:\n    S *= q\n    cnt += 1\nprint(cnt)"
 ],
 "766": [
  "from collections import Counter\ns = input()\ncounts = Counter(s)\neven_count = 0\nodd_count = 0\nfor count in counts.values():\n    if count % 2 == 0:\n        even_count += 1\n    else:\n        odd_count += 1\nif odd_count > 1:\n    print(\"No\")\nelse:\n    print(\"Yes\")"
 ],
 "767": [
  "n, z = map(int, input().split())\nx = sorted(list(map(int, input().split())))\ni = 0\nj = n//2\nmatched = 0\nwhile i < n//2 and j < n:\n    if x[j] - x[i] >= z:\n        matched += 1\n        i += 1\n        j += 1        \n    else:\n        j += 1\nprint(matched)"
 ],
 "768": [
  "F, I, T = map(int,input().split())\nopinions = []\nfor i in range(F):\n    opinions.append(input())\n\nresult = 0\nfor j in range(I):\n    likes = 0\n    for i in range(F):\n        if opinions[i][j] == \"Y\":\n            likes += 1\n    if likes >= T:\n        result += 1\n\nprint(result)"
 ],
 "769": [
  "a, b, c = map(int, input().split())\nfrac = str(a/b - a//b)\nif c in frac:\n    print(frac.index(c) + 1)\nelse:\n    print(-1)"
 ],
 "770": [
  "n = int(input())\nletters = list(map(int, input().split()))\nread = 0\ncurrent = 0\n\nwhile current < n:\n    if letters[current] == 1:\n        read += 1\n        current += 2\n    else:\n        current += 1\n\nprint(read)"
 ],
 "771": [
  "n, k, m = map(int, input().split())\nmultiset = list(map(int, input().split()))\n\nfreq = {}\nfor num in multiset:\n    freq[num % m] = freq.get(num % m, 0) + 1\n\nans = []\nfor rem in freq.keys():\n    if len(ans) == k:\n        break\n    if freq[rem] >= k:\n        temp = []\n        for num in multiset:\n            if len(temp) == k:\n                break\n            if num % m == rem:\n                temp.append(num)\n        ans = temp\n        \nif len(ans) != k:\n    print(\"No\")\nelse:\n    print(\"Yes\")\n    print(*ans)"
 ],
 "772": [
  "grid = []\nfor i in range(3):\n    grid.append(list(map(int, input().split())))\n\nfor i in range(3):\n    for j in range(3):\n        count = grid[i][j]\n        if i > 0:\n            count += grid[i-1][j]\n        if j > 0:\n            count += grid[i][j-1]\n        if i < 2:\n            count += grid[i+1][j]\n        if j < 2:\n            count += grid[i][j+1]\n        if count % 2 == 0:\n            print(\"1\", end=\"\")\n        else:\n            print(\"0\", end=\"\")\n    print()"
 ],
 "773": [
  "from itertools import combinations\nn, q = map(int, input().split())\nfacts = []\nfor i in range(q):\n    t, l, r, v = map(int, input().split())\n    facts.append((t, l-1, r, v))\n\npossible_values = set(range(1,n+1))\ngood_values = set(range(1, n+1))\n\nfor comb_len in range(1,n+1):\n    combs = combinations(possible_values, comb_len)\n    for comb in combs:\n        is_good_comb = True\n        for fact in facts:\n            t, l, r, v = fact\n            if t == 1:\n                if v not in comb:\n                    continue\n                if any(a not in comb for a in range(l, r)):\n                    is_good_comb = False\n                    break\n            else:\n                if v in comb:\n                    continue\n                if all(a in comb for a in range(l, r)):\n                    is_good_comb = False\n                    break\n        if is_good_comb:\n            good_values = comb\n            break\n    if len(good_values) != n:\n        possible_values -= good_values\n    else:\n        break\n\nif len(good_values) != n:\n    print(-1)\nelse:\n    cost = sum(good_values.count(i)**2 for i in range(1, n+1))\n    print(cost)"
 ],
 "774": [
  "x, y, n = map(int, input().split())\nbest_a, best_b = 0, 1\nmin_diff = float('inf')\nfor b in range(1, n+1):\n    a = int(round((b*x)/y))\n    for delta in [-1, 0, 1]:\n        new_a = a + delta\n        if 0 <= new_a <= b:\n            num = abs(x*y - new_a*y*b)\n            if num < min_diff:\n                min_diff = num\n                best_a, best_b = new_a, b\n            elif num == min_diff and b < best_b:\n                best_a, best_b = new_a, b\n            elif num == min_diff and b == best_b and new_a < best_a:\n                best_a, best_b = new_a, b\nprint(f\"{best_a}/{best_b}\")"
 ],
 "775": [
  "n, m, k = map(int, input().split())\nholes = set(map(int, input().split()))\n\nposition = 1\nfor _ in range(k):\n    u, v = map(int, input().split())\n    if position == u and v not in holes:\n        position = v\n    elif position == v and u not in holes:\n        position = u\n\nprint(position)"
 ],
 "776": [
  "num_usb, num_ps2, num_both = map(int, input().split())\nm = int(input())\nusb_mice, ps2_mice = [], []\nfor i in range(m):\n    cost, port = input().split()\n    if port == 'USB':\n        usb_mice.append(int(cost))\n    else:\n        ps2_mice.append(int(cost))\n\nusb_mice.sort()\nps2_mice.sort()\n\nnum_computers = 0\ntotal_cost = 0\n\nfor i in range(min(num_usb, len(usb_mice))):\n    num_computers += 1\n    total_cost += usb_mice[i]\n\nfor i in range(min(num_ps2, len(ps2_mice))):\n    num_computers += 1\n    total_cost += ps2_mice[i]\n\nfor i in range(min(num_both, len(usb_mice)+len(ps2_mice))):\n    if i % 2 == 0:\n        num_computers += 1\n    total_cost += usb_mice[i//2] + ps2_mice[i//2]\n\nprint(num_computers, total_cost)"
 ],
 "777": [
  "s = input()\nprint(26*(len(s)+1) - len(s))"
 ],
 "778": [
  "n, k = map(int, input().split())\nreq = []\nfor i in range(k):\n    r = input().split()\n    req.append((int(r[0]), r[1], int(r[2])))\n\ndp = [[[[None for _ in range(2)] for _ in range(40)] for _ in range(40)] for _ in range(2)]\ndp[0][0][0][0] = dp[0][0][0][1] = 1\n\nfor i in range(1, 2 * n + 1):\n    cur, prev = i % 2, (i - 1) % 2\n    for c1 in range(n + 1):\n        for c2 in range(n + 1):\n            for was_up in range(2):\n                dp[cur][c1][c2][was_up] = [0, 0]\n                if c1 != 0:\n                    for up_prev in range(was_up + 1):\n                        if dp[prev][c1 - 1][c2][up_prev][1]:\n                            dp[cur][c1][c2][was_up][0] = 1\n                            break\n                if c2 != 0:\n                    for up_prev in range(was_up + 1):\n                        if dp[prev][c1][c2 - 1][up_prev][0]:\n                            dp[cur][c1][c2][was_up][1] = 1\n                            break\n\nsol = 0\nfor i in range(n + 1):\n    for j in range(n + 1):\n        for was_up in range(2):\n            if dp[cur][i][j][was_up][0] or dp[cur][i][j][was_up][1]:\n                ok = True\n                for r in req:\n                    h1, dir1, h2 = i + n - j + 1, r[1], n + 1 - i - j\n                    if dir1 == \">\" and h1 <= h2:\n                        ok = False\n                    if dir1 == \"<\" and h1 >= h2:\n                        ok = False\n                    if dir1 == \">=\" and h1 < h2:\n                        ok = False\n                    if dir1 == \"<=\" and h1 > h2:\n                        ok = False\n                    if dir1 == \"=\" and h1 != h2:\n                        ok = False\n                if ok:\n                    sol += 1\n\nprint(sol)"
 ],
 "779": [
  "n = int(input())\ncount = 0\nfor i in range(2, n+1):\n    if n % i == 0:\n        k = n // i\n        if (i + k) % 2 == 0:\n            count += 1\nprint(count)"
 ],
 "780": [
  "s = input()\ninf = len(s) + 1\nn = len(s)\nans = [[inf]*10 for _ in range(10)]\nfor x in range(10):\n    for y in range(10):\n        pos = [0]*n\n        pos[0] = 1\n        nx = 0\n        valid = True\n        for i in range(n):\n            if pos[i] == 0:\n                continue\n            if i + nx + x < n and s[i+nx+x] != '0':\n                pos[i+nx+x] = 1\n            elif i + nx + y < n and s[i+nx+y] != '0':\n                pos[i+nx+y] = 1\n            else:\n                valid = False\n                break\n            while nx < n and pos[nx]:\n                nx += 1\n        if valid:\n            for i in range(n):\n                if pos[i] == 0:\n                    for a in range(10):\n                        b = (a-x)%10\n                        c = (a-y)%10\n                        if i+x+b < n and s[i+x+b] != '0' and i+x+b > i:\n                            if pos[i+x+b] == 0:\n                                pos[i+x+b] = -1\n                            else:\n                                pos[i+x+b] = min(pos[i+x+b], -1)\n                        if i+y+c < n and s[i+y+c] != '0' and i+y+c > i:\n                            if pos[i+y+c] == 0:\n                                pos[i+y+c] = -1\n                            else:\n                                pos[i+y+c] =  min(pos[i+y+c], -1)\n            for i in range(n):\n                if pos[i] == -1:\n                    pos[i] = 0\n                elif pos[i]:\n                    pos[i] = -1\n            for i in range(n):\n                if pos[i]:\n                    ans[x][y] = min(ans[x][y], pos[i])\nfor i in range(10):\n    print(' '.join([str(ans[i][j]) for j in range(10)]))"
 ],
 "781": [
  "board = [input() for i in range(8)]\ncolors = ['WBWBWBWB', 'BWBWBWBW']\n\ndef checker(board):\n    for i in range(8):\n        row = board[i]\n        if row != colors[i%2]: # check if the row matches the pattern\n            return False\n    return True\n\ndef rotate(board):\n    new_board = ['']*8\n    for i in range(8):\n        for j in range(8):\n            new_board[j] += board[i][j]\n    return new_board\n\nfor _ in range(2):\n    for i in range(8):\n        if checker(board): # check if the board is already valid\n            print(\"YES\")\n            exit()\n        board = rotate(board) # rotate the board\nprint(\"NO\")"
 ],
 "782": [
  "import math\n\nm = int(input())  # size of set S\ns = list(map(int, input().split()))  # set S\n\nif s[0] != 1:  # checking for the first element of the sequence\n    print(-1)\nelse:\n    ans = []  # initial sequence\n    for i in range(m-1):\n        ans.append(s[i])  # adding the elements in S to the initial sequence\n        if math.gcd(s[i], s[i+1]) != 1:  # checking if there is a possible missing number between s[i] and s[i+1]\n            x = s[i]  # checking starts from s[i]\n            while math.gcd(x, s[i+1]) != 1:\n                ans.append(x*math.gcd(x, s[i+1]))  # adding the missing element to the sequence\n                x *= math.gcd(x, s[i+1])\n            if ans[-1] != s[i+1]:  # if the last number added is not s[i+1], there is no solution\n                print(-1)\n                break\n    else:\n        ans.append(s[-1])  # adding the last element of S to the sequence\n        print(len(ans))\n        print(*ans)"
 ],
 "783": [
  "n = int(input())\nh = list(map(int, input().split()))\n\nmax_floor = 0\nans = []\nfor i in range(n):\n    if h[i] > max_floor:\n        ans.append(0)\n        max_floor = h[i]\n    else:\n        ans.append(max_floor - h[i] + 1)\n\nprint(*ans)"
 ],
 "784": [
  "a, b = map(int, input().split())\n\ndef dfs(num, path):\n    if num == b:\n        print(\"YES\")\n        print(len(path))\n        print(*path, b)\n        exit()\n    if num > b:\n        return\n    dfs(num*2, path+[num*2])\n    dfs(num*10+1, path+[num*10+1])\n\ndfs(a, [a])\n\nprint(\"NO\")"
 ],
 "785": [
  "n, a, b = map(int, input().split())\n\ns = n * 6\n\nif s <= a*b:\n    print(a*b, a, b)\nelse:\n    x = s // b + (s % b > 0)\n    if x > a:\n        x = a\n        y = s // a + (s % a > 0)\n    else:\n        y = b\n    print(x*y, x, y)"
 ],
 "786": [
  "n = int(input())\ndetails = []\nfor i in range(n):\n    c, d = map(int, input().split())\n    details.append((c, d))\n \nrating = 0\ninf_flag = False\nfor c, d in details:\n    if c == 0:\n        rating += 0\n    elif c > 0:\n        if d == 1:\n            rating += c\n        else:\n            rating += c\n            if rating < 1900:\n                inf_flag = True\n    else:\n        if d == 1:\n            rating += c\n            if rating < 1900:\n                inf_flag = True\n        else:\n            rating += c\n \nif inf_flag:\n    print(\"Infinity\")\nelif rating >= 1900:\n    print(rating)\nelse:\n    print(\"Impossible\")"
 ],
 "787": [
  "k = int(input())\nq = input()\nset_q = set(q)\nif k > len(set_q):\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    for i in range(k):\n        s_i = \"\"\n        for j, c in enumerate(q):\n            if c not in set(s_i) and (j == 0 or c != q[j-1]):\n                s_i += c\n                if len(s_i) == 1:\n                    start = j+1\n                if len(s_i) == k:\n                    break\n        print(q[start:j+1])"
 ],
 "788": [
  "s = input()\nprint(int(s[1:3]))"
 ],
 "789": [
  "n = input()\nlucky_nums = []\nfor i in range(10):\n    for j in range(10):\n        if i == 4 or i == 7:\n            if j == 4 or j == 7:\n                num = int(str(i) + str(j))\n                lucky_nums.append(num)\n        elif j == 4 or j == 7:\n            num = int(str(i) + str(j))\n            lucky_nums.append(num)\nlucky_nums.sort()\nprint(lucky_nums.index(int(n))+1)"
 ],
 "790": [
  "from heapq import heappush, heappop\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nd = list(map(int, input().split()))\n\nans = 0\n\nif k == 0:\n    for i in range(n):\n        if a[i] > 0:\n            ans += a[i]\nelse:\n    adj = [[] for _ in range(n)]\n    for i in range(n - 1):\n        adj[i].append((i + 1, a[i + 1]))\n        adj[i + 1].append((i, a[i + 1]))\n    for i in range(n):\n        adj[i].append((i, -d[i]))\n\n    q = []\n    for i in range(n):\n        heappush(q, (-a[i], i))\n    used = [False] * n\n    for _ in range(k):\n        while used[q[0][1]]:\n            heappop(q)\n        cost, i = heappop(q)\n        ans -= cost\n        j = (i + 1) % n\n        if not used[j]:\n            heappush(q, (-a[j], j))\n        adj[i].append((j, -a[j]))\n        adj[j].append((i, -a[i]))\n        used[i] = True\n\n    dist = [10**18] * n\n    dist[0] = 0\n    q = [(0, 0)]\n    while q:\n        di, i = heappop(q)\n        if di != dist[i]:\n            continue\n        for j, cost in adj[i]:\n            if dist[j] > dist[i] + cost:\n                dist[j] = dist[i] + cost\n                heappush(q, (dist[j], j))\n\n    ans += max(0, max(dist) - dist[0])\nprint(ans)\n"
 ],
 "791": [
  "n = int(input())\nbits = input()\ncarry = True\ncount = 0\nfor i in range(n-1, -1, -1):\n    if carry:\n        if bits[i] == '1':\n            carry = True\n        else:\n            carry = False\n            count += 1\n    else:\n        break\nif carry:\n    count += 1\nprint(count)"
 ],
 "792": [
  "n, d = map(int, input().split())\na = list(map(int, input().split()))\n\nmoney = 0\nmax_money = 0\ndeposit_needed = 0\n\nfor i in range(n):\n    money += a[i]\n    \n    if money > d:\n        deposit_needed = -1\n        break\n        \n    if a[i] == 0 and money < 0:\n        deposit = min(d - money, max_money)\n        money += deposit\n        max_money = deposit\n        \n        if money < 0:\n            deposit_needed += 1\n            money = d\n            max_money = 0\n            \n    else:\n        max_money = max(max_money, -money)\n        \nprint(deposit_needed)"
 ],
 "793": [
  "MOD = 10 ** 9 + 7\nN, M = map(int, input().split())\nS = list(map(int, input().split()))\nT = list(map(int, input().split()))\n\ndp = [[0] * (M + 1) for _ in range(N + 1)]\nsums = [[0] * (M + 1) for _ in range(N + 1)]\n\nfor i in range(1, N + 1):\n    for j in range(1, M + 1):\n        if S[i-1] == T[j-1]:\n            dp[i][j] = sums[i-1][j-1] + 1\n        sums[i][j] = (sums[i][j-1] + sums[i-1][j] - sums[i-1][j-1] + dp[i][j]) % MOD\n\nprint((sums[N][M] + 1) % MOD)"
 ],
 "794": [
  "n = int(input())\na = list(map(int, input().split()))\n\nsum1 = sum(a[:n])\nsum2 = sum(a[n:])\n\nif sum1 == sum2:\n    print(-1)\nelse:\n    # Sort the array and then swap the first and last n/2 elements\n    a.sort()\n    for i in range(n//2):\n        a[i], a[i+n] = a[i+n], a[i]\n    print(*a)"
 ],
 "795": [
  "n = int(input())\ncount = 0\nfor c in range(1, n+1):\n    for b in range(1, c+1):\n        for a in range(1, b+1):\n            if a**2 + b**2 == c**2:\n                count += 1\nprint(count)"
 ],
 "796": [
  "n, k = map(int, input().split())\nMOD = 10**9 + 7\n\ndp = [[0] * (k+1) for _ in range(n+1)]\ndp[0][0] = 1\n\nfor i in range(1, n+1):\n    for j in range(1, k+1):\n        dp[i][j] = (dp[i-1][j] * (j+1)) % MOD\n        s = 1\n        while s <= j:\n            dp[i][j] += dp[i-1][j-s]\n            dp[i][j] %= MOD\n            s += 1\n\nans = 0\nfor j in range(1, k+1):\n    ans += dp[n][j]\n    ans %= MOD\n\nprint(ans)"
 ],
 "797": [
  "n, m, a, b = map(int, input().split())\ng0, x, y, z = map(int, input().split())\n\nmat = []\nfor i in range(n):\n    mat.append([])\n    for j in range(m):\n        mat[i].append(g0)\n        g0 = (g0 * x + y) % z\n\nq = []\nfor i in range(n):\n    for j in range(m):\n        q.append(mat[i][j])\n\nans = float(\"inf\")\nfor i in range(n - a + 1):\n    for j in range(m - b + 1):\n        sub = []\n        for k in range(a):\n            sub += q[k * m + j:k * m + j + b]\n        ans = min(ans, sum(sub))\n\nprint(ans)"
 ],
 "798": [
  "a, b, c = map(int, input().split())\n\nif a + b == c:\n    print('{} {}'.format(a, b), '0')\nelif a + c == b:\n    print('{} {}'.format(a, c), '0')\nelif b + c == a:\n    print('{} {}'.format(b, c), '0')\nelse:\n    # check if all valence numbers are odd\n    if a % 2 == 1 and b % 2 == 1 and c % 2 == 1:\n        print('{} {} {}'.format((a+1)//2, (b+1)//2, (c+1)//2))\n    # check if all valence numbers are even\n    elif a % 2 == 0 and b % 2 == 0 and c % 2 == 0:\n        print('{} {} {}'.format(a//2, b//2, c//2))\n    else:\n        print(\"Impossible\")"
 ],
 "799": [
  "n = int(input())\na = list(map(int, input().split()))\nburle = max(a) # find the highest wealth in the kingdom\nburles = 0 # initialize the minimum burles needed to spend\nfor i in a:\n    burles += burle - i # add the difference between highest wealth and citizen's wealth\nprint(burles)"
 ],
 "800": [
  "import math\n\nn = int(input())\nmannequins = []\nfor i in range(n):\n    xi, yi = map(int, input().split())\n    mannequins.append((xi, yi))\n\nangles = []\nfor i in range(n):\n    xi, yi = mannequins[i]\n    angle_i = math.atan2(yi, xi)\n    angles.append(angle_i)\n    angles.append(angle_i + 2*math.pi)\n\nangles.sort()\nmin_angle = 2*math.pi - angles[-1] + angles[0]\nfor i in range(1, len(angles)):\n    angle_diff = angles[i] - angles[i-1]\n    if angle_diff < min_angle:\n        min_angle = angle_diff\n\nprint('{:.10f}'.format(min_angle*180/math.pi))"
 ],
 "801": [
  "n = int(input())\na = list(map(int, input().split()))\n\nans = set()\n\nfor i in range(n):\n    m = a[i]\n    ans.add(m)\n    for j in range(i+1, n):\n        m = min(m, a[j])\n        ans.add(m)\n    \nmex = 1\nwhile mex in ans:\n    mex += 1\n    \nprint(mex)"
 ],
 "802": [
  "n = int(input())\ns = input()\nans = float('inf')\n\ntypes = set(s)\n\nstart = 0\ncount = {char: 0 for char in types}\n\nfor end in range(n):\n    count[s[end]] += 1\n    while start < end and count[s[start]] > 1:\n        count[s[start]] -= 1\n        start += 1\n    if len(count) == len(types):\n        ans = min(ans, end - start + 1)\n\nprint(ans)"
 ],
 "803": [
  "n = int(input())\nhamsters = input()\n\nnum_to_stand = n//2 - hamsters.count('X')\nnum_to_sit = n//2 - hamsters.count('x')\n\nif num_to_stand < 0 or num_to_sit < 0:\n    print(-1)\nelse:\n    minutes = 0\n    new_hamsters = ''\n    for hamster in hamsters:\n        if hamster == 'X':\n            if num_to_stand > 0:\n                new_hamsters += 'x'\n                num_to_stand -= 1\n                minutes += 1\n            else:\n                new_hamsters += 'X'\n        else:\n            if num_to_sit > 0:\n                new_hamsters += 'X'\n                num_to_sit -= 1\n                minutes += 1\n            else:\n                new_hamsters += 'x'\n\n    print(minutes)\n    print(new_hamsters)"
 ],
 "804": [
  "s = input()\nk = int(input())\nif k > len(s):\n    print(\"impossible\")\nelse:\n    unique_chars = set(s)\n    if k <= len(unique_chars):\n        print(0)\n    else:\n        print(k-len(unique_chars))"
 ],
 "805": [
  "n = int(input())\nsegments = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l, r))\n\nalexey_segment = segments[0]\nother_segments = segments[1:]\n\nvalid_segments = []\n\n# include leftmost valid segment, if any\nif alexey_segment[0] < other_segments[0][0]:\n    valid_segments.append((alexey_segment[0], other_segments[0][0]))\n\n# check for all other segments\nfor i in range(1, n-1):\n    curr = other_segments[i]\n    prev = other_segments[i-1]\n    if alexey_segment[1] <= prev[1] or alexey_segment[0] >= curr[0]: # no valid segment between curr and prev\n        continue\n    valid_l = max(alexey_segment[1], prev[1]) # left endpoint of the valid segment\n    valid_r = min(curr[0], alexey_segment[0]) # right endpoint of the valid segment\n    valid_segments.append((valid_l, valid_r))\n\n# include rightmost valid segment, if any\nif alexey_segment[1] > other_segments[-1][1]:\n    valid_segments.append((other_segments[-1][1], alexey_segment[1]))\n\ntotal_length = sum(end - start for start, end in valid_segments)\nprint(total_length)"
 ],
 "806": [
  "MOD = 10**9 + 7\n\nn, l, r = map(int, input().split())\n\n# dp[i][j] represents the number of ways to fill the array ending at index i, with sum j modulo 3.\ndp = [[0] * 3 for _ in range(n+1)]\ndp[0][0] = 1\n\nfor i in range(1, n+1):\n    for j in range(3):\n        for k in range(l, r+1):\n            dp[i][(j+k)%3] += dp[i-1][j]\n            dp[i][(j+k)%3] %= MOD\n\n# the total number of arrays with sum divisible by 3 is sum(dp[n][j]) where j%3==0\nans = dp[n][0]\nprint(ans)"
 ],
 "807": [
  "n, c = map(int, input().split())\nx = list(map(int, input().split()))\n\nmax_profit = 0\nfor i in range(n-1):\n    profit = x[i] - x[i+1] - c\n    if profit > max_profit:\n        max_profit = profit\n\nprint(max_profit if max_profit > 0 else 0)"
 ],
 "808": [
  "x = input().strip('0')\nif x == '':\n    x = '0'\nif x[0] == '.':\n    x = '0' + x\nif x[-1] == '.':\n    x = x[:-1]\n\na, b = x.split('.')\nif a == '':\n    a = '0'\nif b == '':\n    b = '0'\nelif int(b) == 0:\n    b = '0'\n\nif int(a) == 0:\n    print('0')\nelif int(b) == 0:\n    print(a)\nelse:\n    n = len(a)\n    if n == 1:\n        print(a + 'E' + str(n-1))\n    else:\n        print(a[0] + '.' + a[1:] + 'E' + str(n-1))"
 ],
 "809": [
  "n, k, a, b = map(int, input().split())\nif abs(a - b) > k or (n == k and abs(a - b) != 0):\n    print(\"NO\")\nelse:\n    ans = ''\n    if a > b:\n        ans += 'G'\n        n -= 1\n        a -= 1\n    else:\n        ans += 'B'\n        n -= 1\n        b -= 1\n    \n    while n > 0:\n        if ans[-1] == 'G':\n            if b > a:\n                ans += 'B'\n                b -= 1\n            else:\n                ans += 'G'\n                a -= 1\n        else:\n            if a > b:\n                ans += 'G'\n                a -= 1\n            else:\n                ans += 'B'\n                b -= 1\n        n -= 1\n    \n    print(ans)"
 ],
 "810": [
  "a, b, n = map(int, input().split())\nMOD = 10**9 + 7\n\nans = 0\n\nfor i in range(n+1):\n    s = i*a + (n-i)*b\n    if str(s).count(str(a)) + str(s).count(str(b)) == n:\n        ans = (ans + pow(2, n-i, MOD)) % MOD\n\nprint(ans % MOD)"
 ],
 "811": [
  "a, b = map(int, input().split())\nhours = a\nwhile a >= b:\n    hours += a // b\n    a = a // b + a % b\nprint(hours)"
 ],
 "812": [
  "n=int(input())\na=list(map(int,input().split()))\nif n==2:\n    print(1)\nelse:\n    a.sort()\n    if (a[-1]-a[0])%(n-1)!=0:\n        print(-1)\n    else:\n        d=(a[-1]-a[0])//(n-1)\n        found=False\n        i=1\n        while i<n-1:\n            if a[i]-a[0]!=i*d:\n                if not found and (a[n-1]-a[0]==(n-1)*d or a[n-1]-a[i]==(n-2)*d):\n                    found=True\n                    ans=i\n                else:\n                    print(-1)\n                    exit()\n            i+=1\n        print(ans if found else n-1)"
 ],
 "813": [
  "n, a, b = map(int, input().split())\narthur_likes = set(map(int, input().split()))\nalexander_likes = set(map(int, input().split()))\n\nfor i in range(1, n+1):\n    if i in arthur_likes:\n        print(\"1\", end=\"\")\n    else:\n        print(\"2\" if i in alexander_likes else \"1\", end=\"\")"
 ],
 "814": [
  "n = int(input())\na = list(map(int, input().split()))\na.sort()\nprint(\" \".join(str(i) for i in a))"
 ],
 "815": [
  "v1, v2, v3, vm = map(int, input().split())\n\nif vm > v3*2 or vm >= v2 or vm >= v1:\n    print(\"-1\")\nelse:\n    if v3*2 >= vm*2:\n        print(v1, v2, v3)\n    elif v2*2 >= vm*2:\n        print(v1, v3, vm)\n    else:\n        print(vm, v2, v3)"
 ],
 "816": [
  "n, x = map(int, input().split())\na = list(map(int, input().split()))\ncount = 0\nfor i in range(n):\n    for j in range(i+1, n):\n        if a[i] ^ a[j] == x:\n            count += 1\nprint(count)"
 ],
 "817": [
  "s=input()\nn=len(s)\na=[]\nfor i in range(n,-1,-1):\n    p=-1\n    for j in range(n-1,i-1,-1):\n        if(s[j]==s[i] and j-1!=p):\n            p=j\n            a.append(s[i:j])\n    a.append(s[i:min(i+1,n)])\na=a[::-1]\nl=0\nfor i in a:\n    l+=1\n    if(len(i)>10):\n        print(len(i),i[0:5]+\"...\"+i[-2:])\n    else:\n        print(len(i),i)   "
 ],
 "818": [
  "n = int(input())\nif n<3:\n    print(-1)\nelse:\n    if(n==3):\n        print(210)\n    else:\n        if(n%2==0):\n            print(\"1\"+(\"0\"*(n-1)))\n        else:\n            print(\"7\"+\"0\"*(n-2)+\"0\")"
 ],
 "819": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\nif k == 1:\n    print(a[0])\nelif k >= 2:\n    if a[n-1] < 0:\n        if k % 2 == 0:\n            print(max(a[0], a[n-1]))\n        else:\n            print(a[n-1])\n    else:\n        sub_max = [a[0]]\n        for i in range(1, n):\n            if a[i] > 0:\n                sub_max.append(a[i])\n                if len(sub_max) == k:\n                    break\n        if len(sub_max) < k:\n            print(max(a[n-1], sub_max[-1]))\n        else:\n            print(sub_max[-1])"
 ],
 "820": [
  "n = int(input())\nm = int(input())\ndrives = [int(input()) for _ in range(n)]\n\ndrives.sort(reverse=True)\nnum_drives = 0\ntotal_space = 0\nfor drive in drives:\n    total_space += drive\n    num_drives += 1\n    if total_space >= m:\n        print(num_drives)\n        break"
 ],
 "821": [
  "s, v1, v2, t1, t2 = map(int, input().split())\n\ntime1 = s * v1 + 2 * t1\ntime2 = s * v2 + 2 * t2\n\nif time1 < time2:\n    print(\"First\")\nelif time2 < time1:\n    print(\"Second\")\nelse:\n    print(\"Friendship\")"
 ],
 "822": [
  "n, m, z = map(int, input().split())\ncount = 0\nfor i in range(1, z+1):\n    if i % n == 0 and i % m == 0:\n        count += 1\nprint(count)"
 ],
 "823": [
  "x, y = map(int, input().split())\n\nif x == y == 0:\n    print(0)\nelse:\n    dist = max(abs(x), abs(y))\n    if x == dist:\n        if y > -dist:\n            print(dist * 4 - 3)\n        else:\n            print(dist * 4 - 1)\n    elif y == dist:\n        if x >= -dist:\n            print(dist * 4 - 2)\n        else:\n            print(dist * 4)\n    elif x == -dist:\n        if y >= -dist + 1:\n            print(dist * 4 - 1)\n        else:\n            print(dist * 4 - 3)\n    else:\n        if y >= -dist:\n            print(dist * 4)\n        else:\n            print(dist * 4 - 2)"
 ],
 "824": [
  "MOD = 10**9 + 7\n\ns = input()\n\nn = len(s)\nleft = [0] * (n + 1)\nright = [0] * (n + 2)\nfor i in range(1, n + 1):\n    left[i] = left[i - 1] + (s[i - 1] == \"(\")\nfor i in range(n, 0, -1):\n    right[i] = right[i + 1] + (s[i - 1] == \")\")\nmatching = [0] * (n + 1)\nfor i in range(1, n + 1):\n    if s[i - 1] == \"(\" and right[i] > 0:\n        j = i + right[i]\n        matching[i] = j\n        matching[j] = i\ndp = [0] * (n + 1)\ndp_ans = [0] * (n + 1)\ndp[0] = 1\nans = 0\nfor i in range(1, n + 1):\n    if s[i - 1] == \"(\":\n        dp[i] = 1\n    if matching[i]:\n        j = matching[i]\n        dp[i] = (dp[i] + dp[j - 1]) % MOD\n    dp_ans[i] = (dp_ans[i - 1] + dp[i]) % MOD\n    if left[i] * 2 == i:\n        ans = (ans + dp_ans[i - 1]) % MOD\nprint(ans)"
 ],
 "825": [
  "n = int(input())\ncount = 0\nfor i in range(2, int(n**(0.5))+1): # iterate through all possible prime factors of N\n    if n%i == 0:\n        count += 1\n        while n%i ==0: # divide N by the prime factor repeatedly until it is no longer divisible by it\n            n //= i\nif n != 1: # if there is a prime factor greater than sqrt(N), count it as well\n    count += 1\nprint(count)"
 ],
 "826": [
  "n = int(input())\nif n == 1:\n  print(1)\nelse:\n  print((n*(n+1))//2 - n)"
 ],
 "827": [
  "n = int(input())\nt = input().strip()\ns = '110'*(10**10)\ncount = 0\nfor i in range(len(s)-n+1):\n    if s[i:i+n] == t:\n        count += 1\nprint(count)"
 ],
 "828": [
  "n, s = map(int, input().split())\na = list(map(int, input().split()))\n\nmistake_count = 0\nchief_sup = max(a)\n\nif chief_sup == 0:\n    print(0)\nelse:\n    for i in range(n):\n        if i+1 != s and a[i] == chief_sup-1:\n            if a[s-1] == chief_sup:\n                mistake_count += 1\n            else:\n                mistake_count += 1\n                a[s-1] -= 1\n\n    print(mistake_count)"
 ],
 "829": [
  "n = int(input())\ns = input()\n\n# list to store the substrings\nres = []\n# variables to keep track of the count of 0's and 1's\nzeros = s.count('0')\nones = s.count('1')\n# variables to keep track of the current substring being built\ncurr = ''\nfor i in range(n):\n    # add current character to current substring\n    curr += s[i]\n    # update count of 0's and 1's\n    if s[i] == '0':\n        zeros -= 1\n    else:\n        ones -= 1\n    # if count of 0's and 1's becomes equal\n    # we have found a good substring\n    if zeros == ones:\n        # add current substring to the result list\n        res.append(curr)\n        # reset current substring and count variables\n        curr = ''\n        zeros = s[i+1:].count('0')\n        ones = s[i+1:].count('1')\n\n# print number of substrings and the substrings\nprint(len(res))\nprint(' '.join(res))"
 ],
 "830": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\nmoves = []\nfor t in range(k):\n    # find the highest and lowest towers\n    max_tower = max(a)\n    min_tower = min(a)\n    if max_tower == min_tower:\n        break\n    # find the towers with highest and lowest height\n    i = a.index(max_tower)\n    j = a.index(min_tower)\n    # move the top cube from the highest tower to the lowest tower\n    a[i] -= 1\n    a[j] += 1\n    moves.append((i+1, j+1))\n\nmin_instability = max(a) - min(a)\nprint(min_instability, len(moves))\nfor move in moves:\n    print(move[0], move[1])"
 ],
 "831": [
  "from collections import defaultdict\nfrom queue import Queue\n\ns = input()\nn = int(input())\n\nnodes = ['s', 't'] + list(s) + [i for i in range(1, n + 1)]\ncapacity, cost = defaultdict(lambda: defaultdict(lambda: 0)), defaultdict(lambda: defaultdict(lambda: 0))\n\nfor i in range(1, n + 1):\n    string, limit = input().split()\n    limit = int(limit)\n    nodes.append(i)\n    cost['s'][i] = 0\n    capacity['s'][i] = limit\n    for c in string:\n        count = string.count(c)\n        j = string.index(c) + 1\n        cost[i][s.index(c) + 1] = count * i\n        capacity[i][s.index(c) + 1] = count\n        while count > 1:\n            k = string.find(c, j)\n            if k == -1:\n                break\n            cost[i][s.index(c) + 1] += count * i\n            capacity[i][s.index(c) + 1] += count\n            j = k + 1\n            count -= 1\n    cost[i]['t'], capacity[i]['t'] = 0, limit\n\ndef min_cost_max_flow(nodes, capacity, cost, source, sink):\n    max_flow, min_cost = 0, 0\n    while True:\n        visited = {source}\n        parent = {}\n        distance = {node: float('inf') for node in nodes}\n        distance[source] = 0\n        q = Queue()\n        q.put(source)\n        \n        while not q.empty():\n            u = q.get()\n            for v in capacity[u]:\n                if capacity[u][v] > 0 and v not in visited:\n                    visited.add(v)\n                    distance[v] = distance[u] + cost[u][v]\n                    parent[v] = u\n                    q.put(v)\n            for v in cost[u]:\n                if capacity[u][v] > 0 and v not in visited:\n                    visited.add(v)\n                    distance[v] = distance[u] + cost[u][v]\n                    parent[v] = u\n                    q.put(v)\n        if sink not in visited:\n            break\n        path_flow, u, v = float('inf'), source, sink\n        while v != source:\n            path_flow = min(path_flow, capacity[parent[v]][v])\n            u, v = parent[v], parent[v]\n        max_flow += path_flow\n        min_cost += path_flow * distance[sink]\n        u, v = source, sink\n        while v != source:\n            capacity[parent[v]][v] -= path_flow\n            capacity[v][parent[v]] += path_flow\n            u, v = parent[v], parent[v]\n    return max_flow, min_cost\n\nflow, cost = min_cost_max_flow(nodes, capacity, cost, 's', 't')\nprint(cost if flow == len(s) else -1)"
 ],
 "832": [
  "n = int(input())\nhome_uniforms = []\nguest_uniforms = []\n\nfor i in range(n):\n    h, a = map(int, input().split())\n    home_uniforms.append(h)\n    guest_uniforms.append(a)\n\ncount = 0\nfor i in range(n):\n    for j in range(n):\n        if i != j and home_uniforms[i] == guest_uniforms[j]:\n            count += 1\n\nprint(count)"
 ],
 "833": [
  "n, v = map(int, input().split())\n\ntrees = [[] for _ in range(3001)]\nfor i in range(n):\n    a, b = map(int, input().split())\n    trees[a].append(b)\n\ncollected = 0\ncurrent_fruits = []\nfor day in range(1, 3001):\n    for fruits in trees[day]:\n        current_fruits.append(fruits)\n    while len(current_fruits) > v:\n        collected += v\n        current_fruits.sort(reverse=True)\n        current_fruits = current_fruits[:len(current_fruits)-v]\n    collected += sum(current_fruits)\n    current_fruits = []\nprint(collected)"
 ],
 "834": [
  "n = int(input())\nf = list(map(int, input().split()))\n\nfor k in range(1, n+1):\n    idempotent = True\n    for i in range(n):\n        x = i\n        for j in range(k):\n            x = f[x]-1\n        if x != f[x]-1:\n            idempotent = False\n            break\n    if idempotent:\n        print(k)\n        break"
 ],
 "835": [
  "recipe = input()\nn_b, n_s, n_c = map(int, input().split())\np_b, p_s, p_c = map(int, input().split())\nr = int(input())\n\nbuns = recipe.count('B')\nsausages = recipe.count('S')\ncheese = recipe.count('C')\n\nlow = 0\nhigh = 10**13\n\nwhile low <= high:\n    mid = (low+high) // 2\n    cost = max(0, mid*buns - n_b)*p_b + max(0, mid*sausages - n_s)*p_s + max(0, mid*cheese - n_c)*p_c\n    if cost <= r:\n       low = mid+1\n    else:\n       high = mid-1\n\nprint(high)"
 ],
 "836": [
  "n, t = map(int, input().split())\nroad = input().strip()\n\nhouses = []\nshops = []\nfor i in range(n):\n    if road[i] == 'H':\n        houses.append(i)\n    elif road[i] == 'S':\n        shops.append(i)\n\nnum_houses = len(houses)\nnum_shops = len(shops)\n\n# if the number of houses is greater than the time available or if there are no houses, the family can't give sweets to all houses in time\nif num_houses > t or num_houses == 0:\n    print(-1)\n    exit()\n\nans = 0\nlow = 0\nhigh = num_shops - 1\n\n# binary search to find the minimum possible value of k\nwhile low <= high:\n    mid = (low + high) // 2\n    total_time = 2 * (shops[mid] - houses[0]) # time to go from the starting house to the current shop and back\n    sweets = 1\n    \n    for i in range(1, num_houses):\n        dist = houses[i] - houses[i-1] # distance between two houses\n        \n        # if the total time taken so far + time to cover the distance to the next house + time to go to the nearest shop and come back is greater than t,\n        # the family can't give sweets to all the houses and we need to increase k\n        if total_time + dist * 2 > t or sweets == num_shops:\n            ans = mid + 1\n            low = mid + 1\n            break\n        \n        # if there is enough time to go to the next house and come back, check if we need to buy sweets from a shop\n        if dist * 2 <= t - total_time and sweets < num_shops:\n            time_to_shop = 2 * (shops[sweets] - houses[i])\n            # if there is enough time to go to the shop and come back and the family hasn't bought sweets from this shop already\n            if time_to_shop + total_time + dist * 2 <= t and sweets < mid + 1:\n                sweets += 1\n                total_time += time_to_shop\n    \n    # if we were able to give sweets to all houses, check if we can reduce k\n    if sweets == num_shops + 1:\n        ans = mid\n        high = mid - 1\n    \nprint(ans)"
 ],
 "837": [
  "n, x, y = map(int, input().split())\nif x > y:\n    print(n * y)\nelse:\n    if n % 2 == 0:\n        print((n//2) * min(2*x, y))\n    else:\n        print((n//2) * min(2*x, y) + x)"
 ],
 "838": [
  "n, m = map(int, input().split())\n\nrows = []\ncolumns = [0]*m\n\nfor i in range(n):\n    row = list(map(int, input().split()))\n    rows.append(row)\n    for j in range(m):\n        columns[j] += row[j]\n\ncount = n*m\nfor i in range(n):\n    for j in range(m):\n        if rows[i][j] == 1:\n            count += (2**(columns[j])-1) + (2**(n-columns[j])-1)\n        else:\n            count += (2**(rows[i].count(1))-1) + (2**(m-rows[i].count(1))-1)\n\nprint(count)"
 ],
 "839": [
  "import itertools\n\nhappiness = [list(map(int, input().split())) for _ in range(5)]\n\nstudents = [1, 2, 3, 4, 5]\nmax_happiness = 0\n\nfor perm in itertools.permutations(students):\n    curr_happiness = happiness[perm[0]-1][perm[1]-1] + happiness[perm[1]-1][perm[0]-1]\n    curr_happiness += happiness[perm[1]-1][perm[2]-1] + happiness[perm[2]-1][perm[1]-1]\n    curr_happiness += happiness[perm[2]-1][perm[3]-1] + happiness[perm[3]-1][perm[2]-1]\n    curr_happiness += happiness[perm[3]-1][perm[4]-1] + happiness[perm[4]-1][perm[3]-1]\n    max_happiness = max(max_happiness, curr_happiness)\n\nprint(max_happiness)"
 ],
 "840": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nleft = 0\nright = 10**18 + 1\n\nwhile left < right:\n    mid = (left + right + 1) // 2\n    needed_powder = 0\n    for i in range(n):\n        needed_powder += max(0, a[i] * mid - b[i])\n    if needed_powder <= k:\n        left = mid\n    else:\n        right = mid - 1\n\nprint(left)"
 ],
 "841": [
  "from math import ceil\n\nfor _ in range(int(input())):\n    n = int(input())\n    s = str(1337)\n    ans = [\"7\"]\n    for i in range(3):\n        for j in range(i + 1, 4):\n            curr = s[i] + s[j]\n            ans.append(curr)\n    idx, cnt = 0, 0\n    while cnt + len(ans) <= n:\n        cnt += len(ans)\n        idx += 1\n    extra = n - cnt\n    res = [\"1\", \"3\", \"7\"]\n    while idx > 0:\n        new_res = []\n        for x in res:\n            for y in ans:\n                new_res.append(x + y)\n        res = new_res\n        idx -= 1\n    for x in res:\n        subseq = 0\n        for i in range(len(x)):\n            if x[i] == \"1\" and subseq == 0:\n                subseq += 1\n            elif x[i] == \"3\" and subseq == 1:\n                subseq += 1\n            elif x[i] == \"3\" and subseq == 2:\n                subseq += 1\n            elif x[i] == \"7\" and subseq == 3:\n                subseq += 1\n            if subseq == 4:\n                break\n        if subseq == 4:\n            extra -= 1\n        if extra == -1:\n            print(x)\n            break"
 ],
 "842": [
  "n = input()\neven_digits = (len(n) // 2) * '9'  # create a string of 9s with half of the length of n\npalindrome = n[:-1] + even_digits + n[:-1][::-1]  # concatenate the first half, the even_digits, and the reversed first half\nprint(palindrome)"
 ],
 "843": [
  "n = int(input())\ndirection = input()\njump_length = list(map(int,input().split()))\n\ncurrent_cell = 0\nvisited_cells = set()\n\nwhile True:\n    if current_cell in visited_cells:\n        print(\"INFINITE\")\n        break\n    if current_cell < 0 or current_cell >= n:\n        print(\"FINITE\")\n        break\n    visited_cells.add(current_cell)\n    if direction[current_cell] == \">\":\n        current_cell += jump_length[current_cell]\n    else:\n        current_cell -= jump_length[current_cell]"
 ],
 "844": [
  "n = int(input())\ns = input()\ndp = [-1] * (n+1)\nans = 0\ncount_zero = 0\ncount_one = 0\nfor i in range(n):\n    if s[i] == '0':\n        count_zero += 1\n    else:\n        count_one += 1\n    diff = count_zero - count_one\n    if diff == 0:\n        ans = i+1\n    elif dp[diff] != -1:\n        ans = max(ans, i-dp[diff])\n    else:\n        dp[diff] = i\nprint(ans)"
 ],
 "845": [
  "shift = input()\nphrase = input()\nkeyboard = 'qwertyuiopasdfghjkl;zxcvbnm,./'\nif shift == 'R':\n    keyboard = keyboard[1:] + keyboard[0]\nelse:\n    keyboard = keyboard[-1] + keyboard[:-1]\noriginal_message = ''\nfor char in phrase:\n    original_message += keyboard[keyboard.index(char) - 1]\nprint(original_message)"
 ],
 "846": [
  "n, m = map(int, input().split())\nbuttons = list(map(int, input().split()))\n\noff_by = [0]*n\noff = []\n\nfor b in buttons:\n    for i in range(b-1, n):\n        if not off_by[i]:\n            off_by[i] = b\n            off.append(i+1)\n            \nprint(*off)"
 ],
 "847": [
  "n, x = map(int, input().split())\ncards = list(map(int, input().split()))\n\ncard_count = abs(sum(cards)) // x\nif abs(sum(cards)) % x != 0:\n    card_count += 1\n\nprint(card_count)"
 ],
 "848": [
  "n, k = map(int, input().split())\n\nif k >= n:\n    print('-1')\nelse:\n    m = n * k\n    print(m)\n    for i in range(n):\n        for j in range(1, k+1):\n            print(i+1, (i+j) % n + 1)"
 ],
 "849": [
  "a, b, c, d = map(int, input().split())\nprob_smallR = a/b\nprob_zanoes = c/d\nres = prob_smallR / (1 - (1 - prob_smallR) * (1 - prob_zanoes))\nprint(round(res, 6))"
 ],
 "850": [
  "k = int(input())\nnumbers = list(map(int, input().split()))\nanswer = []\n\nfor i in range(k):\n    if 0 in str(numbers[i]): # check if the number contains 0\n        answer.append(numbers[i]) # add it to the answer list\n\n        for j in range(i+1, k):\n            if 0 in str(numbers[j]) and set(str(numbers[i])) & set(str(numbers[j])): # check if the numbers share a 0 digit in the same place\n                answer.append(numbers[j]) # add the second number to the answer list\n                break\n\nprint(len(answer))\nprint(*answer)"
 ],
 "851": [
  "n,k=map(int,input().split())\ns=input()\n\ndef is_possible(t):\n    prev=-1\n    for i in range(n):\n        if s[i]==\"0\":\n            if i-prev-1>=t:\n                if k==0:\n                    return False\n                k-=1\n                prev=i\n    return True\n\nl,r=0,n\nwhile l<r:\n    mid=(l+r)//2\n    if is_possible(mid):\n        r=mid\n    else:\n        l=mid+1\nprint(l)"
 ],
 "852": [
  "for _ in range(int(input())):\n    n,k,l=map(int,input().split())\n    a=[0]+list(map(int,input().split()))+[0]\n    l+=k\n    dp=[0]*(n+2)\n    dp[0]=1\n    for i in range(1,n+2):\n        if a[i]+p[(i-1)%2*k]>l:break\n        for j in range(i):\n            if dp[j]==0 or a[i]+p[(i-1)%2*k]>l+j:continue\n            if i-j<=k:\n                dp[i]=1;break\n    print('Yes' if dp[n+1] else 'No')"
 ],
 "853": [
  "n = int(input())\nnums = list(map(int, input().split()))\nif nums.count(0) == 0:\n    print(-1)\nelse:\n    digits_sum = sum(nums)\n    num_of_fives = digits_sum // 9 * 9 // 5\n    if num_of_fives == 0:\n        print(0)\n    else:\n        print('5' * num_of_fives + '0' * nums.count(0))"
 ],
 "854": [
  "n,T = map(int,input().split())\nc = list(map(int,input().split()))\n\ndef can_buy(k):\n    s = T\n    for i in range(n):\n        s -= min(k,c[i])\n        if s < 0:\n            return False\n    return True\n\nlo, hi = 0, T\nwhile lo < hi:\n    mid = (lo + hi + 1) // 2\n    if can_buy(mid):\n        lo = mid\n    else:\n        hi = mid - 1\n\ntotal_candies = 0\ns = T\nfor i in range(n):\n    b = min(lo,c[i])\n    total_candies += b\n    s -= b\ntotal_candies += (s//lo)*n\n\nprint(total_candies)"
 ],
 "855": [
  "#input\nk, a, b = map(int,input().split())\nA = [list(map(int,input().split())) for _ in range(3)]\nB = [list(map(int,input().split())) for _ in range(3)]\n\n#logic\ndef matmul(A,B,m):\n    C = [[0]*m for _ in range(m)]\n    for i in range(m):\n        for j in range(m):\n            for k in range(m):\n                C[i][j] = (C[i][j]+A[i][k]*B[k][j]) % 3\n    return C\n \nC = A\nfor _ in range(k-1):\n    C = matmul(C,B,3)\n    \na_points = sum(C[a-1])\nb_points = sum(C[b-1])\n\n#output\nprint(a_points, b_points)"
 ],
 "856": [
  "t = int(input())\nfor _ in range(t):\n    n,k = map(int, input().split())\n    a = list(map(int, input().split()))\n    for i in range(min(k, 2*(10**9))):\n        max_a = max(a)\n        for j in range(n):\n            a[j] = max_a - a[j]\n    print(\" \".join(str(x) for x in a))"
 ],
 "857": [
  "n, m = map(int, input().split())\nseq = list(map(int, input().split()))\nkeys = set(map(int, input().split()))\ncode = []\nfor digit in seq:\n    if digit in keys:\n        code.append(digit)\nprint(*code)"
 ],
 "858": [
  "n = int(input())\nprint(n//2)"
 ],
 "859": [
  "from math import comb\n\ns1 = input().strip()\ns2 = input().strip()\n\nnum_q = s2.count('?')\ndiff = s1.count('+') - s1.count('-')\ndiff2 = s2.count('+') - s2.count('-')\n\nif num_q < abs(diff - diff2) or (num_q - abs(diff - diff2)) % 2 == 1:\n    print(0)\nelse:\n    p = (num_q - abs(diff - diff2)) // 2\n    k = max(0, p - (diff - diff2))\n    ans = 0\n    while k <= num_q - p and p + k <= num_q:\n        ans += comb(num_q, p + k) * (1 / 2) ** (p + k) * (1 / 2) ** (num_q - p - k) * comb(num_q - p, k)\n        k += 1\n    print(\"%.12f\" % ans)"
 ],
 "860": [
  "n=int(input())\na=list(map(int,input().split()))\npos=[-1]*n\nfor i in range(n):\n    if a[i]==n-1:\n        pos[0]=i\n        break\nfor i in range(1,n):\n    x=pos[i-1]\n    while x>=0:\n        f=0\n        for j in range(n):\n            if pos[a[j]]==-1 and a[x]+a[j]==i:\n                pos[i]=j\n                f=1\n                break\n        if f==1:\n            break\n        x-=1\n    if pos[i]==-1:\n        print(\"Impossible\")\n        exit(0)\nprint(\"Possible\")\nfor i in pos:\n    print(i+1, end=\" \")"
 ],
 "861": [
  "import math\n\nm, R = map(int, input().split())\n\nans = 0\n\nfor i in range(m * m):\n    v = i // m + 1\n    u = m + 1 + (i % m)\n    if v > u:\n        u, v = v, u\n    if u <= m + v - 1:\n        ans += 2 * R\n    else:\n        d = u - (m + v) + 1\n        l = math.sqrt((2 * R) ** 2 + d ** 2)\n        ans += l\n\nprint('{:.10f}'.format(ans / (m * m)))"
 ],
 "862": [
  "n = int(input())\na = list(map(int, input().split()))\n\ntotal_sum = sum(a)\ncurr_sum = 0\nfor i in range(n):\n    if curr_sum <  total_sum - curr_sum - a[i]:\n        curr_sum += a[i]\n    else:\n        print(i+1)\n        break"
 ],
 "863": [
  "a, ta = map(int, input().split())\nb, tb = map(int, input().split())\nh, m = map(int, input().split(':'))\n\nstart_time = h*60 + m\nend_time = 60*23 + 59 # last bus departs at 11:59 PM\ncount = 0\n\nfor t1 in range(start_time + ta, end_time + 1, a):\n    t2 = t1 - ta + tb\n    if (t2 - start_time) % b == 0 and t2 <= end_time:\n        count += 1\n\nprint(count)"
 ],
 "864": [
  "n, m = map(int, input().split())\nfood_types = list(map(int, input().split()))\n\nmax_days = 0\nfor food_type in set(food_types):\n    count = food_types.count(food_type)\n    if count >= n:\n        days = count // n\n        if max_days < days:\n            max_days = days\n\nprint(max_days)"
 ],
 "865": [
  "N, T = map(int, input().split())\narr = []\nfor i in range(N):\n    a, b = map(int, input().split())\n    arr.append((a, b))\narr.sort()\n\ndp = [0] * (T+1)\nfor i in range(N):\n    a, b = arr[i]\n    for j in range(T, 0, -1):\n        if j >= a:\n            dp[j] = max(dp[j], dp[j-a]+b)\n\nprint(dp[T])"
 ],
 "866": [
  "MOD=1000000007\nX,Y=map(int,input().split())\ndp = [0] * (Y+1)\ndp[0] = 1\nfor j in range(1, Y+1):\n    dp[j] =(2*dp[j-1])%MOD\n    if j>=2 and j%2==0:\n        dp[j] = (dp[j]- dp[j//2-1] + MOD)%MOD\nans=(dp[Y] * pow(2,X,MOD))%MOD\nprint(ans)"
 ],
 "867": [
  "n = int(input())\nprint((n+1)//2)"
 ],
 "868": [
  "n = int(input())\nprint(pow(1378, n, 10))"
 ],
 "869": [
  "a, b = map(int, input().split())\nmin_socks = min(a,b)\nmax_socks = max(a,b)\ndiff = min_socks\nsame = (max_socks - min_socks) // 2\nprint(diff, same)"
 ],
 "870": [
  "d, L, v1, v2 = map(int, input().split())\ntime_alive = (L - d) / (v1 + v2)\nprint('{:.20f}'.format(time_alive))"
 ],
 "871": [
  "n, s = map(int, input().split())\nlandings = []\nfor i in range(n):\n    h, m = map(int, input().split())\n    landings.append(h*60 + m) # convert to minutes from 0:00\n\nearliest_takeoff = 0\nfor i in range(1, n):\n    gap = landings[i] - landings[i-1]\n    if gap >= 2*s + 2: # enough space for takeoff\n        earliest_takeoff = landings[i-1] + s + 1 # one minute after previous landing\n        break\nelse: # no gaps found, place takeoff after last landing\n    earliest_takeoff = landings[-1] + s + 1\n\nprint(earliest_takeoff // 60, earliest_takeoff % 60)"
 ],
 "872": [
  "n = int(input())\na = list(map(int,input().split()))\nodd = []\neven = []\nfor i in a:\n    if i%2==0:\n        even.append(i)\n    else:\n        odd.append(i)\nodd = sorted(odd)\neven = sorted(even)\nif len(odd) == 0 or len(even) == 0 or abs(len(odd)-len(even)) <= 1:\n    print(*a)\nelse:\n    if len(odd) < len(even):\n        odd,even=even,odd\n    ans = []\n    for i in range(len(even)):\n        ans.append(odd[i])\n        ans.append(even[i])\n    if len(odd)>len(even):\n        ans.append(odd[-1])\n    print(*ans)"
 ],
 "873": [
  "n = int(input())\noriginal = input()\ncombination = input()\nmoves = 0\n\nfor i in range(n):\n    a = abs(int(original[i]) - int(combination[i]))\n    b = 10 - a\n    moves += min(a, b)\n\nprint(moves)"
 ],
 "874": [
  "n = int(input())\nif n%2 != 0:\n    print(-1)\nelse:\n    for i in range(1,n+1,2):\n        print(i+1, i, end=' ')"
 ],
 "875": [
  "import heapq\n\nn = int(input())\nstones = list(map(int, input().split()))\ncolors = [input().strip() for _ in range(n)]\n\ngraph = [[] for _ in range(n)]\nfor i in range(n):\n    for j in range(i+1, n):\n        if colors[i][j] != '*':\n            graph[i].append((j, colors[i][j]))\n            graph[j].append((i, colors[i][j]))\n\n\ndef dijkstra(start, target):\n    dist = [-1] * n\n    prev = [-1] * n\n    heap = [(0, start)]\n    while heap:\n        d, u = heapq.heappop(heap)\n        if dist[u] >= 0:\n            continue\n        dist[u] = d\n        if u == target:\n            break\n        for v, c in graph[u]:\n            if dist[v] < 0 and (not prev[u] or colors[prev[u]][u] == c):\n                prev[v] = u\n                heapq.heappush(heap, (d+1, v))\n    if dist[target] < 0:\n        return None\n    path = []\n    while target != start:\n        path.append((prev[target], target))\n        target = prev[target]\n    path.reverse()\n    return path\n\n\npath12 = dijkstra(stones[0]-1, stones[1]-1)\npath23 = dijkstra(stones[1]-1, stones[2]-1)\nif not path12 or not path23:\n    print(-1)\n    exit()\n\nmoves = path12 + path23\nif len(moves) >= 2 and moves[0][0] == moves[1][1]:\n    moves.pop(0)\nif len(moves) >= 2 and moves[-1][1] == moves[-2][0]:\n    moves.pop()\n\nif moves[0][0] != stones[0]-1:\n    moves.insert(0, (stones[0]-1, moves[0][0]))\nif moves[-1][1] != stones[2]-1:\n    moves.append((moves[-1][1], stones[2]-1))\n\nprint(len(moves))\nfor a, b in moves:\n    print('{} {}'.format(a+1, b+1))"
 ],
 "876": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\ns = [0]\nfor i in range(n):\n    s.append(s[-1] + a[i])\nl, r = 0, n + 1\nwhile l + 1 < r:\n    m = (l + r) // 2\n    ok = False\n    for i in range(n - m + 1):\n        if s[i + m] - s[i] >= k:\n            ok = True\n    if ok:\n        r = m\n    else:\n        l = m\nprint(r - 1)"
 ],
 "877": [
  "import sys\nn, m = map(int, input().split())\nsimilar = set()\nfor _ in range(m):\n    u, v = map(int, input().split())\n    if (u, v) in similar:\n        continue\n    if (v, u) in similar:\n        continue\n    similar.add((u, v))\n\nsimilar_groups = []\nfor u, v in similar:\n    group = None\n    for similar_group in similar_groups:\n        if u in similar_group or v in similar_group:\n            if group is None:\n                group = similar_group\n            else:\n                group.update(similar_group)\n                similar_groups.remove(similar_group)\n    if group is None:\n        similar_groups.append({u, v})\n    else:\n        group.add(u)\n        group.add(v)\n        \nsimilar_problems = set()\nfor similar_group in similar_groups:\n    problem = min(similar_group)\n    for i in similar_group:\n        similar_problems.add(i)\n\noutput = 0\nfor similar_group in similar_groups:\n    last_problem_div1 = None\n    for i in sorted(similar_group, reverse=True):\n        if last_problem_div1 is None:\n            last_problem_div1 = i\n            continue\n        if i > last_problem_div1:\n            last_problem_div1 = i\n    \n    if last_problem_div1 is None:\n        last_problem_div1 = min(similar_group)\n        similar_problems.add(last_problem_div1)\n    else:\n        for i in similar_group:\n            if i != last_problem_div1:\n                similar_problems.add(i)\n        \n    div1 = set(range(1, last_problem_div1+1))\n    div2 = set(range(last_problem_div1+1, n+1)).difference(similar_problems)\n    if len(div1) == 0 or len(div2) == 0:\n        continue\n    output += 1\n\nprint(output)"
 ],
 "878": [
  "n = int(input())\na = list(map(int, input().split()))\n\nif 2 in a and 3 in a and 1 not in a:\n    print(\"Finite\")\n    idx = a.index(2)\n    cnt = idx + 1 + (n - idx - 1) * 2\n    print(cnt)\n    \nelif 3 in a and 1 in a and 2 not in a:\n    print(\"Finite\")\n    idx = a.index(3)\n    cnt = idx + 1 + (n - idx - 1) * 2\n    print(cnt)\n    \nelif 1 in a and 2 in a and 3 not in a:\n    print(\"Finite\")\n    idx = a.index(1)\n    cnt = idx + 1 + (n - idx - 1) * 2\n    print(cnt)\n    \nelse:\n    print(\"Infinite\")"
 ],
 "879": [
  "n = int(input())\np = list(map(int, input().split()))\npath = [n]\n\nwhile path[-1] != 1:\n    path.append(p[path[-1]-2])\n\nprint(' '.join(map(str, path[::-1])))"
 ],
 "880": [
  "MOD = 998244353\n\nn = int(input())\n\nfac = [1]*(n+1) # Initializing factorials\nfor i in range(1,n+1):\n    fac[i] = (fac[i-1]*i)%MOD\n\nfinv = [1]*(n+1) #Initializing modular inverses of factorials\nfinv[n] = pow(fac[n], MOD-2, MOD)\nfor i in range(n-1,-1,-1):\n    finv[i] = (finv[i+1]*(i+1))%MOD\n\nchoose = lambda i,j : (0 if i < j else fac[i]*(finv[j]*finv[i-j])%MOD)\n\nans = 0\n\nfor i in range(n): #Iterating over sub of length n\n    sign = (-1)**(i%2)\n    ct = (choose(n,i)*fac[n-i])%MOD\n    for j in range(n-i): #Iterating over elements of sub\n        q1 = (i+j)*fac[n-i-1]\n        q2 = (n-i-j-1)*fac[n-i-1]       \n        ans = (ans + sign*ct*(q1 - q2))%MOD\n        sign = -sign\n\nans = (ans*finv[n])%MOD\n\nprint(ans)\n"
 ],
 "881": [
  "n = int(input())\na = list(map(int, input().split()))\n\ncnt = {}\nfor x in a:\n    if x not in cnt:\n        cnt[x] = 0\n    cnt[x] += 1\n\nans = 1\nfor x in cnt:\n    if cnt[x] > ans:\n        ans = cnt[x]\n\nprint(ans)"
 ],
 "882": [
  "s = input()\nt = input()\n\nn = len(s)\nm = len(t)\n\ndp = [[0] * (m+1) for _ in range(n+1)]\nfor i in range(n+1):\n    dp[i][0] = 1\n\nfor i in range(1, n+1):\n    for j in range(1, m+1):\n        if s[i-1] == t[j-1]:\n            dp[i][j] = dp[i-1][j-1]\n        elif s[i-1] == '?':\n            dp[i][j] = dp[i-1][j-1] + dp[i-1][j]\n        else:\n            dp[i][j] = dp[i-1][j]\n\nprint(dp[n][m])"
 ],
 "883": [
  "n = int(input())\nfingers = list(map(int, input().split()))\n\ntotal_fingers = sum(fingers)\ncount = 0\n\nfor i in range(1, 6):\n    if (total_fingers + i) % (n+1) != 1:\n        count += 1\n        \nprint(count)"
 ],
 "884": [
  "a,b,c=map(int,input().split())\nmod=998244353\nf=[1]*(max(a,b,c)+1)\nfor i in range(2,max(a,b,c)+1):\n    f[i]=i*f[i-1]%mod\nca=f[a];cb=f[b];cc=f[c];cab=f[a+b];cac=f[a+c];cbc=f[b+c];cabc=f[a+b+c]\nans=((ca*cb%mod*cac%mod*cbc%mod)+(cb*cc%mod*cab%mod*cac%mod)+(cc*ca%mod*cbc%mod*cab%mod))%mod\nans=(ans*2*f[a]%mod*f[b]%mod*f[c]%mod)%mod\nprint(ans)"
 ],
 "885": [
  "MOD = 998244353\n\ndef solve():\n    n = int(input())\n    edge = [tuple(map(int, input().split())) for _ in range(n - 1)]\n    g = [[] for _ in range(n)]\n    for u, v in edge:\n        g[u - 1].append(v - 1)\n        g[v - 1].append(u - 1)\n\n    def dfs(u, parent):\n        dp = [1, 1]\n        for v in g[u]:\n            if v != parent:\n                res = dfs(v, u)\n                dp[1] = (dp[1] * (res[0] + res[1]) + dp[0] * res[1]) % MOD\n                dp[0] = (dp[0] * (res[0] + res[1])) % MOD\n        return dp\n    return (dfs(0, -1)[1] - 1 + MOD) % MOD\n\nprint(solve())"
 ],
 "886": [
  "n = input()\nn_arr = list(n)\neven_arr = []\nfor i, digit1 in enumerate(n_arr):\n    if int(digit1) % 2 == 0:\n        even_arr.append([i, int(digit1)])\nif len(even_arr) == 0 or len(even_arr) == 1:\n    print(-1)\nelse:\n    max_even = [-1, -1]\n    for i in range(len(even_arr)):\n        for j in range(i+1, len(even_arr)):\n            new_n_arr = n_arr.copy()\n            new_n_arr[even_arr[i][0]] = str(even_arr[j][1])\n            new_n_arr[even_arr[j][0]] = str(even_arr[i][1])\n            new_even = int(\"\".join(new_n_arr))\n            if new_even % 2 == 0 and new_even > max_even[1]:\n                max_even = [new_even, new_even]\n    if max_even[0] == -1:\n        print(-1)\n    else:\n        print(max_even[0])"
 ],
 "887": [
  "n = int(input().strip())\nbuttons = list(map(int, input().split()))\nif n == 1:\n    print(\"YES\" if buttons[0] == 1 else \"NO\")\nelse:\n    unfastened_count = buttons.count(0)\n    fastened_count = buttons.count(1)\n    if unfastened_count == 1 and fastened_count != n:\n        print(\"YES\")\n    else:\n        print(\"NO\")"
 ],
 "888": [
  "n = int(input())\np = list(map(int, input().split()))\ns = list(map(int, input().split()))\n\n# create dictionary to store indices of elements in s\ns_indices = {s[i]: i for i in range(n)}\n\n# initialize variables\nnum_swaps = 0\noperations = []\n\n# loop through p and swap elements to obtain s\nfor i in range(n):\n    # if p[i] is already in the correct position, continue\n    if p[i] == s[i]:\n        continue\n    \n    # find index of p[i] in s\n    j = s_indices[p[i]]\n    \n    # swap p[i] and p[j], and update s_indices dictionary\n    p[i], p[j] = p[j], p[i]\n    s_indices[p[j]], s_indices[p[i]] = s_indices[p[i]], s_indices[p[j]]\n    \n    # increment num_swaps and store operation\n    num_swaps += abs(i - j)\n    operations.append((i+1, j+1))\n    \n# print output\nprint(num_swaps)\nprint(len(operations))\nfor op in operations:\n    print(op[0], op[1])"
 ],
 "889": [
  "grid = [input() for _ in range(4)]\n\nvalid = False\n\n# Check if there's already a 2x2 square of the same color\nfor i in range(3):\n    for j in range(3):\n        if len(set([grid[i][j], grid[i+1][j], grid[i][j+1], grid[i+1][j+1]])) == 1:\n            valid = True\n            break\n    if valid:\n        break\n\n# Check if a 2x2 square of the same color can be created by repainting one cell\nif not valid:\n    for i in range(4):\n        for j in range(4):\n            temp = grid[i][:j] + ('#' if grid[i][j] == '.' else '.') + grid[i][j+1:]\n            for k in range(3):\n                for l in range(3):\n                    if len(set([temp[k][l], temp[k+1][l], temp[k][l+1], temp[k+1][l+1]])) == 1:\n                        valid = True\n                        break\n                if valid:\n                    break\n            if valid:\n                break\n\nprint(\"YES\" if valid else \"NO\")"
 ],
 "890": [
  "n, l, r, x = map(int, input().split())\nproblems = list(map(int, input().split()))\ncount = 0\n\nfor mask in range(1, 2**n):  \n    chosen_probs = [problems[i] for i in range(n) if (mask & (1<<i)) != 0]\n    if len(chosen_probs) >= 2 and l <= sum(chosen_probs) <= r and max(chosen_probs) - min(chosen_probs) >= x:\n        count += 1\n\nprint(count)"
 ],
 "891": [
  "n,k=map(int,input().split())\ns=list(input())\nfor j in range(k):\n    a=s[-1]+s[0]\n    for i in range(1,n-1):\n        a+=s[i-1]+s[i+1]\n    a+=s[n-2]+s[0]\n    t=\"\"\n    for i in range(n):\n        if a[i*3:i*3+3].count('W')>1:\n            t+='W'\n        else:\n            t+='B'\n    s=t\nprint(''.join(s))"
 ],
 "892": [
  "from math import gcd\nfrom collections import defaultdict\n\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\npos = defaultdict(list)\nfor i, num in enumerate(a):\n    pos[num].append(i)\n\nans_l, ans_kmax, ans_seq = 1, 0, []\n\nfor i in range(n):\n    seq = [a[i]]\n    p = pos[a[i]][1:]\n    while len(p) > 0:\n        j = p[0]\n        new_seq = seq + a[i+1:j]\n        new_lcm = seq[-1]\n        for num in a[i+1:j]:\n            new_lcm = lcm(new_lcm, num)\n            if new_lcm > m:\n                break\n        if new_lcm <= m and len(new_seq) > len(ans_seq):\n            ans_l, ans_kmax, ans_seq = new_lcm, len(new_seq), new_seq\n        seq = new_seq + [a[j]]\n        p = pos[a[j]][1:]\n\nnew_ans_seq = [str(i+1) for i in ans_seq]\nprint(ans_l, ans_kmax)\nprint(' '.join(new_ans_seq))"
 ],
 "893": [
  "MOD = 10 ** 9 + 7\n\ndef dfs(curr, parent, d):\n    dp[curr][0] = dp[curr][1] = 1\n    for child in graph[curr]:\n        if child == parent: continue\n        dfs(child, curr, d)\n\n        # calculating dp[curr][0] or 0th state of dp[curr]\n        dp[curr][0] = dp[curr][0] * (dp[child][0] + dp[child][1]) % MOD\n\n    # calculating dp[curr][1] or 1st state of dp[curr]\n    for child in graph[curr]:\n        if child == parent: continue\n        # sum1 will calculate the total contribution of removing a set of valid node from each child\n        sum1 = dp[child][1] * dp[curr][0] * pow(dp[child][0] + dp[child][1], MOD - 2, MOD) % MOD\n        # sum2 will calculate the total states of removing a set of valid node from this child only and including this child\n        sum2 = dp[child][0] * dp[curr][1] * pow(dp[child][0] + dp[child][1], MOD - 2, MOD) % MOD\n        dp[curr][1] = (dp[curr][1] * (sum1 + sum2)) % MOD\n\n    # Taking care for the case where the current node itself can form a valid set\n    if a[curr-1] - d <= a[maxSub[curr]-1]:\n        dp[curr][1] = (dp[curr][1] + dp[curr][0]) % MOD\n\nn, d = map(int, input().split())\nmaxa = max(list(map(int, input().split())))\na = list(map(int, input().split()))\ngraph = {}\nfor i in range(1, n+1):\n    graph[i] = []\n\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n    graph[v].append(u)\n\nmaxSub = [0 for i in range(n + 1)]\nfor i in range(1, n + 1):\n    stack = [i]\n    visited = [0 for j in range(n + 1)]\n    while stack:\n        curr = stack.pop()\n        visited[curr] = 1\n        maxSub[i] = max(maxSub[i], a[curr-1])\n        for child in graph[curr]:\n            if visited[child] == 0:\n                stack.append(child)\n\ndp = [[0 for i in range(2)] for j in range(n+1)]\ndfs(1, -1, d)\nprint((dp[1][0] + dp[1][1]) % MOD)"
 ],
 "894": [
  "x, y = map(int, input().split())\nif x > 0 and y > 0:\n    print(0, x + y, x + y, 0)\nelif x < 0 and y > 0:\n    print(x - y, 0, 0, y - x)\nelif x < 0 and y < 0:\n    print(x + y, 0, 0, x + y)\nelse:\n    print(0, y - x, x - y, 0)"
 ],
 "895": [
  "n = int(input())\nsacrament_times = sorted(list(map(int,input().split())))\nT = int(input())\n\nmax_visits = 0\n\nfor i in range(n):\n    j = i+1\n    while j < n and sacrament_times[j]-sacrament_times[i] <= T:\n        j += 1\n    max_visits = max(max_visits, j-i)\n\nprint(max_visits)"
 ],
 "896": [
  "n, m = map(int, input().split())\nrow_xor = list(map(int, input().split()))\ncol_xor = list(map(int, input().split()))\nmatrix = [[0] * m for i in range(n)]\nfor i in range(n-1):\n    matrix[i][-1] = row_xor[i]\nfor i in range(m-1):\n    matrix[-1][i] = col_xor[i]\nmatrix[-1][-1] = row_xor[-1] ^ col_xor[-1]\nif matrix[-1][-1] != sum(col_xor) ^ sum(row_xor) ^ col_xor[-1]:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    for i in range(n):\n        print(\" \".join(str(matrix[i][j]) for j in range(m)))"
 ],
 "897": [
  "n,m=map(int,input().split())\ns1=list(map(int,input().split()))\ns2=list(map(int,input().split()))\n\nmod=10**9 + 7\ninvM=pow(m,mod-2,mod)\n\ndef calc(seg):\n    ans = [0] * ((m + 5) * 2)\n    ans_dev = [0] * ((m + 5) * 2)\n    for i in range(m + 2):\n        ans[m + i] = 1\n    for i in range(n):\n        for j in range(2):\n            for k in range(m + 2):\n                ans_dev[j * (m + 2) + k] = ans[j * (m + 1) + k + (s1[i] > 0)] * (m - seg[j][i])\n            for k in range(m + 1):\n                ans_dev[j * (m + 2)] += ans[j * (m + 1) + k + (s1[i] > 0)] * seg[j ^ 1][i]\n            for k in range(m + 1, -1, -1):\n                ans_dev[(j + 1) * (m + 2) - 1] += ans[j * (m + 1) + k + (s1[i] > 0)] * (seg[j ^ 1][i] - (k > 0))\n        for j in range((m + 2) * 2):\n            ans[j] = ans_dev[j] % mod\n            ans_dev[j] = 0\n    return ans[m+1]-1\n\np1=calc([list(range(1 if s1[i]==0 else s1[i],m+1)) for i in range(n)])\np2=calc([list(range(1 if s2[i]==0 else s2[i],m+1)) for i in range(n)])\n\nprint((p1-p2)*invM % mod)"
 ],
 "898": [
  "from math import gcd\n\nn, m = map(int, input().split())\n\n# Find the divisors of M\ndivisors = []\nfor i in range(1, int(m**0.5)+1):\n    if m % i == 0:\n        divisors.append(i)\n        if m // i != i:\n            divisors.append(m // i)\n            \n# Sort the divisors in decreasing order\ndivisors.sort(reverse=True)\n\n# Check each divisor if it can be a valid greatest common divisor\nfor d in divisors:\n    if m//d >= n:\n        print(d)\n        break"
 ],
 "899": [
  "import heapq\n\nINF = float('inf')\n\n\ndef dijkstra(s):\n    dist = [INF] * (n + 1)\n    dist[s] = 0\n    visited = [False] * (n + 1)\n    hq = [(0, s)]\n\n    while hq:\n        v_cost, v = heapq.heappop(hq)\n        if visited[v]:\n            continue\n        visited[v] = True\n\n        for to, cost in graph[v]:\n            if visited[to]:\n                continue\n\n            via_v_cost = v_cost + cost\n            if dist[to] > via_v_cost:\n                dist[to] = via_v_cost\n                heapq.heappush(hq, (dist[to], to))\n\n    return dist\n\n\nn, m = map(int, input().split())\ngraph = {i: [] for i in range(1, n + 1)}\n\nfor _ in range(m):\n    a, b, c = map(int, input().split())\n    graph[a].append((b, c))\n    graph[b].append((a, c))\n\nans = 0\nfor i in range(1, n + 1):\n    shortest = dijkstra(i)\n    for v in graph[i]:\n        u, c = v\n        if shortest[i] + shortest[u] + c == shortest[1] + shortest[n]:\n            continue\n        ans += 1\n\nprint(ans // 2)"
 ],
 "900": [
  "MOD = 10**9 + 7\n\nS = input().strip()\nn = len(S)\ndp = [[0]*13 for _ in range(n+1)]\ndp[0][0] = 1\n\nfor i in range(1, n+1):\n    c = S[i-1]\n    for j in range(13):\n        if c=='?':\n            for k in range(10):\n                dp[i][(j*10+k)%13] += dp[i-1][j]\n        else:\n            dp[i][(j*10+int(c))%13] += dp[i-1][j]\n        dp[i][j] = dp[i][j] % MOD\n\nprint(dp[n][5])"
 ],
 "901": [
  "n, m = map(int, input().split())\n\ngroups = [[] for i in range(m)]\n\nfor i in range(m):\n    k, *members = map(int, input().split())\n    for member in members:\n        groups[i].append(abs(member)-1)\n        # mark as negative if it's a Rick, positive if Morty\n        if member < 0:\n            groups[i][-1] = -groups[i][-1]\n\nworld_end = False\n\nfor rick_traitor in range(n):\n    for morty_traitor in range(n):\n        if rick_traitor == morty_traitor:\n            continue\n        traitors = {rick_traitor, morty_traitor}\n        for group in groups:\n            traitors_in_group = set()\n            for member in group:\n                if member < 0 and abs(member)-1 in traitors:\n                    traitors_in_group.add(member)\n                elif member > 0 and abs(member)-1 in traitors:\n                    traitors_in_group.add(member)\n            if len(traitors_in_group) == len(group):\n                world_end = True\n                break\n        if world_end:\n            break\n    if world_end:\n        break\n\nif world_end:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "902": [
  "n, k = map(int, input().split())\npowers = list(map(int, input().split()))\n\nwinner = powers[0]\n\nconsecutive_wins = 0\n\nfor i in range(1, n):\n    if powers[i] > winner:\n        winner = powers[i]\n        consecutive_wins = 1\n    else:\n        consecutive_wins += 1\n\n    if consecutive_wins == k:\n        break\n\nprint(winner)"
 ],
 "903": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort()\n\nmid = n//2\nans = a[mid]\n\nfor i in range(mid+1, n):\n    if a[i] > ans:\n        diff = a[i] - ans\n        if k >= diff*(i-mid):\n            k -= diff*(i-mid)\n            ans = a[i]\n        else:\n            ans += k//(i-mid)\n            break\n    elif k >= i-mid:\n        k -= i-mid\n        ans = a[i]\n    else:\n        ans += k//(i-mid)\n        break\n\nprint(ans)"
 ],
 "904": [
  "python\nn = int(input())\nwords = input().split()\nvolume = max([sum([1 for letter in word if letter.isupper()]) for word in words])\nprint(volume)"
 ],
 "905": [
  "n, s = map(int, input().split())\nmax_sweets = -1\nfor i in range(n):\n    x, y = map(int, input().split())\n    if x < s:\n        if y != 0:\n            max_sweets = max(max_sweets, (100 - y) % 100)\n        else:\n            max_sweets = max(max_sweets, 0)\n    elif x == s:\n        if y == 0:\n            max_sweets = max(max_sweets, 0)\nprint(max_sweets)"
 ],
 "906": [
  "n, m, k = map(int, input().split())\nif k == -1 and abs(n-m) % 2 == 1:\n    print(0)\nelse:\n    print(pow(pow(2, n-1, 10**9+7), m-1, 10**9+7) * pow(pow(2, m-1, 10**9+7), n-1, 10**9+7) % (10**9+7))"
 ],
 "907": [
  "n, m = map(int, input().split())\npairs = [tuple(map(int, input().split())) for _ in range(m)]\nfor x in range(1, n+1):\n    for y in range(x+1, n+1):\n        valid = True\n        for a, b in pairs:\n            if a != x and a != y and b != x and b != y:\n                valid = False\n                break\n        if valid:\n            print(\"YES\")\n            exit(0)\nprint(\"NO\")"
 ],
 "908": [
  "n = int(input())\nc = list(map(int, input().split()))\ns = [input() for _ in range(n)]\ndp = [[float('inf')]*2 for _ in range(n)]\ndp[0][0] = 0\ndp[0][1] = c[0]\n\nfor i in range(1, n):\n    if s[i] >= s[i-1]:\n        dp[i][0] = dp[i-1][0]\n    if s[i] >= s[i-1][::-1]:\n        dp[i][0] = min(dp[i][0], dp[i-1][1])\n    if s[i][::-1] >= s[i-1]:\n        dp[i][1] = dp[i-1][0] + c[i]\n    if s[i][::-1] >= s[i-1][::-1]:\n        dp[i][1] = min(dp[i][1], dp[i-1][1] + c[i])\n\nans = min(dp[n-1])\nif ans == float('inf'):\n    print(-1)\nelse:\n    print(ans)"
 ],
 "909": [
  "a = int(input().strip())\nb = int(input().strip())\nc = int(input().strip())\nprint(max(a+b+c, a*b*c, a+b*c, a*b+c, (a+b)*c, a*(b+c)))"
 ],
 "910": [
  "n, a, b = map(int, input().split())\n\nif n > a*b:\n    print(-1)\nelse:\n    ans = [[0]*b for i in range(a)]\n    dem, rep = 1, 2\n    for i in range(a):\n        for j in range(b):\n            if(i%2==0 and j%2==0 and dem<=n):\n                ans[i][j] = dem\n                dem += 2\n            elif(i%2==1 and j%2==1 and rep<=n):\n                ans[i][j] = rep\n                rep += 2\n    for i in ans:\n        print(*i)"
 ],
 "911": [
  "n, c = map(int, input().split())\np = list(map(int, input().split()))\nt = list(map(int, input().split()))\n\n# calculate Limak's score\nlimak_score = 0\nlimak_time = 0\nfor i in range(n):\n    limak_time += t[i]\n    limak_score += max(0, p[i] - c * limak_time)\n\n# calculate Radewoosh's score\nradewoosh_score = 0\nradewoosh_time = 0\nfor i in range(n-1, -1, -1):\n    radewoosh_time += t[i]\n    radewoosh_score += max(0, p[i] - c * radewoosh_time)\n\n# determine the winner or tie\nif limak_score > radewoosh_score:\n    print(\"Limak\")\nelif radewoosh_score > limak_score:\n    print(\"Radewoosh\")\nelse:\n    print(\"Tie\")"
 ],
 "912": [
  "t = int(input())\n\nfor _ in range(t):\n    n, s, k = map(int, input().split())\n    closed_restaurants = set(map(int, input().split()))\n    \n    i = 0\n    while s-i >=1 and s-i in closed_restaurants:\n        i += 1\n    \n    j = 0\n    while s+j <=n and s+j in closed_restaurants:\n        j += 1\n        \n    print(min(i,j))"
 ],
 "913": [
  "n = int(input())\nr = list(map(int, input().split()))\nb = list(map(int, input().split()))\nmax_p = 0\nfor i in range(n):\n    if r[i] and not b[i]:\n        max_p = max(max_p, 1)\n    elif r[i] and b[i]:\n        max_p = 0\n        break\nif max_p == 0:\n    print(-1)\nelse:\n    print(max_p+1)"
 ],
 "914": [
  "from collections import Counter\n\ns = input().strip()\nn = int(input())\n\nif len(s) % n != 0:\n    print(-1)\nelse:\n    freq = Counter(s)\n    sheet_size = len(s) // n\n    for c in freq:\n        if freq[c] % sheet_size != 0:\n            print(-1)\n            break\n    else:\n        num_sheets = len(s) // (sheet_size * n)\n        sheet = \"\".join([c * (freq[c] // (sheet_size * num_sheets)) for c in freq])\n        print(num_sheets)\n        print(sheet)"
 ],
 "915": [
  "k = int(input())\ns = \"codeforces\"\nn = 1\nwhile n**10 < k:\n    n += 1\na = [n]*10\nfor i in range(10):\n    if i < k-(n**10)+(n-1)**10:\n        a[i] -= 1\nprint(\"\".join([s[i]*a[i] for i in range(10)]))"
 ],
 "916": [
  "from collections import deque\n\ndef bfs(N, adjacency_list, start, end=None): \n    dist = [-1 for _ in range(N)]\n    dist[start] = 0\n    q = deque([start])\n    while q:\n        v = q.popleft()\n        for nv in adjacency_list[v]:\n            if dist[nv] == -1:\n                dist[nv] = dist[v] + 1\n                q.append(nv)\n    if end is not None:\n        return dist[end]\n    return dist\n\nN = int(input())\nA = list(map(int, input().split()))\ng = [[] for i in range(N)]\n\nfor i in range(1, N):\n    p = int(input())-1\n    g[p].append(i)\n    g[i].append(p)\n\ndepth = bfs(N, g, 0)\neven = [i for i in range(N) if depth[i]%2 == 0]\nodd = [i for i in range(N) if depth[i]%2 == 1]\n\neven_dist = bfs(N, g, even[0])\nmost_distant_even = max(even, key=lambda x: even_dist[x])\neven_dist2 = bfs(N, g, most_distant_even)\ndiam_evens = max(even_dist2)\n\nodd_dist = bfs(N, g, odd[0])\nmost_distant_odd = max(odd, key=lambda x: odd_dist[x])\nodd_dist2 = bfs(N, g, most_distant_odd)\ndiam_odds = max(odd_dist2)\n\nif diam_evens % 2 == 0:\n    winners = even\nelse:\n    winners = odd\n\nis_win = {}\nfor start in winners:\n    dist = bfs(N, g, start)\n    max_dist = max(dist)\n    nd = dist.count(max_dist)\n    cnts = [0]*9\n    for x in range(N):\n        if dist[x] == max_dist:\n            cnts[min(A[x], 8)] += 1\n    res = 0\n    for i in range(1, 9):\n        if cnts[i]:\n            res ^= cnts[i]\n    if nd == 1 and res == 0: \n        is_win[start] = True\n    else:\n        is_win[start] = False\n\nif len(winners) == 1:\n    print(0)\nelse:\n    cnt = 0\n    for i in range(N):\n        if i == most_distant_even or i == most_distant_odd:\n            continue\n        u, v = i, i\n        if depth[u] % 2 == 0:\n            u, v = v, u\n        if is_win[u] and not is_win[v]:\n            cnt += 1\n    print(cnt)\n"
 ],
 "917": [
  "n, h, m = map(int, input().split())\nhouses = [h]*n\nfor _ in range(m):\n    l, r, x = map(int, input().split())\n    for i in range(l-1, r):\n        houses[i] = min(houses[i], x)\nprofit = sum([height**2 for height in houses])\nprint(profit)"
 ],
 "918": [
  "n,m = map(int, input().split())\n\nregions = [[] for _ in range(m)]\n\nfor _ in range(n):\n    name, region, score = input().split()\n    region = int(region) - 1\n    score = int(score)\n    regions[region].append((name, score))\n\nfor i in range(m):\n    if len(regions[i]) < 2:\n        print(\"?\")\n    else:\n        regions[i].sort(key=lambda x: -x[1])\n        if regions[i][0][1] > regions[i][1][1]:\n            print(regions[i][0][0], regions[i][1][0])\n        else:\n            print(\"?\")"
 ],
 "919": [
  "n, k = map(int, input().split())\ns = input()\n\nif k < 5:\n    print(-1)\n    exit()\n\nans = float('inf')\nfor comb in combinations(set(s), k):\n    if set('abcde').issubset(comb):\n        rocket = ''.join(sorted(comb))\n        prev = 0\n        weight = 0\n        for c in rocket:\n            cur = s.index(c)\n            weight += cur - prev + 1\n            prev = cur + 1\n        ans = min(ans, weight)\n\nprint(ans if ans != float('inf') else -1)"
 ],
 "920": [
  "n = int(input())\n\nguards = []\nfor i in range(4):\n    a, b, c, d = map(int, input().split())\n    guards.append([a, b, c, d])\n\nfor i in range(4):\n    for j in range(4):\n        if i == j:\n            continue\n        if guards[i][0] + guards[j][1] <= n:\n            print(f\"{i+1} {guards[i][0]} {guards[j][1]}\")\n            exit()\n        if guards[i][1] + guards[j][0] <= n:\n            print(f\"{i+1} {guards[j][0]} {guards[i][1]}\")\n            exit()\n\nprint(\"-1\")"
 ],
 "921": [
  "n,w=map(int,input().split())\na=list(map(int,input().split()))\ns=sorted(((a[i],i) for i in range(n)),reverse=True)    \n \nans=[0]*n\ncur=w       \nfor i in range(n):\n    half= (a[s[i][1]]+1)//2\n    if cur>=half:\n        ans[s[i][1]]=half\n        cur-= half\n    else:\n        print(-1)\n        exit()\nif cur>0:\n    for i in range(n-1,-1,-1):\n        half=(a[s[i][1]]+1)//2\n        if ans[s[i][1]]<half and cur>0:\n            need=half-ans[s[i][1]]\n            add=min(need,cur)\n            ans[s[i][1]]+=add\n            cur-=add\nif cur>0:\n    print(-1)\nelse:\n    print(*ans)"
 ],
 "922": [
  "n, A = map(int, input().split())\nd = list(map(int, input().split()))\ns = sum(d)\nfor i in range(n):\n    max_sum = A - (s - d[i])\n    min_sum = A - (d[i]*(n-1))\n    res = max(0, min((max_sum-d[i]+1), d[i]) - max(min_sum, 1) + 1)\n    print(res, end=\" \")"
 ],
 "923": [
  "n = int(input())\nactive_teeth = list(map(int, input().split()))\n\nfor i in range(n):\n    sequence = [0] * n\n    curr_index = i\n    for j in range(n):\n        sequence[j] = active_teeth[curr_index]\n        curr_index = (curr_index + 1) % n if j % 2 == 0 else (curr_index - 1) % n\n    if sequence == list(range(n)):\n        print(\"Yes\")\n        break\nelse:\n    print(\"No\")"
 ],
 "924": [
  "la, ra, ta = map(int,input().split())\nlb, rb, tb = map(int,input().split())\nl = max(la,lb)\nr = min(ra,rb)\nt = ta*tb//(a:=math.gcd(ta,tb))\nprint((r-l)//t + 1 if l<=r else 0)"
 ],
 "925": [
  "n = input()\ncount = 0\nfor i in range(100):\n    broken = False\n    si = str(i).zfill(2) # pad with leading zero if the number is a single digit\n    \n    for j in range(2):\n        if (si[j] == '0' and n[j] != '0') or (si[j] == '1' and n[j] != '1') or (si[j] == '2' and n[j] != '5') or (si[j] == '5' and n[j] != '2') or (si[j] == '8' and n[j] != '8'):\n            broken = True # broken stick detected, cannot be a good integer\n            break\n    \n    if not broken:\n        count += 1 # no broken stick detected, this is a good integer\n\nprint(count)"
 ],
 "926": [
  "n = int(input())\nstones = []\nfor i in range(n):\n    a, b, c = sorted(map(int, input().split()))\n    stones.append((a, b, c, i+1))\n\nstones.sort(key = lambda x: (-x[0], -x[1], -x[2]))\n\ndef sphere_volume(a, b, c):\n    r = min(a, b, c)\n    return (4/3)*3.141592653589793*r**3\n\nvolumes = []\nfor i in range(n-1):\n    for j in range(i+1, n):\n        if stones[i][0] != stones[j][0] or stones[i][1] != stones[j][1]:\n            continue\n        a = stones[i][0]\n        b = stones[i][1] + stones[j][2]\n        c = stones[i][2] + stones[j][1]\n        volumes.append((sphere_volume(a, b, c), [stones[i][3], stones[j][3]]))\n\nvolumes.append((sphere_volume(*stones[0][:3]), [stones[0][3]]))\nvolumes.sort(reverse=True)\n\nprint(len(volumes))\nprint(*volumes[0][1])"
 ],
 "927": [
  "n, m = map(int, input().split())\na = list(map(int, input().split()))\n\nmatchsticks = [0, 2, 5, 5, 4, 5, 6, 3, 7, 6]\n\nnum_cnt = [0] * 10\nfor ai in a:\n    num_cnt[ai] = matchsticks[ai]\n\ndp = [-1] * (n + 1)\ndp[0] = 0\nfor i in range(1, n + 1):\n    for num, cnt in enumerate(matchsticks):\n        if cnt <= i and dp[i-cnt] >= 0:\n            dp[i] = max(dp[i], dp[i-cnt] * 10 + num)\nans = dp[n]\n\nwhile ans > 0:\n    max_matchsticks = 0\n    for i in range(10):\n        if num_cnt[i] > 0 and n - matchsticks[i] >= 0 and dp[n-matchsticks[i]] == dp[n] // 10:\n            max_matchsticks = matchsticks[i]\n    if max_matchsticks == 0:\n        break\n    n -= max_matchsticks\n    num_cnt[dp[n] % 10] -= 1\n    print(dp[n] % 10, end=\"\")\n    ans //= 10"
 ],
 "928": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\nrunning_sum = [0] * (n + 1)\nfor i in range(n):\n    running_sum[i+1] = running_sum[i] + a[i]\n\ncount = 0\nfor i in range(n):\n    for j in range(i+1, n+1):\n        if running_sum[j] - running_sum[i] >= k:\n            count += 1\n\nprint(count)"
 ],
 "929": [
  "H, W = map(int, input().split())\n\neven_cells = []\nodd_cells = []\n\nfor i in range(1, H+1):\n    row = list(map(int, input().split()))\n    for j in range(1, W+1):\n        if row[j-1] % 2 == 0:\n            even_cells.append((i, j))\n        else:\n            odd_cells.append((i, j))\n\noperations = []\nfor i in range(len(odd_cells)):\n    if i == len(even_cells) - 1:\n        break\n    diff_row = even_cells[i][0] - odd_cells[i][0]\n    diff_col = even_cells[i][1] - odd_cells[i][1]\n    if diff_row != 0:\n        if even_cells[-1][0] > odd_cells[i][0]:\n            operations.append((even_cells[-1][0], even_cells[-1][1], odd_cells[i][0]+1, odd_cells[i][1]))\n            even_cells[-1] = (odd_cells[i][0]+1, odd_cells[i][1])\n        else:\n            operations.append((even_cells[-1][0], even_cells[-1][1], odd_cells[i][0]-1, odd_cells[i][1]))\n            even_cells[-1] = (odd_cells[i][0]-1, odd_cells[i][1])\n    else:\n        if even_cells[-1][1] > odd_cells[i][1]:\n            operations.append((even_cells[-1][0], even_cells[-1][1], odd_cells[i][0], odd_cells[i][1]+1))\n            even_cells[-1] = (odd_cells[i][0], odd_cells[i][1]+1)\n        else:\n            operations.append((even_cells[-1][0], even_cells[-1][1], odd_cells[i][0], odd_cells[i][1]-1))\n            even_cells[-1] = (odd_cells[i][0], odd_cells[i][1]-1)\n\nprint(len(operations))\nfor operation in operations:\n    print(*operation)"
 ],
 "930": [
  "n, k = map(int, input().split())\nmod = 10**9 + 7\n\ndef mod_combination(n, r, mod):\n    if n < r or n < 0 or r < 0:\n        return 0\n    r = min(r, n - r)\n    return fact[n] * fact_inv[r] * fact_inv[n - r] % mod\n\nfact = [1] * (n+k+1)\nfact_inv = [1] * (n+k+1)\nfor i in range(1, n+k+1):\n    fact[i] = i * fact[i-1] % mod\nfact_inv[-1] = pow(fact[-1], mod-2, mod)\nfor i in range(n+k-1, 0, -1):\n    fact_inv[i] = fact_inv[i+1] * (i+1) % mod\n\nans = 0\nfor i in range(n):\n    ans += mod_combination(n, i, mod) * mod_combination(n-1+i, i, mod) % mod\n    ans %= mod\n    \nprint(ans)"
 ],
 "931": [
  "n, m, x, y, z, p = map(int, input().split())\nx = x % 4\ny = y % 2\nz = z % 4\n\nfor i in range(p):\n    k, l = map(int, input().split())\n    for _ in range(x):\n        k, l = l, n + 1 - k\n    if y == 1:\n        l = m + 1 - l\n    for _ in range(z):\n        k, l = m + 1 - l, k\n    print(k, l)"
 ],
 "932": [
  "m, n = map(int, input().split())\nb = [list(map(int, input().split())) for _ in range(m)]\na = [[1]*n for _ in range(m)] # initialize a with all 1s\nfor i in range(m):\n    for j in range(n):\n        if b[i][j] == 0:\n            # set all elements in row i of a to 0\n            for k in range(n):\n                a[i][k] = 0\n            # set all elements in column j of a to 0\n            for k in range(m):\n                a[k][j] = 0\n# check if Nam made a mistake by comparing b and the calculated b\ncalculated_b = [[0]*n for _ in range(m)]\nfor i in range(m):\n    for j in range(n):\n        calculated_b[i][j] = 1 if any(a[i][k] == 1 or a[k][j] == 1 for k in range(m)) else 0\nif calculated_b == b:\n    print(\"YES\")\n    for row in a:\n        print(*row)\nelse:\n    print(\"NO\")"
 ],
 "933": [
  "s = input()\n\n# Remove triple letters\ni = 0\nwhile i < len(s)-2:\n    if s[i] == s[i+1] == s[i+2]:\n        s = s[:i] + s[i+1:]\n    else:\n        i += 1\n\n# Remove double-double letters\ni = 0\nwhile i < len(s)-3:\n    if s[i] == s[i+1] and s[i+2] == s[i+3]:\n        s = s[:i+2] + s[i+3:]\n    else:\n        i += 1\n        \nprint(s)"
 ],
 "934": [
  "table_card = input()\nhand_cards = input().split()\nfor card in hand_cards:\n    if card[0] == table_card[0] or card[1] == table_card[1]:\n        print(\"YES\")\n        break\nelse:\n    print(\"NO\")"
 ],
 "935": [
  "n, m = map(int, input().split())\nif n > m:\n    n, m = m, n\nif n == 1:\n    if m % 2 == 0:\n        print(\"Malvika\")\n    else:\n        print(\"Akshat\")\nelse:\n    if (n * m) % 2 == 0:\n        print(\"Malvika\")\n    else:\n        print(\"Akshat\")"
 ],
 "936": [
  "n = int(input())\nlikes = list(map(int,input().split()))\nphoto_map = {}\nfor i in likes:\n    if i not in photo_map:\n        photo_map[i] = 1\n    else:\n        photo_map[i] += 1\nmax_likes = max(photo_map.values())\nwinners = []\nfor key, value in photo_map.items():\n    if value == max_likes:\n        winners.append(key)\nif len(winners) == 1:\n    print(winners[0])\nelse:\n    earliest = float('inf')\n    winner = None\n    for w in winners:\n        index = likes.index(w)\n        if index < earliest:\n            earliest = index\n            winner = w\n    print(winner)"
 ],
 "937": [
  "n, k = map(int, input().split())\ntheorem = list(map(int, input().split()))\nbehavior = list(map(int, input().split()))\n\nmax_theorem = 0\nfor i in range(n-k+1):\n    theorem_count = sum(theorem[i:i+k])\n    behavior_count = sum(behavior[i:i+k])\n    max_theorem = max(max_theorem, theorem_count + behavior_count*(1-theorem_count))\nprint(max_theorem)"
 ],
 "938": [
  "a ,b = map(int,input().split())\ntotal = a + b\ncount = 0\nday_1 = []\nfor i in range(1, total+1):\n    if(i <= a):\n        a -= i\n        count += 1\n        day_1.append(i)\n    else:\n        break\nprint(count)\nprint(\" \".join([str(val) for val in day_1]))\nprint(total - count)\nday_2 = []\nfor i in range(1, total+1):\n    if(i not in day_1 and i<=b):\n        day_2.append(i)\nprint(len(day_2))\nprint(\" \".join([str(val) for val in day_2]))"
 ],
 "939": [
  "n, m = map(int, input().split())\n\ndances = []\nfor i in range(m):\n    dances.append(list(map(int, input().split())))\n\ncolors = [0] * n\nfor i in range(m):\n    for j in range(3):\n        dancer = dances[i][j] - 1\n        if colors[dancer] == 0:\n            available_colors = [1, 2, 3]\n            for k in range(3):\n                neighbor = dances[i][k] - 1\n                if neighbor != dancer and colors[neighbor] in available_colors:\n                    available_colors.remove(colors[neighbor])\n            colors[dancer] = available_colors[0]\n\nprint(\" \".join(map(str, colors)))"
 ],
 "940": [
  "a, b, c = sorted(map(int, input().split()))\n\nif a + b > c:\n    print(0)\nelse:\n    print(c - a - b + 1)"
 ],
 "941": [
  "b, k = map(int, input().split())\na = list(map(int, input().split()))\nn = sum([a[i]*(b**(k-i-1)) for i in range(k)])\nprint(\"even\" if n%2==0 else \"odd\")"
 ],
 "942": [
  "n = int(input())\na = list(map(int, input().split()))\n\nb = [0] * n\nfor i in range(n):\n    if a[i] > n - 1 - i:\n        print(\"Impossible\")\n        exit()\n    b[i] = n - a[i] - 1\n\nused = [False] * (n + 1)\nfor i in range(n):\n    if b[i] < 1 or b[i] > n or used[b[i]]:\n        print(\"Impossible\")\n        exit()\n    used[b[i]] = True\n\nprint(\"Possible\")\nprint(*b)"
 ],
 "943": [
  "n = int(input())\narr = list(map(int,input().split()))\narr.sort(reverse=True)\ns = sum(arr)\n\nif s % 2 == 0:\n    print(s)\nelse:\n    for i in range(n):\n        if arr[i] % 2 != 0:\n            s -= arr[i]\n        if s % 2 == 0:\n            print(s)\n            break"
 ],
 "944": [
  "import sys\nsys.setrecursionlimit(2*10**5)\n\ndef dfs(node, parent):\n    global day\n    subtree_sizes[node]=1\n    for child in graph[node]:\n        if child != parent:\n            dfs(child, node)\n            subtree_sizes[node] += subtree_sizes[child]\n            days[(node,child)] = subtree_sizes[child] * (n - subtree_sizes[child])\n    subtrees = sorted([days[(node, child)] for child in graph[node] if child != parent],reverse=True)\n    while(sum(subtrees) > 0):\n        day += 1\n        i = 0\n        while(i<len(subtrees) and subtrees[i]>0):\n            j = i+1\n            while(j < len(subtrees) and subtrees[j]>0 and subtrees[i] + subtrees[j] <= 0):\n                j += 1\n            j -= 1\n            repairs = []\n            if i == j:\n                repairs.append(edges[(node,graph[node][i])])\n            else:\n                repairs = [edges[(node,graph[node][i])], edges[(node,graph[node][j])]]\n            for k in repairs:\n                ans[day].append(k)\n                days[k] = 0\n            subtrees[i] += subtrees[j]\n            subtrees[j] = 0\n            i = j+1\n\nn = int(input())\ngraph = {i: [] for i in range(1, n+1)}\nedges = {}\nfor i in range(1, n):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n    graph[v].append(u)\n    edges[(u,v)] = edges[(v,u)] = i\nsubtree_sizes = [0] * (n+1)\ndays = {}\nday = 0\nans = [[] for i in range(n+1)]\ndfs(1, 0)\nprint(day)\nfor i in range(1, day+1):\n    print(len(ans[i]), *ans[i])"
 ],
 "945": [
  "n = int(input())\npoints = list(map(int, input().split()))\n\nyes = False\n\nfor i in range(n - 1):\n    for j in range(i + 1, n - 1):\n        if min(points[i], points[i+1]) < min(points[j], points[j+1]) < max(points[i], points[i+1]) < max(points[j], points[j+1]) or min(points[j], points[j+1]) < min(points[i], points[i+1]) < max(points[j], points[j+1]) < max(points[i], points[i+1]):\n            yes = True\n            break\n\nif yes:\n    print(\"yes\")\nelse:\n    print(\"no\")"
 ],
 "946": [
  "n = int(input())\nopinions = list(map(int, input().split()))\nprint(\"HARD\" if any(opinions) else \"EASY\")"
 ],
 "947": [
  "t = int(input())\nfor i in range(t):\n    n = int(input())\n    if n % 2 == 0:\n        print(n//2, n//2)\n    else:\n        for j in range(3, int(n**0.5)+1, 2):\n            if n % j == 0:\n                print(n//j, n - n//j)\n                break\n        else:\n            print(1, n-1)"
 ],
 "948": [
  "n, m = map(int, input().split())\nimage = [input() for _ in range(n)]\ncount = 0\nfor i in range(n-1):\n    for j in range(m-1):\n        if set(image[i][j:j+2]+image[i+1][j:j+2]) == set(\"face\"):\n            count += 1\nprint(count)"
 ],
 "949": [
  "def gcd(a,b):\n    if a==0:\n        return b\n    elif b==0:\n        return a\n    else:\n        return gcd(b,a%b)\n\na,b = map(int, input().split())\nprint(gcd(a,b))"
 ],
 "950": [
  "n, m = map(int, input().split())\npassword = []\nfor i in range(n):\n    password.append(input())\n\nsymbols = '0123456789abcdefghijklmnopqrstuvwxyz#*&'\nrequired_symbols = [False, False, False]\n\n# find the required symbols and their locations\nfor i in range(n):\n    for j in range(m):\n        if password[i][j].isdigit():\n            required_symbols[0] = True\n        elif password[i][j].islower():\n            required_symbols[1] = True\n        elif password[i][j] in '#*&':\n            required_symbols[2] = True\n\nlocations = [[] for _ in range(3)]\nfor i in range(n):\n    for j in range(m):\n        if password[i][j] in '0123456789':\n            locations[0].append((i, j))\n        elif password[i][j].islower():\n            locations[1].append((i, j))\n        elif password[i][j] in '#*&':\n            locations[2].append((i, j))\n\n# find the minimum number of operations to satisfy the requirements\nans = float(\"inf\")\nfor indices in zip(*[range(len(locations[i])) for i in range(3)]):\n    symbols_indices = [locations[i][indices[i]] for i in range(3)]\n    cost = 0\n    for i in range(3):\n        symbol, loc = symbols_indices[i]\n        cost += min(abs(loc - loc2) for _, loc2 in symbols_indices if _ != i)\n    if all(required_symbols):\n        ans = min(ans, cost)\n\nprint(ans)"
 ],
 "951": [
  "k = int(input())\nn = input()\n\ninitial_sum = sum(int(d) for d in n)\n\nif initial_sum >= k:\n    print(0)\nelse:\n    digits = sorted((int(d), i) for i, d in enumerate(n))\n    diff = k - initial_sum\n    count = 0\n    for d, i in digits:\n        if d == 9:\n            continue\n        diff -= 9 - d\n        count += 1\n        if diff <= 0:\n            break\n    print(count)"
 ],
 "952": [
  "import heapq\n\ndef dfs(u, p=None, edge_id=None):\n    global ans\n    visited.add(u)\n    nonlocal edge_count\n    \n    for v, c, idx in edges[u]:\n        if v == p:\n            if idx != edge_id: # we have found the cycle\n                if c < edges[edge_id][0][1]: # check if the edge we are considering has less cost to reverse\n                    heapq.heappop(roads)\n                    heapq.heappush(roads, (c, idx))\n                    ans += c - edges[edge_id][0][1]\n                return\n        elif v not in visited:\n            dfs(v, u, idx)\n        \n    if edge_id is not None:\n        heapq.heappush(roads, (edges[edge_id][0][1], edge_id))\n        edge_count += 1\n            \n\nn, m = map(int, input().split())\nedges = [[] for _ in range(n)]\nfor i in range(m):\n    u, v, c = map(int, input().split())\n    edges[u-1].append((v-1, c, i+1))\n    edges[v-1].append((u-1, c, i+1))\n\nvisited = set()\nroads = []\nedge_count = 0\nans = 0\n\nfor i in range(n):\n    if i not in visited:\n        dfs(i)\n    \nprint(ans, edge_count)\nprint(\" \".join(str(x[1]) for x in roads))"
 ],
 "953": [
  "n = int(input())\np = list(map(int, input().split()))\na = []\nfor i in range(n):\n    a.append(list(map(int,input())))\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            if a[i][j] == 1:\n                if p[i] > p[j]:\n                    p[i], p[j] = p[j], p[i]\nprint(*p)"
 ],
 "954": [
  "s = input().strip()\nn = len(s)\nwords_set = set()\nfor i in range(n):\n    words_set.add(s) # Add current string to set\n    s = s[-1] + s[:n-1] # Perform cyclic shift\nprint(len(words_set))"
 ],
 "955": [
  "n = int(input())\njuices = []\nfor i in range(n):\n    price, vitamins = input().split()\n    vitamins = set(vitamins)\n    juices.append((price, vitamins))\n\nmin_price = float('inf')\nfor i in range(n):\n    for j in range(i+1, n):\n        for k in range(j+1, n):\n            vitamins = juices[i][1].union(juices[j][1], juices[k][1])\n            if len(vitamins) == 3:\n                total_price = int(juices[i][0]) + int(juices[j][0]) + int(juices[k][0])\n                min_price = min(min_price, total_price)\n\nif min_price == float('inf'):\n    print(-1)\nelse:\n    print(min_price)"
 ],
 "956": [
  "from collections import defaultdict\n\nm, k = map(int, input().split())  # \u0432\u0432\u043e\u0434 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0430 \u043f\u0430\u0440 \u0434\u0440\u0443\u0437\u0435\u0439 \u0438 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e\u0433\u043e \u043f\u0440\u043e\u0446\u0435\u043d\u0442\u0430 \u043e\u0431\u0449\u0438\u0445 \u0434\u0440\u0443\u0437\u0435\u0439\nfriends = defaultdict(set)  # \u0441\u043b\u043e\u0432\u0430\u0440\u044c \u0434\u043b\u044f \u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u043f\u0430\u0440 \u0434\u0440\u0443\u0437\u0435\u0439. \u041a\u043b\u044e\u0447 \u2014 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u0447\u0435\u043b\u043e\u0432\u0435\u043a\u0430, \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u2014 \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440\u043e\u0432 \u0435\u0433\u043e \u0434\u0440\u0443\u0437\u0435\u0439.\n\nfor i in range(m):\n    a, b = map(int, input().split())\n    friends[a].add(b)  # \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0434\u0440\u0443\u0433\u0430 b \u043a \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u0443 \u0434\u0440\u0443\u0437\u0435\u0439 \u0447\u0435\u043b\u043e\u0432\u0435\u043a\u0430 a\n    friends[b].add(a)  # \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0434\u0440\u0443\u0433\u0430 a \u043a \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u0443 \u0434\u0440\u0443\u0437\u0435\u0439 \u0447\u0435\u043b\u043e\u0432\u0435\u043a\u0430 b\n\nfor person in sorted(friends.keys()):\n    candidate_friends = set()  # \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e \u043f\u0440\u0435\u0434\u043f\u043e\u043b\u0430\u0433\u0430\u0435\u043c\u044b\u0445 \u0434\u0440\u0443\u0437\u0435\u0439\n    for friend in friends[person]:  # \u043f\u0440\u043e\u0445\u043e\u0434\u0438\u043c \u043f\u043e \u0432\u0441\u0435\u043c \u0434\u0440\u0443\u0437\u044c\u044f\u043c \u0447\u0435\u043b\u043e\u0432\u0435\u043a\u0430\n        common_friends = friends[friend] & friends[person]  # \u043d\u0430\u0445\u043e\u0434\u0438\u043c \u043e\u0431\u0449\u0438\u0445 \u0434\u0440\u0443\u0437\u0435\u0439\n        if len(common_friends)/len(friends[person]) >= k/100:  # \u0435\u0441\u043b\u0438 \u0442\u0430\u043a\u0438\u0445 \u043e\u0431\u0449\u0438\u0445 \u0434\u0440\u0443\u0437\u0435\u0439 \u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e\n            continue  # \u043f\u0435\u0440\u0435\u0445\u043e\u0434\u0438\u043c \u043a \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u043c\u0443 \u0434\u0440\u0443\u0433\u0443\n        candidate_friends |= friends[friend]  # \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0432\u0441\u0435\u0445 \u0434\u0440\u0443\u0437\u0435\u0439 \u0434\u0440\u0443\u0433\u0430 \u0432 \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e \u043f\u0440\u0435\u0434\u043f\u043e\u043b\u0430\u0433\u0430\u0435\u043c\u044b\u0445 \u0434\u0440\u0443\u0437\u0435\u0439\n    candidate_friends -= friends[person]  # \u0443\u0434\u0430\u043b\u044f\u0435\u043c \u0438\u0437 \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u0430 \u043f\u0440\u0435\u0434\u043f\u043e\u043b\u0430\u0433\u0430\u0435\u043c\u044b\u0445 \u0434\u0440\u0443\u0437\u0435\u0439 \u0443\u0436\u0435 \u0434\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u043d\u044b\u0445 \u0434\u0440\u0443\u0437\u0435\u0439\n    if candidate_friends: # \u0435\u0441\u043b\u0438 \u0435\u0441\u0442\u044c \u043f\u0440\u0435\u0434\u043f\u043e\u043b\u0430\u0433\u0430\u0435\u043c\u044b\u0435 \u0434\u0440\u0443\u0437\u044c\u044f, \u0432\u044b\u0432\u043e\u0434\u0438\u043c \u0438\u0445\n        print(person, \":\", len(candidate_friends), *sorted(candidate_friends))\n    else:  # \u0438\u043d\u0430\u0447\u0435 \u0432\u044b\u0432\u043e\u0434\u0438\u043c \u0442\u043e\u043b\u044c\u043a\u043e \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u0440\u0435\u0434\u043f\u043e\u043b\u0430\u0433\u0430\u0435\u043c\u044b\u0445 \u0434\u0440\u0443\u0437\u0435\u0439\n        print(person, \":\", 0)"
 ],
 "957": [
  "s = input()\nif \"heidi\" in s:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "958": [
  "n, k = map(int, input().split())\ns = input()\n\ndist = [min(ord(s[i]) - ord('a'), ord('z') - ord(s[i])) for i in range(n)]\ntotal_dist = sum(dist)\n\nif total_dist > k:\n    print(\"-1\")\nelse:\n    extra = k - total_dist\n    i = 0\n    while i < n and extra > 0:\n        d = min(extra, 25 - dist[i])\n        extra -= d\n        dist[i] += d\n        i += 1\n\n    s_prime = \"\"\n    for i in range(n):\n        if i % 2 == 0:\n            s_prime += chr(ord(s[i]) + dist[i])\n        else:\n            s_prime += chr(ord(s[i]) - dist[i])\n    print(s_prime)"
 ],
 "959": [
  "MOD = int(1e9) + 7\n\nn, m, mod = map(int, input().split())\na = [input() for _ in range(m)]\ncnt = [0] * n\n\nfor i in range(m):\n    for j in range(n):\n        cnt[j] += a[i][j] == '1'\n\nfor i in range(n):\n    if cnt[i] == 0:\n        cnt[i] = 2\nres = 1\nfor i in range(n):\n    if cnt[i] == 2:\n        res *= 2\n        res %= mod\n    elif cnt[i] == 1:\n        res *= 1\n        res %= mod\n    else:\n        res *= 1\n        for j in range(3, cnt[i] + 1):\n            res *= j\n            res %= mod\n        \nprint(res % mod)"
 ],
 "960": [
  "n,k=map(int,input().split())\nfor i in range(1,k+1):\n    if (n % i ==0) and (n // i < k):\n        print(i*k+(n//i))\n        break"
 ],
 "961": [
  "n=int(input())\na=list(map(int,input().split()))\n\ndict_pos={}\nfor i in range(n):\n    if a[i] not in dict_pos:\n        dict_pos[a[i]]=[i]\n    else:\n        dict_pos[a[i]].append(i)\n\ndp=[0]*n\n\nfor i in range(n):\n    distinct=[]\n\n    min_pos=i\n    max_pos=i\n\n    for j in range(i,-1,-1):\n        if a[j] not in distinct:\n            distinct.append(a[j])\n            min_pos=min(min_pos,dict_pos[a[j]][0])\n            max_pos=max(max_pos,dict_pos[a[j]][-1])\n\n        if j==0:\n            dp[i]=max(dp[i],dp[0]+(i-min_pos+1)^distinct[-1])\n        else:\n            dp[i]=max(dp[i],dp[j-1]+(max_pos-j+1)^distinct[-1])\n\nprint(dp[n-1])"
 ],
 "962": [
  "n, m = map(int, input().split())\ngraph = {i: [] for i in range(1, n+1)}\n\nfor i in range(m):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n\nans = []\nfor i in range(1, n+1):\n    if len(graph[i]) == 1:   # checking if in-degree of vertex is 1\n        out_node = graph[i][0]\n        if len(graph[out_node]) == 1:  # checking if out-degree of vertex is 1\n            ans.append(i)\n\nif ans:\n    print(len(ans))\n    for ele in ans:\n        print(ele)\nelse:\n    print(-1)"
 ],
 "963": [
  "mod = 998244353\n\nN, K = map(int, input().split())\n\nseg = []\nfor i in range(K):\n    l, r = map(int, input().split())\n    seg.append((l, r))\n\ndp = [0] * N\ndp[0] = 1\n\nfor i in range(1, N):\n    for l, r in seg:\n        if i - l >= 0:\n            dp[i] += dp[i - l] % mod\n        if i - r - 1 >= 0:\n            dp[i] -= dp[i - r - 1] % mod\n    dp[i] %= mod\n\nprint(dp[N - 1])"
 ],
 "964": [
  "x1, y1, x2, y2, x3, y3 = sorted(map(int, input().split()))\nif x1 + x2 + x3 == y1 == y2 == y3:\n    for n in range(x3, y1 + 1):\n        if n >= x1 + x2 and n >= y1 and n >= y2:\n            ans = [['A']*n for _ in range(n)]\n            for i in range(x1):\n                for j in range(n - y1, n):\n                    ans[i][j] = 'B'\n            for i in range(x2):\n                for j in range(n - y1 - y2, n - y1):\n                    ans[i + x1][j] = 'C'\n            for i in range(x3):\n                for j in range(n - y1):\n                    ans[i + x1 + x2][j] = 'A'\n            print(n)\n            print('\\n'.join(''.join(row) for row in ans))\n            break\n    else:\n        print(-1)\nelse:\n    print(-1)"
 ],
 "965": [
  "n=int(input())\nstatus=input()\nprint(status.count(\"A\")+(status.count(\"I\")==1))"
 ],
 "966": [
  "y = int(input())\nwhile True:\n    y += 1\n    if len(set(str(y))) == len(str(y)):\n        print(y)\n        break"
 ],
 "967": [
  "n = int(input())\na = list(map(int,input().split()))\n\nans = 0\nmax_seen = 0\n\nfor i in range(n-1,-1,-1):\n    if a[i] > max_seen:\n        max_seen = a[i]\n    elif a[i] < max_seen:\n        ans += 1\n\nprint(ans)"
 ],
 "968": [
  "n = int(input())\nnames = []\nfor i in range(n):\n    f, s = input().split()\n    names.append((f, s))\np = list(map(int, input().split()))\n\nhandles = []\nfor i in range(n):\n    f, s = names[i]\n    if p[i] <= n//2:\n        handles.append(f)\n    else:\n        handles.append(s)\n\nif sorted(handles) == handles:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "969": [
  "s = input().strip()\nt = input().strip()\nif not all(c in s for c in t):\n    print(-1)\nelse:\n    pieces = []\n    while t:\n        for i in range(len(s)):\n            if t.startswith(s[i:]):\n                pieces.append((i+1, i+len(t)))\n                t = s[:i] + t\n                if i:\n                    pieces[-1] = (i+1, i+len(t)-1, -1)\n                break\n    print(len(pieces))\n    for p in pieces[::-1]:\n        print(*p)"
 ],
 "970": [
  "n = int(input())\npieces = list(map(int, input().split()))\ntotal_moves = 0\n\nfor i in range(n//2):\n    if pieces[i] % 2 != i % 2:\n        total_moves += 1\n        \nprint(total_moves)"
 ],
 "971": [
  "n, b, d = map(int, input().split())\na = list(map(int, input().split()))\n\nwaste_section = 0\ntotal_juice = 0\n\nfor orange in a:\n    if orange <= b:\n        total_juice += orange\n        if total_juice > d:\n            waste_section += 1\n            total_juice = 0\n\nprint(waste_section)"
 ],
 "972": [
  "n, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\n\ndef check_convex():\n    black_cells = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'B':\n                black_cells.append((i, j))\n\n    if len(black_cells) == 1:\n        return True\n\n    for cell1 in black_cells:\n        for cell2 in black_cells:\n            if cell1 != cell2:\n                if not check_path(cell1, cell2):\n                    return False\n    return True\n\ndef check_path(cell1, cell2):\n    dx = cell2[0] - cell1[0]\n    dy = cell2[1] - cell1[1]\n\n    for cell in black_cells:\n        if (cell[0]-cell1[0])*dy == (cell[1]-cell1[1])*dx:\n            if (cell[0]-cell1[0])*dx >= 0 and (cell[1]-cell1[1])*dy >= 0:\n                return False\n    return True\n\nif check_convex():\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "973": [
  "R, C = map(int, input().split())\npasture = [input() for _ in range(R)]\ndogs = [['.' for _ in range(C)] for _ in range(R)]\n\nfor i in range(R):\n    for j in range(C):\n        if pasture[i][j] == 'S':\n            # check if sheep has a dog neighbor\n            has_dog = False\n            for r, c in [(i-1,j), (i+1,j), (i,j-1), (i,j+1)]:\n                if 0 <= r < R and 0 <= c < C and pasture[r][c] == 'D':\n                    has_dog = True\n                    break\n            if not has_dog:\n                print(\"No\")\n                exit()\n        elif pasture[i][j] == 'W':\n            # place dog around wolf to protect adjacent sheep\n            for r, c in [(i-1,j), (i+1,j), (i,j-1), (i,j+1)]:\n                if 0 <= r < R and 0 <= c < C and pasture[r][c] == '.':\n                    dogs[r][c] = 'D'\n        else:\n            dogs[i][j] = '.'\n\nprint(\"Yes\")\nprint('\\n'.join([''.join(row) for row in dogs]))"
 ],
 "974": [
  "n = int(input())\nstack = []\nremoved_count = 0\nreorder_count = 0\n\nfor _ in range(2*n):\n    op = input().split()\n    \n    if op[0] == \"add\":\n        stack.append(int(op[1]))\n    else:\n        removed_count += 1\n        if stack and stack[-1] == removed_count:\n            stack.pop()\n        else:\n            reorder_count += 1\n            stack = []\n\nprint(reorder_count)"
 ],
 "975": [
  "n = int(input())\ns = input()\nm = input()\n\n# Minimum possible flicks\nmin_flicks = 0\ntemp_m = list(m)\n\nfor d in s:\n    if d in temp_m:\n        temp_m.remove(d)\n    else:\n        min_flicks += 1\n\n# Maximum possible flicks\nmax_flicks = 0\ns = sorted(s)\ntemp_m = sorted(temp_m)\n\nwhile s and temp_m:\n    if s[0] < temp_m[0]:\n        max_flicks += 1\n        s.pop(0)\n        temp_m.pop(0)\n    else:\n        temp_m.pop(0)\n        s.pop(0)\n\nprint(min_flicks)\nprint(max_flicks)"
 ],
 "976": [
  "n, x = map(int, input().split())\nbest_moments = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    best_moments.append((l, r))\n\ncurrent_minute = 1\ntotal_minutes_watched = 0\nfor moment in best_moments:\n    while current_minute + x <= moment[0]:\n        current_minute += x\n    total_minutes_watched += (moment[1] - current_minute + 1)\n    current_minute = moment[1] + 1\n\nprint(total_minutes_watched)"
 ],
 "977": [
  "from math import factorial\n\nn, p = map(int,input().split())\na = sorted(list(map(int,input().split())))\nans = 0\nfor i in range(n):\n    if i > 0 and a[i] == a[i-1]:\n        continue\n    cnt = factorial(n-i-1)\n    for j in range(i,n):\n        if a[j]-a[i] > p:\n            break\n        else:\n            cnt //= (j-i+1)\n    ans += cnt\nprint(ans)\nfor x in range(1,n+1):\n    cnt = 0\n    for i in range(n):\n        if a[i] >= x:\n            cnt += 1\n        else:\n            cnt -= 1\n    if cnt == 0:\n        if factorial(n-x) % p != 0:\n            print(x,end=\" \")\n    elif cnt > 0:\n        if factorial(n-x)*(cnt+1) % p != 0:\n            print(x,end=\" \")\nprint()"
 ],
 "978": [
  "k = int(input())\npanel_table = [input() for _ in range(4)]\npanel_freq = [0] * 10\n\nfor i in range(4):\n    for j in range(4):\n        if panel_table[i][j] != '.':\n            panel_freq[int(panel_table[i][j])] += 1\n\nfor freq in panel_freq:\n    if freq > 2*k:\n        print('NO')\n        break\nelse:\n    print('YES')"
 ],
 "979": [
  "n, m = map(int, input().split())\na = sorted(list(map(int, input().split())))\nans = 1\nfor i in range(n):\n    for j in range(i+1, n):\n        ans *= abs(a[i] - a[j])\n        ans %= m\nprint(ans)"
 ],
 "980": [
  "from collections import defaultdict\n\nk, n = map(int, input().split())\nstrings = [input() for _ in range(k)]\n\n# Check if there exists a character swap that can make all strings identical\ndef check_swap(s1, s2):\n    diffs = []\n    for i in range(n):\n        if s1[i] != s2[i]:\n            diffs.append(i)\n            if len(diffs) > 2:\n                return None\n    if len(diffs) == 2:\n        return (diffs[0], diffs[1])\n    return None\n\n# Try all pairs of strings to find a character swap that can make them identical\nswap = None\nfor i in range(k):\n    for j in range(i+1, k):\n        curr_swap = check_swap(strings[i], strings[j])\n        if curr_swap is not None:\n            if swap is not None and swap != curr_swap:\n                print(-1)\n                exit()\n            swap = curr_swap\n\n# If no swap was found, the strings are already identical\nif swap is None:\n    print(strings[0])\nelse:\n    a, b = swap\n    s = list(strings[0])\n    s[a], s[b] = s[b], s[a] # Perform the character swap on the first string\n    # Check if the swap can make all strings identical\n    for i in range(1, k):\n        if strings[i] != ''.join(s):\n            print(-1)\n            exit()\n    print(''.join(s))"
 ],
 "981": [
  "v = int(input())\na = list(map(int, input().split()))\n\nmin_paint = min(a)\nif v < min_paint:\n    print(-1)\nelse:\n    max_digit = (v // min_paint)\n    remaining_paint = v - (min_paint * max_digit)\n\n    for i in range(9, 0, -1):\n        if a[i-1] - min_paint <= remaining_paint:\n            max_digit -= (remaining_paint // (a[i-1] - min_paint))\n            remaining_paint %= (a[i-1] - min_paint)\n        \n        if max_digit == 0:\n            break\n    \n    print('{}'.format(''.join(str(i) * max_digit for i in range(9, 0, -1)))))"
 ],
 "982": [
  "t = int(input())\nfor i in range(t):\n    l, r = map(int, input().split())\n    if l*2 > r:\n        print(\"NO\")\n    else:\n        print(\"YES\")"
 ],
 "983": [
  "n, p, q, r = map(int, input().split())\na = list(map(int, input().split()))\n\nmaxA = [a[0]]\nfor i in range(1, n):\n    maxA.append(max(maxA[i - 1], a[i]))\n\nminA = [a[-1]]\nfor i in range(n - 2, -1, -1):\n    minA.insert(0, min(minA[0], a[i]))\n\nmaxValue = float('-inf')\nfor i in range(n):\n    maxValue = max(maxValue, p * a[i] + q * maxA[i] + r * minA[i])\n\nprint(maxValue)"
 ],
 "984": [
  "n = int(input())\ntree = {}\nfound = set()\n\nfor i in range(1, n+1):\n    v, l, r = map(int, input().split())\n    tree[i] = (v, l, r)\n\ndef search(node, value):\n    if node == -1:\n        return False\n    v, l, r = tree[node]\n    if v == value:\n        return True\n    elif value < v:\n        return search(l, value)\n    else:\n        return search(r, value)\n\ndef traverse(node):\n    if node == -1:\n        return\n    v, l, r = tree[node]\n    traverse(l)\n    if v in found or not search(1, v):\n        found.add(v)\n    else:\n        global count\n        count += 1\n    traverse(r)\n\ncount = 0\ntraverse(1)\nprint(count)"
 ],
 "985": [
  "n = int(input())\nrow_count = [0]*1001\ncol_count = [0]*1001\ndiag1_count = [0]*2001\ndiag2_count = [0]*2001\nans = 0\nfor i in range(n):\n    x,y = map(int,input().split())\n    ans += row_count[x] + col_count[y] + diag1_count[x+y] + diag2_count[x-y+1000]\n    row_count[x] += 1\n    col_count[y] += 1\n    diag1_count[x+y] += 1\n    diag2_count[x-y+1000] += 1\nprint(ans)"
 ],
 "986": [
  "n, k = map(int, input().split())\nbooks_requested = list(map(int, input().split()))\nbooks_at_library = set()\ncost = 0\n\nfor book in books_requested:\n    if book not in books_at_library:\n        cost += 1\n        if len(books_at_library) < k:\n            books_at_library.add(book)\n        else:\n            books_to_remove = books_requested.index(max(books_at_library, key=lambda x: books_requested.index(x)))\n            books_at_library.remove(books_requested[books_to_remove])\n            books_at_library.add(book)\n\nprint(cost)"
 ],
 "987": [
  "n, m = map(int, input().split())\np = list(map(int, input().split()))\n\npar = [i for i in range(n+1)]\nrank = [0]*(n+1)\n\ndef find(x):\n    if par[x] != x:\n        par[x] = find(par[x])\n    return par[x]\n\ndef union(x, y):\n    px, py = find(x), find(y)\n    if px == py:\n        return\n    if rank[px] < rank[py]:\n        px, py = py, px\n    par[py] = px\n    if rank[px] == rank[py]:\n        rank[px] += 1\n\nfor _ in range(m):\n    u, v = map(int, input().split())\n    union(u, v)\n\ngroups = [[] for _ in range(n+1)]\nfor i in range(1, n+1):\n    groups[find(i)].append(i)\n\np_prime = [0]*n\nfor group in groups:\n    group_vals = sorted([p[i-1] for i in group], reverse=True)\n    for i, val in zip(group, group_vals):\n        p_prime[i-1] = val\n\nprint(*p_prime)"
 ],
 "988": [
  "row1 = input().strip()\nrow2 = input().strip()\nrow3 = input().strip()\nrow4 = input().strip()\nrow5 = input().strip()\nrow6 = input().strip()\n\nclassroom = [row1,row2,row3,row4,row5,row6]\n\nmax_convenience = -1\nmax_convenience_coords = []\n\n# Determine max convenience\nfor i in range(6):\n    for j in range(2,6):\n        if classroom[i][j] == '.':\n            # Calculate convenience score\n            convenience = 0\n            if i == 0:\n                convenience += 3\n            elif i == 1:\n                convenience += 2\n            elif i == 4:\n                convenience += 2\n            elif i == 5:\n                convenience += 3\n            if j == 2 or j == 5:\n                convenience += 1\n            if convenience > max_convenience:\n                max_convenience = convenience\n                max_convenience_coords = [(i,j)]\n            elif convenience == max_convenience:\n                max_convenience_coords.append((i,j))\n\n# Update classroom with Petya's desk\nrow, col = max_convenience_coords[0]\nnew_row = classroom[row][:col] + 'P' + classroom[row][col+1:]\nclassroom[row] = new_row\n\n# Print updated classroom\nfor row in classroom:\n    print(row)"
 ],
 "989": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\ni, j = 0, n-1\nwhile k>0 and i<j:\n    if i<n-j:\n        x = min(k//(i+1),a[i+1]-a[i])\n        if x==0:\n            break\n        a[i] += x\n        k -= x*(i+1)\n        i += 1\n    else:\n        x = min(k//(n-j),a[j]-a[j-1])\n        if x==0:\n            break\n        a[j] -= x\n        k -= x*(n-j)\n        j -= 1\nprint(a[j]-a[i])"
 ],
 "990": [
  "from itertools import product\n\nn = int(input())\nedges = [list(map(int, input().split())) for _ in range(n-1)]\nm = int(input())\ncond = [list(map(int, input().split())) for _ in range(m)]\n\nans = 0\nfor paint in product([0,1], repeat=n-1):\n    valid = True\n    for u, v in cond:\n        u, v = u-1, v-1\n        if not paint[u:v]:\n            valid = False\n            break\n    if valid:\n        ans += 1\n\nprint(ans)"
 ],
 "991": [
  "from heapq import heappush, heappop\n\nN, M, S = map(int, input().split())\nedges = [[] for _ in range(N)]\nfor i in range(M):\n    u, v, a, b = map(int, input().split())\n    u -= 1\n    v -= 1\n    edges[u].append((v, a, b))\n    edges[v].append((u, a, b))\n\nC = []\nD = []\nfor i in range(N):\n    c, d = map(int, input().split())\n    C.append(c)\n    D.append(d)\n\n# Perform Dijkstra's algorithm on the graph.\n# Instead of tracking minimum distance, track minimum time\ninf = float('inf')\ndist = [inf for _ in range(N)]\ndist[0] = 0\npq = [(0, 0, S)]\nwhile pq:\n    t, u, s = heappop(pq)\n    if t > dist[u]:\n        continue\n    for v, a, b in edges[u]:\n        # Check if we can afford the fare\n        if s < a:\n            continue\n        # Calculate time to take this edge\n        nt = t + b\n        # Calculate silver coins left after taking this edge\n        ns = s - a\n        # Exchange gold coins if needed\n        ns = min(C[v], ns + D[v])\n        # Check if we improved the time to reach v\n        if nt < dist[v]:\n            dist[v] = nt\n            heappush(pq, (nt, v, ns))\n\n# Output the results\nfor i in range(1, N):\n    print(dist[i])"
 ],
 "992": [
  "MOD = 998244353\nn, s = map(int, input().split())\na = list(map(int, input().split()))\ndp = [0] * (s + 1)\ndp[0] = 1\nfor x in a:\n    for i in range(s, x - 1, -1):\n        dp[i] = (dp[i] * 2 + dp[i - x]) % MOD\nprint(dp[s])"
 ],
 "993": [
  "N, M = map(int, input().split())\nA = list(map(int, input().split()))\nsums = [0] * (N + 1)\nfor i in range(N):\n    sums[i+1] = sums[i] + A[i]\nmods = {}\nfor s in sums:\n    m = s % M\n    if m in mods:\n        mods[m] += 1\n    else:\n        mods[m] = 1\nans = 0\nfor mod, cnt in mods.items():\n    ans += cnt * (cnt - 1) // 2\nprint(ans)"
 ],
 "994": [
  "n, m = map(int, input().split())\nnotes = [list(map(int, input().split())) for _ in range(m)]\n\nleft, right = [0] * (n + 2), [0] * (n + 2)\nfor i in range(1, m):\n    d1, h1 = notes[i-1]\n    d2, h2 = notes[i]\n    diff = h2 - h1\n    left[d1+1] += diff\n    right[d2] += diff\n\nans = [0] * (n + 1)\nheight = 0\nfor i in range(1, n+1):\n    height += left[i]\n    ans[i] = height\n    height -= right[i+1]\n\nfor i in range(1, m+1):\n    d, h = notes[i-1]\n    if ans[d] != h:\n        print(\"IMPOSSIBLE\")\n        break\nelse:\n    print(max(ans))"
 ],
 "995": [
  "from collections import defaultdict\nn = int(input())\na = list(map(int, input().split()))\nfreq = defaultdict(int)\nfor i in range(n):\n    for j in range(i, n):\n        prod = 1\n        for k in range(i, j+1):\n            prod *= a[k] \n        sqrt_prod = int(prod**0.5)\n        if sqrt_prod**2 == prod:\n            freq[j-i+1] += 1\nfor k in range(1, n+1):\n    print(freq[k])"
 ],
 "996": [
  "n,m,k = map(int, input().split())\nstate = []\nfor i in range(n):\n    temp = []\n    input()  # to ignore empty line between blocks\n    for j in range(m):\n        temp.append(list(input().strip()))\n    state.append(temp)\n\ncritical_cnt = 0\nfor i in range(n):\n    for j in range(m):\n        for q in range(k):\n            if state[i][j][q] == '1':\n                cnt = 0\n                if i+1 < n and state[i+1][j][q] == '1':   # checking x+1\n                    cnt += 1\n                if j+1 < m and state[i][j+1][q] == '1':   # checking y+1\n                    cnt += 1\n                if q+1 < k and state[i][j][q+1] == '1':   # checking z+1\n                    cnt += 1\n                \n                if cnt == 1:   # the current cell has only one connection to other working cell\n                    critical_cnt += 1\n\nprint(critical_cnt)"
 ],
 "997": [
  "import re\n\ns = input().strip()\n\nints = re.findall(r'\\b(?:0|[1-9]\\d*)\\b', s)\na = ','.join(num for num in ints if not num.startswith('0'))\nb = re.sub(r'[;,]+', ',', s)\nb = re.sub(r'\\b(?:0|[1-9]\\d*)\\b', '', b)\n\nprint(f'\"{a}\"' if a else '-')\nprint(f'\"{b}\"' if b else '-')"
 ],
 "998": [
  "n, x = map(int, input().split())\n\nif n == 1 and x == 1:\n    print(0)\nelse:\n    print(2**n - 1)\n    ans = []\n    for i in range(1, 2**n):\n        ans.append(i^(i>>1))\n    if x in ans:\n        ans.remove(x)\n        if n > 2:\n            ans[0], ans[1] = ans[1], ans[0]\n    print(*ans)"
 ],
 "999": [
  "n = int(input())\nchess_periods = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    chess_periods.append((l, r))\nm = int(input())\nprog_periods = []\nfor i in range(m):\n    l, r = map(int, input().split())\n    prog_periods.append((l, r))\n\nchess_periods.sort()\nprog_periods.sort()\n\nmax_distance = 0\ni = 0\nfor j in range(m):\n    while i < n - 1 and chess_periods[i+1][1] < prog_periods[j][0]:\n        i += 1\n    max_distance = max(max_distance, min(prog_periods[j][1], chess_periods[i][1]) - max(prog_periods[j][0], chess_periods[i][0]))\ni = 0\nfor j in range(n):\n    while i < m - 1 and prog_periods[i+1][1] < chess_periods[j][0]:\n        i += 1\n    max_distance = max(max_distance, min(prog_periods[i][1], chess_periods[j][1]) - max(prog_periods[i][0], chess_periods[j][0]))\n\nprint(max_distance)"
 ]
}