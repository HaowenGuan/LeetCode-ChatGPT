{
 "1500": [
  "n, k = map(int, input().split())\nx = list(map(int, input().split()))\n\nif x[-1] - x[0] <= k:\n    print(1)\nelse:\n    bikes_needed = 1\n    dist_covered = 0\n    last_bike_loc = x[0]\n    for i in range(1, n):\n        if x[i] - last_bike_loc > k:\n            bikes_needed += 1\n            dist_covered = 0\n            last_bike_loc = x[i-1]\n        else:\n            dist_covered = x[i] - x[i-1]\n\n    if x[-1] - last_bike_loc > k:\n        print(-1)\n    else:\n        print(bikes_needed)"
 ],
 "1501": [
  "MOD = 10**9 + 7\n\nn,m = map(int, input().split())\np = input()\nm_values = sorted(map(int, input().split()))\nk = len(m_values)\n\n# calculate lengths of gaps between m_values\ngaps = []\nif k>0 and m_values[0] > 1:\n    gaps.append(m_values[0]-1)\nfor i in range(k-1):\n    gaps.append(m_values[i+1]-m_values[i]-len(p))\nif k>0 and m_values[-1]+len(p)<=n:\n    gaps.append(n-m_values[-1]-len(p)+1)\n\n# calculate number of possible s for each gap\nans = 1\nfor gap in gaps:\n    ans *= pow(26, gap, MOD)\n    ans %= MOD\n\nprint(ans)"
 ],
 "1502": [
  "a = int(input())\nprint((1 << a) ^ (1 << 16) - 1)"
 ],
 "1503": [
  "from collections import Counter\nn, m = map(int, input().split())\ns = [Counter(input().split()) for _ in range(m)]\nmid = m // 2\na = s[mid]\nans = 0\nfor i in range(mid):\n    t = s[i]\n    for k in t.keys():\n        if k in a:\n            ans += 1\n            break\nfor i in range(mid + 1, m):\n    t = s[i]\n    for k in t.keys():\n        if k in a:\n            ans += 1\n            break\nprint(ans + len(a))"
 ],
 "1504": [
  "# brute force approach\nfor _ in range(int(input())):\n    n, k = map(int, input().split())\n    l1, r1 = map(int, input().split())\n    l2, r2 = map(int, input().split())\n    ans = float('inf')\n    for i in range(n + 1):  # let's try all possible intersections lengths\n        a_left = max(l1 - i, l2 - (n - i))\n        b_left = max(l2 - (n - i), l1 - i)\n        a_right = min(r1, r2) - max(l1, l2) + i  # calculate leftmost pos\n        b_right = min(r2, r1) - max(l1, l2) + n - i  # calculate rightmost pos\n        intersection = max(0, a_right - a_left + 1) + max(0, b_right - b_left + 1)\n        if intersection >= k:\n            ans = i * a_left + (n - i) * b_left\n            break\n    print(ans)"
 ],
 "1505": [
  "from math import sqrt\n\npx, py, vx, vy, a, b, c, d = map(int, input().split())\n\nlen_v = sqrt(vx**2 + vy**2)\nvx, vy = vx/len_v, vy/len_v\n\ntip_x, tip_y = px + a*vx, py + a*vy\nleft_x, left_y = px + c*vy, py - c*vx\nright_x, right_y = px - c*vy, py + c*vx\n\nprint(\"{:.12f} {:.12f}\".format(tip_x, tip_y))\nprint(\"{:.12f} {:.12f}\".format(left_x+b*vx, left_y+b*vy))\nprint(\"{:.12f} {:.12f}\".format(left_x-b*vx, left_y-b*vy))\nprint(\"{:.12f} {:.12f}\".format(right_x-b*vx, right_y-b*vy))\nprint(\"{:.12f} {:.12f}\".format(right_x+b*vx, right_y+b*vy))\nprint(\"{:.12f} {:.12f}\".format(px+d*vy, py-d*vx))\nprint(\"{:.12f} {:.12f}\".format(px-d*vy, py+d*vx))"
 ],
 "1506": [
  "MOD = 10**9 + 7\nn = int(input().strip())\na = list(map(int, input().strip().split()))\n\nfactorial = [1]\nfor i in range(1, n+1):\n    factorial.append(factorial[-1] * i % MOD)\n\na_sorted = sorted(enumerate(a), key=lambda x: x[1], reverse=True)\n\nans = 0\nmax_idx = a_sorted[0][0]\nfor i in range(1, n):\n    if a_sorted[i][0] > max_idx:\n        ans = (ans + a[max_idx] * factorial[n-1-i]) % MOD\n        max_idx = a_sorted[i][0]\n\nprint(ans)"
 ],
 "1507": [
  "n, k = map(int, input().split())\nguests = input()\n\ndoor_counts = {}\n\nfor door in guests:\n    if door not in door_counts:\n        door_counts[door] = 0\n    door_counts[door] += 1\n    if door_counts[door] > k:\n        print(\"YES\")\n        break\nelse:\n    print(\"NO\")"
 ],
 "1508": [
  "n = int(input())\na = list(map(int, input().split()))\na.sort(reverse=True)\nb = [0] * n\nif n % 2 == 0:\n    half = n // 2\nelse:\n    half = n // 2 + 1\nb[0::2] = a[half:]\nb[1::2] = a[:half][::-1]\nprint(*b)"
 ],
 "1509": [
  "n = int(input())\na = list(map(int, input().split()))\nans = 0\nfor l in range(1,n+1):\n    r = l\n    while r <= n and a[r-1] >= l:\n        r += 1\n    r -= 1\n    ans += (r-l+1)*(r-l+2)//2\nprint(ans)"
 ],
 "1510": [
  "n, m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\na.sort()\nb.sort(reverse=True)\ncount = 0\ni, j = 0, 0\nwhile i < n and j < m:\n    if a[i] < b[j]:\n        count += b[j] - a[i]\n        i += 1\n    else:\n        j += 1\nprint(count)"
 ],
 "1511": [
  "n, m, k = map(int, input().split())\ncores = []\nfor i in range(n):\n    cores.append(list(map(int, input().split())))\n    \nlocked = [0]*n\nmem_lock = [False]*(k+1)\n\nfor j in range(m):\n    for i in range(n):\n        if not locked[i]:\n            if cores[i][j]!=0:\n                if not mem_lock[cores[i][j]]:\n                    mem_lock[cores[i][j]] = True\n                else:\n                    locked[i] = j+1\n    for i in range(n):\n        if not locked[i]:\n            if cores[i][j]!=0:\n                mem_lock[cores[i][j]] = False\n                \nfor i in range(n):\n    print(locked[i])"
 ],
 "1512": [
  "n = int(input())\np = list(map(int, input().split()))\n\nif n <= 2:\n    print(p[0])\nelse:\n    cnt = [0] * n\n    for i in range(n):\n        if i == 0:\n            if p[i] > p[i+1]:\n                cnt[i] += 1\n        elif i == n-1:\n            if p[i] > p[i-1]:\n                cnt[i] += 1\n        else:\n            if p[i] > p[i-1]:\n                cnt[i] += 1\n            if p[i] > p[i+1]:\n                cnt[i] += 1\n\n    max_cnt = max(cnt)\n    max_pos = cnt.index(max_cnt)\n\n    if max_pos == 0:\n        if p[max_pos] < p[max_pos+1]:\n            print(p[max_pos])\n        else:\n            print(p[max_pos+1])\n    elif max_pos == n-1:\n        if p[max_pos] < p[max_pos-1]:\n            print(p[max_pos])\n        else:\n            print(p[max_pos-1])\n    elif p[max_pos] < p[max_pos-1]:\n        print(p[max_pos])\n    elif p[max_pos] < p[max_pos+1]:\n        print(p[max_pos])\n    else:\n        print(p[max_pos+1])"
 ],
 "1513": [
  "n, m, k = map(int, input().split())\nbroken = list(map(int, input().split()))\n\ngaps = []\nfor i in range(1,n):\n    gaps.append(broken[i]-broken[i-1]-1)\n\ngaps.sort(reverse=True)\n\nans = n\nfor i in range(k-1):\n    ans += gaps[i]\n\nprint(ans)"
 ],
 "1514": [
  "from collections import defaultdict\n\nn = int(input())\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\n\n# Check for invalid input\nif b[0] != c[-1] or b[-1] != c[0]:\n    print(\"-1\")\nelse:\n    # Create the graph\n    graph = defaultdict(list)\n    for i in range(n-2):\n        graph[b[i]].append(c[i])\n        graph[c[i]].append(b[i])\n    # Perform dfs to find the array a\n    visited = [False] * (n+1)\n    a = [0] * n\n    def dfs(node, prev):\n        nonlocal a\n        a[node-1] = c[prev-b.index(node)] if node in b else b[prev-c.index(node)]\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, b.index(node) if node in b else c.index(node))\n    dfs(b[0], -1)\n    if visited.count(True) != n:\n        print(\"-1\")\n    else:\n        print(\" \".join(str(x) for x in a))"
 ],
 "1515": [
  "p, x = map(int, input().split())\n\nfor i in range(1, 10):\n    n = i\n    k = p-1\n    \n    while k > 0:\n        if (n*x) % 10 == i:\n            n = (n*x) // 10\n            k -= 1\n        else:\n            break\n    \n    if k == 0 and (n*x) % 10 == i and len(str(n)) == p:\n        print(n)\n        break\nelse:\n    print(\"Impossible\")"
 ],
 "1516": [
  "MOD = 998244353\n\nn = int(input())\na = list(map(int, input().split()))\n\nans = 0\nfor d in range(len(str(a[0]))):\n    cnt = {str(i): 0 for i in range(10)}\n    for x in a:\n        s = str(x)[~d]\n        cnt[s] += 1\n    # calculate contribution of current digit position to the answer\n    curr = 0\n    for i in range(10):\n        for j in range(10):\n            curr += cnt[str(i)] * cnt[str(j)] * (i + j) * pow(10, d, MOD)\n    ans = (ans + curr) % MOD\n\nprint(ans)"
 ],
 "1517": [
  "n = int(input())\n\nfact = [1]*(n+1)\nfor i in range(1, n+1):\n    fact[i] = (i*fact[i-1])%mod\n\nmod = 1000000007\n\ndp = [[0]*((1<<n)+1) for _ in range(n+1)]\ndp[0][0] = 1\n\nfor i in range(1, n+1):\n    for j in range(1<<n):\n        cnt = 0\n        for k in range(n):\n            if (j>>k) & 1:\n                cnt += 1\n        for k in range(n):\n            if (j>>k) & 1:\n                dp[i][j] = (dp[i][j] + dp[i-1][j^(1<<k)]*fact[cnt-1]*fact[n-cnt])%mod\n\nans = 0\nfor i in range(1<<n):\n    cnt = 0\n    for j in range(n):\n        if (i>>j) & 1:\n            cnt += 1\n    if cnt%2 == 0:\n        ans = (ans + dp[n][i]*dp[n][(1<<n)-1-i])%mod\n    else:\n        ans = (ans - dp[n][i]*dp[n][(1<<n)-1-i])%mod\n\nprint((ans+mod)%mod)"
 ],
 "1518": [
  "n=int(input())\na=list(map(int,input().split()))\nb=sorted(a)\nd={x:i for i,x in enumerate(a)}\nans=[]\nfor i in range(n):\n    while a[i]!=b[i]:\n        t=d[b[i]]\n        if (t-i+1)%2:\n            for j in range(i+1,t+1):\n                if (t-j)%2:\n                    ans.append((i+1,j+1))\n                    d[a[i]],d[a[j]]=d[a[j]],d[a[i]]\n                    a[i],a[j]=a[j],a[i]\n                    break\n        else:\n            for j in range(i+1,t+1):\n                if (t-j)%2==0:\n                    ans.append((i+1,j+1))\n                    d[a[i]],d[a[j]]=d[a[j]],d[a[i]]\n                    a[i],a[j]=a[j],a[i]\n                    break\nprint(len(ans))\nfor i in ans:\n    print(*i)"
 ],
 "1519": [
  "n, L, a = map(int, input().split())\ntotal_breaks = 0\nlast_end_time = 0\n\nfor i in range(n):\n    t, l = map(int, input().split())\n    # calculate the time Vasya will finish serving this customer\n    end_time = t + l\n    # calculate the time Vasya can take a break after serving this customer\n    break_time = t - last_end_time\n    # add the number of breaks Vasya can take between serving this customer and the previous one\n    total_breaks += break_time // a\n    # update the last end time with the end time of the current customer\n    last_end_time = end_time\n\n# calculate the time Vasya can take a break after serving the last customer\nbreak_time = L - last_end_time\n# add the number of breaks Vasya can take between serving the last customer and the end of the day\ntotal_breaks += break_time // a\n\nprint(total_breaks)"
 ],
 "1520": [
  "n = int(input())\nstrings = []\nfor _ in range(n):\n    strings.append(input())\n\nbeauty = 1\ncur_len = 1\nfor i in range(1, len(strings[0])):\n    if strings[0][i] == strings[0][i-1]:\n        cur_len += 1\n    else:\n        beauty = max(beauty, cur_len)\n        cur_len = 1\nbeauty = max(beauty, cur_len)\n\nfor i in range(1, n):\n    res = \"\"\n    for j in strings[i]:\n        res += j*len(strings[0]) + strings[0]\n    strings[0] = res\n    \n    cur_len = 1\n    for j in range(1, len(strings[0])):\n        if strings[0][j] == strings[0][j-1]:\n            cur_len += 1\n        else:\n            beauty = max(beauty, cur_len)\n            cur_len = 1\n    beauty = max(beauty, cur_len)\n\nprint(beauty)"
 ],
 "1521": [
  "p, n = map(int, input().split())\nbuckets = set()\n\nfor i in range(n):\n    x = int(input())\n    if x % p in buckets:\n        print(i+1)\n        break\n    else:\n        buckets.add(x % p)\nelse:\n    print(-1)"
 ],
 "1522": [
  "n = int(input())\ns = input()\n\nkeys = {}\nfor i in range(0, len(s), 2):\n    door = s[i+1]\n    key = s[i].lower()\n    if key in keys:\n        keys[key].append(door)\n    else:\n        keys[key] = [door]\n\ncurrent_keys = [s[0].lower()]\nmissing_keys = []\nfor door in range(1, len(s), 2):\n    required_key = s[door].lower()\n    if required_key in current_keys:\n        current_keys.extend(keys[required_key])\n    else:\n        missing_keys.append(required_key)\n\nprint(len(missing_keys))"
 ],
 "1523": [
  "n,k = map(int,input().split())\njobs = list(map(int,input().split()))\ntime = list(map(int, input().split()))\n\nassigned_jobs = {}\nfor i in range(n):\n    if jobs[i] in assigned_jobs:\n        assigned_jobs[jobs[i]].append(time[i])\n    else:\n        assigned_jobs[jobs[i]] = [time[i]]\n\nidle_workers = []\nfor i in range(1, k+1):\n    if i not in assigned_jobs:\n        idle_workers.append(0)\n    else:\n        assigned_jobs[i].sort()\n        idle_workers.append(sum(assigned_jobs[i][1:]))\n        \nidle_workers.sort()\nprint(sum(idle_workers))"
 ],
 "1524": [
  "s = input().strip()\n\n# Initialize an array to store the number of children on each square\n# Initially, there is one child on each square\nnum_children = [1] * len(s)\n\n# For each move, update the number of children on each square according to the\n# direction of the current square\nfor i in range(10**100):\n    new_num_children = [0] * len(s)\n    for j in range(len(s)):\n        if s[j] == \"R\":\n            new_num_children[j+1] += num_children[j]\n        else:\n            new_num_children[j-1] += num_children[j]\n    num_children = new_num_children\n\n# Print the final number of children on each square\nfor num in num_children:\n    print(num, end=\" \")"
 ],
 "1525": [
  "MOD = 10**9+7\nh, w, k = map(int, input().split())\ndp = [[0]*w for _ in range(h+1)]\ndp[0][0] = 1\n\nfor i in range(h):\n    for j in range(w):\n        for bit in range(1<<(w-1)):\n            ok = True\n            # Check no two adjacent horizontal lines\n            for l in range(w-2):\n                if (bit>>l) & 1 and (bit>>(l+1)) & 1:\n                    ok = False\n            if ok:\n                # Check the path from the top to the bottom of the Kth vertical line\n                if j > 0 and (bit>>(j-1)) & 1:\n                    dp[i+1][j-1] += dp[i][j]\n                    dp[i+1][j-1] %= MOD\n                elif j < w-1 and (bit>>j) & 1:\n                    dp[i+1][j+1] += dp[i][j]\n                    dp[i+1][j+1] %= MOD\n                else:\n                    dp[i+1][j] += dp[i][j]\n                    dp[i+1][j] %= MOD\n\nprint(dp[h][k-1])"
 ],
 "1526": [
  "a, b, c = map(int, input().split())\nmax_num = max(a, b, c)\nsum_num = sum((max_num-a, max_num-b, max_num-c))\nif sum_num % 2 == 0:\n    ans = sum_num // 2\nelse:\n    ans = (sum_num + 3) // 2\nprint(int(ans))"
 ],
 "1527": [
  "h, w = map(int, input().split())\nS = [input() for _ in range(h)]\n\nmax_dist = -1\nfor i in range(h):\n    for j in range(w):\n        if S[i][j] == '.':\n            dist = [[-1]*w for _ in range(h)]\n            dist[i][j] = 0\n            \n            que = [(i, j)]\n            while que:\n                x, y = que.pop(0)\n                for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                    nx, ny = x+dx, y+dy\n                    if not (0 <= nx < h and 0 <= ny < w):\n                        continue\n                    if S[nx][ny] == '#':\n                        continue\n                    if dist[nx][ny] == -1:\n                        dist[nx][ny] = dist[x][y] + 1\n                        que.append((nx, ny))\n            \n            max_dist = max(max_dist, max([max(d) for d in dist]))\n            \nprint(max_dist)"
 ],
 "1528": [
  "n, x = map(int, input().split())\nans = 0\nfor i in range(n+1):\n    if x % 2 == 1:\n        ans += 2**i\n    x //= 2\nprint(ans)"
 ],
 "1529": [
  "n=int(input())\nfor i in range(n):\n    s=input()\n    if s.startswith(\"miao.\") and s.endswith(\"lala.\"):\n        print(\"OMG>.< I don't know!\")\n    elif s.endswith(\"lala.\"):\n        print(\"Freda's\")\n    elif s.startswith(\"miao.\"):\n        print(\"Rainbow's\")\n    else:\n        print(\"OMG>.< I don't know!\")"
 ],
 "1530": [
  "from collections import defaultdict\n\nn = int(input())\narr = list(map(int, input().split()))\ntree = defaultdict(int)\n\nfor i in range(1, n):\n    curr = arr[i]\n    node = arr[0]\n    while True:\n        if curr < node:\n            if tree[node]['left'] == 0:\n                tree[node]['left'] = curr\n                break\n            else:\n                node = tree[node]['left']\n        else:\n            if tree[node]['right'] == 0:\n                tree[node]['right'] = curr\n                break\n            else:\n                node = tree[node]['right']\n\nfor i in range(1, n):\n    curr = arr[i]\n    node = arr[0]\n    while True:\n        if curr < node:\n            node = tree[node]['left']\n        else:\n            node = tree[node]['right']\n        if node == curr:\n            print(curr, end=' ')\n            break\n        elif (curr < node and tree[node]['left'] == 0) or (curr > node and tree[node]['right'] == 0):\n            print(node, end=' ')\n            break"
 ],
 "1531": [
  "n = int(input())\na = list(map(int, input().split()))\n\nfreq = {}\nfor i in range(n):\n    if a[i] in freq:\n        freq[a[i]].append(i+1)\n    else:\n        freq[a[i]] = [i+1]\nmaxi = max(freq.keys(), key=lambda x: len(freq[x]))\n\ncutTrees = []\nfor i in range(n-1, -1, -1):\n    if a[i] != maxi:\n        cutTrees.append(i)\n    else:\n        break\n\nfor i in range(len(cutTrees)):\n    a.pop(cutTrees[i])\n\nfreq.clear()\nfor i in range(len(a)):\n    if a[i] in freq:\n        freq[a[i]].append(i+1)\n    else:\n        freq[a[i]] = [i+1]\n\nmaxi1 = max(freq.keys(), key=lambda x: len(freq[x]))\n\nfor i in range(n-2, -1, -1):\n    if a[i] != maxi1:\n        cutTrees.append(i)\n    else:\n        cutTrees.append(i+2)\n        break\n\ncutTrees.sort()\n\nremovedElastic = sum([a[x] for x in cutTrees])\n_trees = [str(x+1) for x in cutTrees]\nprint(f\"{sum(a)-removedElastic} {len(cutTrees)}\")\nprint(\" \".join(_trees))"
 ],
 "1532": [
  "from math import gcd\n\nn = int(input())\nans = [0] * (n-1)\n\nfor i in range(2, n+1):\n    if ans[i-2] == 0:\n        for j in range(i, n+1, i):\n            if ans[i-2] == 0:\n                ans[i-2] = j\n            else:\n                ans[i-2] = gcd(ans[i-2], j)\n    print(ans[i-2], end=\" \")"
 ],
 "1533": [
  "n = int(input())\nnames = []\nencountered = set()\nfor i in range(n):\n    name = input()\n    names.append(name)\n    if name in encountered:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n    encountered.add(name)"
 ],
 "1534": [
  "s = input()  # read the input string\n\n# find the longest substring of \"a\" before the first \"b\" (if any)\nfirst_a = s.find('a')\nif first_a == -1:\n    print(0)\n    exit()\nlast_a = s.rfind('a')\nmiddle_b = s[first_a:last_a+1].find('b')\nif middle_b == -1:\n    print(len(s))\nelse:\n    print(middle_b + 1)"
 ],
 "1535": [
  "n, x0, y0 = map(int, input().split())\nshots = set()\nfor i in range(n):\n    x, y = map(int, input().split())\n    if x == x0:\n        shots.add(float('inf'))\n    else:\n        shots.add((y - y0) / (x - x0))\nprint(len(shots))"
 ],
 "1536": [
  "from itertools import combinations\n\nn = int(input())\npts = []\nfor i in range(n):\n    pts.append(list(map(int, input().split())) + [i+1])\n\npairs = []\nfor _ in range(n//2):\n    mbb = [0, 0, 0, 0, 0, 0]\n    for c in combinations(pts, 2):\n        bounds = [max(c[0][j], c[1][j]) - min(c[0][j], c[1][j]) for j in range(3)]\n        vol = bounds[0] * bounds[1] * bounds[2]\n        if vol > mbb[-1]:\n            mbb = c[0] + c[1] + [vol]\n    pairs.append([mbb[-2], mbb[-1]])\n    pts.remove(mbb[:3])\n    pts.remove(mbb[3:6])\n\nfor p in pairs:\n    print(p[0], p[1])"
 ],
 "1537": [
  "n, k = map(int, input().split())\n\ngrid = []\nfor i in range(n):\n    grid.append(input())\n\nrows = [0] * n\ncols = [0] * n\nfor i in range(n):\n    for j in range(n):\n        if grid[i][j] == 'B':\n            rows[i] += 1\n            cols[j] += 1\n\nmax_lines = 0\nfor i in range(n-k+1):\n    for j in range(n-k+1):\n        lines = rows[:i] + rows[i+k:] + cols[:j] + cols[j+k:]\n        max_lines = max(max_lines, lines.count(0))\n\nprint(max_lines)"
 ],
 "1538": [
  "n = int(input())\na = list(map(int, input().split()))\na.sort(reverse=True)\n\nans = 1\nfor i in range(1, n):\n    if a[i] < a[i-1]:\n        ans += 1\n\nprint(ans)"
 ],
 "1539": [
  "n = int(input())\nlegs = list(map(int, input().split()))\nenergy = list(map(int, input().split()))\n\nmaxleg = max(legs)\ncountMaxleg = legs.count(maxleg)\nif countMaxleg >= n//2:\n    print(0)\nelse:\n    oddEnergy = []\n    evenEnergy = []\n    for i in range(n):\n        if legs[i] == maxleg:\n            if i%2 == 0:\n                evenEnergy.append(energy[i])\n            else:\n                oddEnergy.append(energy[i])\n    evenEnergy.sort()\n    oddEnergy.sort()\n    minEnergy = sum(evenEnergy)\n    remain = countMaxleg - (n+1)//2\n    if remain > 0:\n        for i in range(remain):\n            minEnergy += oddEnergy[i]\n    print(minEnergy)"
 ],
 "1540": [
  "n, m, k = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\nmsg_counts = [0] * n\nfor _ in range(k):\n    x, y = map(int, input().split())\n    for i in range(n):\n        if a[i][y-1] and i+1 != x:\n            msg_counts[i] += 1\nprint(*msg_counts)"
 ],
 "1541": [
  "s = input()\nw_left = 0 #total weight on the left side of pivot\nw_right = 0 #total weight on the right side of pivot\np = s.index('^') #index of the pivot in the string\nfor i in range(p):\n    if s[i] != '=': #if there is a weight at this point\n        w_left += int(s[i]) * (p - i) #calculate torque due to weight\nfor i in range(p + 1, len(s)):\n    if s[i] != '=': #if there is a weight at this point\n        w_right += int(s[i]) * (i - p) #calculate torque due to weight\nif w_left == w_right: #if torques are equal, the bar is in balance\n    print('balance')\nelif w_left > w_right:\n    print('left')\nelse:\n    print('right')"
 ],
 "1542": [
  "n = int(input())\nprices = list(map(int, input().split()))\nq = int(input())\n\n# Sort the prices in non-descending order\nprices.sort()\n\n# Calculate the prefix sum of prices to avoid recomputing it for each query\nprefix_sum = [prices[0]]\nfor i in range(1, n):\n    prefix_sum.append(prefix_sum[-1] + prices[i])\n\nfor i in range(q):\n    m = int(input())\n\n    # Binary search to find the leftmost index j such that prices[j] > m\n    # Then the number of shops where Vasiliy can buy a drink is j\n    # If no such index j exists, that means Vasiliy can buy a drink in all n shops\n    left, right = 0, n-1\n    while left <= right:\n        mid = (left + right) // 2\n        if prices[mid] > m:\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    if left == 0:\n        print(n)\n    elif left == n:\n        print(0)\n    else:\n        print(left)"
 ],
 "1543": [
  "n = int(input())\ncities = []\nfor i in range(n):\n    x, c = input().split()\n    cities.append((int(x), c))\n\ndist_b = 0\ndist_r = 0\ndist_p = 0\n\np_index = -1\nfor i in range(n):\n    if cities[i][1] == 'B':\n        dist_b += abs(cities[i][0] - cities[p_index][0]) if p_index != -1 else 0\n        p_index = i\n    elif cities[i][1] == 'P':\n        dist_p += abs(cities[i][0] - cities[p_index][0])\n    else:\n        dist_r += abs(cities[i][0] - cities[p_index][0]) if p_index != -1 else 0\n        p_index = i\n\nif p_index < n-1:\n    if cities[p_index][1] == 'B':\n        dist_b += cities[n-1][0] - cities[p_index][0]\n        dist_r += cities[n-1][0] - cities[p_index][0]\n    elif cities[p_index][1] == 'R':\n        dist_r += cities[n-1][0] - cities[p_index][0]\n        dist_b += cities[n-1][0] - cities[p_index][0]\n    else:\n        p_dist_b = dist_b + abs(cities[n-1][0] - cities[p_index][0])\n        p_dist_r = dist_r + abs(cities[n-1][0] - cities[p_index][0])\n        dist_b = min(dist_b, p_dist_r)\n        dist_r = min(dist_r, p_dist_b)\n\nprint(dist_b + dist_r + dist_p)"
 ],
 "1544": [
  "n = int(input())\nans = 0\nfor i in range(n + 1):\n    for j in range(n - i + 1):\n        k = n - i - j\n        fact = [1, 1, 2, 6, 24]\n        ans += fact[n] // (fact[i] * fact[j] * fact[k] * fact[5])\nprint(ans)"
 ],
 "1545": [
  "MOD = 10**9 + 7\nn = int(input())\ns = input().strip()\na = list(map(int, input().split()))\n\ndp = [0] * (n + 1)\ndp[0] = 1\n\nmax_len = 0\nmin_cnt = float('inf')\nfor i in range(n):\n    cnt = [0] * 26\n    tmp = 1\n    for j in range(i, n):\n        c = ord(s[j]) - ord('a')\n        cnt[c] += 1\n        if cnt[c] > a[c]:\n            break\n        max_len = max(max_len, j - i + 1)\n        tmp = (tmp * 2) % MOD\n        if dp[i]:\n            dp[j + 1] = (dp[j + 1] + dp[i]) % MOD\n    if dp[i]:\n        min_cnt = min(min_cnt, i + 1)\n\nprint(dp[n])\nprint(max_len)\nprint(min_cnt)"
 ],
 "1546": [
  "n = int(input())\npairs = [[] for i in range(n)]\nendPoints = {}\nfor i in range(2*n):\n    a, b = map(int, input().split())\n    pairs[a-1].append(b)\n    pairs[b-1].append(a)\n    if a not in endPoints:\n        endPoints[a] = 0\n    if b not in endPoints:\n        endPoints[b] = 0\n    endPoints[a] += 1\n    endPoints[b] += 1\n\norder = [-1] * n\nendPointVals = sorted(list(endPoints.values()))\nif endPointVals[0] != 2 or endPointVals[-1] != 2:\n    print(\"-1\")\n    exit(0)\n    \ncurrent = next(iter(endPoints))\nidx = 0\nprev = -1\nwhile current != next(iter(endPoints)):\n    order[idx] = current\n    idx += 2 if endPoints[current]==2 else 1\n    endPoints[current] -= 1\n    if endPoints[current] == 0:\n        if current not in pairs[prev-1]:\n            print(\"-1\")\n            exit(0)\n        prev = current\n        current = pairs[current-1][0] if pairs[current-1][0] != prev else pairs[current-1][1]\nprint(\" \".join(map(str, order)))"
 ],
 "1547": [
  "n, m, k = map(int, input().split())\nrows = [0] * (n+1)\ncols = [0] * (m+1)\nfor i in range(k):\n    op, index, color = map(int, input().split())\n    if op == 1:\n        rows[index] = color\n    else:\n        cols[index] = color\nfor i in range(1, n+1):\n    for j in range(1, m+1):\n        print(max(rows[i], cols[j]), end=' ')\n    print()"
 ],
 "1548": [
  "n = int(input())\nsticks = list(map(int, input().split()))\n\n# Split the sticks into two lists, one for horizontal and one for vertical\nhoriz = []\nvert = []\nfor s in sticks:\n    if s % 2 == 0:\n        horiz.append(s)\n    else:\n        vert.append(s)\n\n# Sort the lists in descending order\nhoriz.sort(reverse=True)\nvert.sort(reverse=True)\n\n# Calculate the maximum distance using the sorted lists\nmax_dist = 0\nx = 0  # current x-coordinate\ny = 0  # current y-coordinate\nwhile len(horiz) > 0 and len(vert) > 0:\n    if horiz[0] > vert[0]:\n        max_dist += (x + horiz[0])**2 + y**2\n        x += horiz[0]\n        horiz.pop(0)\n    else:\n        max_dist += (y + vert[0])**2 + x**2\n        y += vert[0]\n        vert.pop(0)\n\n# Add any remaining sticks to the total distance\nfor s in horiz + vert:\n    max_dist += s**2\n\nprint(max_dist)"
 ],
 "1549": [
  "n, m, q = map(int, input().split())\na = list(map(int, input().split()))\n\n# map each city to the number of times it has hosted the olympiad\ncity_count = [0] * (m+1)\nfor i in range(n):\n    city_count[a[i]] += 1\n\n# generate a list of tuples (city, count) and sort it by count first,\n# then by city index\ncity_counts = [(i, city_count[i]) for i in range(1, m+1)]\ncity_counts.sort(key=lambda x: (x[1], x[0]))\n\n# use binary search to find the city that will host the olympiad for each year\nfor i in range(q):\n    k = int(input())\n    left, right = 0, m-1\n    while left < right:\n        mid = (left+right) // 2\n        if city_counts[mid][1] < k:\n            left = mid+1\n        else:\n            right = mid\n    print(city_counts[left][0])"
 ],
 "1550": [
  "n = int(input())\ndigits = list(map(int,input()))\n\nfor i in range(n):\n    if digits[i] > 4:\n        digits[i] -= 5\n    else:\n        digits[i] += 5\n        \nif n > 1:\n    first_digit = digits[0]\n    digits = digits[1:]\n    digits.append(first_digit)\n\nprint(*digits, sep='')"
 ],
 "1551": [
  "import sys\nimport math\n\nn, s = map(int, input().split())\n\na = []\nfor i in range(n):\n    x, v, t = map(int, input().split())\n    a.append((x, v, t))\n\ndef can_reach(t):\n    min_left, max_right = -math.inf, math.inf\n    for x, v, tdir in a:\n        if tdir == 1:\n            min_left = max(min_left, x - t * v)\n        else:\n            max_right = min(max_right, x + t * v)\n    return min_left + s * t >= max_right\n\nleft, right = 0, 10**15\nwhile left < right:\n    mid = (left + right) / 2\n    if can_reach(mid):\n        right = mid\n    else:\n        left = mid + 1\n\nprint(\"{:.6f}\".format(left))"
 ],
 "1552": [
  "n = int(input())\nskills = list(map(int, input().split()))\nmaths = [i+1 for i in range(n) if skills[i] == 2]\nprogramming = [i+1 for i in range(n) if skills[i] == 1]\npe = [i+1 for i in range(n) if skills[i] == 3]\nteams = []\nwhile len(maths) > 0 and len(programming) > 0 and len(pe) > 0:\n    teams.append((maths.pop(), programming.pop(), pe.pop()))\nprint(len(teams))\nfor team in teams:\n    print(team[0], team[1], team[2])"
 ],
 "1553": [
  "n, h = map(int, input().split())\nbottles = list(map(int, input().split()))\n\nlo, hi = 0, n\nwhile lo < hi:\n    mid = (lo + hi + 1) // 2\n    temp = sorted(bottles[:mid])[::-1]\n    space = h\n    for i in range(0, mid, 2):\n        space_above_shelf = space - temp[i]\n        if space_above_shelf < 0:\n            break\n        if i + 1 < mid and temp[i + 1] <= space_above_shelf:\n            space = space_above_shelf - temp[i + 1]\n        else:\n            space = space_above_shelf\n    if space >= 0:\n        lo = mid\n    else:\n        hi = mid - 1\n        \nprint(lo)"
 ],
 "1554": [
  "n = int(input())\npearls = list(map(int, input().split()))\nsegments = []\ni = 0\nwhile i < n:\n    current = pearls[i]\n    j = i + 1\n    while j < n and pearls[j] != current:\n        j += 1\n    if j == n:\n        print(-1)\n        exit()\n    else:\n        segments.append((i+1, j+1))\n        i = j + 1\nprint(len(segments))\nfor segment in segments:\n    print(segment[0], segment[1])"
 ],
 "1555": [
  "# Reading input\nn, m = map(int, input().split())\na = [input() for _ in range(n)]\n\n# Checking for contradictions\nfor i in range(n):\n    for j in range(m):\n        if a[i][j] == \"=\":\n            # Checking if evaluation is already determined for both dishes\n            eval_i, eval_j = 0, 0\n            for k in range(n):\n                if a[k][j] == \"<\":\n                    eval_j -= 1\n                elif a[k][j] == \">\":\n                    eval_j += 1\n                elif a[k][j] == \"=\" and k != i:\n                    if eval_i == 0:\n                        eval_i += 1\n                    if eval_j == 0:\n                        eval_j += 1\n            \n            for k in range(m):\n                if a[i][k] == \"<\":\n                    eval_i += 1\n                elif a[i][k] == \">\":\n                    eval_i -= 1\n                elif a[i][k] == \"=\" and k != j:\n                    if eval_i == 0:\n                        eval_i -= 1\n                    if eval_j == 0:\n                        eval_j -= 1\n            \n            if eval_i != eval_j:\n                print(\"No\")\n                exit()\n\n# Evaluating dishes\neval_first_day = [0] * n\neval_second_day = [0] * m\neval_count = 0\nfor i in range(n):\n    has_eval = False\n    for j in range(m):\n        if a[i][j] == \"<\":\n            if eval_second_day[j] == 0:\n                eval_count += 1\n                eval_second_day[j] = eval_count\n            eval_first_day[i] = eval_second_day[j] + 1\n            has_eval = True\n            break\n        elif a[i][j] == \">\":\n            if eval_first_day[i] == 0:\n                eval_count += 1\n                eval_first_day[i] = eval_count\n            eval_second_day[j] = eval_first_day[i] + 1\n            has_eval = True\n            break\n    # If evaluation not done, give max evaluation to dish\n    if not has_eval:\n        eval_count += 1\n        eval_first_day[i] = eval_count\n        for j in range(m):\n            if eval_second_day[j] == 0:\n                eval_second_day[j] = eval_count + 1\n\nprint(\"Yes\")\nprint(\" \".join(map(str, eval_first_day)))\nprint(\" \".join(map(str, eval_second_day)))"
 ],
 "1556": [
  "from heapq import heappush, heappop\nn, k, x = map(int, input().split())\na = list(map(int, input().split()))\nq = []\nfor i in range(n):\n    heappush(q, (abs(a[i]), i))\nfor i in range(k):\n    _, j = heappop(q)\n    a[j] += (a[j] // abs(a[j])) * x\n    heappush(q, (abs(a[j]), j))\nprint(*a)"
 ],
 "1557": [
  "h1, a1, c1 = map(int, input().split())\nh2, a2 = map(int, input().split())\nans = []\nwhile h2 > 0:\n    if h1 <= a2:\n        # Vova's health is too low, so he must use a potion.\n        h1 += c1\n        ans.append('HEAL')\n    else:\n        # Vova can defeat the monster with his next strike.\n        h2 -= a1\n        ans.append('STRIKE')\n        if h2 <= 0:\n            # The monster has been defeated by Vova.\n            break\n        # The monster is still alive, so it attacks Vova.\n        h1 -= a2\nans.insert(0, str(len(ans)))\nprint('\\n'.join(ans))"
 ],
 "1558": [
  "n, r, avg = map(int, input().split())\nexams = []\nessays_needed = 0\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    exams.append((b, r-a)) # We reverse the order to make sorting easier\n    avg -= a\n\nexams.sort() # We sort by the number of essays needed in ascending order\n\ni = 0\nwhile avg > 0:\n    essays = min(avg, exams[i][1]) # Take the minimum between what we need and what we can do\n    avg -= essays\n    essays_needed += essays * exams[i][0]\n    i += 1\n\nprint(essays_needed)"
 ],
 "1559": [
  "L = int(input())\nA = input().strip()\n\nP = A[:L] # get the first L digits\nwhile int(P) <= int(A): # keep incrementing P until it becomes greater than A\n    P = str(int(P)+1).zfill(L) # increment P by 1 and pad zeros to the left to maintain L digits\n\nprint(P* (len(A) // L)) # repeat P to match the length of A and print the result"
 ],
 "1560": [
  "n=int(input())\nc=input()\nx1,x2=0,0\nfor i in range(n):\n    if (i%2==0 and c[i]=='r') or (i%2==1 and c[i]=='b'):\n        x1+=1\n    else:\n        x2+=1\nprint(min(x1,x2))"
 ],
 "1561": [
  "n,m,k = map(int, input().split())\ngrid = [input() for _ in range(n)]\n\n# counting consecutive empty seats in rows\ndef count_row(row):\n    count = 0\n    for i in range(m-k+1):\n        if row[i:i+k] == '.'*k:\n            count += 1\n    return count\n\n# transpose the grid to count columns as rows\ntranspose = [''.join(col) for col in zip(*grid)]\n\n# count consecutive empty seats in columns\ncount_col = sum([count_row(col) for col in transpose])\n\n# count consecutive empty seats in rows\ncount_row = sum([count_row(row) for row in grid])\n\n# output the total count\nprint(count_row + count_col)"
 ],
 "1562": [
  "n,m,k,q=map(int,input().split())\ntreasures=[]\nfor i in range(k):\n    r,c=map(int,input().split())\n    treasures.append([r,c])\nsafe_cols=list(map(int,input().split()))\n\ntreasures=sorted(treasures, key=lambda x: (x[1],x[0]))\nsafe_cols.sort()\nmaxTreasure=[[0 for i in range(q+2)] for j in range(k+2)]\nfor i in range(k):\n    maxTreasure[i][0]=maxTreasure[i-1][0]+treasures[i][0]+treasures[i][1]*2\nfor i in range(k):\n    for j in range(1,q+1):\n        distToPrev=maxTreasure[i][j-1]-treasures[i][1]*2\n        if treasures[i][1]<=safe_cols[j-1]:\n            maxTreasure[i][j]=min(maxTreasure[i][j-1]+treasures[i][0]+(safe_cols[j-1]-treasures[i][1]),\n            maxTreasure[i-1][j]+distToPrev+(treasures[i][0]-treasures[i-1][0])+treasures[i][1]-treasures[i-1][1])\n        else:\n            maxTreasure[i][j]=maxTreasure[i][j-1]+treasures[i][0]+(safe_cols[j-1]-treasures[i][1])\nprint (maxTreasure[k-1][q])"
 ],
 "1563": [
  "n, m = map(int, input().split())\ncolors = list(map(int, input().split()))\nedges = [[] for _ in range(n)]\nfor i in range(m):\n    a, b = map(int, input().split())\n    edges[a-1].append(b-1)\n    edges[b-1].append(a-1)\n\nmax_cardinality = 0\nmax_color = float('inf')\nfor color in range(1, max(colors)+1):\n    if color not in set(colors):\n        continue\n    neighbors = set()\n    for vertex, color_of_vertex in enumerate(colors):\n        if color_of_vertex == color:\n            for neighbor in edges[vertex]:\n                neighbors.add(colors[neighbor])\n    cardinality = len(neighbors)\n    if cardinality > max_cardinality:\n        max_cardinality = cardinality\n        max_color = color\nprint(max_color)"
 ],
 "1564": [
  "n = int(input())\ns = input()\nt = input()\n\nsa = [i for i in range(n) if s[i] == 'a']\nsb = [i for i in range(n) if s[i] == 'b']\nta = [i for i in range(n) if t[i] == 'a']\ntb = [i for i in range(n) if t[i] == 'b']\n\nif len(sa) != len(ta) or len(sb) != len(tb):\n    print(-1)\nelse:\n    swaps = [(sa[i], ta[i]) for i in range(len(sa))] + [(sb[i], tb[i]) for i in range(len(sb))]    \n    print(len(swaps))\n    for swap in swaps:\n        print(swap[0]+1, swap[1]+1)"
 ],
 "1565": [
  "l = int(input())\nn = input()\n\nfor i in range(1, l):\n    if n[i] == '0':\n        num1 = n[:i]\n        num2 = n[i:]\n        break\n\nif 'num2' not in locals():\n    num1 = n[:l-1]\n    num2 = n[l-1:]\n\nprint(int(num1) + int(num2))"
 ],
 "1566": [
  "n = int(input())\ngrid = []\nfor i in range(n):\n    row = input().strip()\n    grid.append([int(x) for x in row])\n\ndef is_valid(i, j, k, l):\n    count = 0\n    for x in range(i, k+1):\n        for y in range(j, l+1):\n            count += grid[x][y]\n    if count == 0:\n        return False\n    for x in range(i, k+1):\n        for y in range(j, l+1):\n            count = 0\n            if x > i:\n                count += grid[x-1][y]\n            if y > j:\n                count += grid[x][y-1]\n            if x < k:\n                count += grid[x+1][y]\n            if y < l:\n                count += grid[x][y+1]\n            if count == 0:\n                return False\n    return True\n\nfound = False\nfor i in range(n):\n    for j in range(n):\n        for k in range(i, n):\n            for l in range(j, n):\n                if is_valid(i, j, k, l):\n                    found = True\n                    break\n            if found:\n                break\n        if found:\n            break\n    if found:\n        break\n\nif found:\n    print(\"Yes\")\nelse:\n    print(\"No\")"
 ],
 "1567": [
  "MOD = 998244353\n\nn, k = map(int, input().split())\n\ninv = [0] * (n + 1)\ninv[1] = 1\nfor i in range(2, n + 1):\n    inv[i] = (MOD - MOD // i) * inv[MOD % i] % MOD\n\nans = 0\np = 1\nfor i in range(k):\n    ans += p * inv[i + 1]\n    ans %= MOD\n    p *= (n - i)\n    p *= inv[i + 1]\n    p %= MOD\n\nprint(ans)"
 ],
 "1568": [
  "n, A, B, C, T = map(int, input().split())\nt = list(map(int, input().split()))\n\nans = A * n\n\nfor i in range(n):\n    if i > 0:\n        ans += (A - B * (t[i] - t[i-1])) * (min(t[i], T) - t[i-1])\n    else:\n        ans += (A - B * t[i]) * min(t[i], T)\n    if t[i] <= T:\n        ans += C * (n - i - 1) * (T - t[i])\n\nprint(ans)"
 ],
 "1569": [
  "import heapq\ndef dijkstra(n, adj, start):\n    dist = [float(\"inf\")] * n\n    dist[start] = 0\n    pq = [(0, start)]\n    while pq:\n        (d, u) = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for (v, weight) in adj[u]:\n            if dist[u] + weight < dist[v]:\n                dist[v] = dist[u] + weight\n                heapq.heappush(pq, (dist[v], v))\n    return dist\n\ndef main():\n    n, m = map(int, input().split())\n    adj = [[] for _ in range(n)]\n    for i in range(m):\n        x, y, z = map(int, input().split())\n        adj[x-1].append((y-1, z))\n        adj[y-1].append((x-1, z))\n        \n    dist = dijkstra(n, adj, 0)\n    reverse_dist = dijkstra(n, adj, n-1)\n    opt_dist = dist[n-1]\n    \n    # now build the graph of working roads on the optimal path\n    on_optimal_path = [False] * n\n    for i in range(n):\n        if(dist[i] + reverse_dist[i] == opt_dist):\n            on_optimal_path[i] = True\n    \n    queue = [n-1]\n    seen = [False] * n\n    seen[n-1] = True\n    affected_roads = []\n    repair_roads = []\n    blown_up_roads = []\n    while queue:\n        u = queue.pop(0)\n        for (v, weight) in adj[u]:\n            if(dist[v] + weight == dist[u] and not seen[v] and on_optimal_path[v]):\n                queue.append(v)\n                seen[v] = True\n            elif(on_optimal_path[u] and on_optimal_path[v] and weight == 1):\n                affected_roads.append((u+1, v+1, 1))\n    \n    for i in range(n):\n        if(not on_optimal_path[i]):\n            for (v, weight) in adj[i]:\n                if(on_optimal_path[v] and weight == 1):\n                    blown_up_roads.append((i+1, v+1, 0))\n                    break\n            else:\n                continue\n            break\n    \n    for i in range(n-1):\n        if(on_optimal_path[i] and not seen[i]):\n            repair_roads.append((i+1, i+2, 1))\n            \n    print(len(repair_roads) + len(blown_up_roads))\n    for r in repair_roads:\n        print(r[0], r[1], r[2])\n    for r in blown_up_roads:\n        print(r[0], r[1], r[2])  \n\nif __name__ == \"__main__\":\n    main() "
 ],
 "1570": [
  "k, n, w = map(int, input().split())\nneeded_money = max(0, (w*(w+1)//2)*k - n)\nprint(needed_money)"
 ],
 "1571": [
  "S = input().strip()\nT = input().strip()\n\nMOD = 998244353\n\nn, m = len(S), len(T)\ndp = [[0] * (m + 1) for _ in range(n + 1)]\ndp[0][0] = 1\n\nfor i in range(1, n + 1):\n    for j in range(m + 1):\n        if j > i:\n            break\n        if j > 0 and S[i - 1] == T[j - 1]:\n            dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD\n        dp[i][j] = (dp[i][j] + dp[i - 1][j] * 2) % MOD\n        if j > 0:\n            dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD\n\nans = sum(dp[n]) % MOD\nprint(ans)"
 ],
 "1572": [
  "n=int(input())\na=list(map(int,input().split()))\npos=-1\nmax_length=2\nfor i in range(n-2):\n    if a[i]+a[i+1]==a[i+2]:\n        j=i+2\n        while j<n and a[j]==a[j-1]+a[j-2]:\n            j+=1\n        if j-i>max_length:\n            max_length=j-i\n            pos=i\nif max_length==2 and n>1:\n    max_length=2\nelif max_length<2:\n    max_length=1\nprint(max_length)"
 ],
 "1573": [
  "n, d = map(int, input().split())\nfriends = []\nfor i in range(n):\n    m, s = map(int, input().split())\n    friends.append((m, s))\n\nfriends.sort()\n\nl, r = 0, 0\nmax_sum = -1\n\nwhile r < n:\n    while friends[r][0] - friends[l][0] >= d:\n        cur_sum = sum([friends[i][1] for i in range(l, r)])\n        max_sum = max(max_sum, cur_sum)\n        l += 1\n    r += 1\n\ncur_sum = sum([friends[i][1] for i in range(l, r)])\nmax_sum = max(max_sum, cur_sum)\n\nprint(max_sum)"
 ],
 "1574": [
  "n, m = map(int, input().split())\n\nadj_list = [[] for _ in range(n+1)]\nfor _ in range(m):\n    a, b = map(int, input().split())\n    adj_list[a].append(b)\n    adj_list[b].append(a)\n\ntriplets = []\nfor i in range(1, n+1):\n    for j in adj_list[i]:\n        for k in adj_list[j]:\n            # checking if all three know each other\n            if (k in adj_list[i]) and (k in adj_list[j]):\n                triplet = sorted([i,j,k])\n                if triplet not in triplets:\n                    triplets.append(triplet)\n\nmin_recognition = float('inf')\nfor triplet in triplets:\n    recognition_sum = 0\n    for musketeer in triplet:\n        recognition = len(set(adj_list[musketeer]) - set(triplet)) # calculating recognition\n        recognition_sum += recognition\n    min_recognition = min(min_recognition, recognition_sum)\n\nif min_recognition == float('inf'):\n    print(\"-1\")\nelse:\n    print(min_recognition)"
 ],
 "1575": [
  "ts, tf, t = map(int, input().split())\nn = int(input())\nvisitors = list(map(int, input().split()))\n\nif n == 0:\n    print(ts)\nelse:\n    if ts >= visitors[0]:\n        queue = []\n        for v in visitors:\n            if v <= ts:\n                queue.append(v)\n            else:\n                break\n        if len(queue) < tf - ts:\n            print(ts)\n        else:\n            print(-1)\n    else:\n        last_time = ts\n        for v in visitors:\n            if v > last_time:\n                if v - last_time > tf - ts: # no time to wait\n                    break\n                elif v - last_time < t:\n                    last_time = v # serve the visitor right away\n                else:\n                    last_time += t # wait in queue\n        else:\n            if tf - last_time >= t:\n                print(last_time)\n            else:\n                print(-1)\n       "
 ],
 "1576": [
  "s = input()\nn = len(s)\nans = [''] * n\nif n % 2 == 0:\n    mid = n // 2 - 1\nelse:\n    mid = n // 2\nans[mid] = s[0]\nj = mid + 1\nk = mid - 1\nfor i in range(1, n):\n    if i % 2 == 1:\n        ans[j] = s[i]\n        j += 1\n    else:\n        ans[k] = s[i]\n        k -= 1\nprint(''.join(ans))"
 ],
 "1577": [
  "n = int(input())\ns = input()\n\nif s.count('A') > s.count('D'):\n    print('Anton')\nelif s.count('A') < s.count('D'):\n    print('Danik')\nelse:\n    print('Friendship')"
 ],
 "1578": [
  "n = int(input())\nans = 0\nfor i in range(1, n):\n    ans += (n-1) // i\nprint(ans)"
 ],
 "1579": [
  "from collections import defaultdict\n\nN = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(N)]\n\nx_count = defaultdict(int)\ny_count = defaultdict(int)\nxy_count = defaultdict(int)\n\nfor x, y in points:\n    x_count[x] += 1\n    y_count[y] += 1\n    xy_count[(x, y)] += 1\n\nvalid = {i for i in range(N)}\n\nwhile True:\n    remove = set()\n    for i in valid:\n        x, y = points[i]\n        if x_count[x] > 1 and y_count[y] > 1 and \\\n           xy_count[(x, y)] == 1 and xy_count[(x, y-1)] and \\\n           xy_count[(x, y+1)] and xy_count[(x-1, y)] and xy_count[(x+1, y)]:\n            remove.add(i)\n            x_count[x] -= 1\n            y_count[y] -= 1\n            xy_count[(x, y)] = 0\n            xy_count[(x, y-1)] -= 1\n            xy_count[(x, y+1)] -= 1\n            xy_count[(x-1, y)] -= 1\n            xy_count[(x+1, y)] -= 1\n    if not remove:\n        break\n    valid -= remove\n\nprint(N - len(valid))"
 ],
 "1580": [
  "n,m=map(int,input().split())\na=[set() for i in range(n)]\nfor i in range(m):\n  x,y,z=map(int,input().split())\n  x-=1\n  y-=1\n  a[x].add((y,z%2))\n  a[y].add((x,z%2))\n\nused=[False]*n\nans=0\n\nfor i in range(n):\n  if used[i]:\n    continue\n\n  que=[i]\n  used[i]=True\n  node_cnt=0\n  zero_cnt=0\n  while len(que)>0:\n    now=que.pop()\n    node_cnt+=1\n    if 0 in a[now]:\n      zero_cnt+=1\n    for j in a[now]:\n      if used[j[0]]:\n        if (j[1]+a[now][0][1])%2==1:\n          print(\"-1\")\n          exit()\n      else:\n        used[j[0]]=True\n        que.append(j[0])\n\n  if zero_cnt>node_cnt//2:\n    zero_cnt=node_cnt-zero_cnt\n  ans+=zero_cnt+1\n\nprint(ans)"
 ],
 "1581": [
  "MOD = 10**9 + 7\nN, K = map(int, input().split())\n\ndp = [[0]*(N+1) for _ in range(K+1)]\ndp[0][1] = 1\n\nfor i in range(K):\n    for j in range(N):\n        dp[i+1][j+1] += dp[i][j+1]\n        dp[i+1][j+1] %= MOD\n        if 2*j+2 <= N:\n            dp[i+1][2*j+2] += dp[i][j+1]\n            dp[i+1][2*j+2] %= MOD\n\nprint(sum(dp[K]) % MOD)"
 ],
 "1582": [
  "N = int(input())\ncount = 0\nfor i in range(1, N+1):\n    i_str = str(i)\n    if i_str[0] == i_str[-1]:\n        count += 1\nfor j in range(1, N+1):\n    for k in range(1, N+1):\n        if str(j)[-1] == str(k)[0]:\n            count += 1\nprint(count)"
 ],
 "1583": [
  "import math\n\na, b, x = map(int, input().split())\n\nif x > a*a*b/2:\n    t = 2*(a*a*b-x)/(a*a*a)\n    print(math.degrees(math.atan(t)))\nelse:\n    t = (a*b*b)/(2*x)\n    print(math.degrees(math.atan(t)))"
 ],
 "1584": [
  "n = int(input())\nl = list(map(int, input().split()))\nl.sort()\ncount = 0\nfor i in range(n):\n    for j in range(i+1, n):\n        k = j + 1\n        while k < n and l[i] + l[j] > l[k]:\n            k += 1\n        count += k - j - 1\nprint(count)"
 ],
 "1585": [
  "x, y = map(int, input().split())\nans = 0\nwhile x <= y:\n    x *= 2\n    ans += 1\nprint(ans)"
 ],
 "1586": [
  "n = int(input())\nzeros = 0\ndivisor = 5\nwhile n >= divisor:\n    zeros += n // divisor\n    divisor *= 5\nprint(zeros)"
 ],
 "1587": [
  "n = int(input())\nstones = input()\ncount = stones.count('WRR')\nprint(count + max(stones[:count].count('R'), stones[count:].count('W')))"
 ],
 "1588": [
  "n = int(input())\nx = set(map(int, input().split()))\n\ns = sum(x)  # sum of all elements in X\nm = 1000000 - n  # total number of blocks in Y\nt = (s - (m * (m + 1) // 2)) // m  # number to increment by for Y\ny = set(i + t for i in range(m))  # set of elements in Y\n\n# print the elements in Y that are not in X\nprint(len(y - x))\nprint(*(y - x))"
 ],
 "1589": [
  "n, m = map(int, input().split())\ncount = 0\nfor i in range(n):\n    windows = list(map(int, input().split()))\n    for j in range(0, 2 * m, 2):\n        if windows[j] == 1 or windows[j+1] == 1:\n            count += 1\n\nprint(count)"
 ],
 "1590": [
  "MOD = 10**9+7\n\nn = int(input())\na = list(map(int, input().split()))\n\nans = 0\nfor i in range(n):\n    left = i+1\n    right = n-i\n    ans += ((left*right)%MOD*a[i])%MOD\nans = (ans*(n+1))//2\nprint(ans%MOD)"
 ],
 "1591": [
  "from collections import Counter\nn, k = map(int, input().split())\nlst = [int(input()) for i in range(n)]\nct = Counter(lst)\nans = 0\nfor i in ct.values():\n    ans += i//2*2\nprint(n-(n-ans))"
 ],
 "1592": [
  "n = int(input())\ntasks = []\nqueue_size = 0\nmax_queue_size = 0\ntime_last_message_sent = 0\n\nfor i in range(n):\n    t, c = map(int, input().split())\n    queue_size += c\n    tasks.append((t, c))\n    while tasks and tasks[0][0] <= t:\n        queue_size -= tasks[0][1]\n        tasks.pop(0)\n    if queue_size > max_queue_size:\n        max_queue_size = queue_size\n    time_last_message_sent = t + queue_size - 1\n\nprint(time_last_message_sent, max_queue_size)"
 ],
 "1593": [
  "import math\n\nn, s = map(int, input().split())\n\npopulations = []\nfor i in range(n):\n    x, y, p = map(int, input().split())\n    populations.append((math.sqrt(x*x + y*y), p))\n\npopulations.sort()\ntotal_pop = s\nfor dist, pop in populations:\n    total_pop += pop\n    if total_pop >= 1000000:\n        print(\"{:.7f}\".format(dist))\n        break\nelse:\n    print(\"-1\")"
 ],
 "1594": [
  "n, m = map(int, input().split())\nsongs = []\ntotal_duration = 0\nfor i in range(n):\n    ci, ti = map(int, input().split())\n    songs.append((total_duration+1, total_duration+ci*ti, i+1))\n    total_duration += ci*ti\n\ntimes = list(map(int, input().split()))\n\nresult = []\nfor time in times:\n    left, right = 0, n-1\n    while left <= right:\n        mid = (left+right)//2\n        if songs[mid][0] <= time <= songs[mid][1]:\n            result.append(songs[mid][2])\n            break\n        elif time < songs[mid][0]:\n            right = mid-1\n        else:\n            left = mid+1\n\nprint(*result)"
 ],
 "1595": [
  "def lowbit(x):\n    return x & (-x)\n\nsum, limit = map(int, input().split())\n\nif sum > limit*(limit+1)//2:\n    print(-1)\nelse:\n    ans = []\n    i = limit\n    while sum > 0 and i > 0:\n        if sum - i >= 0:\n            ans.append(i)\n            sum -= i\n        i -= lowbit(i)\n    if sum > 0:\n        ans.append(sum)\n    ans_len = len(ans)\n    print(ans_len)\n    for i in range(ans_len):\n        print(ans[i], end=\" \")"
 ],
 "1596": [
  "MOD = 10**9+7\ns = input()\nn = len(s)\ndp = [0] * (n+1)\ndp[0] = 1\nfor i in range(1, n+1):\n    if s[i-1] not in {\"w\", \"m\"}:\n        dp[i] += dp[i-1]\n    if i > 1 and s[i-2:i] in {\"uu\", \"nn\"}:\n        dp[i] += dp[i-2]\n    dp[i] %= MOD\nprint(dp[n])"
 ],
 "1597": [
  "n = int(input())\nstudents = []\nfor i in range(n):\n    s = input().strip()\n    students.append((s, i))\npseudonyms = []\nfor i in range(n):\n    p = input().strip()\n    pseudonyms.append((p, i))\nstudents.sort()\npseudonyms.sort()\nmatches = [(-1, -1) for i in range(n)]\nlcp = [[0 for j in range(n)] for i in range(n)]\nfor i in range(n):\n    for j in range(n):\n        k = 0\n        while k < len(students[i][0]) and k < len(pseudonyms[j][0]) and students[i][0][k] == pseudonyms[j][0][k]:\n            k += 1\n        lcp[i][j] = k\ntaken_pseudonyms = set()\ntaken_students = set()\nfor t in range(n):\n    best = (-1, -1, -1)\n    for i in range(n):\n        if i in taken_students:\n            continue\n        for j in range(n):\n            if j in taken_pseudonyms:\n                continue\n            match_score = lcp[i][j]\n            if match_score > best[0]:\n                best = (match_score, i, j)\n    matches[students[best[1]][1]] = (pseudonyms[best[2]][1], best[0])\n    taken_students.add(best[1])\n    taken_pseudonyms.add(best[2])\ntotal_score = 0\nfor match in matches:\n    total_score += match[1]\nprint(total_score)\nfor match in matches:\n    print(match[0]+1, match[1]+1)"
 ],
 "1598": [
  "s = input()\nn = len(s)\n\n# create a list of zeros with the same length as s\nt = ['0'] * n\n\n# set the first digit of t to 0\nt[0] = '0'\n\n# loop through the rest of s\nfor i in range(1, n):\n    # if the current digit in s is less than or equal to the previous digit\n    if s[i] <= s[i-1]:\n        # set the current digit in t to 0\n        t[i] = '0'\n    # otherwise\n    else:\n        # set the current digit in t to 1\n        t[i] = '1'\n\n# print the resulting string t\nprint(''.join(t))"
 ],
 "1599": [
  "s = input().strip()\nn = len(s)\nm = int(input())\n\ndp = [0]*(n+1)\nfor i in range(2,n+1):\n    if s[i-1] == s[i-2] == '.':\n        dp[i] = dp[i-1] + 1\n    else:\n        dp[i] = dp[i-1]\n\nfor i in range(m):\n    l,r = map(int,input().split())\n    print(dp[r]-dp[l])"
 ],
 "1600": [
  "n = int(input())\nheights = list(map(int, input().split()))\n\nblocks = 1\nmax_height = 0\nfor height in heights:\n    if height >= max_height:\n        max_height = height\n    else:\n        blocks += 1\n\nprint(blocks)"
 ],
 "1601": [
  "from itertools import combinations\n\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\nremaining_indices = set(range(n))\n\nwhile remaining_indices:\n    x_min, x_max = min(points[i][0] for i in remaining_indices), max(points[i][0] for i in remaining_indices)\n    y_min, y_max = min(points[i][1] for i in remaining_indices), max(points[i][1] for i in remaining_indices)\n    z_min, z_max = min(points[i][2] for i in remaining_indices), max(points[i][2] for i in remaining_indices)\n    mid_x, mid_y, mid_z = (x_min + x_max) / 2, (y_min + y_max) / 2, (z_min + z_max) / 2\n    found_pair = False\n    \n    for i, j in combinations(remaining_indices, 2):\n        if (x_min <= points[i][0] <= x_max or x_min <= points[j][0] <= x_max) and \\\n           (y_min <= points[i][1] <= y_max or y_min <= points[j][1] <= y_max) and \\\n           (z_min <= points[i][2] <= z_max or z_min <= points[j][2] <= z_max):\n            continue\n        else:\n            remaining_indices.remove(i)\n            remaining_indices.remove(j)\n            print(i+1, j+1)\n            found_pair = True\n            break\n    \n    assert found_pair, \"Unable to find valid pair\"\n"
 ],
 "1602": [
  "n=int(input()) \na=list(map(int,input().split()))\nb=[(bin(i)[2:])[::-1] for i in a]\nzeros=[0]*32\nones=[0]*32\nans=[]\nfor i in b:\n    for j in range(len(i)):\n        if i[j]==\"0\":\n            zeros[j]+=1\n        else:\n            ones[j]+=1\nfor i in range(n):\n    s=0\n    for j in range(32):\n        if ones[j]!=0 and zeros[j]!=0:\n            s+=(2**j)\n            ones[j]-=1\n            zeros[j]-=1 \n    ans.append(s)\nfor i in ans:\n     print(i,end=\" \")"
 ],
 "1603": [
  "n=int(input())\na=list(map(int,input().split()))\na1=a.copy()\na1.sort()\nm=int(input())\nfor _ in range(m):\n    t,l,r=map(int,input().split())\n    if(t==1):\n        print(sum(a[l-1:r]))\n    else:\n        print(sum(a1[l-1:r]))"
 ],
 "1604": [
  "MOD = 998244353\nn, k = map(int, input().split())\nlamps = sorted([list(map(int, input().split())) for i in range(n)])\ndp = [0] * (n+1)\ndp[0] = 1\nj = 0\ncur = 1\nfor i in range(n):\n    cur = (cur * max(i-j, 0)) % MOD\n    while j < i and lamps[i][0] > lamps[j][1]:\n        cur = (cur * pow(max(i-j-1, 0), MOD-2, MOD)) % MOD\n        cur = (cur * max(i-j, 0)) % MOD\n        cur = (cur - dp[j] * max(i-j-1, 0)) % MOD\n        j += 1\n    dp[i+1] = cur\nprint((dp[n]+MOD) % MOD if k == n else 0)"
 ],
 "1605": [
  "s = input().strip()\nn = len(s)\n\n# Count good substrings of even length\ncnt_even = 0\nfor i in range(n):\n    l = r = i\n    while r+1 < n and s[r+1] == s[i]:\n        r += 1\n    cnt_even += (r-l+1)//2   # Add the number of even-length substrings\n    i = r   # Move to the next index\n\n# Count good substrings of odd length\ncnt_odd = 0\nfor i in range(n):\n    l = r = i\n    while r+1 < n and s[r+1] == s[i]:\n        r += 1\n    diff = (r-l+1) % 2   # Check if this substring has odd or even length\n    cnt_odd += (r-l+1+diff)//2   # Add the number of odd-length substrings\n    i = r   # Move to the next index\n\nprint(cnt_even, cnt_odd)"
 ],
 "1606": [
  "n = int(input())\nA = [[int(x) for x in input().split()] for i in range(n)]\n\nrowOnes = [sum(row) for row in A]\ncolOnes = [sum(A[i][j] for i in range(n)) for j in range(n)]\nans = 0\nfor i in range(n):\n    ans ^= rowOnes[i]\n    ans ^= colOnes[i]\n\nq = int(input())\noutput = \"\"\nfor i in range(q):\n    query = input().split()\n    if query[0] == '1':\n        row = int(query[1])-1\n        ans ^= rowOnes[row]\n        rowOnes[row] = n-rowOnes[row]\n        ans ^= rowOnes[row]\n    elif query[0] == '2':\n        col = int(query[1])-1\n        ans ^= colOnes[col]\n        colOnes[col] = n-colOnes[col]\n        ans ^= colOnes[col]\n    else:\n        output += str(ans)\nprint(output)"
 ],
 "1607": [
  "n, k = map(int, input().split())\nmod = 998244353\n\ndp = [[0] * (k+1) for _ in range(n+1)]\ndp[1][1] = dp[1][2] = 1\n\nfor i in range(2, n+1):\n    for j in range(1, k+1):\n        dp[i][j] = (dp[i-1][j-1] * (j+1) + dp[i-1][j] * (i-j)) % mod\n\nprint(dp[n][k])"
 ],
 "1608": [
  "MOD = 10**9 + 7\n\nn = int(input())\na = list(map(int, input().split()))\n\ncnt = [0]*100001\nfor i in range(n):\n    cnt[a[i]] += 1\n\ndp = [0]*(100001)\nfor i in range(1, 100001):\n    dp[i] = pow(2, cnt[i], MOD) - 1\n    \nfor i in range(2, 100001):\n    if not cnt[i]:\n        continue\n    for j in range(i*2, 100001, i):\n        cnt[i] += cnt[j]\n\n    dp[i] = (pow(2, cnt[i], MOD) - 1 - dp[i]) % MOD\n    \nans = sum(dp[i] for i in range(2, 100001)) % MOD\n\nprint(ans)"
 ],
 "1609": [
  "n = int(input())\na = list(map(int, input().split()))\n\nnew_a = list(range(1, n+1))\nfor i in range(n):\n    if a[i] in new_a:\n        new_a.remove(a[i])\na_dict = {}\nfor i in range(n):\n    if a[i] not in a_dict:\n        a_dict[a[i]] = new_a.pop(0)\n        continue\n    new_num = new_a.pop(0)\n    while new_num in a_dict.values():\n        new_num = new_a.pop(0)\n    a_dict[a[i]] = new_num\n\nfor i in range(n):\n    print(str(a_dict[a[i]]) + \" \", end='')"
 ],
 "1610": [
  "n, k = map(int, input().split())\np = [0] * n\nfor i in range(n-k):\n    p[i] = i+1\nfor i in range(n-k, n):\n    p[i] = n-k + (n-1-i)\nprint(*p)"
 ],
 "1611": [
  "n = int(input())\nl = list(map(int, input().split()))\nl.sort()\nif l[-1] >= sum(l[:-1]):\n    print(l[-1]-sum(l[:-1])+1)\nelse:\n    print(0)"
 ],
 "1612": [
  "n = int(input())\ncards = []\nfor i in range(n):\n    cards.append(set(list(map(int, input().split()))[1:]))\n    \nfor i in range(n):\n    can_win = False\n    for j in range(n):\n        if i == j:\n            continue\n        if cards[j].issubset(cards[i]):\n            can_win = True\n            break\n    if can_win:\n        print(\"NO\")\n    else:\n        print(\"YES\")"
 ],
 "1613": [
  "n = int(input())\na = list(map(int,input().split()))\nprocesses = [i for i in range(1,n+1) if i in a]\noccupied = [i for i in a if i != 0]\ncount = 0\nfor i in range(len(occupied)):\n    if occupied[i] != processes[i]:\n        count += 1\nprint(count)"
 ],
 "1614": [
  "n, h = map(int, input().split())\na = list(map(int, input().split()))\nbent = [1 if i <= h else 2 for i in a]\nprint(sum(bent))"
 ],
 "1615": [
  "n, k = map(int, input().split())\nsegments = []\nfor i in range(n):\n    segments.append(list(map(int, input().split())))\n\ntotal = sum(r - l + 1 for l, r in segments)\nremainder = total % k\nprint((k - remainder) % k) "
 ],
 "1616": [
  "from collections import defaultdict\nfrom math import sqrt\n\nn = int(input())\na = list(map(int, input().split()))\n\ngraph = defaultdict(set)\n\nfor i in range(n):\n    for j in range(i+1, n):\n        prod = a[i] * a[j]\n        if sqrt(prod).is_integer():\n            graph[i].add(j)\n            graph[j].add(i)\n\nvisited = set()\ndef dfs(node, curr):\n    visited.add(node)\n    curr.add(node)\n    for neighbor in graph[node]:\n        if neighbor not in visited:\n            dfs(neighbor, curr)\n\nsubseq_lens = []\nfor i in range(n):\n    if i not in visited:\n        subseq = set()\n        dfs(i, subseq)\n        div_counts = defaultdict(int)\n        for node in subseq:\n            num = a[node]\n            for i in range(2, int(sqrt(num))+1):\n                while num % i == 0:\n                    num //= i\n                    div_counts[i] += 1\n            if num > 1:\n                div_counts[num] += 1\n        if all(count % 2 == 0 for count in div_counts.values()):\n            subseq_lens.append(len(subseq))\n\nif subseq_lens:\n    print(min(subseq_lens))\nelse:\n    print(-1)"
 ],
 "1617": [
  "n = int(input())\nf = set() # using set to remove duplicates\nfor k in range(1, n+1):\n    curr = 1\n    touched = set()\n    touched.add(curr)\n    while True:\n        curr = (curr + k - 1) % n + 1\n        if curr in touched:\n            break\n        touched.add(curr)\n    f.add(sum(touched))\nprint(*sorted(f))"
 ],
 "1618": [
  "n = int(input())\nstairs = list(map(int, input().split()))\n\nm = int(input())\nlast_height = 0\nfor i in range(m):\n    w, h = map(int, input().split())\n    base_height = max(stairs[w-1], last_height)\n    last_height = base_height + h\n    print(base_height)"
 ],
 "1619": [
  "from math import atan2\n\ndef is_left(p0, p1, p2):\n    return (p1[0] - p0[0]) * (p2[1] - p0[1]) - (p2[0] - p0[0]) * (p1[1] - p0[1])\n\ndef wind(p):\n    n = len(p)\n    w = 0\n    for i in range(n):\n        j = (i + 1) % n\n        prod = p[i][0] * p[j][1] - p[j][0] * p[i][1]\n        if prod < 0:\n            w -= 1\n        elif prod > 0:\n            w += 1\n    return w    \n\nn = int(input())\np = [list(map(int, input().split())) for _ in range(n)]\n\nm = int(input())\nq = [list(map(int, input().split())) for _ in range(m)]\n\nwind_p = wind(p)\nwind_q = wind(q)\n\ncw_count = ccw_count = 0\nfor i in range(n):\n    j = (i + 1) % n\n    for k in range(m):\n        l = (k + 1) % m\n        cpq1 = is_left(p[i], p[j], q[k])\n        cpq2 = is_left(p[i], p[j], q[l])\n        cqp1 = is_left(q[k], q[l], p[i])\n        cqp2 = is_left(q[k], q[l], p[j])\n        if cpq1 * cpq2 < 0 and cqp1 * cqp2 < 0:\n            if cpq1 < 0:\n                ccw_count += 1\n            else:\n                cw_count += 1\n            \nif (cw_count == ccw_count and wind_p == wind_q) or (cw_count != 0 and ccw_count != 0):\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "1620": [
  "n = int(input())\n\nif n == 1:\n    print('a')\nelse:\n    ans = ['a', 'b']\n    idx = 2\n    while idx < n:\n        if ans[idx-1] != ans[idx-2]:\n            ans.append(ans[idx-2])\n        else:\n            ans.append('c' if ans[idx-2] != 'c' else 'a')\n        idx += 1\n    print(''.join(ans))"
 ],
 "1621": [
  "s = input()\nk = int(input())\nw = list(map(int, input().split()))\n\nmax_w = max(w)\nvalue = 0\nfor i in range(len(s)):\n    value += w[ord(s[i]) - ord('a')] * (i + 1)\n\nfor j in range(len(s) + 1, len(s) + k + 1):\n    value += j * max_w\n\nprint(value)"
 ],
 "1622": [
  "n, m = map(int, input().split())\nparent = [i for i in range(n+1)]\n\ndef find(x):\n    if parent[x] == x:\n        return x\n    parent[x] = find(parent[x])\n    return parent[x]\n\nfor i in range(m):\n    data = list(map(int, input().split()))\n    if data[0] == 1:\n        x, y = data[1:]\n        parent[find(x)] = find(y)\n    elif data[0] == 2:\n        x = data[1]\n        while x != parent[x]:\n            x = parent[x]\n        parent[x] = find(x+1)\n    else:\n        x, i = data[1:]\n        if find(x) == find(i):\n            print('YES')\n        else:\n            print('NO')"
 ],
 "1623": [
  "n, l, r = map(int, input().split())\n\n# finding the minimum possible sum\nmin_sum = n - l + (l - 1) * 1\nmax_one_count = l if n - l > 0 else n\nmin_sum += max_one_count\n\n# finding the maximum possible sum\nmax_sum = (2 ** r - 1) * (n - r + 1)\nif r < n:\n    max_sum += (2 ** (r - 1)) * (n - r) * (2 ** (l - 1))\n\nprint(min_sum, max_sum)"
 ],
 "1624": [
  "n = int(input())\na = list(map(int, input().split()))\na.sort()\nans = 0\nfor i in range(n // 2):\n    ans += (a[i] + a[-i-1]) ** 2\nprint(ans)"
 ],
 "1625": [
  "n = int(input())\nnums = list(map(int, input().split()))\n\nfor i in range(n, 0, -1):\n    submatrix_size = 2 ** (i - 1)\n    max_val = max(nums)\n    nums.remove(max_val)\n    submatrix_sum = sum([num for num in nums if num < max_val])\n    nums = [num for num in nums if num >= max_val]\n    beauty = max_val + 4 * submatrix_sum\n    nums += [beauty] * (submatrix_size ** 2 - 1)\n\nprint(nums[0])"
 ],
 "1626": [
  "MOD = 10 ** 9 + 7\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nans = 1\n\nfor i in range(n // k):\n    cnt = 0\n    for j in range(k):\n        if (b[i] * 10 ** (k - j - 1)) % a[i] == 0:\n            cnt += 1\n    ans *= cnt\n    ans %= MOD\n\nprint(ans)"
 ],
 "1627": [
  "n = int(input())\na = list(map(int, input().split()))\n\ndef swap(start, end):\n    swaps = []\n    for i in range(start, end, 2):\n        swaps.append((i+1, i))\n    return swaps\n\nswaps = []\nfor i in range(n-1):\n    min_val = min(a[i:])\n    min_j = a.index(min_val, i)\n    if (min_j - i) % 2 == 1:\n        swaps.extend(swap(i, min_j+1))\n    else:\n        swaps.extend(swap(i+1, min_j+1))\n    a = a[:i] + a[i:min_j+1][::-1] + a[min_j+1:]\n\nprint('\\n'.join([f'{l+1} {r+1}' for (l, r) in swaps]))"
 ],
 "1628": [
  "s = input()\n\nwhile True:\n    flag = False\n    for i in range(len(s)-1):\n        if s[i]==\"y\" and s[i+1]==\"x\":\n            s = s[:i]+\"xy\"+s[i+2:]\n            flag = True\n            break\n    if not flag:\n        for i in range(len(s)-1):\n            if s[i]==\"x\" and s[i+1]==\"y\":\n                s = s[:i]+s[i+2:]\n                flag = True\n                break\n    if not flag:\n        print(s)\n        break"
 ],
 "1629": [
  "n, x = map(int, input().split())\nballs = list(map(int, input().split()))\n\nremaining_balls = balls[x-1]\nballs[x-1] = 0\n\ni = x-1\nwhile remaining_balls > 0:\n    i = (i+1) % n\n    balls[i] += 1\n    remaining_balls -= 1\n\nprint(*balls)"
 ],
 "1630": [
  "n = int(input())\nclubs = []\nfor i in range(n):\n    team, city = input().split()\n    clubs.append((team[:2]+city[0], team[:3]))\n\nshort_names = {}\nfor i in range(n):\n    if clubs[i][1] not in short_names:\n        short_names[clubs[i][1]] = clubs[i][0]\n    elif short_names[clubs[i][1]] == clubs[i][1]:\n        print('NO')\n        exit()\n    else:\n        if short_names[clubs[i][1]] != clubs[i][0]:\n            print('NO')\n            exit()\n    if clubs[i][0] not in short_names:\n        short_names[clubs[i][0]] = clubs[i][1]\n    else:\n        if short_names[clubs[i][0]] != clubs[i][1]:\n            print('NO')\n            exit()\n\nprint('YES')\nfor i in range(n):\n    print(short_names[clubs[i][0]])"
 ],
 "1631": [
  "from collections import defaultdict\nn = int(input())\ngraph = defaultdict(set)\nindegree = {char: 0 for name in range(n) for char in name}\nfor i in range(n-1):\n    name1, name2 = input().split()\n    for char1, char2 in zip(name1, name2):\n        if char1 != char2:\n            if char2 not in graph[char1]:\n                graph[char1].add(char2)\n                indegree[char2] += 1\n            break\n    else:\n        if len(name1) > len(name2):\n            print(\"Impossible\")\n            exit()\norder = []\nq = [char for char in indegree if not indegree[char]]\nwhile q:\n    char = q.pop()\n    order.append(char)\n    for next_char in graph[char]:\n        indegree[next_char] -= 1\n        if not indegree[next_char]:\n            q.append(next_char)\nif len(order) < len(indegree):\n    print(\"Impossible\")\nelse:\n    print(\"\".join(order))"
 ],
 "1632": [
  "n = int(input())\nballs = list(map(int, input().split()))\nballs.sort()\nwins = [[0]*(n+1) for _ in range(n+1)]\nfor i in range(n):\n    for j in range(i+1, n):\n        if balls[i]>balls[j]:\n            wins[i][j]=1\n        else:\n            wins[j][i]=1\nprob=0\nfor k in range(n):\n    for l in range(k+1,n):\n        if wins[k][l]!=1:\n            continue\n        for m in range(n):\n            if m==k or m==l:\n                continue\n            if (wins[k][m] and wins[l][m]):\n                prob+=1\n                break\nprint(\"%.10f\" % (prob/((n*(n-1)*(n-2))/6)))\u200b"
 ],
 "1633": [
  "n, m, k = map(int, input().split())\npixels = [[False for j in range(m)] for i in range(n)]\n\nfor move in range(1, k+1):\n    i, j = map(int, input().split())\n    pixels[i-1][j-1] = True\n    \n    if move >= 4:\n        for x in range(i-1, i+1):\n            for y in range(j-1, j+1):\n                if x >= 1 and y >= 1 and pixels[x-1][y-1] and pixels[x-1][y] and pixels[x][y-1] and pixels[x][y]:\n                    print(move)\n                    exit()\n\nprint(0)"
 ],
 "1634": [
  "c1, c2, c3, c4 = map(int, input().split())\nn, m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\ntotal_cost = 0\n\n# option 1: buy a ticket for each ride\ntotal_cost += sum(min(ai*c1, c2) for ai in a)  # cost for buses\ntotal_cost += sum(min(bi*c1, c2) for bi in b)  # cost for trolleys\n\n# option 2: buy a ticket for unlimited rides on a single transport\ntotal_cost = min(total_cost, c3*max(sum(a), sum(b)))\n\n# option 3: buy a ticket for unlimited rides on all buses OR all trolleys\ntotal_cost = min(total_cost, c3*(n+m))\n\n# option 4: buy a ticket for unlimited rides on all transports\ntotal_cost = min(total_cost, c4)\n\nprint(total_cost)"
 ],
 "1635": [
  "n = int(input())\ncafe_indices = list(map(int, input().split()))\n\nlast_visited = {}\nresult = -1\n\nfor i in range(n-1, -1, -1):\n    index = cafe_indices[i]\n    if index not in last_visited:\n        last_visited[index] = i\n    else:\n        result = index\n    if result == -1:\n        result = index\n    elif last_visited[index] > last_visited[result]:\n        result = index\n\nprint(result)"
 ],
 "1636": [
  "n = int(input())\npoints = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    points.append((x, y))\nw = list(map(int, input().split()))\npoints.sort()\nnum = [0] * n\nfor i in range(n):\n    diff = w[i] - (points[i][1] - points[i][0])\n    if diff < 0:\n        print(\"NO\")\n        break\n    else:\n        num[i] = diff\n        if i > 0 and num[i] <= num[i-1]:\n            num[i] = num[i-1] + 1\nelse:\n    print(\"YES\")\n    for i in range(n):\n        print(points[i][0], points[i][1] - num[i])"
 ],
 "1637": [
  "import sys\n\nn,m = map(int, sys.stdin.readline().split())\ncompetitors = [None] * n\nfor i in range(n):\n    competitors[i] = tuple(map(int, sys.stdin.readline().split()))\nhate = [None] * m\nfor i in range(m):\n    hate[i] = tuple(map(int, sys.stdin.readline().split()))\n\nscores1 = []\nscores2 = []\nfor i in range(n):\n    scores1.append((competitors[i][0], i)) # append tuple with first task score and index\n    scores2.append((competitors[i][1], i)) # append tuple with second task score and index\n\nscores1.sort()\nscores2.sort()\n\nsums = [0] * n\nfor i in range(n//2):\n    c1 = scores1[i][1] # get the competitor index\n    c2 = scores2[i][1]\n    if (c1,c2) in hate or (c2,c1) in hate: # check if they hate each other\n        i -= 1\n        continue\n    sums[c1] += competitors[c2][1] # add the second task score to the first competitor's sum\n    sums[c2] += competitors[c1][0] # add the first task score to the second competitor's sum\n\n    c1 = scores1[n-i-1][1] # repeat for reverse order of scores\n    c2 = scores2[n-i-1][1]\n    if (c1,c2) in hate or (c2,c1) in hate:\n        i -= 1\n        continue\n    sums[c1] += competitors[c2][1]\n    sums[c2] += competitors[c1][0]\n\nif n % 2 == 1: # if n is odd, one competitor will not have a pair\n    i = n // 2\n    c1 = scores1[i][1]\n    c2 = scores2[i][1]\n    if (c1,c2) not in hate and (c2,c1) not in hate:\n        sums[c1] += competitors[c2][1]\n        sums[c2] += competitors[c1][0]\n\nfor i in range(n):\n    print(sums[i], end=' ')"
 ],
 "1638": [
  "n = int(input())\nm = list(map(int, input().split()))\na = [0] * n \nfor i in range(n):\n    a[i] = min(m[i], m[i-1]) if i > 0 else m[0]\nprint(\" \".join(str(x) for x in a))"
 ],
 "1639": [
  "n = int(input())\na = list(map(int, input().split()))\n\nmaxLength = 1\ncurrentLength = 1\n\nfor i in range(1, n):\n    if a[i] >= a[i-1]:\n        currentLength += 1\n    else:\n        maxLength = max(maxLength, currentLength)\n        currentLength = 1\n\nmaxLength = max(maxLength, currentLength)\nprint(maxLength)"
 ],
 "1640": [
  "n = int(input())\na = list(map(int, input().split()))\n\nans = 0\n\nfor i in range(n):\n    for j in range(i+1, n):\n        if abs(a[i] - a[j]) > 1:\n            ans += a[j] - a[i]\n\nprint(ans)"
 ],
 "1641": [
  "n, k, s, t = map(int, input().split())\ncv = [list(map(int, input().split())) for _ in range(n)]\ngas_stations = sorted(list(map(int, input().split())))\ngas_stations = [0] + gas_stations + [s]\nans = -1\nfor i in range(n):\n    c, v = cv[i]\n    if gas_stations[-2] + v >= s:\n        speed = 1\n    else:\n        speed = 2\n    t_total = 0\n    fuel = v\n    dist = gas_stations[1]\n    j = 1\n    while dist < s and t_total <= t:\n        fuel_required = (gas_stations[j] - gas_stations[j-1]) * (speed-1)\n        while fuel < fuel_required and j <= k+1:\n            j += 1\n            fuel += v\n            if fuel < fuel_required:\n                t_total = t+1\n                break\n        if t_total > t:\n            break\n        fuel -= fuel_required\n        if speed == 1:\n            t_total += (gas_stations[j] - gas_stations[j-1])\n        else:\n            t_total += (gas_stations[j] - gas_stations[j-1]) * 2\n        dist = gas_stations[j]\n    if t_total <= t:\n        if ans == -1:\n            ans = c\n        else:\n            ans = min(ans, c)\nprint(ans)"
 ],
 "1642": [
  "import math\n\nn = int(input().strip())\n\npoints = []\n\nfor i in range(n):\n    x, y = map(int, input().split())\n    points.append((x, y))\n\nx1, y1 = points[0]\n\n# Find the maximum distance by checking the angle formed by consecutive points\nmax_dist = 0\nfor i in range(n):\n    x2, y2 = points[(i+1)%n]\n    x3, y3 = points[(i+2)%n]\n    d = (y2-y1)*(x3-x2) - (x2-x1)*(y3-y2)\n    dist = math.sqrt((x2-x1)**2 + (y2-y1)**2)\n    if d < 0:\n        # points form a right angle or obtuse angle, find the minimum distance\n        max_dist = max(max_dist, dist/2)\n    else:\n        # points form an acute angle, find the maximum distance\n        max_dist = max(max_dist, dist)\n\nprint(max_dist)"
 ],
 "1643": [
  "s = input()\nn = len(s)\nt = ['0'] * n\nlast = '0'\nfor i in range(n):\n    if s[i] == '0':\n        t[i] = '0'\n    elif last == '0':\n        t[i] = '0'\n    else:\n        t[i] = '1'\n    last = t[i]\nprint(''.join(t))"
 ],
 "1644": [
  "n = int(input())\nrings = []\nfor i in range(n):\n    a, b, h = map(int, input().split())\n    rings.append((a, b, h))\n\nrings.sort(reverse=True, key=lambda x: x[1])\n\ndp = [0] * n\ndp[0] = rings[0][2]\n\nfor i in range(1, n):\n    temp = 0\n    for j in range(i):\n        if rings[j][0] < rings[i][1]:\n            temp = max(temp, dp[j])\n    dp[i] = temp + rings[i][2]\n\nprint(max(dp))"
 ],
 "1645": [
  "from collections import defaultdict\n\nn = int(input())\na = list(map(int, input().split()))\n\nprefix_sum = [0] * (n+1)\nfor i in range(1, n+1):\n    prefix_sum[i] = prefix_sum[i-1] + a[i-1]\n\ngood_subarrays = defaultdict(int)\nresult = 0\n \nl = 1\nfor r in range(1, n+1):\n    if prefix_sum[r] == 0:\n        result += 1\n    result += good_subarrays[prefix_sum[r]]\n    good_subarrays[prefix_sum[r]] += 1\n    while good_subarrays[prefix_sum[r]] > 1:\n        good_subarrays[prefix_sum[l]] -= 1\n        l += 1\n\nprint(result)"
 ],
 "1646": [
  "n=int(input());s=input();s=s.replace(\"11\",\"1\")\nc=0\nfor i in s:\n    if i==\"0\":\n        c+=1\n    else:\n        break\nif c==n:\n    print(\"0\")\nelse:\n    print(\"0\"+\"1\"*c+s[c:])"
 ],
 "1647": [
  "n = int(input())\ns = input()\nt = input()\ndsu = list(range(26))  # initialize disjoint set union\nans = []  # stores the required spells\n \n# function to find root of a set\ndef root(i):\n    if dsu[i] == i:\n        return i\n    dsu[i] = root(dsu[i])  # path compression\n    return dsu[i]\n \n# function to perform union of two sets\ndef union(a, b):\n    ra, rb = root(a), root(b)\n    if ra != rb:\n        dsu[rb] = ra\n \n# check and update the disjoint set\nfor i in range(n):\n    union(ord(s[i])-97, ord(t[i])-97)\n \n# finding and storing the required spells\nfor i in range(26):\n    if root(i) != i:\n        ans.append((chr(i+97), chr(root(i)+97)))  # converting to lowercase letter\nprint(len(ans))\nfor a in ans:\n    print(a[0], a[1])"
 ],
 "1648": [
  "n, k = map(int, input().split())\nMOD = 10**9+7\n\ndef mod_inv(a, m):\n    return pow(a, m-2, m)\n\ndef binom(n, k, m):\n    if n < k:\n        return 0\n    num = 1\n    for i in range(n, n-k, -1):\n        num = (num*i) % m\n    den = 1\n    for i in range(1, k+1):\n        den = (den*i) % m\n    return (num*mod_inv(den, m)) % m\n\n# calculate prefix sum and sum of i-th prefix sums\nP = [0]\nS = [0]\nfor i in range(k):\n    p = binom(n-k+1, i+1, MOD) * binom(k-1, i, MOD)\n    P.append((P[i]+p) % MOD)\n    S.append((S[i]+i*p) % MOD)\n\n# calculate answer for each i using prefix sums and S\nans = [0] * k\nfor i in range(1, k+1):\n    for j in range(i, k+1):\n        c = binom(j-1, i-1, MOD)\n        if (j-i) % 2 == 0:\n            ans[i-1] = (ans[i-1]+c*(P[j]-P[j-i])) % MOD\n        else:\n            ans[i-1] = (ans[i-1]-c*(P[j]-P[j-i])) % MOD\n    ans[i-1] = (ans[i-1] * binom(n-k+1, i, MOD)) % MOD\n    ans[i-1] = (ans[i-1] * mod_inv(pow(k, i, MOD), MOD)) % MOD\n    ans[i-1] = (ans[i-1] * pow(S[i], n-k, MOD)) % MOD\n\n# output answer\nfor i in range(k):\n    print(ans[i])"
 ],
 "1649": [
  "a, b, c, d = map(int, input().split())\nif a+b == c+d or a+c == b+d or a+d == b+c or a == b+c+d or b == a+c+d or c == a+b+d or d == a+b+c:\n    print(\"Yes\")\nelse:\n    print(\"No\")"
 ],
 "1650": [
  "L = int(input(), 2)\nMOD = 10**9 + 7\n\ndp = [[0]*2 for _ in range(100005)]\ndp[0][0] = 1\n\nfor i in range(100004):\n    now = (L>>i) & 1\n    dp[i+1][0] = dp[i][0] * (1 + now) % MOD\n    dp[i+1][1] = dp[i][1] * 3 % MOD\n    if now:\n        dp[i+1][1] += dp[i][0]\n        dp[i+1][0] += dp[i][1]\n    dp[i+1][0] %= MOD\n    dp[i+1][1] %= MOD\n\nprint((dp[100000][0] + dp[100000][1])%MOD)"
 ],
 "1651": [
  "S, P = map(int, input().split())\nfor i in range(1, int((P+1)**0.5)+1):\n    if P % i == 0:\n        j = P // i\n        if i + j == S:\n            print(\"Yes\")\n            exit()\nprint(\"No\")"
 ],
 "1652": [
  "s = input()\nwhile len(s) > 0:\n    if s.endswith(\"dream\"):\n        s = s[:-5]\n    elif s.endswith(\"dreamer\"):\n        s = s[:-7]\n    elif s.endswith(\"erase\"):\n        s = s[:-5]\n    elif s.endswith(\"eraser\"):\n        s = s[:-6]\n    else:\n        print(\"NO\")\n        break\nif len(s) == 0:\n    print(\"YES\")"
 ],
 "1653": [
  "s = input()\nt = input()\nq = int(input())\n\ndef possible(a, b, c, d):\n    if len(s[a-1:b]) < len(t[c-1:d]):\n        return False\n    pos = 0\n    for i, ch in enumerate(t[c-1:d], start=c-1):\n        while pos < len(s[a-1:b]) and s[pos+a-1] != ch:\n            pos += 1\n        if pos >= len(s[a-1:b]):\n            return False\n        pos += 1\n    return True\n\nans = \"\"\nfor i in range(q):\n    a, b, c, d = map(int, input().split())\n    ans += \"1\" if possible(a, b, c, d) else \"0\"\nprint(ans)"
 ],
 "1654": [
  "from collections import Counter\ns = input().strip()\nt = input().strip()\ns_count = Counter(s)\nt_count = Counter(t)\n\nq_count = s_count.get('?', 0)\n\nfor i in range(26):\n    char = chr(ord('a') + i)\n    diff = t_count[char] - s_count[char]\n    if diff > 0 and q_count < diff:\n        print('NO')\n        break\n\nelse:\n    ans = []\n    j = 0\n    for i in range(len(s)):\n        if s[i] != '?':\n            ans.append(s[i])\n        else:\n            if j < len(t) and t[j] not in ans:\n                ans.append(t[j])\n                j += 1\n            else:\n                for k in range(26):\n                    char = chr(ord('a') + k)\n                    if char not in ans and char != t[j]:\n                        ans.append(char)\n                        break\n    print(''.join(ans))"
 ],
 "1655": [
  "n = int(input())\nclaws = list(map(int, input().split()))\n\nalive = n\nmax_kill_range = [-1] * n\n\nfor i in range(n):\n    if i - claws[i] <= 0:\n        max_kill_range[i - claws[i]] = max(max_kill_range[i - claws[i]], i)\n\nfor i in range(n):\n    if max_kill_range[i] != -1:\n        alive = min(alive, max_kill_range[i] - i + 1)\n\nprint(alive)"
 ],
 "1656": [
  "s = input()\nn = len(s)\nw_count = 0\nwow_counts = [0] * n\n\nif s[0] == 'o':  # base case for wow_counts\n    wow_counts[0] = 0\nelse:\n    wow_counts[0] = 1\n\nfor i in range(1, n):\n    if s[i] == 'o':\n        wow_counts[i] = wow_counts[i-1]\n    else:\n        wow_counts[i] = wow_counts[i-1] + w_count\n        if i >= 2 and s[i-1:i+1] == 'vv':\n            w_count += 1\n\nprint(wow_counts[n-1])"
 ],
 "1657": [
  "import sys\n\ndef solve(n, p, devices):\n    total_power = sum(devices[i][0] for i in range(n))\n    if total_power <= p:\n        # can use devices indefinitely\n        return -1\n    \n    # binary search for maximum time\n    lo, hi = 0, sys.maxsize\n    while hi - lo > 1e-9:\n        mid = (lo + hi) / 2\n        remaining_power = mid * p\n        for i in range(n):\n            power_needed = devices[i][0] * mid - devices[i][1]\n            if power_needed > 0:\n                remaining_power -= power_needed\n                if remaining_power < 0:\n                    break\n        if remaining_power >= 0:\n            lo = mid\n        else:\n            hi = mid\n    \n    return lo\n\nn, p = map(int, input().split())\ndevices = [tuple(map(int, input().split())) for _ in range(n)]\nans = solve(n, p, devices)\nprint(\"{:.10f}\".format(ans))"
 ],
 "1658": [
  "MOD = 10**9 + 7\nn, x = map(int, input().split())\nd = list(map(int, input().split()))\n\nf = [[0] * (x + 1) for _ in range(n)]\ng = [[0] * (x + 1) for _ in range(n)]\n\nfor i in range(n):\n    f[i][0] = 1\n    g[i][0] = 1\n    for j in range(1, x+1):\n        if j < d[i]:\n            f[i][j] = 0\n        else:\n            f[i][j] = sum(g[i][:j-d[i]+1]) % MOD\n        g[i][j] = (f[i][j] + g[i][j-1]) % MOD\n \nans = sum(g[i][x] for i in range(n)) % MOD\nprint(ans)"
 ],
 "1659": [
  "n, x = map(int, input().split())\nice_cream = x\ndistressed_kids = 0\n\nfor i in range(n):\n    action, d = input().split()\n    d = int(d)\n    if action == '+':\n        ice_cream += d\n    else:\n        if ice_cream >= d:\n            ice_cream -= d\n        else:\n            distressed_kids += 1\n\nprint(ice_cream, distressed_kids)"
 ],
 "1660": [
  "n,m=map(int,input().split())\ngraph=[[] for i in range(n)]\nfor i in range(m):\n    u,v,w=map(int,input().split())\n    graph[u-1].append((v,w))\ndp=[0]*n\nfor i in range(n-1,-1,-1):\n    for j in range(len(graph[i])):\n        v,w=graph[i][j]\n        if dp[v-1]<dp[i]+1 and w>dp[i]:\n            dp[v-1]=dp[i]+1\nprint(max(dp))"
 ],
 "1661": [
  "# get the input values\nn, m = map(int, input().split())\nc = list(map(int, input().split()))\na = list(map(int, input().split()))\n\n# initialize game counter, bill index\ngames_bought = 0\nbill_index = 0\n\n# loop through each game\nfor i in range(n):\n    # try to buy the game with the current bill\n    if bill_index < m and a[bill_index] >= c[i]:\n        games_bought += 1\n        bill_index += 1\n\n# print the number of games bought\nprint(games_bought)"
 ],
 "1662": [
  "m = int(input())\ncards = list(map(int, input().split()))\n\nseq = []\ni = 0\n\nwhile i < m:\n    seq.append(cards[i])\n    if i < m - 1 and cards[i] < cards[i+1]:\n        while i < m - 1 and cards[i] < cards[i+1]:\n            i += 1\n        while i < m - 1 and cards[i] == cards[i+1]:\n            i += 1\n        if i == m - 1 or cards[i] > cards[i+1]:\n            break\n    elif i < m - 1 and cards[i] == cards[i+1]:\n        i += 1\n    else:\n        break\n    i += 1\n \nprint(len(seq))\nprint(\" \".join(str(x) for x in seq))"
 ],
 "1663": [
  "MOD = 10**9 + 7\ns = input().strip()\nn = len(s)\n\n# Prefix sum to calculate powers of 10 modulo MOD\np = [1] * (n+1)\nfor i in range(1, n+1):\n    p[i] = (p[i-1] * 10) % MOD\n\n# Calculate total sum using dynamic programming\ndp = [0] * n\ndp[0] = int(s[0])\nfor i in range(1, n):\n    dp[i] = (dp[i-1] * 10 + int(s[i]) * (i+1)) % MOD\n\n# Calculate the sum of all possible substrings\ntotal_sum = 0\nfor i in range(n):\n    total_sum = (total_sum + ((dp[n-1] - dp[i]) * p[n-i-1]) % MOD) % MOD\n\n# Subtract sum of substrings where Vova removes all digits\ntotal_sum = (total_sum - (((n-1) * n) // 2) % MOD) % MOD\n\nprint(total_sum)"
 ],
 "1664": [
  "n = int(input())\nres = {}\nvar = set()\nfor i in range(n):\n    l = input().split('=')\n    if len(l) == 2:\n        res[l[0]] = l[1]\n    else:\n        var.add(l[0])\nres_set = set(res.keys())\n\ndef get_new_var():\n    for i in range(1, 5):\n        for c in itertools.product(string.ascii_letters + string.digits, repeat=i):\n            nc = ''.join(c)\n            if nc[0].isalpha() and nc not in var | res_set:\n                var.add(nc)\n                return nc\n\ntmp_res = {}\nfor v in var:\n    tmp_res[v] = v\n\nans = []\nfor l in range(n):\n    if len(input()) == 3:\n        continue\n    items = input().split('=')\n    if len(items) == 2:\n        items[1] = tmp_res[items[1]] if items[1] in tmp_res else items[1]\n        if items[0] == 'res':\n            tmp_res[items[0]] = items[1]\n        else:\n            var.discard(items[0])\n            tmp_res[items[0]] = items[1]\n    else:\n        new_var = get_new_var()\n        op = items[1][1]\n        items[1] = items[1][0] + op + items[1][2]\n        for k, v in tmp_res.items():\n            items[1] = items[1].replace(k, v)\n        tmp_res[new_var] = items[1]\n        ans.append(new_var + '=' + items[1])\n\nfor k, v in res.items():\n    v = tmp_res[v] if v in tmp_res else v\n    ans.append(k + '=' + v)\n\nprint(len(ans))\nprint('\\n'.join(ans))"
 ],
 "1665": [
  "from collections import defaultdict\n\nn = int(input())\ngraph = defaultdict(list)\n\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    graph[u].append((v, i))\n    graph[v].append((u, i))\n\nvisited = set()\nans = [-1]*(n-1)\n\ndef dfs(node, prev_label):\n    visited.add(node)\n\n    label = 0\n    for nei, edge_idx in graph[node]:\n        if nei not in visited:\n            dfs(nei, label)\n            label += 1\n\n    for nei, edge_idx in graph[node]:\n        if nei not in visited:\n            ans[edge_idx] = prev_label\n        else:\n            ans[edge_idx] = label\n\ndfs(1, 0)\n\nprint(*ans)"
 ],
 "1666": [
  "x, y, a, b = map(int, input().split())\n\npossible_outcomes = []\nfor i in range(a, x+1):\n    for j in range(b, y+1):\n        if i > j:\n            possible_outcomes.append((i, j))\n\nprint(len(possible_outcomes))\nfor outcome in sorted(possible_outcomes):\n    print(*outcome)"
 ],
 "1667": [
  "n = int(input())\na = list(map(int, input().split()))\n\na_sorted = sorted(a)\nans = 1\nfor i in range(2, n + 1):\n    if all((a_sorted[j] - a_sorted[j - i + 1]) % (i - 1) == 0 for j in range(i - 1, n, i)):\n        k = (a_sorted[-1] - a_sorted[0]) // (i - 1)\n        if all((a_sorted[j] - a_sorted[j - i + 1]) // (i - 1) == k for j in range(i - 1, n, i)):\n            ans = k\n\nprint(ans)"
 ],
 "1668": [
  "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    pins = []\n    for i in range(n):\n        pins.append(input())\n\n    changes = 0\n    used_pins = []\n    for i in range(n):\n        if pins[i] in used_pins:\n            for j in range(4):\n                if pins[i][:j]+pins[i][j+1:] not in used_pins:\n                    used_pins.append(pins[i][:j]+pins[i][j+1:])\n                    pins[i] = pins[i][:j]+pins[i][j+1:]\n                    changes += 1\n                    break\n        else:\n            used_pins.append(pins[i])\n\n    print(changes)\n    for pin in pins:\n        print(pin)"
 ],
 "1669": [
  "n = int(input())\nreserved_tokens = input().split()\nm = int(input())\nlines = [input().strip() for _ in range(m)]\n\n# create the set of reserved tokens\nreserved_set = set()\nfor token in reserved_tokens:\n    reserved_set.add(token)\n\n# create the list of all possible words (not reserved) to replace\ntarget_words = []\nfor i in range(1, 3):\n    for j in range(26):\n        if i == 1:\n            target_words.append(chr(97+j))\n        else:\n            target_words.append(chr(97+j)*i)\n\n# helper function to check if a token is a word\ndef is_word(token):\n    if len(token) == 0 or token[0].isdigit():\n        return False\n    for char in token:\n        if not(char.isalnum() or char == '_' or char == '$'):\n            return False\n    return True\n\n# create a dictionary to store the mapping of words to target words\nmapping = {}\nword_idx = 0  # current index in the target words list\nfor line in lines:\n    tokens = line.split()\n\n    for i in range(len(tokens)):\n        if tokens[i] not in reserved_set and is_word(tokens[i]):\n            if tokens[i] not in mapping:\n                mapping[tokens[i]] = target_words[word_idx]\n                word_idx += 1\n    \n    for i in range(len(tokens)):\n        if tokens[i] in mapping:\n            tokens[i] = mapping[tokens[i]]\n\n    # join the tokens and add the line to the minified program\n    minified_line = ' '.join(tokens)\n    print(minified_line)"
 ],
 "1670": [
  "home_team = input()\naway_team = input()\nn = int(input())\n\ncards = {}\n\nfor i in range(n):\n    t, team, player, card = input().split()\n    t = int(t)\n    player = int(player)\n    if card == 'y':\n        if cards.get((team, player)):\n            cards[(team, player)].append(t)\n        else:\n            cards[(team, player)] = [t]\n    else:\n        if cards.get((team, player)):\n            cards[(team, player)].append(t)\n        else:\n            cards[(team, player)] = [t]\n        \nres = []\nfor player, times in cards.items():\n    times.sort()\n    if len(times) == 2:\n        res.append((player[0], player[1], times[1]))\n    elif len(times) > 2:\n        for i in range(1, len(times)):\n            if times[i] - times[i-1] <= 45:\n                res.append((player[0], player[1], times[i]))\n                break\n\nres.sort(key=lambda x: x[2])\nfor event in res:\n    print(f\"{event[0]} {event[1]} {event[2]}\")"
 ],
 "1671": [
  "n = int(input())\nm = list(map(int, input().split()))\navg = sum(m) // n\ndiff = [0] * n\nfor i in range(n):\n    diff[i] = m[i] - avg\nfor i in range(1, n):\n    diff[i] += diff[i-1]\ndiff.sort()\nmedian = diff[n//2]\nres = 0\nfor num in diff:\n    res += abs(num - median)\nprint(res)"
 ],
 "1672": [
  "n = int(input())\nmagnets = []\nfor i in range(n):\n    magnets.append(input())\n\ngroups = 1\nfor i in range(1, n):\n    if magnets[i] != magnets[i-1]:\n        groups += 1\n\nprint(groups)"
 ],
 "1673": [
  "MOD = 998244353\n\nn, k = map(int, input().split())\n\narr = list(map(int, input().split()))\n\narr.sort()\n\ndp = [[0 for _ in range(n)] for _ in range(k)]\n\ndp[1] = [1 for _ in range(n)]\n\nfor i in range(2, k+1):\n    for j in range(n):\n        cnt = 1\n        for m in range(j-1, -1, -1):\n            if arr[j] - arr[m] < arr[m]:\n                break\n            cnt += dp[i-1][m]\n            cnt %= MOD\n        dp[i][j] = cnt\n\nans = 0\nfor i in range(n):\n    ans += dp[k][i]\n    ans %= MOD\n\nprint(ans)"
 ],
 "1674": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\ns = input().strip()\n\ncurr = [0]*26\ntotal = 0\nl = 0\n\nfor r, c in enumerate(s):\n    id = ord(c)-ord('a')\n    curr[id] += 1\n    total += a[r]\n\n    while curr[id] > k:\n        total -= a[l]\n        curr[ord(s[l]) - ord('a')] -= 1\n        l += 1\n\nprint(total)"
 ],
 "1675": [
  "n = int(input())\nteams = []\nfor i in range(n):\n    teams.append(list(map(int, input().split())))\n\nhome_dict = {}\naway_dict = {}\n\nfor i in range(n):\n    if teams[i][0] in home_dict:\n        home_dict[teams[i][0]] += 1\n    else:\n        home_dict[teams[i][0]] = 1\n    \n    if teams[i][1] in away_dict:\n        away_dict[teams[i][1]] += 1\n    else:\n        away_dict[teams[i][1]] = 1\n\nfor i in range(n):\n    home_games = n - 1 + away_dict[teams[i][0]]\n    away_games = n - 1 + home_dict[teams[i][1]]\n    \n    if teams[i][0] == teams[i][1]:\n        home_games -= 1\n        away_games -= 1\n    \n    print(home_games, away_games)"
 ],
 "1676": [
  "import heapq\n\nn, b = map(int, input().split())\nqueue = []\ntime = 0\n\nfor i in range(n):\n    t, d = map(int, input().split())\n    while queue and queue[0][0] <= t:\n        _, _, end_time = heapq.heappop(queue)\n        time = end_time\n    if len(queue) < b:\n        if time < t:\n            end_time = t+d\n            heapq.heappush(queue, (end_time, i, end_time))\n            print(end_time, end=' ')\n            time = end_time\n        else:\n            end_time = time+d\n            heapq.heappush(queue, (end_time, i, end_time))\n            print(end_time, end=' ')\n            time = end_time\n    else:\n        print(-1, end=' ')\nprint()"
 ],
 "1677": [
  "n=int(input())\nb=list(map(int,input().split()))\ndp=[]\nfor i in range(n):\n    dp.append([1]*n)\n    \nd={}\nfor i in range(n):\n    if b[i] not in d:\n        d[b[i]]=[]\n    d[b[i]].append(i)\n\nans=1\nfor i in range(n):\n    for j in range(i+1,n):\n        k=j+j-i\n        cnt=2\n        last=j\n        if k<n and b[k]==b[i]+(b[j]-b[i])*2:\n            cnt+=1\n            last=k\n        if b[j] in d:\n            for nxt in d[b[j]]:\n                if nxt>last:\n                    cnt+=1\n                    last=nxt\n                    break\n                    \n        ans=max(ans,cnt)\nprint(ans)"
 ],
 "1678": [
  "n, t = map(int, input().split())\na = list(map(int, input().split()))\n\nans = 0\nj = 0\nsum_j = 0\nfor i in range(n):\n    sum_j += a[i]\n    while sum_j >= t:\n        sum_j -= a[j]\n        j += 1\n    ans += i-j+1\n\nprint(ans)"
 ],
 "1679": [
  "n = int(input())\ns = input()\n\ni = 0\nans = ''\nwhile i < n:\n    j = i\n    while j < n and s[j] == '1':\n        j += 1\n    ans += str(j-i)\n    i = j+1\n\nprint(int(ans))"
 ],
 "1680": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\ncount = 0\nfor i in range(n):\n    for j in range(i+1, n):\n        if bin(a[i] ^ a[j]).count('1') == k:\n            count += 1\nprint(count)"
 ],
 "1681": [
  "colors = input()\ngarland_colors = input()\ntotal_area = 0\n\nfor c in set(garland_colors):\n    if c not in colors:\n        print(-1)\n        break\n    else:\n        total_area += min(colors.count(c), garland_colors.count(c))\nelse:\n    print(total_area)"
 ],
 "1682": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nc = [(b[i] - a[i], i) for i in range(n)]\nc.sort(reverse=True)\n\nans = 0\nfor i in range(k):\n    ans += a[c[i][1]]\nfor i in range(k, n):\n    ans += min(a[c[i][1]], b[c[i][1]])\n\nprint(ans)"
 ],
 "1683": [
  "n = int(input())\na = list(map(int,input().strip().split()))\n\nmod = 998244353\n\nans = 0\nfor i in range(11):\n    b = [0]*n\n    for j in range(n):\n        b[j] = (a[j]//(10**i))%10\n    cnt = [0]*10\n    for j in range(n):\n        cnt[b[j]] += 1\n    res = [0]*10\n    for j in range(10):\n        res[j] = cnt[j]*pow(10,i,mod)%mod\n    for j in range(n):\n        res[b[j]] -= pow(10,i,mod)\n    for j in range(10):\n        for k in range(j+1,10):\n            ans += (res[j]*res[k])%mod\n    for j in range(n):\n        for k in range(j+1,n):\n            ans += ((a[j] % (10**i)) * (a[k] % (10**i)))%mod\n            ans %= mod\n\nprint(ans%mod)"
 ],
 "1684": [
  "n, m = map(int, input().split())\na = [[0 for j in range(0, n)] for i in range(0, m)] \nfor i in range(m): \n    x, y = map(int, input().split())\n    if y < x: \n        x, y = y, x\n    a[i][x - 1] = 1 \n    a[i][y - 1] = -1\nfor k in range(1, n):\n    flag = True\n    for i in range(m):\n        x, y = -1, -1\n        for j in range(n):\n            if a[i][j] == 1:\n                x = j\n            if a[i][j] == -1:\n                y = j\n            if x != -1 and y != -1:\n                if a[i][(x + k) % n] != -1 or a[i][(y + k) % n] != 1:\n                    flag = False\n                    break\n        if not flag:\n            break\n    if flag:\n        print(\"Yes\")\n        exit(0)\nprint(\"No\")"
 ],
 "1685": [
  "from math import log2\n\nn, q = map(int, input().split())\ndepth = int(log2(n+1))\n\n# dictionaries to store left and right child of each vertex\nleft_child = {}\nright_child = {}\nfor i in range(1, n+1):\n    left_child[i] = 2*i if 2*i <= n else None\n    right_child[i] = 2*i+1 if 2*i+1 <= n else None\n\n# function to traverse the tree given a starting vertex and a path string\ndef traverse(u, s):\n    for c in s:\n        if c == 'L':\n            if left_child[u]:\n                u = left_child[u]\n        elif c == 'R':\n            if right_child[u]:\n                u = right_child[u]\n        else:\n            u = (u-1) // 2\n        if not u:  # if u reaches the root, stop processing path string\n            break\n    return u\n\n# process queries\nfor _ in range(q):\n    u = int(input())\n    s = input().strip()\n    v = traverse(u, s)\n    print(v)"
 ],
 "1686": [
  "n, k = map(int, input().split())\n\nips = []\nfor i in range(n):\n    ips.append(list(map(int, input().split('.'))))\n\nres = [[0,0,0,0]]\nfor i in range(30, -1, -1):\n    new_res = []\n    for r in res:\n        bits = [1, 1, 1, 1]\n        for j in range(4):\n            if r[j] == 255:\n                bits[j] = 0\n            else:\n                mask = 255\n                while mask > r[j]:\n                    mask >>= 1\n                while mask:\n                    nr = r.copy()\n                    nr[j] |= mask\n                    if nr not in new_res:\n                        new_res.append(nr)\n                    mask >>= 1\n        if len(new_res) > k:\n            break\n    if len(new_res) == k:\n        res = new_res\n        break\n    else:\n        res = new_res\n\nif len(res) != k:\n    print(\"-1\")\nelse:\n    for r in res:\n        print(\".\".join(str(x) for x in r))"
 ],
 "1687": [
  "n = int(input())\na = list(map(int, input().split()))\n\n# Sort the array in ascending order\na.sort()\n\n# Check if the first element is a divisor of all other elements\nfor i in range(1, n):\n    if a[i] % a[0] != 0:\n        print(\"-1\")\n        break\nelse:\n    print(a[0])"
 ],
 "1688": [
  "n = int(input())\na = list(map(int, input().split()))\n\ndef nxt(i):\n    return (i + 1) % n\n\nans = []\nfor i in range(n):\n    x = a[i]\n    j = nxt(i)\n    count = 1\n    while j != i:\n        if a[j] * 2 <= x:\n            ans.append(-1)\n            break\n        else:\n            x = max(x, a[j])\n            j = nxt(j)\n            count += 1\n    else:\n        ans.append(count)\n\nprint(*ans)"
 ],
 "1689": [
  "n = int(input())\nseats = []\nflag = False\nfor i in range(n):\n    seats.append(input())\n    if not flag and \"OO\" in seats[-1]:\n        seats[-1] = seats[-1].replace(\"OO\", \"++\", 1)\n        flag = True\nif flag:\n    print(\"YES\")\n    for seat in seats:\n        print(seat)\nelse:\n    print(\"NO\")"
 ],
 "1690": [
  "n = int(input())\na = list(map(int, input().split()))\n\nans = a[-1]  # start with buying all of the last type of chocolate\nmax_a = a[-1]  # the maximum number of chocolates seen so far\n\nfor i in range(n-2, -1, -1):\n    max_a = max(max_a-1, a[i])  # update the maximum number of chocolates seen so far\n    if max_a <= 0:  # can't buy any more chocolates\n        break\n    ans += max_a  # buy the maximum number of chocolates possible\n\nprint(ans)"
 ],
 "1691": [
  "from math import gcd\nn, k = map(int, input().split())\ncount = 1\nresult = [1]\nfor i in range(2, n+1):\n    count += gcd(n, k)\n    result.append(count)\n    k += gcd(n, k)\n    if k > n:\n        k -= n\nprint(*result)"
 ],
 "1692": [
  "s = input()\ncount = 0\nn = len(s)\n\nfor i in range(n):\n    if int(s[i]) % 4 == 0:\n        count += 1\n\nfor i in range(1, n):\n    num = int(s[i - 1:i + 1])\n    if num % 4 == 0:\n        count += i\n    if i < n - 1 and int(s[i + 1]) % 2 == 0:\n        count += i\n\nprint(count)"
 ],
 "1693": [
  "n = int(input())\nm = list(map(int, input().split()))\n\n# Initialize variables\na = [0] * n\nleft = [0] * n\nright = [0] * n\nstack = []\n\n# Computing left values\nfor i in range(n):\n    while stack and m[stack[-1]] < m[i]:\n        stack.pop()\n    if not stack:\n        left[i] = 0\n    else:\n        left[i] = stack[-1] + 1\n    stack.append(i)\n\n# Computing right values\nstack = []\nfor i in range(n-1, -1, -1):\n    while stack and m[stack[-1]] < m[i]:\n        stack.pop()\n    if not stack:\n        right[i] = n-1\n    else:\n        right[i] = stack[-1] - 1\n    stack.append(i)\n\n# Finding optimal height for each building\nfor i in range(n):\n    possible_height = min(m[i], i - left[i], right[i] - i)\n    if possible_height > 0:\n        a[i] = possible_height\n\n# Printing result\nprint(*a)"
 ],
 "1694": [
  "n, m, s, f = map(int, input().split())\n\n# initialize the moves as empty string\nmoves = \"\"\n\n# initialize the leftmost and rightmost positions\nleftmost, rightmost = s, s\n\n# loop through each watching step\nfor i in range(1, m+1):\n    ti, li, ri = map(int, input().split())\n    \n    # calculate the distance between the leftmost and rightmost positions\n    distance = rightmost - leftmost\n    \n    # if the destination spy is already within the range of the watched spies,\n    # keep the note in order not to be caught by Xenia\n    if li <= f <= ri:\n        moves += \"X\"\n    else:\n        # if the destination spy is to the left of the range of the watched spies\n        # and we are not already at the leftmost position, move left\n        if f < li:\n            if leftmost > 1:\n                leftmost -= 1\n                rightmost -= 1\n                moves += \"L\"\n            else:\n                moves += \"X\"\n        # if the destination spy is to the right of the range of the watched spies\n        # and we are not already at the rightmost position, move right\n        elif f > ri:\n            if rightmost < n:\n                rightmost += 1\n                leftmost += 1\n                moves += \"R\"\n            else:\n                moves += \"X\"\n\n# print the final moves\nprint(moves)"
 ],
 "1695": [
  "n, m = map(int, input().split())\nstudent_answers = []\nfor i in range(n):\n    student_answers.append(input().strip())\n\npoints = list(map(int, input().split()))\n\nbest_score = 0\nfor q in range(m):\n    correct_answer = max([student_answers[i][q] for i in range(n)], key=[student_answers[i][q] for i in range(n)].count)\n    best_score += points[q] * [student_answers[i][q] for i in range(n)].count(correct_answer)\n\nprint(best_score)"
 ],
 "1696": [
  "n, m, k = map(int, input().split())\ncenters = [tuple(map(int, input().split())) for i in range(k)]\n\ndef is_possible(time):\n    min_x, max_x = n, 1\n    min_y, max_y = m, 1\n    for x, y in centers:\n        if time < abs(n - x) + 1:\n            min_x = min(min_x, x - time)\n            max_x = max(max_x, x + time)\n        if time < abs(m - y) + 1:\n            min_y = min(min_y, y - time)\n            max_y = max(max_y, y + time)\n    return (max_x - min_x + 1) * (max_y - min_y + 1) <= n * m\n\nlow, high = 0, n + m\nwhile low < high:\n    mid = (low + high) // 2\n    if is_possible(mid):\n        high = mid\n    else:\n        low = mid + 1\n\nprint(low)"
 ],
 "1697": [
  "n, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\n\ndef dfs(i, j, pi, pj, color, visited):\n    if not (0 <= i < n and 0 <= j < m):\n        return False\n    if visited[i][j]:\n        return True\n    if grid[i][j] != color:\n        return False\n    visited[i][j] = True\n    for ni, nj in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:\n        if (ni,nj) == (pi,pj):\n            continue\n        if dfs(ni, nj, i, j, color, visited):\n            return True\n    return False\n\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] != '.':\n            visited = [[False]*m for _ in range(n)]\n            if dfs(i, j, -1, -1, grid[i][j], visited):\n                print('Yes')\n                exit()\nprint('No')"
 ],
 "1698": [
  "n, k = map(int, input().split())\nfloors = sorted(map(int, input().split()), reverse=True)\ntime = 0\nwhile floors:\n    time += 2 * (floors.pop(0) - 1)\n    group = min(k, len(floors))\n    for _ in range(group):\n        time += abs(floors.pop(0) - floors[-1])\nprint(time)"
 ],
 "1699": [
  "from math import ceil, sqrt\n\nn, m = map(int, input().split())\n\na = [[0] * m for _ in range(n)]\n\nfor i in range(n):\n    for j in range(m):\n        s = set()\n        if i > 0:\n            s.add(a[i-1][j])\n        if j > 0:\n            s.add(a[i][j-1])\n        if i == 0 and j == 0:\n            s.add(1)\n        while True:\n            x = ceil(sqrt(sum(x*x for x in s) + 1))\n            if x > 10**8:\n                break\n            if x not in s:\n                a[i][j] = x\n                break\n            s.add(x)\n\nfor row in a:\n    print(*row)"
 ],
 "1700": [
  "n=int(input())\ns=input()\nans=[]\nstack=[]\nfor i in range(n):\n    if len(stack)==0:\n        stack.append(s[i])\n        ans.append(\"0\")\n    else:\n        if stack[-1]==\"(\" and s[i]==\")\":\n            stack.pop()\n            ans.append(\"0\")\n        else:\n            stack.append(s[i])\n            ans.append(\"1\")\nprint(''.join(ans))"
 ],
 "1701": [
  "n, m = map(int, input().split())\n\nips = {}\nfor i in range(n):\n    name, ip = input().split()\n    ips[ip] = name\n\nfor i in range(m):\n    command, ip = input().split(';')\n    ip = ip[:-1]\n    print(command + ' ' + ip + '; #' + ips[ip])"
 ],
 "1702": [
  "import math\nn=int(input())\ntime = []\nPetya=[-1]*5\nVasya=[-1]*5\ni=0\nwhile i<n:\n    arr=[int(x) for x in input().split()]\n    if i==0:\n        Vasya=arr\n    elif i==1:\n        Petya=arr\n    time.append(arr)\n    i+=1\npoints={'A': 500,'B': 1000,'C': 1500,'D': 2000,'E': 2500,'F': 3000}\nproblems=['A','B','C','D','E']\nmin_points=[500,1000,1500,2000,2500,3000]\nfor i in range(5):\n    submits=0\n    success=0\n    for j in range(n):\n        if time[j][i]!=-1:\n            submits+=1\n            if j==0:\n                success+=1\n            if j==1:\n                success+=1\n    ratio=success/submits\n    point=0\n    if ratio>1/2:\n        point=points[problems[i]]\n    elif ratio>1/4 and ratio<=1/2:\n        point=points[problems[i]]-min_points[1]\n    elif ratio>1/8 and ratio<=1/4:\n        point=points[problems[i]]-min_points[2]\n    elif ratio>1/16 and ratio<=1/8:\n        point=points[problems[i]]-min_points[3]\n    elif ratio>1/32 and ratio<=1/16:\n        point=points[problems[i]]-min_points[4]\n    else:\n        point=points[problems[i]]-min_points[5]\n    Vasya[i]=point*(1-Vasya[i]/250)\n    Petya[i]=point*(1-Petya[i]/250)\nfor acc in range(1000000009):\n    diff=[a-b for a,b in zip(Vasya,Petya)]\n    if max(diff)<=0:\n        print(acc)\n        break\n    idx=diff.index(max(diff))\n    success=0\n    total=0\n    for i in range(n):\n        if time[i][idx]!=-1:\n            submits+=1\n            if i==0:\n                success+=1\n            if i==1:\n                success+=1\n            total+=1\n    ratio=success/total\n    if ratio>=1/32:\n        points[problems[idx]]=3000\n    elif ratio>=1/16:\n        points[problems[idx]]=2500\n    elif ratio>=1/8:\n        points[problems[idx]]=2000\n    elif ratio>=1/4:\n        points[problems[idx]]=1500\n    elif ratio>=1/2:\n        points[problems[idx]]=1000\n    else:\n        points[problems[idx]]=500\n    Vasya[idx]+=points[problems[idx]]*(1+acc/250)"
 ],
 "1703": [
  "n = int(input())\nseqs = []\nfor i in range(n):\n    seqs.append(input())\n    \ncount = 0\nregular_seqs = set()\n\nfor seq in seqs:\n    bal = 0\n    for c in seq:\n        if c == '(':\n            bal += 1\n        else:\n            bal -= 1\n        if bal < 0:\n            break\n    else:\n        regular_seqs.add(seq)\n\nfor i in range(n):\n    for j in range(n):\n        if i != j:\n            if (seqs[i] + seqs[j]) in regular_seqs:\n                count += 1\n\nprint(count)"
 ],
 "1704": [
  "n, k = map(int, input().split())\ndigits = [input() for i in range(n)]\n\ndp = [[-1 for j in range(k+1)] for i in range(n+1)]\ndp[n][0] = 0\n\nfor i in range(n-1, -1, -1):\n    for j in range(k+1):\n        if dp[i+1][j] != -1:\n            dp[i][j] = dp[i+1][j]\n            for digit in range(10):\n                possible = True\n                for seg in range(7):\n                    if digits[i][seg] == \"1\" and num_segments[digit][seg] == 0:\n                        possible = False\n                    if possible and digits[i][seg] == \"0\" and num_segments[digit][seg] == 1 and j >= 1 and dp[i+1][j-1] != -1:\n                        possible = False\n                if possible:\n                    dp[i][j] = digit\n                    break\n\nif dp[0][k] == -1:\n    print(-1)\nelse:\n    ans = \"\"\n    j = k\n    for i in range(n):\n        ans += str(dp[i][j])\n        if dp[i][j] != dp[i+1][j]:\n            j -= 1\n    print(ans)"
 ],
 "1705": [
  "n = int(input())\ndoors = list(map(int, input().split()))\nleft = 0\nright = 0\ncount = 0\nfor i in range(n):\n    if doors[i] == 0:\n        left += 1\n    else:\n        right += 1\n    if left > 0 and right > 0:\n        count += 1\n        left -= 1\n        right -= 1\nif left == 0 or right == 0:\n    print(count + left + right)\nelse:\n    print(count + 1)"
 ],
 "1706": [
  "s = input()\nn = len(s)\nans = []\n\ndef append_left(index):\n    ans.append(('L', index))\n    s = s[index-1::-1] + s\n    return s\n\ndef append_right(index):\n    ans.append(('R', index))\n    s = s + s[n-1:index-1:-1]\n    return s\n\nfor i in range(2, n+1):\n    if s[i-2] == s[-i]:\n        continue\n    elif s[i-2] == s[i-1]:\n        s = append_right(i)\n    elif s[-i] == s[-i+1]:\n        s = append_left(i)\n\nprint(len(ans))\nfor move in ans:\n    print(move[0], move[1])"
 ],
 "1707": [
  "n = int(input())\na = sorted(list(map(int,input().split())))\nans = 0\nfor i in range(n):\n    for j in range(i+1,n):\n        if a[i]+a[j] in a and a[j]-a[i] in a:\n            ans +=1\nprint(ans)"
 ],
 "1708": [
  "import heapq\n\nn,m=map(int,input().split())\na=list(map(int,input().split()))\nc=list(map(int,input().split()))\nd=[]\nfor i in range(m):\n    d.append(list(map(int,input().split())))\nheap=[(c[i],i) for i in range(n)]\nheapq.heapify(heap)\nr=a.copy()\nans=[0]*m\nfor i in range(m):\n    t=d[i][0]-1\n    di=d[i][1]\n    while r[t]<di:\n        try:cmin,_=heapq.heappop(heap)\n        except:\n            ans[i]=0\n            break\n        if r[heap.index((cmin,_))]>0:\n            ans[i]+=cmin\n            r[heap.index((cmin,_))]-=1\n            di-=1\n        else:continue\n    if ans[i]==0:continue\n    ans[i]*=di\n    di=d[i][1]-di\n    r[t]-=di\n    heapq.heappush(heap,(c[t],t))\nfor i in ans:\n    print(i)"
 ],
 "1709": [
  "n, m, k = map(int, input().split())\n\ncol = list(map(int, input().split()))\n\ndp = [[[float('inf') for c in range(m+1)] for j in range(k+1)] for i in range(n+1)]\n\nfor i in range(1, n+1):\n    costs = list(map(int, input().split()))\n    if col[i-1] == 0:\n        for j in range(1, k+1):\n            for c in range(1, m+1):\n                if j == 1:\n                    dp[i][j][c] = costs[c-1]\n                else:\n                    for cc in range(1, m+1):\n                        if c != cc:\n                            dp[i][j][c] = min(dp[i][j][c], dp[i-1][j-1][cc] + costs[c-1])\n    else:\n        c = col[i-1]\n        for j in range(1, k+1):\n            if j == 1:\n                dp[i][j][c] = 0\n            else:\n                for cc in range(1, m+1):\n                    if c != cc:\n                        dp[i][j][c] = min(dp[i][j][c], dp[i-1][j-1][cc])\n            \nans = float('inf')\nfor c in range(1, m+1):\n    ans = min(ans, dp[n][k][c])\n    \nprint(ans if ans != float('inf') else -1)"
 ],
 "1710": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\ncount = 0\nfor i in range(n):\n    prod = a[i]\n    summ = a[i]\n    if prod == k*summ:\n        count += 1\n    for j in range(i+1,n):\n        prod *= a[j]\n        summ += a[j]\n        if prod == k*summ:\n            count += 1\n\nprint(count)"
 ],
 "1711": [
  "MOD = 998244353\n\ndef C(n, k):\n    numerator = 1\n    for i in range(n, n - k, -1):\n        numerator = (numerator * i) % MOD\n    denominator = 1\n    for i in range(1, k + 1):\n        denominator = (denominator * i) % MOD\n    inv_denominator = pow(denominator, MOD - 2, MOD)\n    return (numerator * inv_denominator) % MOD\n\nn, m = map(int, input().split())\nans = C(m, n - 1) * C(n - 2, n - 1) % MOD * (n - 2) % MOD * pow(2, n - 3, MOD) % MOD\n\nprint(ans)"
 ],
 "1712": [
  "import math\n\nn, x, y = map(int, input().split())\n\nfor i in range(n):\n    a = int(input())\n    time_vanya = a / x\n    time_vova = a / y\n    total_time = time_vanya + time_vova\n    gcd = math.gcd(x, y)\n    cycle_length = (x // gcd) * y\n    if total_time % cycle_length == 0:\n        print('Both')\n    else:\n        last_hit_time = cycle_length * (total_time // cycle_length)\n        if time_vanya > last_hit_time % x:\n            print('Vova')\n        elif time_vova > last_hit_time % y:\n            print('Vanya')\n        else:\n            print('Both')"
 ],
 "1713": [
  "n, s, t = map(int, input().split())\np = list(map(int, input().split()))\n\ni = s\nans = 0\nwhile i != t:\n    i = p[i-1]\n    ans += 1\n    if ans > n:\n        ans = -1\n        break\n\nprint(ans)"
 ],
 "1714": [
  "n,k=map(int,input().split())\nif k==0:\n    for i in range(1,n+1):\n        print(i,i+n,end=' ')\nelse:\n    print(2*k,1,2*n,end=' ')\n    pos=2\n    for i in range(n-k):\n        print(pos,pos+2,end=' ')\n        pos+=2\n    for i in range(k):\n        print(pos+1,pos,pos+2,end=' ')\n        pos+=2"
 ],
 "1715": [
  "import bisect\nINF = float('inf')\n\n# Reading input\nA, B, Q = map(int, input().split())\ns = [int(input()) for _ in range(A)]\nt = [int(input()) for _ in range(B)]\nx = [int(input()) for _ in range(Q)]\n\ns = [-INF] + s + [INF]      # Adding -inf and +inf to s and t\nt = [-INF] + t + [INF]\n\n# answer queries\nfor xi in x:\n    ans = INF\n    seis, teis = bisect.bisect_right(s, xi), bisect.bisect_right(t, xi)\n    swes, twes = seis-1, teis-1\n\n    # for each case\n    for shrine in [s[swes], s[seis]]:\n        for temple in [t[twes], t[teis]]:\n            # caluculating minimum distance\n            d1 = abs(shrine-xi) + abs(shrine-temple)\n            d2 = abs(temple-xi) + abs(shrine-temple)\n            ans = min(ans, d1, d2)\n    print(ans)"
 ],
 "1716": [
  "n, m, q = map(int, input().split())\n\n# Creating a list of trains with their start and end points\ntrains = []\nfor i in range(m):\n    l, r = map(int, input().split())\n    trains.append((l, r))\n\n# Sorting the trains by their start points for efficient search\ntrains = sorted(trains)\n\n# Looping through each query and counting the number of trains\nfor i in range(q):\n    p, q = map(int, input().split())\n    count = 0\n    for j in range(m):\n        if p <= trains[j][0] and trains[j][1] <= q:\n            count += 1\n    print(count)"
 ],
 "1717": [
  "n = int(input())\nans = n\nfor i in range(2, n+1):\n    while ans % i != 1:\n        ans += n\nprint(ans)"
 ],
 "1718": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\ncnt = 0\nfor i in range(n-k+1):\n    if a[i] < a[i+k-1]:\n        cnt += 1\nprint(cnt + 1)"
 ],
 "1719": [
  "m=10**9+7;S=((['TTT','TAT','TCT','TGT','CTT','ATT','GTT','TTC','TAC','TCG','TCC','TCG','TCA','TAA','TGA','TAG']+['ACA'+i for i in ['T','G','C']]+['AC'+i+'C' for i in ['T','G','C']]+['AG'+i+'C' for i in ['T','A','C','G']]).count);dp=[[[0]*4 for i in range(4)]for j in range(4)];dp[3][0][0]=dp[0][3][0]=dp[3][0][3]=1;for i in range(N-3):ndp=[[[0]*4 for i in range(4)]for j in range(4)];for u in range(4):for v in range(4):for w in range(4):for x in range(4):if v==0 and w==2 and x==1:continue;if v==2 and w==0 and x==1:continue;if v==0 and w==1 and x==2:continue;if u==0 and w==2 and x==1:continue;if u==0 and v==2 and x==1:continue;ndp[v][w][x]+=dp[u][v][w];ndp[v][w][x]%=m;dp=ndp;res=0;for i in range(4):for j in range(4):for k in range(4):res+=dp[i][j][k];res%=m;print((pow(4,N)-res)%m)"
 ],
 "1720": [
  "from collections import deque\n\nn, m, k = map(int, input().split())\n\ngrid = []\nfor i in range(n):\n    row = input().strip()\n    grid.append(row)\n\nx1, y1, x2, y2 = map(int, input().split())\nx1, y1, x2, y2 = x1-1, y1-1, x2-1, y2-1 # convert to 0-indexing\n\ndist = [[-1]*m for _ in range(n)]\ndist[x1][y1] = 0\n\nqueue = deque([(x1, y1)])\nwhile queue:\n    x, y = queue.popleft()\n    for dx, dy in [(1,0),(-1,0),(0,1),(0,-1)]:\n        for i in range(1, k+1):\n            nx, ny = x+dx*i, y+dy*i\n            if nx<0 or nx>=n or ny<0 or ny>=m: # out of bounds\n                break\n            if grid[nx][ny] == \"#\": # obstacle\n                break\n            if dist[nx][ny] != -1: # already visited\n                continue\n            dist[nx][ny] = dist[x][y] + 1\n            if (nx, ny) == (x2, y2):\n                print(dist[nx][ny])\n                exit()\n            queue.append((nx, ny))\n\nprint(-1) # destination not reached"
 ],
 "1721": [
  "n = int(input())\ns = input()\nswaps = 0\n\nfor i in range(n//2):\n   if s[i] != s[n-i-1]:\n      left = s[:i] + s[n-i-1] + s[i+1:n-i-1] + s[i]\n      right = s[:n-i-1] + s[i] + s[n-i:]\n      if left.count(s[n-i-1]) >= right.count(s[n-i-1]):\n         s = left\n         swaps += right.count(s[i])\n      else:\n         s = right\n         swaps += left.count(s[n-i-1])\n            \nprint(swaps)"
 ],
 "1722": [
  "from collections import defaultdict\nn=int(input())\nld=defaultdict(int)\nfor i in range(n):\n    cnt=input().strip()\n    ld[cnt[0]]+=1\na=ld.values()\nans = 0\nfor i in a:\n    ans+=i*(i-1)//2\nprint(ans)"
 ],
 "1723": [
  "n = int(input())\n\nif n == 2:\n    print(\"-1\")\nelse:\n    # Incorrect tree\n    for i in range(1, n):\n        print(i, i+1)\n    # Correct tree\n    for i in range(1, n//2+1):\n        print(i, i+n//2)"
 ],
 "1724": [
  "n = int(input())\na = list(map(int, input().split()))\nm = int(input(), 2)\n\nans = 0\ncurr = 0\nfor i in range(1 << n):\n    if i > m:\n        break\n    curr = sum([a[j] for j in range(n) if i & (1 << j)])\n    ans = max(ans, curr)\nprint(ans)"
 ],
 "1725": [
  "n, m, d = map(int, input().split())\na = []\nfor i in range(n):\n    a.append(list(map(int, input().split())))\n\nvals = set()\nfor i in range(n):\n    for j in range(m):\n        vals.add(a[i][j] % d)\n        \nif len(vals) > 1:\n    print(-1)\nelse:\n    vals = list(vals)[0]\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            count += abs(a[i][j] % d - vals) // d\n    print(count)"
 ],
 "1726": [
  "n, t = map(int, input().split())\nwork = list(map(int, input().split()))\ntotal_work = sum(work)\n\nfor i in range(n):\n    if t <= 0:\n        break\n    t -= (86400 - work[i])\n\nprint(i+1)"
 ],
 "1727": [
  "n = int(input())\ntrees = []\nfor i in range(n):\n    x, h = map(int, input().split())\n    trees.append((x,h))\n    \nans = 2 if n > 1 else 1\nfor i in range(1, n-1):\n    if trees[i-1][0] < trees[i][0]-trees[i][1]:\n        ans += 1\n    elif trees[i][0]+trees[i][1] < trees[i+1][0]:\n        ans += 1\n    else:\n        continue\nif n > 1 and trees[-2][0] < trees[-1][0]-trees[-1][1]:\n    ans += 1\nelse:\n    pass\n\nprint(ans)"
 ],
 "1728": [
  "n=int(input())\np=list(map(int,input().split()))\nc=list(map(int,input().split()))\nadj=[[] for i in range(n)]\nfor i in range(n-1):\n    adj[p[i]-1].append(i+1)\nans=0\ndef dfs(u,col,parent_col):\n    global ans\n    if col!=c[u-1]:\n        col=c[u-1]\n        ans+=1\n    for v in adj[u-1]:\n        if v==parent_col:\n            continue\n        dfs(v,col,u)\ndfs(1,0,0)\nprint(ans)"
 ],
 "1729": [
  "# Reading input\nn, q = map(int, input().split())\ns = input()\n\n# Looping through the queries\nfor i in range(q):\n    l, r = map(int, input().split())\n\n    # Initializing variables\n    dp = 1\n    cp = l - 1\n    counts = [0] * 10\n\n    # Running the program for the specified range\n    while cp >= l - 1 and cp <= r - 1:\n        ch = s[cp]\n\n        # If the character is a digit\n        if ch.isdigit():\n            counts[int(ch)] += 1\n            s = s[:cp] + str(int(ch) - 1) + s[cp + 1:]\n\n            # If the digit becomes 0, remove it from string\n            if int(ch) == 0:\n                s = s[:cp] + s[cp+1:]\n                r -= 1\n                if dp == -1:\n                    cp -= 1\n\n        # If the character is \"<\" or \">\", change direction pointer\n        if ch == \"<\":\n            dp = -1\n            if cp > l - 1 and s[cp-1] in \"<>\":\n                s = s[:cp-1] + s[cp:]\n                if dp == -1:\n                    cp -= 1\n            else:\n                cp += dp\n        elif ch == \">\":\n            dp = 1\n            if cp < r - 1 and s[cp+1] in \"<>\":\n                s = s[:cp+1] + s[cp+2:]\n                cp += dp\n            else:\n                cp += dp\n\n    # Printing the counts for the current query\n    print(\" \".join(map(str, counts)))"
 ],
 "1730": [
  "import sys\n\nn, m, k = map(int, input().split())\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(m):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\nvisited = [False] * (n + 1)\ncycle = []\n\n\ndef dfs(node, parent, depth):\n    visited[node] = True\n    cycle.append(node)\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            if visited[neighbor]:\n                if depth >= k + 1:\n                    cycle.append(neighbor)\n                    print(len(cycle))\n                    print(*cycle)\n                    sys.exit()\n            else:\n                dfs(neighbor, node, depth + 1)\n    cycle.pop()\n\n\nfor i in range(1, n + 1):\n    if not visited[i]:\n        dfs(i, -1, 1)"
 ],
 "1731": [
  "MOD = 10**9+7\nn, m = map(int, input().split())\n\ndp = [[0]*(n+1) for _ in range(m+1)]\nfor i in range(1, n+1):\n    dp[1][i] = 1\n\nfor i in range(2, m+1):\n    for j in range(1, n+1):\n        dp[i][j] = (dp[i][j-1] + dp[i-1][j-1]) % MOD\n\nans = 0\nfor i in range(1, n+1):\n    for j in range(i, n+1):\n        ans = (ans + dp[m][i] * dp[m][n-j+1]) % MOD\n\nprint(ans)"
 ],
 "1732": [
  "n = int(input())\nl = list(map(int, input().split()))\nc = list(map(int, input().split()))\n\npossibles = [0] * (1 << n)\npossibles[0] = 1\n\nfor mask in range(1, 1 << n):\n    max_dist = -1\n    for i in range(n):\n        if mask & (1 << i):\n            if possibles[mask ^ (1 << i)] and max_dist < l[i]:\n                max_dist = l[i]\n                possibles[mask] = possibles[mask ^ (1 << i)]\n    for i in range(n):\n        if mask & (1 << i):\n            if l[i] <= max_dist and possibles[mask ^ (1 << i)]:\n                possibles[mask] = min(possibles[mask], c[i] + possibles[mask ^ (1 << i)])\n\nif possibles[(1 << n) - 1]:\n    print(possibles[(1 << n) - 1])\nelse:\n    print(-1)"
 ],
 "1733": [
  "n, f, b = map(int, input().split()) \ng = [[] for i in range(n + 1)] \nfor i in range(n - 1): \n    x, y = map(int, input().split()) \n    g[x].append(y) \n    g[y].append(x) \nans = n * (n - 1) - (n - 1) \nsz, vis = [0] * (n + 1), [0] * (n + 1) \ndef dfs(x, p): \n    global ans \n    sz[x] = 1 \n    vis[x] = 1 \n    for v in g[x]: \n        if v == p: continue \n        dfs(v, x) \n        sz[x] += sz[v] \n    if x == f: \n        ans -= sz[b] \n    if x == b: \n        ans -= sz[f] \ndfs(f, 0) \nprint(ans)"
 ],
 "1734": [
  "n = int(input())\ncontacts = []\nfor i in range(n):\n    contacts.append(input())\n\ndef get_shortest_sequence(contact):\n    for i in range(1, 10):\n        for j in range(10-i):\n            subsequence = contact[j:j+i]\n            matches = 0\n            for c in contacts:\n                if subsequence in c:\n                    matches += 1\n            if matches == 1:\n                return subsequence\n\nfor c in contacts:\n    print(get_shortest_sequence(c))"
 ],
 "1735": [
  "s = input()\nstack = []\nfor c in s:\n    if stack and stack[-1] == c:\n        stack.pop()\n    else:\n        stack.append(c)\nif len(stack) % 2 == 1:\n    print(\"Yes\")\nelse:\n    print(\"No\")"
 ],
 "1736": [
  "n, t = map(int, input().split())\na = list(map(int, input().split()))\n\nleft, right = 0, 0\ntotal_time = 0\nmax_books = 0\n\nwhile right < n:\n    total_time += a[right]\n    while total_time > t:\n        total_time -= a[left]\n        left += 1\n    max_books = max(max_books, right - left + 1)\n    right += 1\n\nprint(max_books)"
 ],
 "1737": [
  "from collections import deque\n\nn = int(input())\nprojects = {}\nfor i in range(n):\n    name, version = input().split()\n    projects[name+version] = {'deps': set(), 'dist': float('inf'), 'actual': '', 'name': name, 'version': int(version)}\n\n# add dependencies\nfor i in range(n):\n    name, version = input().split()\n    p = projects[name+version]\n    k = len(projects)\n    for j in range(int(input())):\n        name, version = input().split()\n        q = projects[name+version]\n        p['deps'].add(name+version)\n        if j == 0:\n            q['deps'].add(name+version+str(k))\n            projects[name+version+str(k)] = {'deps': set(), 'dist': float('inf'), 'actual': '', 'name': name, 'version': int(version)}\n\n# calculate distances\nstart = next(iter(projects))\nprojects[start]['dist'] = 0\nqueue = deque([start])\nwhile queue:\n    cur = queue.popleft()\n    for dep in projects[cur]['deps']:\n        if dep not in projects:\n            continue\n        dist = projects[cur]['dist'] + 1\n        if dist < projects[dep]['dist']:\n            projects[dep]['dist'] = dist\n            queue.append(dep)\n\n# find actual dependencies\nactual_deps = set()\nfor key, val in sorted(projects.items()):\n    if val['dist'] == float('inf'):\n        continue\n    if val['name'] == projects[start]['name'] and val['version'] == projects[start]['version']:\n        continue\n    if val['name']+str(val['version']) not in actual_deps:\n        actual_deps.add(val['actual'])\n        if (val['name']+str(val['version'])) in projects[start]['deps']:\n            projects[start]['deps'].remove(val['name']+str(val['version']))\n        for dep in val['deps']:\n            dep_val = projects[dep]\n            if dep_val['name']+str(dep_val['version']) != val['name']+str(val['version']):\n                actual_deps.discard(dep_val['name']+str(dep_val['version']))\n            elif val['dist'] < dep_val['dist']:\n                actual_deps.discard(dep)\n            else:\n                actual_deps.discard(val['name']+str(val['version']))\n                actual_deps.add(dep)\n                val['actual'] = dep\n                dep_val['actual'] = dep\n\n# output actual dependencies\nprint(len(actual_deps))\nfor dep in sorted(actual_deps):\n    print(dep)"
 ],
 "1738": [
  "s = input()\nn = len(s)\ndp = [n]*(n+1)\ndp[0] = 0\nfor i in range(n):\n    for j in range(i, n):\n        sub = s[i:j+1]\n        cnt = str(j-i+1)\n        l = len(cnt) + len(sub)\n        if i-int(cnt)+1 >= 0 and s[i-int(cnt)+1:i+1] == sub*int(cnt):\n            l = len(cnt)+2\n        dp[j+1] = min(dp[j+1], dp[i]+l)\nprint(dp[-1])"
 ],
 "1739": [
  "from math import gcd\nmod = 1000000007\n\nn, x = map(int, input().split())\na = list(map(int, input().split()))\nt = sum([pow(x, a[i], mod) for i in range(n)]) % mod\ns = sum([t // pow(x, a[i], mod) for i in range(n)]) % mod\nans = gcd(s, t)\nprint(ans)"
 ],
 "1740": [
  "n = int(input())\nparent = [i for i in range(n+1)]\n\ndef find(x):\n    if parent[x] != x:\n        parent[x] = find(parent[x])\n    return parent[x]\n\nfor i in range(n-1):\n    x, y = map(int, input().split())\n    parent[find(x)] = find(y)\n\nrepresentatives = {}\nfor i in range(1, n+1):\n    rep = find(i)\n    if rep in representatives:\n        representatives[rep].append(i)\n    else:\n        representatives[rep] = [i]\n\nfor rep in representatives:\n    kittens = representatives[rep]\n    for i in range(len(kittens)):\n        print(kittens[i], end=\" \")"
 ],
 "1741": [
  "from math import sqrt\n\nn = int(input())\nx = []\ny = []\nfor i in range(n):\n    xi, yi = map(int, input().split())\n    x.append(xi)\n    y.append(yi)\n\n# check if it's possible to build a reserve\nif max(y) <= 0 or min(y) >= 0:\n    print(-1)\nelse:\n    left = 0\n    right = 1e7\n    while right - left > 1e-6:\n        mid = (left + right) / 2\n        \n        # check if there is at least one common point with the river\n        top = -1e7\n        bottom = 1e7\n        for i in range(n):\n            d = sqrt(mid**2 - y[i]**2)\n            if d + x[i] >= top:\n                top = d + x[i]\n            if x[i] - d <= bottom:\n                bottom = x[i] - d\n        if top >= bottom:\n            right = mid\n        else:\n            left = mid\n            \n    print(\"{:.7f}\".format(left))"
 ],
 "1742": [
  "n, m = map(int, input().split())\np = list(map(int, input().split()))\n# create adjacency list\nadj = {i: [] for i in range(1, n + 1)}\nfor _ in range(m):\n    u, v = map(int, input().split())\n    adj[u].append(v)\n# apply greedy approach\nans = 0\ncur = n\nwhile cur > 1:\n    found = False\n    for nxt in adj[p[cur - 2]]:  # check all possible swaps\n        if nxt == p[cur - 1]:\n            found = True\n            break\n    if found:\n        ans += 1\n        cur -= 1\n    else:\n        p[cur - 2], p[cur - 1] = p[cur - 1], p[cur - 2]\n        cur -= 1\nprint(ans)"
 ],
 "1743": [
  "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\n\ndp1 = [0] * n\ndp2 = [0] * n\ndp3 = [0] * n\n\ndp1[0] = a[0]\ndp2[0] = b[0]\ndp3[0] = c[0]\n\nfor i in range(1, n):\n    dp1[i] = max(dp2[i-1], dp3[i-1]) + a[i]\n    dp2[i] = max(dp1[i-1], dp3[i-1]) + b[i]\n    dp3[i] = max(dp1[i-1], dp2[i-1], dp3[i-1]) + c[i]\n\nprint(max(dp1[n-1], dp2[n-1], dp3[n-1]))"
 ],
 "1744": [
  "n, M = map(int, input().split())\nt = list(map(int, input().split()))\n\nsum_t = [t[0]]\nfor i in range(1, n):\n    sum_t.append(sum_t[i-1] + t[i])\n\nans = []\nfor i in range(n):\n    l, r = 0, n-i-1\n    res = n-i-1\n\n    while l <= r:\n        mid = (l+r)//2\n        if sum_t[i+mid] - (sum_t[i-1] if i!=0 else 0) + (mid+1)*t[i+mid] <= M:\n            res = mid\n            l = mid+1\n        else:\n            r = mid-1\n            \n    ans.append(res)\n\nprint(*ans)"
 ],
 "1745": [
  "n, m = map(int, input().split())\n\n# read the city map\ncity_map = []\nfor i in range(n):\n    row = input().strip()\n    city_map.append(row)\n\n# initialize dp array\ndp = [[[[0 for _ in range(4)] for _ in range(4)] for _ in range(m)] for _ in range(n)]\n\n# base case\nfor i in range(n):\n    for j in range(m):\n        if city_map[i][j] == '#':\n            continue\n        if i == 0 or j == 0 or i == n-1 or j == m-1:\n            dp[i][j][0][0] = 1\n\n# recurrence relation\nfor i in range(n):\n    for j in range(m):\n        if city_map[i][j] == '#':\n            continue\n        for d in range(4):\n            for t in range(4):\n                for k in range(1, min(n, m)):\n                    if d == 0:\n                        # move down\n                        if i+k < n and city_map[i+k][j] == '.':\n                            if t == 0:\n                                dp[i+k][j][1][t] += dp[i][j][d][t]\n                            elif t == 1:\n                                dp[i+k][j][1][t] += dp[i][j][d][t]\n                            elif t == 2:\n                                continue\n                            else:\n                                dp[i+k][j][1][t] += dp[i][j][d][t]\n                        else:\n                            break\n                    elif d == 1:\n                        # move right\n                        if j+k < m and city_map[i][j+k] == '.':\n                            if t == 0:\n                                continue\n                            elif t == 1:\n                                dp[i][j+k][2][t] += dp[i][j][d][t]\n                            elif t == 2:\n                                dp[i][j+k][2][t] += dp[i][j][d][t]\n                            else:\n                                dp[i][j+k][2][t] += dp[i][j][d][t]\n                        else:\n                            break\n                    elif d == 2:\n                        # move up\n                        if i-k >= 0 and city_map[i-k][j] == '.':\n                            if t == 0:\n                                dp[i-k][j][3][t] += dp[i][j][d][t]\n                            elif t == 1:\n                                continue\n                            elif t == 2:\n                                dp[i-k][j][3][t] += dp[i][j][d][t]\n                            else:\n                                dp[i-k][j][3][t] += dp[i][j][d][t]\n                        else:\n                            break\n                    else:\n                        # move left\n                        if j-k >= 0 and city_map[i][j-k] == '.':\n                            if t == 0:\n                                dp[i][j-k][0][t] += dp[i][j][d][t]\n                            elif t == 1:\n                                dp[i][j-k][0][t] += dp[i][j][d][t]\n                            elif t == 2:\n                                dp[i][j-k][0][t] += dp[i][j][d][t]\n                            else:\n                                continue\n                        else:\n                            break\n\n# sum up the results\ntotal = 0\nfor i in range(n):\n    for j in range(m):\n        if city_map[i][j] == '.':\n            for d in range(4):\n                if (i == 0 or j == 0 or i == n-1 or j == m-1) and d != 0 and d != 2:\n                    continue\n                for t in range(4):\n                    if dp[i][j][d][t] > 0:\n                        total += 1\n\nprint(total)"
 ],
 "1746": [
  "n = int(input())\nadj = [[] for _ in range(n)]\nfor i in range(1, n):\n    p = int(input())-1\n    adj[p].append(i)\n\ndef dfs(node):\n    count_leaves = 0\n    for child in adj[node]:\n        count_leaves += dfs(child)\n    if len(adj[node]) == 0:\n        return 1\n    elif count_leaves < 3:\n        print(\"No\")\n        exit()\n    else:\n        return 0\n\ndfs(0)\nprint(\"Yes\")"
 ],
 "1747": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\nleft = 0\nright = 0\nmax_length = 0\nmax_left = 0\n\ncount = [0] * (10**6 + 1)\n\nwhile right < n:\n    count[a[right]] += 1\n    \n    while len(set(a[left:right+1])) > k:\n        count[a[left]] -= 1\n        left += 1\n    \n    segment_length = right - left + 1\n    if segment_length > max_length:\n        max_length = segment_length\n        max_left = left\n    \n    right += 1\n\nprint(max_left + 1, max_left + max_length)"
 ],
 "1748": [
  "n = int(input())\nv = list(map(int, input().split()))\nt = list(map(int, input().split()))\nmelted = [0] * n\nfor i in range(n):\n    total_melted = 0\n    for j in range(i - 1, -1, -1):\n        volume = v[j] - total_melted\n        if volume <= 0:\n            break\n        melted_on_day = min(volume, t[i])\n        total_melted += melted_on_day\n        melted[i] += melted_on_day\nprint(*melted)"
 ],
 "1749": [
  "n, l, r = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nif sorted(a[l-1:r]) == sorted(b[l-1:r]):\n    print(\"TRUTH\")\nelse:\n    print(\"LIE\")"
 ],
 "1750": [
  "n=int(input())\ng=[[] for i in range(n)]\nfor i in range(n-1):\n    u,v=map(int,input().split())\n    u-=1\n    v-=1\n    g[u].append(v)\n    g[v].append(u)\nans=[0]*n\nvis=[False]*n\ndef dfs(cur,parent,col):\n    vis[cur]=True\n    cur_col=1\n    for i in g[cur]:\n        if i!=parent:\n            if cur_col==col: cur_col+=1\n            if cur_col==ans[parent] or cur_col==col: cur_col+=1\n            ans[i]=cur_col\n            dfs(i,cur,cur_col)\n            cur_col+=1\n    return\nans[0]=1\ndfs(0,0,1)\nprint(max(ans))\nprint(*ans)"
 ],
 "1751": [
  "MOD = int(1e9) + 7\n\n# Multiplication inverse of each number factorial and their factorial inversed\nfact_inv = [1, 1]\nfor i in range(2, 2+10**6):\n    fact_inv.append((MOD - (MOD // i) * fact_inv[MOD % i] % MOD) % MOD)\n\nfactorial = [1]\nfor i in range(1, 2+10**6):\n    factorial.append(i * factorial[-1] % MOD)\n\n# A function to calculate the cycle number of a composite graph\ndef cycle_mnozgraf(num_of_nodes):\n    if num_of_nodes == 0: return 1\n    result = 0\n    for j in range(num_of_nodes % 2, num_of_nodes, 2):\n        temp = (factorial[num_of_nodes - 1] * fact_inv[j] % MOD * fact_inv[(num_of_nodes - j - 1) // 2] % MOD * pow(2, (num_of_nodes - j - 1) // 2, MOD)) % MOD\n        temp = temp * pow(j + 2, j // 2, MOD) % MOD\n        result = (result + temp) % MOD\n    return result\n\nn = int(input())\nprint(factorial[n] * (n - 1 - cycle_mnozgraf(n - 1)) % MOD)"
 ],
 "1752": [
  "n = int(input())\na = list(map(int, input().split()))\n\na_sorted = sorted(a)\nans = [0] * n\nlow, high = 0, n-1\nfor i in range(n):\n    if i % 2 == 0:\n        ans[i] = a_sorted[low]\n        low += 1\n    else:\n        ans[i] = a_sorted[high]\n        high -= 1\nprint(*ans)"
 ],
 "1753": [
  "from collections import deque\n \nn, m = map(int, input().split())\n \ng = [[] for _ in range(n)]\nfor i in range(m):\n    a, b = map(int, input().split())\n    a, b = a-1, b-1\n    g[a].append(b)\n    g[b].append(a)\n \ns = [[] for _ in range(n)]\n \nfor root in range(n):\n    c = [-1] * n\n     \n    q = deque([root])\n    c[root] = root\n \n    while q:\n        v = q.popleft()\n        for u in g[v]:\n            if c[u] == -1:\n                c[u] = root\n                q.append(u)\n \n    for i in range(n):\n        if c[i] != root:\n            s[root].append(i)\n     \nrooks = [[] for _ in range(n)] \n     \nfor color in range(n):\n    for v in s[color]:\n        added = False\n        for i in range(len(rooks[color])):\n            u = rooks[color][i]\n            if u[0] == v+1 or u[1] == v+1:\n                added = True\n                break\n            elif u[0] > v+1 and u[1] > v+1:\n                rooks[color].insert(i, (v+1, v+2))\n                added = True\n                break\n        if not added:\n            rooks[color].append((v+1, 1))\n     \nfor color in range(n):\n    print(len(rooks[color]))\n    for r in rooks[color]:\n        print(r[0], r[1])"
 ],
 "1754": [
  "n, m, k = map(int, input().split())\npowers = list(map(int, input().split()))\nschools = list(map(int, input().split()))\nchosen_ones = set(map(int, input().split()))\n\nschool_powers = [set() for _ in range(m)]\nchosen_one_powers = []\n\nfor i in range(n):\n    school_powers[schools[i]-1].add(powers[i])\n    if i+1 in chosen_ones:\n        chosen_one_powers.append(powers[i])\n\nchosen_one_powers.sort(reverse=True)\n\nnum_made_up_schools = 0\nfor i in range(k):\n    if not school_powers[schools[chosen_ones[i]-1]-1].issuperset(chosen_one_powers[i:num_made_up_schools+i]):\n        num_made_up_schools += 1\nprint(num_made_up_schools)"
 ],
 "1755": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\nb = set(map(int, input().split()))\n\nif k == 0:\n    print(sum(a[i] >= a[i+1] for i in range(n-1)))\nelse:\n    inf = 10**18\n    ans = 0\n    segs = []\n    cur = []\n    for i in range(n):\n        if i+1 not in b:\n            if cur and cur[-1][1] == i-1:\n                cur[-1][1] = i\n            else:\n                cur.append([i, i])\n        elif cur:\n            segs.append(cur)\n            cur = []\n    if cur:\n        segs.append(cur)\n    for seg in segs:\n        l, r = seg[0][0], seg[-1][1]\n        L, R = inf, -inf\n        for i in range(l, r+1):\n            L = min(L, a[i])\n            R = max(R, a[i])\n        if L == R:\n            continue\n        cnt1 = cnt2 = 0\n        for i in range(l):\n            if a[i] >= L:\n                cnt1 += 1\n            if a[i] >= R:\n                cnt2 += 1\n        for i in range(r+1, n):\n            if a[i] <= R:\n                cnt1 += 1\n            if a[i] <= L:\n                cnt2 += 1\n        ans += min(cnt1, cnt2)\n    print(ans)"
 ],
 "1756": [
  "n, x = map(int, input().split())\nd = list(map(int, input().split()))\n\n# Convert the list of month days into a list of accumulating days so we can easily find the day number for a specific month and day.\nacc_days = [0]\nfor i in range(n):\n    acc_days.append(acc_days[-1] + d[i])\n\n# Initialize the maximum number of hugs to 0\nmax_hugs = 0\n\n# Loop through all possible starting days for our vacation\nfor start_day in range(1, acc_days[-1] + 1):\n    # Calculate the ending day of our vacation\n    end_day = start_day + x - 1\n    \n    # Find the starting and ending months for our vacation using binary search\n    start_month = bisect.bisect_right(acc_days, start_day) - 1\n    end_month = bisect.bisect_right(acc_days, end_day) - 1\n    \n    # Calculate the number of hugs we would get if we started on this day\n    hugs = sum(range(1, min(d[start_month] - start_day + 1, x) + 1)) + \\\n           sum(range(1, min(d[end_month], end_day - acc_days[end_month]) + 1))\n    if end_month - start_month > 0:\n        hugs += sum(d[start_month+1:end_month])\n    \n    # Update the maximum number of hugs if this day gives us more hugs than the previous maximum\n    max_hugs = max(max_hugs, hugs)\n    \n# Print the maximum number of hugs\nprint(max_hugs)"
 ],
 "1757": [
  "n = int(input())\n\na, b = 1, 1\nfib = [a, b]\n\nwhile b <= n:\n    a, b = b, a+b\n    fib.append(b)\n\nname = \"\"\nfor i in range(1, n+1):\n    if i in fib:\n        name += \"O\"\n    else:\n        name += \"o\"\n\nprint(name)"
 ],
 "1758": [
  "n = int(input())\ns = input()\nt = input()\n\nif s.count('1') != t.count('1'):\n    print(-1)\nelse:\n    diffs = []\n    for i in range(n):\n        if s[i] != t[i]:\n            if s[i] == '1':\n                diffs.append(1)\n            else:\n                diffs.append(-1)\n    pref_sum = [0] * (n+1)\n    for i in range(n):\n        pref_sum[i+1] = pref_sum[i] + diffs[i]\n    ans = abs(sum(diffs))\n    max_pref_sum = [0] + [pref_sum[i] for i in range(n) if pref_sum[i] > 0]\n    for i in range(len(max_pref_sum)):\n        l, r = 0, len(max_pref_sum)-1\n        while l < r:\n            mid = (l+r)//2\n            if max_pref_sum[mid] < max_pref_sum[i]:\n                l = mid+1\n            else:\n                r = mid\n        ans = min(ans, len(max_pref_sum)-(i-l) + max_pref_sum[i])\n    print(ans)"
 ],
 "1759": [
  "m, n = map(int, input().split())\npictures = []\nfor i in range(m):\n    pictures.append(list(map(int, input().split())))\n\ntimings = [0] * m\nfor i in range(n):\n    curr_time = 0\n    for j in range(m):\n        curr_time = max(curr_time, timings[j])\n        timings[j] = curr_time + pictures[j][i]\nprint(*timings)"
 ],
 "1760": [
  "n = int(input())\ns = input()\ntimes = [0]*n\n \nfor i in range(n):\n    if s[i] == 'U':\n        times[i] = i*2 + n-i-1\n    else:\n        times[i] = (i+1)*2 + n-i-2\n \nfor time in times:\n    print(time)"
 ],
 "1761": [
  "n = int(input())\nwords = [input() for i in range(n)]\nmsg = input()\n\ncode = \"<3\" + \"<3\".join(words) + \"<3\"\nfor c in msg:\n    if code and c == code[0]:\n        code = code[1:]\nif not code:\n    print(\"yes\")\nelse:\n    print(\"no\")"
 ],
 "1762": [
  "import heapq\nn, k = map(int, input().split())\nq, ans = [], []\nfor i in range(n):\n    s, m = map(int, input().split())\n    while q and q[0] <= s:\n        heapq.heappop(q)\n    if len(q) < k:\n        if not q:\n            t = s + m*60\n            ans.append(t)\n        else:\n            t = max(s, q[-1]) + m*60\n            ans.append(t)\n        heapq.heappush(q, t)\n    else:\n        ans.append(-1)\nprint(*ans)"
 ],
 "1763": [
  "python\nn, a, r, m = map(int, input().split())\nh = list(map(int, input().split()))\ns = sum(h)\navg = s // n\nrest = s - (avg * n)\n\ncost1 = r * n\ncost2 = a * rest\ncost3 = min(r*rest+a*(n-rest), m*rest)\n\nprint(min(cost1, cost2+cost3))"
 ],
 "1764": [
  "from bisect import bisect_left\nn = int(input())\na = list(map(int, input().split()))\n\npref = [[0] * (n + 1) for _ in range(3)]\nfor i in range(1, n + 1):\n    for j in range(3):\n        pref[j][i] = pref[j][i-1] + int(a[i-1] == j)\n\ns, t = [], []\nfor ss in range(1, n+1):\n    if n % ss != 0:\n        continue\n    tk = n // ss\n    c1 = pref[1][n]\n    c2 = pref[2][n]\n\n    ok = True\n    while tk > 0:\n        c1_base = bisect_left(pref[1], c1 // tk + 1)\n        c2_base = bisect_left(pref[2], c2 // tk + 1)\n        mx_base = max(c1_base, c2_base)\n        if mx_base == ss:\n            break\n        ok = False\n        if mx_base == c1_base:\n            c1 = pref[1][mx_base * tk]\n        if mx_base == c2_base:\n            c2 = pref[2][mx_base * tk]\n        tk -= 1\n\n    if ok:\n        s.append(ss)\n        t.append(n // ss)\n\nprint(len(s))\nfor i, j in zip(s, t):\n    print(i, j)"
 ],
 "1765": [
  "n = int(input())\na = list(map(int, input().split()))\nmax_num = max(a)\nv = 0\nfor i in range(n):\n    if a[i] & (a[i]-1):\n        v = max(v, (a[i] ^ (a[i]-1)).bit_length()-1)\nb = []\nfor i in range(n):\n    if a[i] & (1<<v):\n        b.append(a[i])\nif len(b) == 0:\n    b.append(max_num)\nprint(len(b))\nprint(*b)"
 ],
 "1766": [
  "n = int(input())\ncards = list(map(int, input().split()))\nsereja_score = 0\ndima_score = 0\nleft_index = 0\nright_index = n-1\n\nfor i in range(n):\n    if i % 2 == 0:\n        if cards[left_index] > cards[right_index]:\n            sereja_score += cards[left_index]\n            left_index += 1\n        else:\n            sereja_score += cards[right_index]\n            right_index -= 1\n    else:\n        if cards[left_index] > cards[right_index]:\n            dima_score += cards[left_index]\n            left_index += 1\n        else:\n            dima_score += cards[right_index]\n            right_index -= 1\n\nprint(sereja_score, dima_score)"
 ],
 "1767": [
  "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nmax_sum = 0\n\nfor l in range(n):\n    for r in range(l, n):\n        f_a = a[l] | a[l+1:r+1]\n        f_b = b[l] | b[l+1:r+1]\n        max_sum = max(max_sum, f_a + f_b)\n\nprint(max_sum)"
 ],
 "1768": [
  "n = int(input())\ns = input()\nq = int(input())\n\n# precompute the count of each letter up to each index\ncounts = [[0] * 26 for _ in range(n+1)]\nfor i in range(1, n+1):\n    letter = ord(s[i-1]) - ord('a')\n    counts[i] = counts[i-1][:]\n    counts[i][letter] += 1\n\n# function to calculate the Koyomity for a given character and range\ndef koyomity(l, r, c):\n    return counts[r][c] - counts[l-1][c]\n\n# function to calculate the maximum Koyomity for a given plan\ndef max_koyomity(m, c):\n    max_len = 0\n    for i in range(n):\n        count = [0] * 26\n        for j in range(i, min(n, i+m)):\n            letter = ord(s[j]) - ord('a')\n            if letter == ord(c) - ord('a'):\n                count[letter] += 1\n            else:\n                count[letter] += 1\n                if count[letter] > m:\n                    break\n            length = j-i+1\n            if length > max_len and count[ord(c) - ord('a')] == length:\n                max_len = length\n    return max_len\n\n# process each plan and output the answer\nfor i in range(q):\n    m, c = input().split()\n    m = int(m)\n    print(max_koyomity(m, c))"
 ],
 "1769": [
  "a = int(input())\nb = int(input())\nn = a + b + 1\n\ndownhill = list(range(2, b+2))\nuphill = list(range(n, n-a-1, -1))\n\nif a == 0:\n    print(*downhill)\nelse:\n    print(*uphill, *downhill)"
 ],
 "1770": [
  "t = int(input())\nfor _ in range(t):\n    n, x, y, d = map(int, input().split())\n    dist = abs(y-x)\n    if dist % d == 0:\n        print(dist // d)\n    else:\n        to_left = x-1\n        to_right = n-x\n        if to_left % d == 0 and to_right % d == 0:\n            print(min(to_left // d + dist // d + (1 if dist % d != 0 else 0), to_right // d + dist // d + (1 if dist % d != 0 else 0)))\n        elif to_left % d == 0:\n            print(to_left // d + dist // d + (1 if dist % d != 0 else 0))\n        elif to_right % d == 0:\n            print(to_right // d + dist // d + (1 if dist % d != 0 else 0))\n        else:\n            print(-1)"
 ],
 "1771": [
  "n, l, w_max = map(int, input().split())\nclouds = []\nfor i in range(n):\n    x_i, v_i = map(int, input().split())\n    clouds.append((x_i, v_i))\n\ndef check(t):\n    left_pos = []\n    right_pos = []\n    for i in range(n):\n        pos = clouds[i][0] + t * clouds[i][1]\n        if pos < 0:\n            left_pos.append(pos)\n        else:\n            right_pos.append(pos)\n    if len(left_pos) < 2 or len(right_pos) < 2:\n        return False\n    left_pos.sort()\n    right_pos.sort()\n    l_index = r_index = 0\n    while l_index < len(left_pos) and r_index < len(right_pos):\n        delta_pos = right_pos[r_index] - left_pos[l_index]\n        if delta_pos < l:\n            r_index += 1\n            continue\n        if delta_pos > l:\n            l_index += 1\n            continue\n        return True\n    return False\n\ncount = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        left_cloud = clouds[i]\n        right_cloud = clouds[j]\n        if left_cloud[1] == right_cloud[1]:\n            continue\n        left_bigger = left_cloud[1] > right_cloud[1]\n        \n        left_pos = left_cloud[0] + 0.0 if left_bigger else left_cloud[0] + l * 1.0\n        right_pos = right_cloud[0] + l * 1.0 if left_bigger else right_cloud[0] + 0.0\n        \n        delta_pos = right_pos - left_pos\n        if delta_pos > l:\n            continue\n        if delta_pos == l:\n            count += 1\n            continue\n        left_v, right_v = left_cloud[1], right_cloud[1]\n        if left_bigger:\n            left_v *= -1\n        else:\n            right_v *= -1\n        left_w = w_max * left_v / (left_v + right_v)\n        right_w = w_max * right_v / (left_v + right_v)\n        if check(left_w) or check(right_w):\n            count += 1\n\nprint(count)"
 ],
 "1772": [
  "n = int(input())\nbouquets = list(map(int, input().split()))\n\nodd = 0\neven = 0\nfor b in bouquets:\n    if b % 2 == 0:\n        even += 1\n    else:\n        odd += 1\nif odd > even:\n    odd, even = even, odd\nprint(odd)"
 ],
 "1773": [
  "n = int(input())\ntrees = []\nfor i in range(n):\n    trees.append(tuple(map(int, input().split())))\ntrees = sorted(trees, key=lambda x: abs(x[0]))\n\napples_collected = 0\nvisited = set()\ndirection = 1 if trees[0][0] > 0 else -1\n\nfor tree in trees:\n    if abs(tree[0]) not in visited:\n        visited.add(abs(tree[0]))\n        apples_collected += tree[1]\n        direction *= -1\n    \nprint(apples_collected)"
 ],
 "1774": [
  "s = input()\nif 'Q' in s:\n    idx = s.index('Q')\n    s1 = s[:idx]\n    s2 = s[idx+1:]\n    if 'H' in (s1+s2):\n        print('Yes')\n    else:\n        print('No')\nelse:\n    print('No')"
 ],
 "1775": [
  "from bisect import bisect_left\nn, m, k = map(int, input().split())\ndroids = [list(map(int, input().split())) for _ in range(n)]\nfreq = [[] for _ in range(m)]\nfor j in range(m):\n    for i in range(n):\n        freq[j].append((droids[i][j], i))\nans = [0] * m\nfor j in range(m):\n    freq[j].sort(reverse=True)\nleft, right = 1, n\nanswer = [0] * m\nwhile left <= right:\n    mid = (left+right)//2\n    current_sum = []\n    for j in range(m):\n        shots = 0\n        for value, index in freq[j]:\n            if mid <= 0: \n                break\n            destroyed = min(mid, value)\n            shots += destroyed\n            mid -= destroyed \n        current_sum.append(shots)\n    if sum(current_sum) <= k:\n        left = mid + 1\n        answer = current_sum[:]\n    else:\n        right = mid - 1\nprint(*answer)"
 ],
 "1776": [
  "exp = input().strip()\nP, M = map(int, input().strip().split())\n\ndef calc(exp, P, M):\n    if len(exp) == 1: # base case, single digit expression\n        return int(exp)\n\n    plus_exp, minus_exp = '', ''\n    depth = 0\n    for i in range(len(exp)):\n        if exp[i] == '(':\n            depth += 1\n        elif exp[i] == ')':\n            depth -= 1\n        elif exp[i] == '?':\n            if P > 0:\n                plus_exp = exp[:i] + '(' + '+' + ')' + exp[i+1:]\n                if depth == 0:\n                    return calc(plus_exp, P-1, M)\n            if M > 0:\n                minus_exp = exp[:i] + '(' + '-' + ')' + exp[i+1:]\n                if depth == 0:\n                    return calc(minus_exp, P, M-1)\n\n    # if no base case is reached\n    return calc(plus_exp, P-1, M) if plus_exp else calc(minus_exp, P, M-1)\n\nprint(calc(exp, P, M))"
 ],
 "1777": [
  "n = int(input())\nstack = []\nans = 0\nfor _ in range(n):\n    s = input().strip()\n    balance = 0\n    first = True\n    for c in s:\n        if c == '(':\n            balance += 1\n        else:\n            balance -= 1\n        if balance < 0 and first:\n            stack.append(s)\n            break\n        first = False\n    if balance >= 0:\n        if not stack:\n            stack.append(s)\n        else:\n            ans += 1\n            stack.pop()\nprint(ans)"
 ],
 "1778": [
  "n = int(input())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\n\na.sort(reverse=True) # sorts in decreasing order\nb.sort(reverse=True)\n\nsum_a = 0\nsum_b = 0\n\ni = 0\nj = 0\n\nwhile i < n and j < n:\n    if a[i] >= b[j]: # player A chooses from his own list\n        sum_a += a[i]\n        i += 1\n    else: # player A chooses from player B's list\n        j += 1\n        \n    if j < n and b[j] >= a[i]: # player B chooses from his list\n        sum_b += b[j]\n        j += 1\n    else: # player B chooses from player A's list\n        i += 1\n\nprint(sum_a - sum_b)"
 ],
 "1779": [
  "first_layout = input()\nsecond_layout = input()\ntext = input()\n\nmapping = dict(zip(first_layout, second_layout))\n\nresult = \"\"\n\nfor char in text:\n    if char.lower() in mapping:\n        if char.isupper():\n            result += mapping[char.lower()].upper()\n        else:\n            result += mapping[char]\n    else:\n        result += char\n\nprint(result)"
 ],
 "1780": [
  "n, m = map(int, input().split())\na = list(map(int, input().split()))\n\n# Count the number of -1's and 1's\nnum_neg = a.count(-1)\nnum_pos = a.count(1)\n\n# Answer each query\nfor i in range(m):\n    l, r = map(int, input().split())\n    length = r - l + 1\n    # If the length of the subarray is odd, it is impossible for the sum to be zero\n    if length % 2 == 1:\n        print(0)\n    else:\n        half_length = length // 2\n        # If both the number of -1's and 1's are not enough to fill the subarray, it is impossible\n        if num_neg < half_length or num_pos < half_length:\n            print(0)\n        else:\n            print(1)"
 ],
 "1781": [
  "n, k = map(int, input().split())\nseats = [input() for i in range(n)]\n\noccupied = set()\nfor i in range(n):\n    for j in range(len(seats[i])):\n        if seats[i][j] == \"S\":\n            occupied.add((i, j))\n\nneighbors = [(1, -1), (1, 0), (1, 1), (0, -3), (0, 3), (-1, -1), (-1, 0), (-1, 1)]\nnum_neighbors = {}\nfor o in occupied:\n    for ni, nj in neighbors:\n        ni += o[0]\n        nj += o[1]\n        if ni >= 0 and ni < n and nj >= 0 and nj < len(seats[ni]) and seats[ni][nj] == \".\":\n            if o in num_neighbors:\n                num_neighbors[o] += 1\n            else:\n                num_neighbors[o] = 1\n\ntotal_neighbors = sum(num_neighbors.values())\nsorted_neighbors = sorted(num_neighbors.items(), key=lambda x: x[1])\n\nfor i in range(k):\n    r, c = sorted_neighbors[i][0]\n    row = seats[r]\n    seats[r] = row[:c] + \"x\" + row[c+1:]\n    num_neighbors.pop((r, c))\n\nfor r, c in num_neighbors.keys():\n    row = seats[r]\n    seats[r] = row[:c] + \"x\" + row[c+1:]\n\nnew_total_neighbors = sum(num_neighbors.values())\nprint(new_total_neighbors)\nfor row in seats:\n    print(row)"
 ],
 "1782": [
  "n, k = map(int, input().split())\nif k > n//2:\n    print(\"-1\")\nelse:\n    ans = [0]*n\n    for i in range(k):\n        for j in range(i, n, k):\n            ans[j] = str(i+1)\n    print(\" \".join(ans))"
 ],
 "1783": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\nweek_sum = sum(a[:k])\ntotal_sum = week_sum\n\nfor i in range(k, n):\n    week_sum += a[i] - a[i-k]\n    total_sum += week_sum\n\naverage_sleep = total_sum / (n-k+1)\nprint('{:.10f}'.format(average_sleep))"
 ],
 "1784": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\nmax_pile = max(a)\nif max_pile > k:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    for i in range(n):\n        colors = list(range(1, a[i] + 1))\n        for j in range(a[i], max_pile):\n            colors.append(1)\n        print(*colors)"
 ],
 "1785": [
  "MOD = 10 ** 9 + 7\n\nn = int(input())\ns = input()\n\ncnt = [0] * n\nfor i in range(1, n):\n    k = cnt[i-1]\n    while k > 0 and s[k] != s[i]:\n        k = cnt[k-1]\n    if s[k] == s[i]:\n        cnt[i] = k+1\n\nres = 1\nif cnt[-1] == 0:\n    print(n)\nelse:\n    res = cnt.count(cnt[-1])\n    if cnt[-1] != n-1:\n        print(res)\n    else:\n        print(res+1)"
 ],
 "1786": [
  "from bisect import bisect_left\nw, h, n = map(int, input().split())\ncw, ch = [w], [h]\nfor _ in range(n):\n    cut = input().split()\n    val = int(cut[1])\n    if cut[0] == 'H':\n        pos = bisect_left(ch, val)\n        ch.insert(pos, val)\n        maxh = max(ch[pos-1]-ch[0], ch[-1]-ch[pos])\n        print(maxh*cw[0])\n    else:\n        pos = bisect_left(cw, val)\n        cw.insert(pos, val)\n        maxw = max(cw[pos-1]-cw[0], cw[-1]-cw[pos])\n        print(ch[0]*maxw)"
 ],
 "1787": [
  "MOD = 10**9+7\n\ns = input()\nn = len(s)\n\ndp = [0] * n\nprev = [-1] * n\ncnt_a = 0\n\nfor i in range(n):\n    if s[i] == 'a':\n        cnt_a += 1\n    if i > 0 and s[i] == 'b' and s[i-1] == 'b':\n        continue\n    for j in range(i-cnt_a-1, prev[i-1], -1):\n        dp[i] = (dp[i] + dp[j] + 1) % MOD\n    prev[i] = i - cnt_a - 1\n\nprint(sum(dp) % MOD)"
 ],
 "1788": [
  "a,b = map(int, input().split())\nprint((a+b)//2, (a-b)//2)"
 ],
 "1789": [
  "a, b, x, y = map(int, input().split())\nif a <= b:\n    ans = min(x*(b-a) + x, y*(b-a-1) + x)\nelse:\n    ans = min(x*(a-b) + x, y*(a-b-1) + x)\nprint(ans)"
 ],
 "1790": [
  "n = int(input())\nlines = set(map(int, input().split()[1:]))\nfor i in range(n-1):\n    curr_lines = set(map(int, input().split()[1:]))\n    lines = lines.intersection(curr_lines)\nprint(*sorted(lines))"
 ],
 "1791": [
  "s=input().strip()\n\nn=len(s)\n\nres=1\n\nfor l in range(n):\n    for r in range(l+1,n+1):\n        t=list(s[l:r])\n        k=len(t)\n\n        mid=(k-1)//2\n\n        if k%2==0 and t[:mid+1]==t[mid+1:][::-1]:\n            res=max(res,k//2)\n\n        elif k%2==1 and t[:mid]==t[mid+1:][::-1]:\n            res=max(res,k//2+1)\n\nprint(res)"
 ],
 "1792": [
  "from heapq import heappush, heappop\nfrom sys import maxsize\n\nn, m = map(int, input().split())\ngraph = [[] for _ in range(n)]\nfor i in range(m):\n    u, v = map(int, input().split())\n    graph[u-1].append(v-1)\n    graph[v-1].append(u-1)\n\ns, b, k, h = map(int, input().split())\nspaceships = []\nfor i in range(s):\n    x, a, f = map(int, input().split())\n    spaceships.append((x-1, a, f))\n\nbases = []\nfor i in range(b):\n    x, d = map(int, input().split())\n    bases.append((x-1, d))\n\n# This is a sub-function to calculate the shortest distance between two planets\ndef dijkstra(start, graph, n):\n    dist = [maxsize]*n\n    dist[start] = 0\n    heap = []\n    heappush(heap, (0, start))\n\n    while heap:\n        d, u = heappop(heap)\n\n        if d != dist[u]:\n            continue\n\n        for v in graph[u]:\n            if dist[v] > dist[u] + 1:\n                dist[v] = dist[u] + 1\n                heappush(heap, (dist[v], v))\n\n    return dist\n\n# Pre-calculate the shortest distance between each base and spaceship\ndists = [[] for _ in range(s)]\nfor i in range(s):\n    dists[i] = dijkstra(spaceships[i][0], graph, n)\n\n# Create a bipartite graph connecting spaceships and bases\nleft = s\nright = b + s\ninf = maxsize\nN = right + 1\nmaxMatching = 0\nnumPaired = 0\nmatchL = [-1]*N\nmatchR = [-1]*N\nslack = [-1]*N\nslackx = [-1]*N\nleftGraph = [[] for _ in range(N)]\nW = [[-inf]*N for _ in range(N)]\nLx = [-inf]*N\nLy = [0]*N\nS = [-1]*N\nT = [-1]*N\nmatchWeight = [0]*right\n\nfor i in range(s):\n    for j in range(b):\n        if spaceships[i][1] >= bases[j][1] and spaceships[i][2] >= dists[i][bases[j][0]]:\n            W[i][j+s] = -k\n        else:\n            W[i][j+s] = -inf\n        Lx[i] = max(Lx[i], W[i][j+s])\n\nfor i in range(left):\n    leftGraph[i] = list(range(right))\n\ndef update(slackx, matchL, matchR, slack, t, leftGraph, N):\n    for i in leftGraph[t]:\n        if slack[i] >= slackx[i]:\n            v = matchL[i]\n            S[v] = True\n            if v < s:\n                return False\n            S[matchR[v]] = True\n            if update(slackx, matchL, matchR, slack, matchR[v], leftGraph, N):\n                return True\n        elif Lx[i] + Ly[i] - W[i][t] < slack[i]:\n            slack[i] = Lx[i] + Ly[i] - W[i][t]\n            slackx[i] = t\n    return False\n\ndef augment(matchL, matchR, leftGraph, N):\n    # Initialisation\n    for i in range(N):\n        matchL[i] = -1\n        matchR[i] = -1\n        Lx[i] = -inf\n        Ly[i] = -inf\n        for j in range(N):\n            W[i][j] = -inf\n\n    # Calculate Lx\n    for i in range(left):\n        for j in leftGraph[i]:\n            Lx[i] = max(Lx[i], W[i][j])\n\n    # Run Hungarian\n    for i in range(left):\n        for j in range(left):\n            slack[j] = inf\n        for j in range(right):\n            slackx[j] = -1\n        matchL[i] = i\n        s = i\n        t = -1\n        while True:\n            S = [False]*N\n            T = [False]*N\n            if update(slackx, matchL, matchR, slack, t, leftGraph, N):\n                break\n\n            # Update labels\n            d = inf\n            for j in range(right):\n                if not T[j]:\n                    d = min(d, slack[j])\n            for j in range(N):\n                if S[j]:\n                    Lx[j] -= d\n                if T[j]:\n                    Ly[j] += d\n\n    # Calculate maximum matching and match cost\n    maxMatching = 0\n    totalCost = 0\n    for i in range(right):\n        if W[matchR[i]][i] > -inf:\n            maxMatching += 1\n            matchL[matchR[i]] = -1\n            matchR[i] = -1\n            matchWeight[i] = -W[matchR[i]][i]\n    for i in range(left):\n        if matchL[i] != -1:\n            maxMatching += 1\n            matchR[matchL[i]] = -1\n            matchL[i] = -1\n            matchWeight[i] = 0\n    for i in range(right):\n        if matchR[i] != -1:\n            totalCost += -W[matchR[i]][i]\n    return maxMatching, totalCost\n\ndone = False\nwhile not done:\n    currMatching, currCost = augment(matchL, matchR, leftGraph, N)\n    if currMatching == numPaired:\n        done = True\n    numPaired = currMatching\n\n# Calculate the number of bases that are attacked with real spaceships and sum up the gold losses\nnumAttacked = 0\nfor i in matchL:\n    if i < s:\n        if matchR[i] != -1:\n            numAttacked += 1\n            matchWeight[matchR[i]] = -k\nprint(-sum(matchWeight) + h*(b - numAttacked))"
 ],
 "1793": [
  "import sys\ninput = sys.stdin.readline\n\nn, L, S = map(int, input().split())\nw = list(map(int, input().split()))\nparent = list(map(int, input().split()))\n\ntree = [[] for i in range(n)]\nfor i in range(1, n):\n    tree[parent[i-1]-1].append(i)\n\ndef dfs(node, path):\n    path.append(node)\n    if not tree[node]:\n        paths.append(path)\n    for child in tree[node]:\n        dfs(child, path.copy())\n\npaths = []\ndfs(0, [])\nfor path in paths:\n    if len(path) > L:\n        print('-1')\n        exit()\n    if sum(w[p] for p in path) > S:\n        print('-1')\n        exit()\n\npaths = sorted(paths, key=lambda x: (len(x), sum(w[p] for p in x)))\nans = 0\nwhile paths:\n    curr_path = paths.pop()\n    if sum(w[p] for p in curr_path) > S:\n        continue\n    S -= sum(w[p] for p in curr_path)\n    ans += 1\n    while paths and len(curr_path) + len(paths[-1]) - 1 <= L and sum(w[p] for p in curr_path + paths[-1]) <= S:\n        next_path = paths.pop()\n        curr_path += next_path[1:]\n    paths.append(curr_path)\n\nprint(ans)"
 ],
 "1794": [
  "n=int(input())\na=list(map(int,input().split()))\nans=0\nmin_val=n\nfor i in range(n-2,-1,-1):\n    min_val=min(min_val,a[i])\n    ans+=(min_val*(n-1-i))-sum(a[i+1:min(min_val+i,n-1)])\nprint(ans)"
 ],
 "1795": [
  "n = int(input())\nplanes = list(map(int, input().split()))\n\nfor i in range(n):\n    if planes[planes[planes[i]-1]-1] == i+1:\n        print(\"YES\")\n        break\nelse:\n    print(\"NO\")"
 ],
 "1796": [
  "n = int(input())\nx = 0\nfor _ in range(n):\n    statement = input()\n    if \"++\" in statement:\n        x += 1\n    else:\n        x -= 1\nprint(x)"
 ],
 "1797": [
  "n = int(input())\np = list(map(int, input().split()))\n\nans = 0\nfor i in range(n):\n    cnt = 0\n    vis = [False] * n\n    j = i\n    while not vis[j]:\n        vis[j] = True\n        j = p[j] - 1\n        cnt += 1\n    if j == i:\n        ans += cnt * (cnt + 1)\n    elif j < i:\n        ans += cnt\nprint(ans)"
 ],
 "1798": [
  "n=int(input())\narr=list(map(int,input().split()))\nfreq={}\npos={}\nfor i in range(n):\n    if arr[i] not in freq:\n        freq[arr[i]]=1\n        pos[arr[i]]=[i]\n    else:\n        freq[arr[i]]+=1\n        pos[arr[i]].append(i)\nans=[]\nfor i in freq.keys():\n    flag=True\n    diff=0\n    p=pos[i]\n    for j in range(len(p)-1):\n        if p[j+1]-p[j]!=p[1]-p[0]:\n            flag=False\n            break\n        else:\n            if diff==0:\n                diff=p[j+1]-p[j]\n            elif diff!=p[j+1]-p[j]:\n                flag=False\n                break\n    if flag:\n        ans.append((i,diff))\nans.sort()\nprint(len(ans))\nfor i in ans:\n    print(i[0],i[1])"
 ],
 "1799": [
  "n = int(input())\nteams = []\nfor i in range(n):\n    balloons, weight = map(int, input().split())\n    teams.append((balloons, weight))\n\nmy_balloons, my_weight = teams[0]\nteams.pop(0)  # remove the first team from the list\n\nteams.sort(reverse=True)  # sort by number of balloons\nplace = 1\nfor i in range(len(teams)):\n    if teams[i][0] > my_balloons:  # if a team has more balloons than us\n        place += 1\n    elif teams[i][1] < my_weight:  # if we can make a team float\n        my_balloons += teams[i][0]  # give them all our balloons\n        teams[i] = (-1, -1)  # mark them as disqualified\n        place = 1  # we are now in first place\n    else:\n        break  # we can't float any more teams\n\nprint(place)"
 ],
 "1800": [
  "n, m = map(int, input().split())\na = list(map(int, input().split()))\n\nfor _ in range(m):\n    t, r = map(int, input().split())\n    if t == 1:\n        a[:r] = sorted(a[:r])\n    else:\n        a[:r] = sorted(a[:r], reverse=True)\n\nprint(*a)"
 ],
 "1801": [
  "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nm = int(input())\n\nsorted_a = sorted([(a[i], i + 1) for i in range(n)])\nsorted_b = sorted([(b[i], i + 1) for i in range(n)])\n\nans = 1\nfor i in range(n):\n    cnt_a = sorted_a[i][1] - 1\n    cnt_b = sorted_b[i][1] - 1\n    cnt = max(cnt_a, cnt_b)\n    ans = (ans * (n - cnt + 1 - i)) % m\n\nprint(ans)"
 ],
 "1802": [
  "n = int(input())\na = list(map(int,input().split()))\na.sort()\nmx = 0\npos = 0\nfor i in range(n):\n    for j in range(i+1,n):\n        ans = 0\n        if i == j:\n            continue\n        st = a[i]\n        diff = a[j] - a[i]\n        pos = i\n        neg = 0\n        for k in range(n):\n            if a[k] == st:\n                continue\n            if a[k] > st + (mx+1)*diff:\n                break\n            if (a[k]-st)%diff == 0:\n                kek = (a[k]-st)//diff\n                if kek > 0:\n                    pos += 1\n                    ans += kek\n                else :\n                    neg += kek\n        if ans - neg > mx:\n            mx = ans - neg\n            ansst = st\n            ansdiff = diff\nprint(mx)\nprint(ansst,ansdiff)"
 ],
 "1803": [
  "n = int(input())\nbirds = list(map(int, input().split()))\nm = int(input())\nfor i in range(m):\n    x, y = map(int, input().split())\n    if x > 1:\n        birds[x-2] += y-1\n    if x < n:\n        birds[x] += birds[x-1]-y\n    birds[x-1] = 0\nfor bird_count in birds:\n    print(bird_count)"
 ],
 "1804": [
  "from bisect import bisect_left\nfrom math import ceil\n\nn, m = map(int, input().split())\n\nc = int(input())\nhotels = []\nfor _ in range(c):\n    x, y = map(int, input().split())\n    hotels.append((x, y))\nhotels.sort()\n\nh = int(input())\nrestaurants = []\nfor _ in range(h):\n    x, y = map(int, input().split())\n    restaurants.append((x, y))\nrestaurants.sort()\n\ndistances = []\nfor i in range(n):\n    # Find the starting hotel on this street\n    start = bisect_left(hotels, (i + 1, 0))\n    if start == c:\n        start -= 1\n    elif start > 0:\n        # Check which hotel on this street is closest to the previous street\n        if abs(hotels[start][1] - i - 1) > abs(hotels[start - 1][1] - i - 1):\n            start -= 1\n    # Iterate over all street-avenue crossings to find the closest restaurant\n    for j in range(m):\n        r_index = bisect_left(restaurants, (i + 1, j + 1))\n        if 0 < r_index < h:\n            # Check both the restaurant before and after this crossing on this street\n            r1, r2 = restaurants[r_index - 1], restaurants[r_index]\n            distance = min(abs(r1[0] - hotels[start][0]) + abs(r1[1] - hotels[start][1]),\n                           abs(r2[0] - hotels[start][0]) + abs(r2[1] - hotels[start][1]))\n            distances.append(distance)\n\nif not distances:\n    print(0)\n    print(1)\nelse:\n    optimal = ceil(max(distances) / 2)\n    print(optimal)\n    print(distances.index(max(distances)) // (m - 1) + 1)"
 ],
 "1805": [
  "from math import ceil\nfor _ in range(int(input())):\n    n=int(input())\n    if (n*(n+1))//2)%2:\n        print(2*(ceil(n/4)-1)+(n%4!=0)+1)\n    else:\n        print(2*(ceil(n/4)-1)) "
 ],
 "1806": [
  "from functools import cmp_to_key\n\nn, m = map(int, input().split())\nintervals = []\nfor _ in range(n):\n    l, r = map(int, input().split())\n    intervals.append((l, r))\nintervals = sorted(intervals, key=cmp_to_key(lambda x, y: x[0] - y[0] if x[0] != y[0] else y[1] - x[1]))\nprefix_max = [-1] * n\ncur_max = -1\nfor i in range(n):\n    cur_max = max(cur_max, intervals[i][1])\n    prefix_max[i] = cur_max\nsuffix_min = [-1] * n\ncur_min = float('inf')\nfor i in range(n - 1, -1, -1):\n    cur_min = min(cur_min, intervals[i][0])\n    suffix_min[i] = cur_min\nfor _ in range(m):\n    x, y = map(int, input().split())\n    covered = False\n    prev = x\n    ans = 0\n    while prev < y:\n        cur_max = float('-inf')\n        for i in range(n):\n            if intervals[i][0] <= prev and intervals[i][1] > prev:\n                if intervals[i][1] < cur_max:\n                    continue\n                cur_max = intervals[i][1]\n            if intervals[i][0] > prev:\n                break\n        if cur_max == float('-inf'):\n            print(-1)\n            covered = True\n            break\n        ans += 1\n        prev = cur_max\n    if not covered:\n        print(ans)"
 ],
 "1807": [
  "a, b = map(int, input().split())\nsegments = [6, 2, 5, 5, 4, 5, 6, 3, 7, 6] # number of segments for each digit from 0 to 9\ntotal_segments = 0\nfor num in range(a, b+1):\n    for digit in str(num):\n        total_segments += segments[int(digit)]\nprint(total_segments)"
 ],
 "1808": [
  "n, k, x = map(int, input().split())\nchores = list(map(int, input().split()))\n\nfor i in range(k, n):\n    if chores[i] > x:\n        chores[i] = x\n\nprint(sum(chores))"
 ],
 "1809": [
  "n, m = map(int, input().split())\nweights = list(map(int, input().split()))\nbooks = list(map(int, input().split()))\n\nbook_positions = {book: i for i, book in enumerate(books)}\nswaps = 0\n\nfor i in range(n):\n    for j in range(i+1, n):\n        if book_positions.get(i+1, -1) < book_positions.get(j+1, -1):\n            swaps += weights[i]\n            weights[i], weights[j] = weights[j], weights[i]\n\nprint(sum(weights[book-1] for book in books))"
 ],
 "1810": [
  "n = int(input())\ncount = 0\nfor i in range(2520, n+1, 2520):\n    count += 1\nprint(count)"
 ],
 "1811": [
  "n, k = map(int, input().split())\nroad = input()\n\ncan_reach = False\ncurrent = 0\nwhile current < n:\n    if road[current] == \"#\":\n        current += 1\n        continue\n    if current == n-1:\n        can_reach = True\n        break\n    for i in range(current+1, min(n, current+k+1)):\n        if road[i] == \".\":\n            current = i\n    else:\n        break\n\nprint(\"YES\" if can_reach else \"NO\")"
 ],
 "1812": [
  "def find_k(num):\n    for i in range(1,201):\n        if int(str(pow(2,i))[-min(i+2,len(str(pow(2,i)))):-2]) == num:\n            return i\n    return -1\n\nn = int(input())\nfor i in range(n):\n    num = int(input())\n    print(find_k(num))"
 ],
 "1813": [
  "n, s, l = map(int, input().split())\na = list(map(int, input().split()))\n\nnum_pieces = 0\nprev_end = 0\nfor i in range(n):\n    if i - prev_end >= l:\n        # check if the piece satisfies the condition\n        if max(a[prev_end: i+1]) - min(a[prev_end: i+1]) <= s:\n            num_pieces += 1\n            prev_end = i + 1\n        else:\n            # try to find a smaller piece that satisfies the condition\n            for j in range(i-1, prev_end-1, -1):\n                if max(a[j:i+1]) - min(a[j:i+1]) <= s and i-j >= l-1:\n                    num_pieces += 1\n                    prev_end = i + 1\n                    break\n            else:\n                # we couldn't find a suitable piece\n                print(-1)\n                break\nelse:\n    if n - prev_end < l:\n        # last piece is too small\n        print(-1)\n    elif max(a[prev_end:]) - min(a[prev_end:]) > s:\n        # last piece doesn't satisfy condition\n        print(-1)\n    else:\n        # we have a valid splitting\n        print(num_pieces + 1)"
 ],
 "1814": [
  "import bisect\nn,m,c1,c2,v = map(int,input().split())\nl = list(map(int,input().split()))\ne = list(map(int,input().split()))\nq = int(input())\n\ndef dist(x,y,i):\n    if x==y:    return 0\n    if i==-1:   return abs(x-y)\n    if x>y: x,y = y,x\n    if l[i]>=x and l[i]<=y: return l[i]-x+y-l[i] + 1 #1 for stairs\n    elif e[i]>=x and e[i]<=y: return (v+abs(e[i]-x)) + abs(e[i]-y) + 1\n    return abs(x-y)\n\nfor _ in range(q):\n    x1,y1,x2,y2 = map(int,input().split())\n    ans = 10**18\n    for i in range(-1,c1+c2):\n        ans = min(ans,dist(y1,y2,i) + abs(x1-x2))\n    print(ans)"
 ],
 "1815": [
  "n=int(input())\na=[0]*100005\nb=[0]*100005\nc=0\nd=0\nans=0\nfor i in range(n):\n    s=int(input())\n    if a[s]==0 and b[s]==0:\n        a[s]=i+1\n        c+=1\n    elif b[s]==0:\n        b[s]=i+1\n        c-=1\n        d+=1\n    else:\n        pos=a[s]\n        a[s]=b[s]\n        b[s]=i+1\n        d+=1\n        if pos>=a[s]:\n            c=d\n            d=0\n    ans=max(ans,c)\nprint(ans)"
 ],
 "1816": [
  "n = int(input())\nfragments = list(map(int, input().split()))\n\ntotal_time = abs(fragments[0] - fragments[-1])  # time to move from first to last fragment\n\nfor i in range(n-1):\n    total_time += abs(fragments[i+1] - fragments[i])  # add time between adjacent fragments\n\nprint(total_time)"
 ],
 "1817": [
  "n = int(input())\na = list(map(int, input().split()))\na.sort()\nif n%2==1:\n    print(a[n//2])\nelse:\n    print(a[n//2 - 1])"
 ],
 "1818": [
  "n = int(input())\na = list(map(int, input().split()))\nf = {}\nfor i in range(n):\n    x = a[i]\n    cnt = 0\n    while x not in f:\n        if x % 2 == 1:\n            cnt += 1\n        x //= 2\n        if x == 0:\n            break\n    if x in f:\n        f[a[i]] = f[x] + cnt\n    else:\n        f[a[i]] = cnt\n\nans = 0\nfor cnt in f.values():\n    ans += cnt*(cnt-1)//2\nprint(ans)"
 ],
 "1819": [
  "from math import log2, floor\n\ndef solve(n, x):\n    ans = x\n    cnt = 0\n    while ans > 1:\n        ans = ans // 2\n        cnt += 1\n    res = 0\n    for i in range(cnt):\n        k = int(2**i)\n        res += k*(n-k+1)\n    if ans == 1:\n        res += n-cnt\n    return res\n\nfor _ in range(int(input())):\n    n, x = map(int, input().split())\n    print(solve(n, x))"
 ],
 "1820": [
  "for _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    for i in range(n - 2):\n        if a[i] + a[i + 1] > a[n - 1]:\n            print(i + 1, i + 2, n)\n            break\n    else:\n         print(-1)"
 ],
 "1821": [
  "n = int(input())\na = list(map(int, input().split()))\ndp = [[0 for i in range(n)] for j in range(n)]\nfor i in range(n):\n    for j in range(i+1, n):\n        dp[i][j] = dp[i][j-1]\n        if abs(a[j] - a[j-1]) == 1 or abs(a[j] - a[j-1]) == 6:\n            dp[i][j] = max(dp[i][j], dp[i][j-2]+1)\n        for k in range(i, j-1):\n            if abs(a[j]-a[k]) == 1 or abs(a[j]-a[k]) == 6:\n                dp[i][j] = max(dp[i][j], dp[i][k]+dp[k+1][j-1]+1)\nans = 0\nfor i in range(n-1):\n    ans = max(ans, dp[0][i]+dp[i+1][n-1])\nprint(ans)"
 ],
 "1822": [
  "n, x = map(int, input().split())\na = list(map(int, input().split()))\n\nans = []\n\nfor i in range(n):\n    if a[i] == x:\n        ans.append(i+1)\n\nfor i in range(n):\n    if a[i] == 0 and i+1 not in ans:\n        visited = set()\n        curr = i+1\n        while a[curr-1] != 0 and a[curr-1] != x and a[curr-1] not in visited:\n            visited.add(curr)\n            curr = a[curr-1]\n        if a[curr-1] == x:\n            ans.append(i+1)\n            continue\n        visited.add(curr)\n        if x in visited:\n            ans.append(i+1)\n\nans.sort()\nfor a in ans:\n    print(a)"
 ],
 "1823": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\ncounts = [0] * k\n\nfor i in range(n):\n    counts[a[i]-1] += 1\n\nmax_count = max(counts)\n    \nprint(counts.index(max_count)+1)"
 ],
 "1824": [
  "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\n\nall_errors = sum(a) + sum(b) + sum(c)\nfixed_errors = sum(set(a)) + sum(set(b)) + sum(set(c))\n\nprint(all_errors - fixed_errors)\nprint(sum(set(b)) - sum(set(a)))"
 ],
 "1825": [
  "from collections import deque\n\nn = int(input())\noccurs = [[] for _ in range(10**6+1)]\nfor i in range(n):\n    s = input().split()\n    k = int(s[1])\n    t = s[0]\n    for j in range(k):\n        pos = int(s[j+2])-1\n        occurs[pos].append((i, t))\n\nres = deque(['a']*10**6)\nfor i in range(10**6):\n    occ = occurs[i]\n    occ.sort()\n    for j in range(len(occ)):\n        if occ[j][1] != res[i]:\n            res[i] = occ[j][1]\n            break\n\nans = \"\".join(res)\nprint(ans)"
 ],
 "1826": [
  "n = int(input())\nmoves = input()\n\nwhile \"RU\" in moves or \"UR\" in moves:\n    moves = moves.replace(\"RU\", \"D\").replace(\"UR\", \"D\")\n\nprint(len(moves))"
 ],
 "1827": [
  "n = int(input())\nparts = list(map(int, input().split()))\nparts.sort()\nfor i in range(n):\n    print(parts[i], parts[i+n])"
 ],
 "1828": [
  "n = int(input())\ncoords = []\nfor _ in range(n+1):\n    x,y = map(int, input().split())\n    coords.append((x,y))\n\ncount = 0\nfor i in range(1, n):\n    x1,y1 = coords[i-1]\n    x2,y2 = coords[i]\n    x3,y3 = coords[i+1]\n    if (x1 < x2 and x2 > x3 and y1 < y2 and y2 < y3) or (x1 > x2 and x2 < x3 and y1 > y2 and y2 > y3):\n        count += 1\n\nprint(count)"
 ],
 "1829": [
  "n, m = map(int, input().split())\npoland_words = set()\nenemy_words = set()\n\nfor _ in range(n):\n    poland_words.add(input().strip())\n\nfor _ in range(m):\n    enemy_words.add(input().strip())\n\ncommon_words = poland_words & enemy_words\n\nif not common_words:\n    if len(poland_words) > len(enemy_words):\n        print(\"YES\")\n    else:\n        print(\"NO\")\nelse:\n    num_common_words = len(common_words)\n    poland_remaining_words = len(poland_words) - num_common_words\n    enemy_remaining_words = len(enemy_words) - num_common_words\n\n    if num_common_words % 2 == 0:\n        if poland_remaining_words > enemy_remaining_words:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n    else:\n        if poland_remaining_words >= enemy_remaining_words:\n            print(\"YES\")\n        else:\n            print(\"NO\")"
 ],
 "1830": [
  "n, m = map(int, input().split())\nrow = set()\ncol = set()\nfor i in range(m):\n    x, y = map(int, input().split())\n    row.add(x)\n    col.add(y)\n    cells_left = (n - len(row)) * (n - len(col))\n    print(cells_left, end=\" \")"
 ],
 "1831": [
  "n, m = map(int, input().split())\nedges = [[] for _ in range(n)]\n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edges[a-1].append(b-1)\n    edges[b-1].append(a-1)\n\ndef dfs(node, visited):\n    visited.add(node)\n    for neighbor in edges[node]:\n        if neighbor not in visited:\n            dfs(neighbor, visited)\n\nvisited = set()\ndfs(0, visited)\n\nif len(visited) == n:\n    print(\"yes\")\nelse:\n    print(\"no\")"
 ],
 "1832": [
  "from string import ascii_lowercase as letters\n\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    # construct the first string with length a[0]+1 and\n    # the prefix with length a[0] equal to 'a'.\n    s = 'a' * a[0] + letters[:1]\n    \n    for i in range(1, n+1):\n        # constructing the string by adding\n        # the required prefix length.\n        prefix = s[:a[i-1]]\n        remain = letters[:1] if prefix[-1] == 'z' else letters[letters.index(prefix[-1])+1 : letters.index(prefix[-1])+2]\n        s = prefix + remain * a[i] + letters[:1]\n        print(s)"
 ],
 "1833": [
  "MOD = 10**9+7\nn = int(input())\na = list(map(int,input().split()))\ncnt = [0]*(n+1)\nfor x in a:\n    cnt[x] += 1\ndp = [1]*(n+1)\nfor i in range(1, n+1):\n    dp[i] = pow(2, cnt[i], MOD) - 1\n    for j in range(i*2, n+1, i):\n        dp[i] -= dp[j]\n        dp[i] %= MOD\nans = 0\nfor i in range(1,n+1):\n    if dp[i] > 0: \n        ans += dp[i]\n        ans %= MOD\nprint(ans)"
 ],
 "1834": [
  "n = int(input())\na = list(map(int, input().split()))\n\na.sort()\n\nmid = n // 2\n\nif n % 2 == 0:\n    mid -= 1\n\nfor i in range(1, mid+1):\n    a[i*2], a[(i*2)-1] = a[(i*2)-1], a[i*2]\n    \nfor i in range(1, n):\n    if i % 2 == 0 and a[i] >= a[i-1]:\n        continue\n    elif i % 2 != 0 and a[i] <= a[i-1]:\n        continue\n    print(\"Impossible\")\n    exit()\n\nprint(*a)"
 ],
 "1835": [
  "for _ in range(int(input())):\n    n = int(input())\n    s = []\n    odd_count = 0\n    even_count = 0\n    for i in range(n):\n        temp = input().strip()\n        s.append(temp)\n        if len(temp) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    flag = True if odd_count <= 1 else False\n    for i in range(n):\n        if len(s[i]) % 2 == 1:\n            mid = s[i][len(s[i])//2]\n            start = s[i][:len(s[i])//2]\n            end = s[i][len(s[i])//2+1:]\n            if flag and mid not in start+end:\n                flag = False\n            else:\n                continue\n        for j in range(i+1,n):\n            if sorted(s[i]) == sorted(s[j]):\n                continue\n            s[j] = s[j][::-1]\n            if s[j] == s[i]:\n                continue\n            if flag and mid in s[j]:\n                flag = False\n            break\n        else:\n            continue\n        break\n    print(1 if even_count == n else n if flag else n-1)"
 ],
 "1836": [
  "from collections import defaultdict\n\nn, m = map(int, input().split())\n\n# Creating graph\ngraph = defaultdict(list)\nfor i in range(m):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\n# Initialize dp arrays for tail and spines\ndp_t = [0] * (n+1)\ndp_s = [0] * (n+1)\n\n# Traversing the graph from the end to the front\nfor i in range(n, 0, -1):\n    for j in graph[i]:\n        if j > i:\n            dp_t[i] = max(dp_t[i], dp_t[j])\n    dp_t[i] += 1\n    dp_s[i] = max(dp_s[i+1], dp_t[i] * (n-i))\n\n# Printing the answer\nprint(dp_s[1])"
 ],
 "1837": [
  "n = int(input())\na = list(map(int, input().split()))\n\ncount = 0\nfor i in range(n):\n    if a[i] == i:\n        count += 1\n\nif count == n:\n    print(n)\nelse:\n    swapped = False\n    for i in range(n):\n        if a[i] != i and a[a[i]] == i:\n            swapped = True\n            break\n    if swapped:\n        print(count + 2)\n    else:\n        print(count + 1)"
 ],
 "1838": [
  "n,m,q = map(int, input().split())\nwords = input().split()\n\n# sets to store synonym and antonym relations\nsynonyms = [set() for _ in range(n)]\nantonyms = [set() for _ in range(n)]\n\n# function to check if a relation is wrong\ndef is_wrong_relation(a,b):\n    if a == b:\n        # a word cannot be equal and opposite to itself\n        return True\n    if a in synonyms[b] or b in synonyms[a]:\n        # if a and b are synonyms, then they cannot be antonyms\n        return True\n    if a in antonyms[b] or b in antonyms[a]:\n        # if a and b are antonyms, then they cannot be synonyms\n        return True\n    return False\n\n# read the relations and check if they are correct\nfor _ in range(m):\n    t, x, y = input().split()\n    x_idx = words.index(x)\n    y_idx = words.index(y)\n    if t == '1':\n        # synonym relation\n        if is_wrong_relation(x_idx, y_idx):\n            # wrong relation\n            print(\"NO\")\n        else:\n            # correct relation\n            print(\"YES\")\n            synonyms[x_idx].add(y_idx)\n            synonyms[y_idx].add(x_idx)\n    else:\n        # antonym relation\n        if is_wrong_relation(x_idx, y_idx):\n            # wrong relation\n            print(\"NO\")\n        else:\n            # correct relation\n            print(\"YES\")\n            antonyms[x_idx].add(y_idx)\n            antonyms[y_idx].add(x_idx)\n\n# function to check if two words are related\ndef relation(a,b):\n    if a == b:\n        # a word is always the same as itself\n        return 1\n    if b in synonyms[a]:\n        # a and b are synonyms\n        return 1\n    if b in antonyms[a]:\n        # a and b are antonyms\n        return 2\n    # check if a and b are related indirectly\n    for c in synonyms[a]:\n        if b in antonyms[c]:\n            # a is a synonym of c and b is an antonym of c\n            return 2\n    for c in antonyms[a]:\n        if b in synonyms[c]:\n            # a is an antonym of c and b is a synonym of c\n            return 2\n    # no relation found\n    return 3\n\n# read the questions and print the relation\nfor _ in range(q):\n    a, b = input().split()\n    a_idx = words.index(a)\n    b_idx = words.index(b)\n    print(relation(a_idx, b_idx))"
 ],
 "1839": [
  "n = int(input())\nhor = set()\nver = set()\nfor i in range(1, n+1):\n    hor.add(i)\n    ver.add(i)\nres = []\nfor i in range(n**2):\n    h, v = map(int, input().split())\n    if h in hor and v in ver:\n        res.append(i+1)\n        hor.remove(h)\n        ver.remove(v)\nprint(*res)"
 ],
 "1840": [
  "from bisect import bisect_right\nn, m = map(int, input().split())\na = list(map(int, input().split()))\nbases = []\nfor i in range(m):\n    d, g = map(int, input().split())\n    bases.append((d, g))\nbases.sort()\nprefix_gold = [0] * (m + 1)\nfor i in range(m):\n    prefix_gold[i + 1] = prefix_gold[i] + bases[i][1]\nans = []\nfor ai in a:\n    ind = bisect_right(bases, (ai, float('inf')))\n    ans.append(prefix_gold[ind])\nprint(*ans)"
 ],
 "1841": [
  "n,m=map(int,input().split())\na=list(map(int,input().split()))\nd={}\nans=[0]*n\ncnt=0\nfor i in range(n-1,-1,-1):\n    if a[i] not in d:\n        cnt+=1\n        d[a[i]]=1\n    ans[i]=cnt\nfor i in range(m):\n    l=int(input())\n    print(ans[l-1])"
 ],
 "1842": [
  "import math\n\na, b, c = map(int, input().split())\n\nroot1 = (-b + math.sqrt(b*b - 4*a*c)) / (2*a)\nroot2 = (-b - math.sqrt(b*b - 4*a*c)) / (2*a)\n\nprint(max(root1, root2))\nprint(min(root1, root2))"
 ],
 "1843": [
  "import math\n\nt = int(input())\n\nfor i in range(t):\n    n = int(input())\n    total_sum = 0\n    for j in range(n):\n        if 2 ** j <= n:\n            if j % 2 == 0:\n                total_sum += 2 ** j\n            else:\n                total_sum -= 2 ** j\n        else:\n            break\n    print(total_sum)"
 ],
 "1844": [
  "n = int(input())\na = list(map(int, input().split()))\n\n# Check if 1 is in the sequence\nif 1 in a:\n    print(1)\n    exit()\n\n# Precompute sieve\nsieve = [0] * (max(a) + 1)\nfor i in range(2, len(sieve)):\n    if sieve[i] == 0:\n        for j in range(i, len(sieve), i):\n            sieve[j] = i\n\n# Find factors of each number in the sequence\nfactors = set()\nfor x in a:\n    while x > 1:\n        factors.add(sieve[x])\n        x //= sieve[x]\n\n# Find smallest subset with gcd 1\nans = n + 1\nfor mask in range(1, 1 << len(factors)):\n    subset = {factors[i] for i in range(len(factors)) if (mask & (1 << i)) > 0}\n    if all(x != 1 for x in subset):\n        continue\n    cnt = sum(1 for x in a if any(x % p == 0 for p in subset))\n    ans = min(ans, cnt)\n\nif ans == n + 1:\n    print(-1)\nelse:\n    print(ans)"
 ],
 "1845": [
  "n = int(input())\na = list(map(int, input().split()))\ns = sum(a)\nans = s\nfor x in range(2, 101):\n    t = s\n    for i in range(n):\n        if a[i] % x == 0:\n            t = min(t, s - a[i] + a[i]//x + a[(i+1)%n]*x - a[(i+1)%n])\n    ans = min(ans, t)\nprint(ans)"
 ],
 "1846": [
  "n = int(input())\nt = list(map(int, input().split()))\n\n# dp to find the length of longest negative subarray ending at i\ndp = [0]*n\nans = 0\nfor i in range(n):\n    if t[i] < 0:\n        dp[i] = 1 if i == 0 else dp[i-1] + 1\n    if t[i] >= 0:\n        dp[i] = 0\n    ans = max(ans, dp[i])\n\nif ans == n:\n    print(n-1)\nelse:\n    print(ans + 1)"
 ],
 "1847": [
  "x0, y0, x1, y1 = map(int, input().split())\nn = int(input())\n\nallowed = {}\nfor _ in range(n):\n    r, a, b = map(int, input().split())\n    if r not in allowed:\n        allowed[r] = set()\n    for c in range(a, b+1):\n        allowed[r].add(c)\n\nmoves = abs(x0 - x1) + abs(y0 - y1)\nif (x0, y0) != (x1, y1):\n    if (x0, y0) in allowed[x1]:\n        moves += 1\n    elif (x1, y1) in allowed[x0]:\n        moves += 1\n    else:\n        found = False\n        for r in allowed:\n            if y0 in allowed[r]:\n                if (abs(x1-x0) % 2 == 0) and (y1 in allowed[r] or abs(y1-y0) % 2 == 0):\n                    found = True\n            elif (y0 in allowed[r] and y1 in allowed[r]):\n                found = True\n            \n        if not found:\n            moves += 2\n            \nprint(moves if moves % 2 == 0 else moves+1 if (x1-x0) % 2 == (y1-y0) % 2 else moves+2)"
 ],
 "1848": [
  "n = int(input())\na = list(map(int, input().split()))\na.sort()\ncount = 0\nfor i in range(n-1):\n    if a[i] + 1 == a[i+1]:\n        count += 1\nprint(count)"
 ],
 "1849": [
  "n = int(input())\n\nMODULO = 998244353\n\ndef binom(n, k):\n    if k > n or n < 0 or k < 0:\n        return 0\n    return fact[n] * pow(fact[k], MODULO - 2, MODULO) * pow(fact[n - k], MODULO - 2, MODULO) % MODULO\n\ndef cnt_zero_blocks(k):\n    ans = 0\n    for i in range(1, n + 1):\n        ans = (ans + binom(n - k + i - 1, i - 1) * pow(10 - k, n - i, MODULO)) % MODULO\n    return ans\n\nfact = [1]\nfor i in range(1, 2 * n + 1):\n    fact.append(i * fact[-1] % MODULO)\n\nfor k in range(1, n + 1):\n    print((cnt_zero_blocks(k) - cnt_zero_blocks(k - 1) + MODULO) % MODULO, end=' ')"
 ],
 "1850": [
  "n, d = map(int, input().split())\ns = list(map(int, input().split()))\np = list(map(int, input().split()))\n\n# find the max points the astronaut can get\nmax_points = s[d-1] + p[0]\n\n# find the minimum rank for the astronaut to achieve that max points\nmin_rank = 1\nfor i in range(n):\n    if p[i] > p[0] or s[i] >= max_points:\n        break\n    if i+1 != d:\n        min_rank += 1\n\nprint(min_rank)"
 ],
 "1851": [
  "n = int(input())\na = list(map(int, input().split()))\n\nread = set()\ndays = 0\n\nfor i in range(n):\n    if i+1 not in read:\n        days += 1\n        curr = i+1\n        while curr in a and curr not in read:\n            read.add(curr)\n            curr = a[curr-1]\n        read.add(i+1)\n\nprint(days)"
 ],
 "1852": [
  "n = int(input())\nedges = [tuple(map(int,input().split())) for _ in range((1<<n)-3)]\n\n# building the tree from edges\ngraph = [[] for _ in range((1<<n)-2)]\nfor u,v in edges:\n    u,v = u-1,v-1\n    graph[u].append(v)\n    graph[v].append(u)\n\nparent = [-1]*(1<<n)\ndepth = [-1]*(1<<n)\ndepth[0] = 0\n\n# bfs traversal to get depth and parent array of nodes\nqueue = [0]\nwhile queue:\n    u = queue.pop(0)\n    for v in graph[u]:\n        if depth[v]==-1:\n            depth[v] = depth[u]+1\n            parent[v] = u\n            queue.append(v)\n\n# function to check if a given subtree is a perfect binary tree or not\ndef check_subtree(u):\n    if u==-1:\n        return True\n    if len(graph[u])!=2: # non-leaf node must have two children\n        return False\n    l,r = graph[u][0],graph[u][1] \n    if depth[l]!=depth[r]: # the two children must have same depth\n        return False\n    return check_subtree(l) and check_subtree(r)\n\nans = []\n# checking every non-leaf node for fulfillment of McDic's generation\nfor u in range(1,(1<<n)-2):\n    if len(graph[u])==1 and parent[u]!=-1:\n        p = parent[u]\n        c = [v for v in graph[u] if v!=p][0]\n        graph[p].remove(u)\n        graph[p] += graph[c]\n        graph[c] = []\n        if check_subtree(p):\n            ans.append(u+1)\n        graph[c] = graph[p][-2:]\n        graph[p] = graph[p][:-2]\nprint(len(ans))\nprint(*ans)"
 ],
 "1853": [
  "from collections import defaultdict\n\nn,m=map(int,input().split())\npos=defaultdict(set)\nres=''\nfor i in range(m):\n    a,b=map(int,input().split())\n    pos[min(a,b)].add(max(a,b))\n    res+='e' if a<b else 'g' if a>b else 'l'\nif len(pos)<=n//2:\n    arr=[-1]*n\n    j=1\n    for i in sorted(pos.keys()):\n        for k in pos[i]:\n            if arr[k-1]==-1:\n                arr[k-1]=arr[i-1]\n        if arr[i-1]==-1:\n            arr[i-1]=j\n            j+=1\n    print('YES')\n    print(*arr)\n    dual=[arr[i] if res[i]=='e' else j+1-arr[i] for i in range(len(res))]\n    print(*dual)\nelse:\n    print('NO')"
 ],
 "1854": [
  "from collections import deque\n\nn = int(input())\na = list(map(int, input().split()))\n\nif sum(a) < 2*(n-1):\n    print(\"NO\")\nelse:\n    print(\"YES\", end=\" \")\n    dia = min(a)\n    for i in range(n):\n        dia = max(dia, min(a[i], (sum(a)-2*(i+1))//(n-i-1)))\n    print(dia)\n    deg = [(a[i], i+1) for i in range(n)]\n    q = deque(deg)\n    m = 0\n    while len(q) > 0:\n        (di, i) = q.popleft()\n        while di > 0:\n            if len(q) == 0:\n                q.append((di-1, i))\n                break\n            (dj, j) = q.pop()\n            if dj > 0:\n                m += 1\n                print(i, j)\n                di -= 1\n                dj -= 1\n                q.append((dj, j))\n            else:\n                q.append((di, i))\n                break\n    print(m)"
 ],
 "1855": [
  "n,k = map(int, input().split())\np = list(map(int, input().split()))\n\nMOD = 998244353\n\ninv_fact = [0] * (n+1)\ninv_fact[0] = 1\nfor i in range(1, n+1):\n    inv_fact[i] = pow(i, MOD-2, MOD) * inv_fact[i-1] % MOD\n\ndef C(n, k):\n    return inv_fact[n-k] * inv_fact[k] % MOD\n\nseg_left = sorted([(p[i], i) for i in range(n)])\n\nactiv_right = []\nf = []\ncurr_sum = 0\ncnt = 1\n\nfor i in range(n):\n    to_add = 0\n    while activ_right and activ_right[0][0] < seg_left[i][1]:\n        _, idx_r = activ_right[0]\n        cnt -= 1\n        curr_sum -= p[idx_r]\n        activ_right.pop(0)\n        to_add = 1\n    \n    activ_right.append((seg_left[i][1], i))\n    cnt += 1\n    curr_sum += p[seg_left[i][1]]\n\n    if cnt == k:\n        f.append(curr_sum)\n        f[-1] += f[-2] if len(f) >= 2 else 0\n        cnt -= 1\n        curr_sum -= p[activ_right[0][1]]\n        activ_right.pop(0)\n        to_add = 1\n\n    if i + 1 == k:\n        f.append(curr_sum)\n\n    if to_add and len(f) >= 2:\n        f[-1] += f[-2]\n\nans = max(f)\nprint(ans, f.count(ans) * C(n,k) % MOD)"
 ],
 "1856": [
  "n = int(input())\npasswords = []\nfor i in range(n):\n    passwords.append(input())\n\n# creating dictionary containing equivalent passwords\nequivalent = {}\nfor password in passwords:\n    root = password\n    for letter in password:\n        temp = password.replace(letter, '')\n        if temp in equivalent:\n            root = equivalent[temp]\n            break\n    for letter in password:\n        temp = password.replace(letter, '')\n        equivalent[temp] = root\n\n# getting unique roots of equivalent passwords\nroots = set()\nfor password in passwords:\n    roots.add(equivalent[password])\n\n# outputting number of unique roots\nprint(len(roots))"
 ],
 "1857": [
  "n = int(input())\nprint((n*(n-1)//2)**2 * (n-2)*(n-3)//24)"
 ],
 "1858": [
  "n = int(input())\n\nif n == 1:\n    print(\"No\")\nelse:\n    print(\"Yes\")\n    if n % 2 == 0:\n        s1 = list(range(1, n//2+1, 1))+list(range(n//2+2, n+1, 1))\n        s2 = [n//2]+list(range(n//2+1, n, 2))+list(range(1, n//2, 2))\n    else:\n        s1 = [1]+list(range(3, n, 2))+list(range(2, n//2+1, 1))+list(range(n//2+2, n, 2))\n        s2 = [2]+list(range(4, n, 2))+list(range(n//2+1, n, 2))\n    print(len(s1), *s1)\n    print(len(s2), *s2)"
 ],
 "1859": [
  "n = int(input())\n\ncount = 0\nwhile n != 0:\n    found_divisor = False\n    for i in range(2, int(n**(0.5))+1):\n        if n % i == 0:\n            n -= i\n            count += 1\n            found_divisor = True\n            break\n    if not found_divisor:\n        n -= n\n        count += 1\n        \nprint(count)"
 ],
 "1860": [
  "n = int(input())\nprint(2**(n+1) - 2)"
 ],
 "1861": [
  "n, k = map(int, input().split())\ncards = [input() for _ in range(n)]\nnum_sets = 0\nfor i in range(n):\n    for j in range(i+1, n):\n        cnt = 0\n        for f in range(k):\n            if cards[i][f] == cards[j][f]:\n                cnt += 1\n            elif cards[i][f] != 'S' and cards[j][f] != 'S':\n                cnt += 1\n            elif cards[i][f] != 'E' and cards[j][f] != 'E':\n                cnt += 1\n            elif cards[i][f] != 'T' and cards[j][f] != 'T':\n                cnt += 1\n        if cnt == k:\n            for m in range(j+1, n):\n                cnt = 0\n                for f in range(k):\n                    if cards[i][f] == cards[m][f]:\n                        cnt += 1\n                    elif cards[j][f] == cards[m][f]:\n                        cnt += 1\n                    elif cards[i][f] != 'S' and cards[j][f] != 'S' and cards[m][f] != 'S':\n                        cnt += 1\n                    elif cards[i][f] != 'E' and cards[j][f] != 'E' and cards[m][f] != 'E':\n                        cnt += 1\n                    elif cards[i][f] != 'T' and cards[j][f] != 'T' and cards[m][f] != 'T':\n                        cnt += 1\n                if cnt == k:\n                    num_sets += 1\nprint(num_sets)"
 ],
 "1862": [
  "n = int(input())\nsocks = list(map(int, input().split()))\n\non_table = 0\nsocks_in_bag = [False] * (n+1)\n\nfor sock in socks:\n    if socks_in_bag[sock]:\n        on_table -= 1\n    else:\n        on_table += 1\n        socks_in_bag[sock] = True\n\nprint(on_table)"
 ],
 "1863": [
  "n = int(input())\ncosts = []\nfor i in range(n):\n    a, g = map(int, input().split())\n    costs.append((a, g, i))\n\ncosts.sort(key=lambda x: abs(x[0]-500), reverse=True)\n\nSa, Sg = 0, 0\nresult = [''] * n\nfor i in range(n):\n    a, g, idx = costs[i]\n    if Sa <= Sg:\n        Sa += a\n        result[idx] = 'A'\n    else:\n        Sg += g\n        result[idx] = 'G'\n\nif abs(Sa - Sg) > 500:\n    print(-1)\nelse:\n    print(''.join(result))"
 ],
 "1864": [
  "n = int(input())\nbanknotes = list(map(int, input().split()))\nbanknotes.sort()\nsum_so_far = 0\nfor note in banknotes:\n    if note > sum_so_far + 1:\n        print(sum_so_far + 1)\n        break\n    sum_so_far += note\nelse:\n    print(sum_so_far + 1)"
 ],
 "1865": [
  "n = int(input())\narr = list(map(int, input().split()))\n\nswaps = []\nfor i in range(n):\n    min_idx = i\n    for j in range(i+1, n):\n        if arr[j] < arr[min_idx]:\n            min_idx = j\n    if min_idx != i:\n        arr[i], arr[min_idx] = arr[min_idx], arr[i]\n        swaps.append((i, min_idx))\n\nprint(len(swaps))\nfor i, j in swaps:\n    print(i, j)"
 ],
 "1866": [
  "n = int(input())\npairs = []\nfor i in range(1, n, 2):\n    pairs.append((i, i+1))\nfor i in range(1, (n//2)+1, 2):\n    pairs.append((i, n-i))\nprint(len(pairs))\nfor p in pairs:\n    print(p[0], p[1])"
 ],
 "1867": [
  "n = int(input())\narr = list(map(int, input().split()))\nfreq = {}\nmax_freq = 0\nmax_elem = -1\nfor i in range(n):\n    if arr[i] not in freq:\n        freq[arr[i]] = 0\n    freq[arr[i]] += 1\n    if freq[arr[i]] > max_freq:\n        max_freq = freq[arr[i]]\n        max_elem = arr[i]\nl = 0\nr = n-1\nfor i in range(n):\n    if arr[i] == max_elem:\n        l = i\n        break\nfor i in range(n-1, -1, -1):\n    if arr[i] == max_elem:\n        r = i\n        break\nprint(l+1, r+1)"
 ],
 "1868": [
  "n, m, a_size = map(int, input().split())\nb = list(map(int, input().split()))\n\nMOD = 998244353\n\ncounts = [0] * (n // 2 + 1)\nfor i in range(m):\n    if i == 0:\n        left, right = 1, b[i]\n    else:\n        left, right = b[i - 1] + 1, b[i]\n    for j in range(left, right + 1):\n        counts[j] = right\n\nans = 1\nfor i in range(m + 1):\n    if i == 0:\n        left, right = 1, b[i] if m else n // 2\n    elif i == m:\n        left, right = b[i - 1] + 1, n // 2\n    else:\n        left, right = b[i - 1] + 1, b[i]\n    cnt = right - left + 1\n    if cnt == 1:\n        continue\n    if cnt % 2 == 1:\n        mid = counts[(left + right) // 2]\n        if mid != right:\n            ans = (ans * 2) % MOD\n        continue\n    a = counts[left + cnt // 2 - 1]\n    b = counts[left + cnt // 2]\n    if a != right or b != left:\n        ans = (ans * 2) % MOD\n\nans = (ans * pow(a_size, n - 2 * (n // 2), MOD)) % MOD\nprint(ans)"
 ],
 "1869": [
  "n = int(input())\na = list(map(int, input().split()))\n\nres = 0\nwhile sum(a) > 0:\n    res += 1\n    l, r = None, None\n    for i in range(n):\n        if a[i] > 0:\n            if not l:\n                l = i + 1\n            r = i + 1\n            a[i] -= 1\n    for i in range(l - 1, r):\n        if a[i] == 0:\n            res += 1\n        a[i] -= 1\n\nprint(res)"
 ],
 "1870": [
  "n, c = map(int, input().split())\nt = list(map(int, input().split()))\n\ncount = 1\nfor i in range(1, n):\n    if t[i] - t[i-1] > c:\n        count = 1\n    else:\n        count += 1\n\nprint(count)"
 ],
 "1871": [
  "n, x = map(int, input().split())\nchapters = list(map(int, input().split()))\n\nchapters.sort() # Sort the subjects by number of chapters\ntime = x * chapters[0] # Initial time to teach first subject\nfor i in range(1, n):\n    if x > 1: \n        x -= 1 # Decrease learning power by 1 hour\n    time += x * chapters[i] # Time to teach next subject\nprint(time)"
 ],
 "1872": [
  "import math\n\nn, r = map(int, input().split())\n\ntheta = math.pi/n\ntan_theta = math.tan(theta/2)\nsmall_triangle_area = (r**2*tan_theta)/2\nbig_triangle_area = small_triangle_area*math.cos(theta/2)*2\nstar_area = n*small_triangle_area*2+big_triangle_area\n\nprint(star_area)"
 ],
 "1873": [
  "n, m = map(int, input().split())\ngenre = list(map(int, input().split()))\n\ncount = [0] * m\nfor i in genre:\n    count[i-1] += 1\n\nans = 0\nfor i in range(m):\n    for j in range(i+1, m):\n        ans += count[i] * count[j]\n\nprint(ans)"
 ],
 "1874": [
  "import math\n\nl3, l4, l5 = map(int, input().split())\n\n# Volume of triangular pyramid\nvolume_t = (l3 ** 3)/(6 * math.sqrt(2))\n\n# Volume of quadrangular pyramid\nvolume_q = (l4 ** 3)/(6)\n\n# Volume of pentagonal pyramid\nvolume_p = (5 * l5 ** 3)/(6 * math.tan(math.pi/5))\n\n# Total volume of the pyramid complex\ntotal_volume = volume_t + volume_q + volume_p\n\nprint(total_volume)"
 ],
 "1875": [
  "n = int(input())\npoints = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    points.append((x,y))\n\nmax_area = 0\nfor i in range(n):\n    for j in range(i+1,n):\n        for k in range(j+1,n):\n            for l in range(k+1,n):\n                # calculate area of quadrilateral\n                area = 0.5 * abs((points[j][0] - points[i][0])*(points[l][1] - points[k][1]) - \n                                 (points[l][0] - points[k][0])*(points[j][1] - points[i][1]))\n                max_area = max(max_area, area)\n\nprint(max_area)"
 ],
 "1876": [
  "MOD = 10**9 + 7\n\nn, k = map(int, input().split())\n\nedges = [[] for _ in range(n)]\nfor i in range(n - 1):\n    u, v, x = map(int, input().split())\n    edges[u-1].append((v-1, x))\n    edges[v-1].append((u-1, x))\n\ndef dfs(node, parent):\n    dp = [0] * (k + 1)\n    dp[0] = 1\n    for (neighbor, color) in edges[node]:\n        if neighbor == parent:\n            continue\n        sub_dp = dfs(neighbor, node)\n        new_dp = [0] * (k + 1)\n        for i in range(k + 1):\n            for j in range(k + 1 - i):\n                if color == 1 or j == k:\n                    new_dp[i+j] = (new_dp[i+j] + dp[i] * sub_dp[j]) % MOD\n                else:\n                    new_dp[i+j] = (new_dp[i+j] + dp[i] * (sub_dp[j] - sub_dp[j+1])) % MOD\n        dp = new_dp\n    return dp\n\nprint(sum(dfs(0, -1)) % MOD)"
 ],
 "1877": [
  "n = int(input())\ns = input()\ncoins = 0\nprev_gate = (0,0)\nfor i in range(n):\n    x, y = prev_gate\n    if s[i] == 'R':\n        x += 1\n    else:\n        y += 1\n    cur_gate = (x, y)\n    if cur_gate[0] > cur_gate[1]:\n        cur_gate = (y, x)\n    if cur_gate != prev_gate:\n        coins += 1\n        prev_gate = cur_gate\nprint(coins)"
 ],
 "1878": [
  "n = int(input())\nmatrix = [[0]*101 for _ in range(101)]\nfor _ in range(n):\n    x1, y1, x2, y2 = map(int, input().split())\n    for i in range(y1, y2+1):\n        for j in range(x1, x2+1):\n            matrix[i][j] += 1\nprint(sum(sum(row) for row in matrix))"
 ],
 "1879": [
  "t, start_x, start_y, end_x, end_y = map(int, input().split())\nwind_directions = input()\n\ncurr_x, curr_y = start_x, start_y\nfor i in range(t):\n    if wind_directions[i] == \"E\":\n        curr_x += 1\n    elif wind_directions[i] == \"S\":\n        curr_y -= 1\n    elif wind_directions[i] == \"W\":\n        curr_x -= 1\n    else:\n        curr_y += 1\n    \n    if curr_x == end_x and curr_y == end_y:\n        print(i+1)\n        break\nelse:\n    print(-1)"
 ],
 "1880": [
  "num = input()\nnum = num[0] + num[2] + num[4] + num[3] + num[1]\nans = str(int(num)**5)[-5:]\nprint(ans)"
 ],
 "1881": [
  "n, k = map(int, input().split())\npixels = list(map(int, input().split()))\n\ngroups = []\ncurrent_group = [pixels[0]]\nfor i in range(1, n):\n    if pixels[i] - current_group[0] >= k:\n        group_key = min(current_group)\n        groups.append([group_key]*len(current_group))\n        current_group = [pixels[i]]\n    else:\n        current_group.append(pixels[i])\nif len(current_group) > 0:\n    group_key = min(current_group)\n    groups.append([group_key]*len(current_group))\n\nnew_pixels = []\nfor group in groups:\n    new_pixels += group\n\nprint(*new_pixels)"
 ],
 "1882": [
  "n, T = map(int, input().split())\nproblems = []\nfor i in range(n):\n    a_i, t_i = map(int, input().split())\n    problems.append((a_i, t_i, i + 1))\nproblems = sorted(problems)\n\ndp = [[0, []] for _ in range(T + 1)]\nfor i in range(n):\n    a_i, t_i, p_i = problems[i]\n    for j in range(T - t_i, -1, -1):\n        if dp[j][0] + 1 > dp[j + t_i][0] and (not dp[j][1] or dp[j][1][-1] < p_i <= a_i):\n            dp[j + t_i][0] = dp[j][0] + 1\n            dp[j + t_i][1] = dp[j][1] + [p_i]\n\nres = max(dp)[1]\nprint(len(res))\nprint(len(res))\nprint(*res)"
 ],
 "1883": [
  "n = int(input())\ntypes = list(map(int, input().split()))\ntracks = list(map(int, input().split()))\n\ncurrent = types.index(1)\npath = [current]\nwhile tracks[current] != 0:\n    current = tracks[current]-1\n    path.append(current)\n    \nprint(len(path))\nprint(*[i+1 for i in path[::-1]])"
 ],
 "1884": [
  "n, x, y = map(int, input().split())\nc = list(map(int, input().split()))\n\nsum_c = sum(c)\nratio_x = [i / x for i in c]\nratio_y = [i / y for i in c]\n\nif max(sum_c / x, sum_c / y) > sum(c):\n    print(\"No\")\nelse:\n    print(\"Yes\")\n    if sum_c // x + 1 <= n // 2:\n        idx_x = sorted(range(n), key=lambda i: ratio_x[i], reverse=True)[:sum_c // x + 1]\n        idx_y = sorted(set(range(n)) - set(idx_x))\n    else:\n        idx_y = sorted(range(n), key=lambda i: ratio_y[i], reverse=True)[:sum_c // y + 1]\n        idx_x = sorted(set(range(n)) - set(idx_y))\n    k_x, k_y = len(idx_x), len(idx_y)\n    res_x = [i + 1 for i in idx_x]\n    res_y = [i + 1 for i in idx_y]\n    print(k_x, k_y)\n    print(*res_x)\n    print(*res_y)"
 ],
 "1885": [
  "from math import comb\nn = int(input())\nprint(sum([comb(n, r) for r in range(5, 8)]))"
 ],
 "1886": [
  "word = input()\nprint(word[0].upper() + word[1:])"
 ],
 "1887": [
  "n = int(input())\nh1 = list(map(int, input().split()))\nh2 = list(map(int, input().split()))\ndp = [[0]*3 for _ in range(n+1)]\nfor i in range(1, n+1):\n    dp[i][0] = max(dp[i-1][0], dp[i-1][1], dp[i-1][2])\n    dp[i][1] = dp[i-1][0] + h1[i-1]\n    dp[i][2] = dp[i-1][0] + h2[i-1]\nprint(max(dp[n][0], dp[n][1], dp[n][2]))"
 ],
 "1888": [
  "n, m = map(int,input().split())\na = [0]*n\nfor i in range(m):\n    x,y,z = map(int,input().split())\n    a[x-1] += z\n    a[y-1] -= z\nans = sum([i for i in a if i > 0])\nprint(ans)"
 ],
 "1889": [
  "n,m,q= map(int,input().split())\nbears=[]\nfor i in range(n):\n    bears.append(list(map(int,input().split())))\nscore=[0]*n\nfor i in range(n):\n    count=0\n    for j in range(m):\n        if bears[i][j]==1:\n            count+=1\n            score[i]=max(score[i],count)\n        else:\n            count=0\nfor i in range(q):\n    x,y=map(int,input().split())\n    x-=1\n    y-=1\n    bears[x][y]=1-bears[x][y]\n    count=0\n    score[x]=0\n    for j in range(m):\n        if bears[x][j]==1:\n            count+=1\n            score[x]=max(score[x],count)\n        else:\n            count=0\n    print(max(score))"
 ],
 "1890": [
  "a = input().strip()\nk = int(input())\n\n# count the number of 5s that can be formed by choosing different subsets of digits\ncount = 0\nfor i in range(len(a)):\n    if int(a[i]) % 5 == 0:\n        count += pow(2, k-1, 1000000007)\n\n# count the number of combinations of digits that can be chosen to form a number divisible by 5\nfor l in range(1, len(a)):\n    for i in range(len(a)-l+1):\n        if int(a[i]) % 2 == 0 and i+l == len(a):\n            # special case for even digits at the end of the string\n            count += pow(2, k-1, 1000000007)\n        elif int(a[i]) % 2 == 1:\n            # use inclusion-exclusion to count the combinations\n            count += pow(2, k-1, 1000000007) * pow(2, l-1, 1000000007) * (1 - pow(2, len(a)-i-l, 1000000007))\n            count %= 1000000007\nprint(count)"
 ],
 "1891": [
  "#taking input:\nn,k,A,B=map(int, input().split())\na=list(map(int,input().split()))\n\na.sort() #sorting the avengers' positions\n\n#defining the function to calculate power required\ndef power_req(l,r):\n    if l==r:\n        if (l in a):   #if there's an avenger at this position\n            return B     #return B*l,as mentioned in the question\n        else:\n            return A     #else return A\n\n    mid=(l+r)//2  #calculating the mid position\n\n    #recursive calls\n    left_power=power_req(l,mid)\n    right_power=power_req(mid+1,r)\n\n    #returning the minimum power required\n    return min(left_power+right_power,B*(sum([1 for i in a if i>=l and i<=r])*(r-l+1)))\n\n#printing the answer\nprint(power_req(1,2**n))"
 ],
 "1892": [
  "MOD = 10**9 + 7\n\nn = int(input())\ncommands = [input() for _ in range(n)]\n\n# dp[i] represents the number of valid programs with the first i commands\ndp = [0] * (n+1)\ndp[0] = 1\n\nstack = []\nfor i in range(1, n+1):\n    if commands[i-1] == 's':\n        dp[i] = dp[i-1]\n    else:  # commands[i-1] == 'f'\n        # remove commands that should be at lower level from stack\n        while stack and stack[-1] > dp[i-1]:\n            stack.pop()\n        # add current level to stack and calculate dp[i] based on previous level\n        prev_level = stack[-1] if stack else 0\n        dp[i] = (dp[prev_level] + dp[i-1]) % MOD\n        stack.append(i)\n\nprint(dp[n])\n\n"
 ],
 "1893": [
  "import math\n\nn, t = map(int, input().split())\nresult = n * math.pow(1.000000011, t)\nprint(\"%.15f\" % result)"
 ],
 "1894": [
  "n,m = map(int, input().split())\nhouse = [list(input()) for _ in range(n)]\nx,direction = n-1, 1\ntime = 0\n\nwhile x >= 0:\n  if house[x][0] == \"#\":\n    direction = 1\n    x -= 1\n  elif house[x][m-1] == \"#\":\n    direction = -1\n    x -= 1\n  else:\n    y = 0 if direction == 1 else m-1\n    while True:\n      if y < 0 or y == m:\n        print(\"Never\")\n        exit()\n      if house[x][y] == \"#\":\n        direction *= -1\n        break\n      time += 1\n      if house[x][y] == \"+\":\n        house[x][y] = \".\"\n        direction *= -1\n        break\n      y += direction\nprint(time)"
 ],
 "1895": [
  "n, m = map(int, input().split())\n\nevents = []\nfor i in range(n):\n    event = input().split()\n    if len(event) == 1:\n        events.append((1, \"\"))\n    else:\n        events.append((2, event[1]))\n\nhappy = 0\nfor i in range(1 << m):\n    handle = \"\"\n    count = 0\n    for j in range(n):\n        if events[j][0] == 1:\n            handle = \"\"\n        else:\n            friend = events[j][1]\n            if handle == friend or (i >> count) % 2 == 1:\n                handle = friend\n            else:\n                break\n            count += 1\n    else:\n        happy = max(happy, bin(i).count(\"1\"))\n\nprint(happy)"
 ],
 "1896": [
  "n = int(input())\nif n == 0:\n    print('1')\nelse:\n    print(3*n*(n+1)+1)"
 ],
 "1897": [
  "s = input()\nn = len(s)\nvowels = \"AEIOUY\"\n\ntotal_pret = 0\n\nfor i in range(n):\n    simple_pret = 0\n    for j in range(i, n):\n        if s[j] in vowels:\n            simple_pret += 1\n        total_pret += simple_pret / (j-i+1)\n\nprint(\"{:.7f}\".format(total_pret))"
 ],
 "1898": [
  "python\nn = int(input())\nfeeling = \"I hate\"\n\nfor i in range(2, n+1):\n    if i%2 == 0:\n        feeling += \" that I love\"\n    else:\n        feeling += \" that I hate\"\n\nfeeling += \" it\"\n\nprint(feeling)"
 ],
 "1899": [
  "import sys\n\nn, s, m, k = map(int, input().split())\na = list(map(int, input().split()))\n\nsegments = []\nfor i in range(s):\n    l, r = map(int, input().split())\n    segments.append((l, r))\n\nsegments.sort()\n\nleft, right = 0, n\nans = -1\nwhile left <= right:\n    mid = (left + right) // 2\n    dp = [-1] * (m + 1)\n    dp[0] = 0\n\n    cnt = [0] * n\n    for l, r in segments:\n        for i in range(l - 1, r):\n            cnt[i] += 1\n\n    for i in range(n):\n        if cnt[i] >= mid:\n            for j in range(m, 0, -1):\n                dp[j] = max(dp[j], dp[j - 1] + a[i])\n\n    if dp[m] >= k:\n        ans = mid\n        right = mid - 1\n    else:\n        left = mid + 1\n\nprint(ans)"
 ],
 "1900": [
  "n, k, m = map(int, input().split())\na = list(map(int, input().split()))\ncount = {}\nfor i in range(n):\n    if a[i] not in count:\n        count[a[i]] = []\n    count[a[i]].append(i)\n\nans = n * m\nfor city in count:\n    indices = count[city]\n    for i in range(len(indices) - k + 1):\n        left = indices[i] - 1 if i > 0 else -1\n        right = indices[i+k-1] + 1 if i+k < len(indices) else n\n        span = right - left - 1 - k\n        ans -= max(span*m, 0)\n\nprint(ans)"
 ],
 "1901": [
  "n, m = map(int, input().split())\nc = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n)]\n\nfor i in range(m):\n    x, y = map(int, input().split())\n    x -= 1\n    y -= 1\n    graph[x].append(y)\n    graph[y].append(x)\n\nvisited = [False] * n\ncosts = []\n\nfor i in range(n):\n    if not visited[i]:\n        visited[i] = True\n        queue = [i]\n        min_cost = c[i]\n        \n        while queue:\n            node = queue.pop(0)\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                    min_cost = min(min_cost, c[neighbor])\n        \n        costs.append(min_cost)\n\nprint(sum(costs))"
 ],
 "1902": [
  "import sys\n\ndef count_clicks(text):\n    words = text.split()\n    clicks = len(words[0])+1\n\n    for i in range(1, len(words)):\n        #if the current word is the prefix of the previous word\n        if words[i-1].startswith(words[i]):\n            clicks += len(words[i-1]) - len(words[i]) + 1\n        else:\n            clicks += len(words[i]) + 1\n\n    return clicks\n\ntext = sys.stdin.read().strip()\nclicks = count_clicks(text)\nprint(clicks)"
 ],
 "1903": [
  "n, m, d = map(int,input().split())\nc1_w1 = []\nfor i in range(n):\n    c1_w1.append(tuple(map(int,input().split())))\n\nc2_w2 = []\nfor i in range(m):\n    c2_w2.append(tuple(map(int,input().split())))\n\nc1_w1.sort(reverse=True)\nc2_w2.sort(reverse=True)\n\nfor i in range(n-1):\n    c1_w1[i+1] = (c1_w1[i+1][0],c1_w1[i+1][1]+c1_w1[i][1])\n\nfor i in range(m-1):\n    c2_w2[i+1] = (c2_w2[i+1][0],c2_w2[i+1][1]+c2_w2[i][1])\n\nans = 0\n\nfor i in range(1,n+1):\n    j = 0\n    while j<m and c1_w1[i-1][1]+c2_w2[j][1]<=d:\n        j+=1\n    if j == 0:\n        continue\n    ans = max(ans,c1_w1[i-1][0]+c2_w2[j-1][0])\n\nfor i in range(1,m+1):\n    j = 0\n    while j<n and c2_w2[i-1][1]+c1_w1[j][1]<=d:\n        j+=1\n    if j == 0:\n        continue\n    ans = max(ans,c2_w2[i-1][0]+c1_w1[j-1][0])\n\nprint(ans)"
 ],
 "1904": [
  "n=int(input())\ns=input()\na=[0]+list(map(int,input().split()))\n\n# Initialize dp array with very large values\ndp=[10**9]*4\ndp[0]=0\n\n# Loop through the string and update dp array\nfor c in s:\n    if c=='h':\n        dp[1]=min(dp[1],a[1])\n    elif c=='a':\n        dp[2]=min(dp[1],dp[2]+a[2])\n    elif c=='r':\n        dp[3]=min(dp[2],dp[3]+a[3])\n    elif c=='d':\n        dp[3]=min(dp[3],dp[3]+a[4])\n\n# Print the final result\nprint(dp[3])"
 ],
 "1905": [
  "# Reading input\nn, m, q = map(int, input().split())\n\n# Initializing matrix with all zeros\nmatrix = [[0 for j in range(m)] for i in range(n)]\n\n# Applying operations in reverse order to obtain the initial matrix\nfor i in range(q-1, -1, -1):\n    operation = input().split()\n    t = int(operation[0])\n    if t == 3:\n        r, c, x = int(operation[1])-1, int(operation[2])-1, int(operation[3])\n        matrix[r][c] = x\n    else:\n        index = int(operation[1])-1\n        if t == 1:\n            row = matrix[index][:]\n            matrix[index] = row[-1:] + row[:-1]\n        else:\n            col = [matrix[i][index] for i in range(n)]\n            for i in range(n-1):\n                matrix[i][index] = col[i+1]\n            matrix[n-1][index] = col[0]\n\n# Printing initial matrix\nfor row in matrix:\n    print(' '.join(map(str, row)))"
 ],
 "1906": [
  "n = int(input())\ncount = 0\nfor i in range(1, n+1):\n    if i%2!=0 and i%3!=0 and i%4!=0 and i%5!=0 and i%6!=0 and i%7!=0 and i%8!=0 and i%9!=0 and i%10!=0:\n        count += 1\nprint(count)"
 ],
 "1907": [
  "import math\nn = int(input())\nx, y, r = [], [], []\nfor i in range(n):\n    xi, yi, ri = map(int, input().split())\n    x.append(xi)\n    y.append(yi)\n    r.append(ri)\n\ndef get_area(i, j):\n    d = math.sqrt((x[i] - x[j])**2 + (y[i] - y[j])**2)\n    if d >= r[i] + r[j]:\n        return 0\n    if r[i] >= d + r[j]:\n        return math.pi * r[j]**2\n    if r[j] >= d + r[i]:\n        return math.pi * r[i]**2\n    alpha_s = math.acos((r[i]**2 + d**2 - r[j]**2) / (2 * r[i] * d))\n    alpha_t = math.acos((r[j]**2 + d**2 - r[i]**2) / (2 * r[j] * d))\n    return r[i]**2 * alpha_s + r[j]**2 * alpha_t - d * r[i] * math.sin(alpha_s)\n\n\nans = -1\nfor half in range(2):\n    f = []\n    for i in range(n):\n        if i % 2 == half:\n            f.append(1)\n        else:\n            f.append(-1)\n    max_area = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_area += f[i] * f[j] * get_area(i, j)\n    ans = max(ans, max_area)\nprint(ans)"
 ],
 "1908": [
  "import heapq\n\nn, m = map(int, input().split())\nw = list(map(int, input().split()))\n\ngraph = [[] for _ in range(2 * n + 2)]\nindegree = [0 for _ in range(2 * n + 2)]\n\nfor i in range(m):\n    x, y = map(int, input().split())\n    graph[x].append(y + n)\n    indegree[y + n] += 1\n    graph[y].append(x + n)\n    indegree[x + n] += 1\n\nfor i in range(1, n + 1):\n    graph[0].append(i)\n    indegree[i] += 1\n    graph[i + n].append(2 * n + 1)\n    indegree[2 * n + 1] += 1\n\nheap = []\nfor i in range(1, 2 * n + 2):\n    if indegree[i] == 0:\n        heapq.heappush(heap, i)\n\nsurvive = []\nwhile heap:\n    u = heapq.heappop(heap)\n    survive.append(u)\n    for v in graph[u]:\n        indegree[v] -= 1\n        if indegree[v] == 0:\n            heapq.heappush(heap, v)\n\nif len(survive) != 2 * n + 2:\n    print(\"DEAD\")\nelse:\n    print(\"ALIVE\")\n    ans = []\n    for i in range(1, n + 1):\n        if survive.index(i) < survive.index(i + n):\n            ans.append(survive.index(i + n))\n            ans.append(survive.index(i))\n        else:\n            ans.append(survive.index(i))\n            ans.append(survive.index(i + n))\n    print(\" \".join(str(item) for item in ans))"
 ],
 "1909": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\nmin_power = float(\"inf\")\nmin_task = -1\n\nfor i in range(k):\n    power = 0\n    for j in range(i, n, k):\n        power += a[j]\n    if power < min_power:\n        min_power = power\n        min_task = i+1\n\nprint(min_task)"
 ],
 "1910": [
  "n = int(input())\nans = 4*(n-1)*(3**(2*n-2)-2*(3**n)+3)//2\nprint(ans)"
 ],
 "1911": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\ns = []\nfor i in range(1, n):\n    s.append(a[i] - a[i-1])\n    \ns.sort(reverse=True)\n\nfor i in range(k-1):\n    s[i] = 0\n\nprint(sum(s))"
 ],
 "1912": [
  "t = int(input())\n\nfor i in range(t):\n    r, g, b, w = map(int, input().split())\n    sum_all = r+g+b+w\n    count_odd = (r%2) + (g%2) + (b%2) + (w%2)\n    \n    if sum_all%2 == 0:\n        if count_odd == 0 or count_odd == 4:\n            print(\"Yes\")\n        elif count_odd == 2 and ((r and g and b) or (not r and not g and not b)):\n            print(\"Yes\")\n        else:\n            print(\"No\")\n    else:\n        if count_odd == 1 or count_odd == 3:\n            print(\"Yes\")\n        elif count_odd == 2 and ((r and g and b) or (not r and not g and not b)):\n            print(\"Yes\")\n        else:\n            print(\"No\")"
 ],
 "1913": [
  "python\nn = int(input())\nnums = input().split()\nflag = False\nfor i in range(n):\n    if '0' in nums[i]:\n        print(0)\n        flag = True\n        break\n    elif '1' not in nums[i]:\n        flag = True\n        nums[i] = '1'\nif not flag:\n    nums.append('1')\nprint(''.join(nums))"
 ],
 "1914": [
  "from collections import defaultdict\n\nt = input().strip()\nn = int(input().strip())\ns = [input().strip() for _ in range(n)]\n\nfreq = defaultdict(int)\nfor i in range(n):\n    for j in range(n):\n        freq[s[i] + s[j]] += 1\n\nans = 0\nfor i in range(len(t)):\n    for j in range(i, len(t)):\n        ans += freq[t[i:j+1]]\nprint(ans)"
 ],
 "1915": [
  "n = int(input())\ntable = [[1]*n] * n  # create initial table filled with ones\nfor i in range(1, n):\n    for j in range(1, n):\n        table[i][j] = table[i-1][j] + table[i][j-1]  # fill up remaining entries using recurrence relation\nprint(table[-1][-1])  # print the bottom-right element, which is the maximum value in the table"
 ],
 "1916": [
  "n, m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nres = 2**9-1 # Set maximum possible value\n\nfor i in range(2**9): # iterate through all possible values of c\n    cur = i\n    for j in range(n):\n        possible_vals = [a[j]&b[k] for k in range(m)] # Find all possible values of c for this j\n        if all(cur|val in possible_vals for val in possible_vals): # Check if c can be achieved for all j\n            res = min(res, cur)\n            break\n\nprint(res)"
 ],
 "1917": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\ndef check(x):\n    b = [min(ai, x) for ai in a]\n    b.sort(reverse=True)\n    return sum(b[:k]) >= x * k\n\nl, r = 0, 10**9\nwhile l < r:\n    mid = (l + r + 1) // 2\n    if check(mid):\n        l = mid\n    else:\n        r = mid - 1\n\nb = [min(ai, l) for ai in a]\nb.sort(reverse=True)\nfor i in range(k):\n    b[i] += 1\n\nprint(*b)"
 ],
 "1918": [
  "n = int(input())\nstrengths = list(map(int, input().split()))\nassignment = input()\n\nteam_A_strengths = [strengths[i] for i in range(n) if assignment[i] == 'A']\nteam_B_strengths = [strengths[i] for i in range(n) if assignment[i] == 'B']\nteam_B_strengths.reverse()\n\nmax_strength = sum(team_B_strengths)\ntemp_sum = 0\n\nfor i in range(min(n, len(team_B_strengths))):\n    temp_sum += team_A_strengths[i] - team_B_strengths[i]\n    max_strength = max(max_strength, temp_sum + sum(team_B_strengths[i + 1:]))\n\ntemp_sum = 0\nfor i in range(min(n, len(team_A_strengths))):\n    temp_sum += team_B_strengths[i] - team_A_strengths[i]\n    max_strength = max(max_strength, temp_sum + sum(team_A_strengths[i + 1:]))\n\nprint(max_strength)"
 ],
 "1919": [
  "n = int(input())\nif n % 2 == 0:\n    print(2)\nelse:\n    print(1)"
 ],
 "1920": [
  "n = int(input())\nmale = []\nfemale = []\nfor i in range(n):\n    friend = input().split()\n    if friend[0] == 'M':\n        male.append((int(friend[1]), int(friend[2])))\n    else:\n        female.append((int(friend[1]), int(friend[2])))\n        \nmax_friends = 0\nfor day in range(1, 367):\n    num_male = 0\n    num_female = 0\n    for m in male:\n        if day >= m[0] and day <= m[1]:\n            num_male += 1\n    for f in female:\n        if day >= f[0] and day <= f[1]:\n            num_female += 1\n    max_friends = max(max_friends, min(num_male, num_female)*2)\n    \nprint(max_friends)"
 ],
 "1921": [
  "import heapq\n\nn, m = map(int, input().split())\nsx, sy, fx, fy = map(int, input().split())\nspecial_X, special_Y = set(), set()\n\nfor i in range(m):\n    x, y = map(int, input().split())\n    special_X.add(x)\n    special_Y.add(y)\n\ndx, dy = [-1, 0, 1, 0], [0, 1, 0, -1]\nq = [(0, sx, sy)]\nvis = set()\n\nwhile q:\n    time, x, y = heapq.heappop(q)\n\n    if (x, y) in vis:\n        continue\n    vis.add((x, y))\n\n    if x == fx and y == fy:\n        print(time)\n        break\n\n    for i in range(4):\n        nx, ny = x + dx[i], y + dy[i]\n\n        if nx >= 1 and nx <= n and ny >= 1 and ny <= n and (nx, ny) not in vis:\n            if nx in special_X or ny in special_Y:\n                heapq.heappush(q, (time, nx, ny))\n            else:\n                heapq.heappush(q, (time + 1, nx, ny))"
 ],
 "1922": [
  "n, m = map(int, input().split())\nprint((n - 1) * (m - 1))"
 ],
 "1923": [
  "n = int(input())\nli = list(map(int, input().split()))\nli.sort()\nans = sum(li[::2])\nprint(ans)"
 ],
 "1924": [
  "MOD = 10**9 + 7\nr1, c1, r2, c2 = map(int, input().split())\n\n# Function to calculate number of paths from (0,0) to (r,c)\ndef f(r, c):\n    return (r+c)*(r-c+1)//2 + r*(r-1)//2*c\n\nans = 0\nans += f(r2, c2)\nans -= f(r2, c1-1)\nans -= f(r1-1, c2)\nans += f(r1-1, c1-1)\n\nprint(ans%MOD)"
 ],
 "1925": [
  "a,b,n=map(int,input().split())\nx=min(n,b-1)\nprint((a*x)//b-a*(x//b))"
 ],
 "1926": [
  "import heapq\n\nn = int(input())\na = list(map(int, input().split()))\n\nres = []\nfor k in range(1, n):\n    cnt = 0\n    heap = a[:k]\n    heapq.heapify(heap)\n    for i in range(k, n):\n        if a[i] < heap[0]:\n            cnt += 1\n        heapq.heappush(heap, a[i])\n        heapq.heappop(heap)\n    res.append(cnt)\n\nprint(*res)"
 ],
 "1927": [
  "n, m = map(int, input().split())\nmessages = list(map(int, input().split()))\n\nmax_pos = [i for i in range(n)]\nmin_pos = [i for i in range(n)]\n\npositions = {}\n\nfor i in range(n):\n    positions[i+1] = i\n    \nfor i in range(m):\n    a = messages[i]\n    a_i = positions[a]\n    \n    if a_i == 0:\n        continue\n        \n    b = a-1\n    b_i = positions[b]\n    \n    positions[a] = a_i - 1\n    positions[b] = b_i + 1\n    \n    max_pos[a_i] = max(max_pos[a_i], positions[a]+1)\n    min_pos[a_i] = min(min_pos[a_i], positions[a]+1)\n    max_pos[b_i] = max(max_pos[b_i], positions[b]+1)\n    min_pos[b_i] = min(min_pos[b_i], positions[b]+1)\n    \nfor i in range(1, n+1):\n    print(min_pos[positions[i]], max_pos[positions[i]])"
 ],
 "1928": [
  "n, m, k = map(int, input().split())\n\nif k > n * m:\n    print(-1)\nelse:\n    path = []\n    for i in range(k):\n        y = i % m\n        x = i // m\n        if x % 2 == 1:\n            y = m - y - 1\n        path.append([(j, 1 + (j + y) % m) for j in range(x + 1)])\n    print(sum(len(p) for p in path))\n    for p in path:\n        print(' '.join(f'({x},{y})' for x, y in p))"
 ],
 "1929": [
  "n, t, c = map(int, input().split())\ncrimes = list(map(int, input().split()))\ncount = 0\ntemp = 0\n\nfor i in crimes:\n    if i <= t:\n        temp += 1\n    else:\n        if temp >= c:\n            count += temp - c + 1\n        temp = 0\n\nif temp >= c:\n    count += temp - c + 1\n    \nprint(count)"
 ],
 "1930": [
  "n=int(input())\np=list(map(int,input().split()))\nmod=998244353\n\nfc=[1]*(n+1)\nfor i in range(2,n+1):\n    fc[i]=(fc[i-1]*i)%mod\n\ninvfc=[1]*(n+1)\ndef inverse(n,p):\n    res=1\n    while p:\n        if p&1:\n            res=res*n%mod\n        n=n*n%mod\n        p>>=1\n    return res\nfor i in range(n-1,0,-1):\n    invfc[i]=(invfc[i+1]*(i+1))%mod\n    \ndef C(x,y):\n    if x<y:\n        return 0\n    return fc[x]*invfc[y]%mod*invfc[x-y]%mod\n    \ncnt=p.count(-1)\ninvsum=[[0 for j in range(cnt+1)] for i in range(cnt+1)]\ninvsum[0][0]=1\nfor i in range(n):\n    if p[i]==-1:\n        for j in range(cnt):\n            for x in range(cnt-j+1):\n                coe=1\n                if x>0:\n                    coe=x*j%mod*inverse(cnt,mod)%mod\n                invsum[j+x][cnt-j-x]+=coe*invsum[j][cnt-j]*C(cnt-j,x)%mod\n                invsum[j+x][cnt-j-x]%=mod\n\nans=0\nfor i in range(cnt+1):\n    for j in range(cnt-i+1):\n        coe=1\n        if j>0:\n            coe=j*(cnt-i-j)%mod*inverse(cnt,mod)%mod\n        ans+=coe*invsum[i][j]*C(cnt,i)%mod*C(cnt-i,j)%mod\n\nfor i in range(2,n-cnt+1):\n    ans=ans*i%mod\n    \nprint(ans*inverse(fc[n],mod)%mod)"
 ],
 "1931": [
  "t = int(input())\nfor i in range(t):\n    n = int(input())\n    count = 0\n    while n >= 2*(count+1)**2 - 3*(count+1) + 2:\n        n -= 2*(count+1)**2 - 3*(count+1) + 2\n        count += 1\n    print(count) "
 ],
 "1932": [
  "n = int(input())\nfaces = {'Tetrahedron': 4, 'Cube': 6, 'Octahedron': 8, 'Dodecahedron': 12, 'Icosahedron': 20}\ntotal_faces = 0\nfor i in range(n):\n    polyhedron = input()\n    total_faces += faces[polyhedron]\nprint(total_faces)"
 ],
 "1933": [
  "n, m, k = map(int, input().split())\na = [list(map(int, input().split())) for i in range(n)]\n\nreplacements = 0\nscore = 0\nfor j in range(m):\n    topmost_one = None\n    for i in range(n):\n        if a[i][j] == 1:\n            topmost_one = i\n            break\n    if topmost_one is None:\n        continue\n    replacements += (n - topmost_one - 1)\n    topmost_one += 1\n    ones_count = 0\n    right = min(topmost_one+k, n)\n    for i in range(topmost_one, right):\n        ones_count += a[i][j]\n    score += ones_count\n\nprint(score, replacements)"
 ],
 "1934": [
  "from collections import defaultdict\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\nidxs = defaultdict(list)\nfor i, num in enumerate(a):\n    idxs[num].append(i)\n\nfor _ in range(m):\n    l, r = map(int, input().split())\n    ans = float('inf')\n    for num, indices in idxs.items():\n        start_idx = bisect_left(indices, l-1)\n        end_idx = bisect_right(indices, r-1)\n        if end_idx - start_idx >= 2:\n            ans = min(ans, indices[end_idx-1]-indices[start_idx])\n    print(ans if ans != float('inf') else -1)"
 ],
 "1935": [
  "from collections import deque\n\nn, m = map(int, input().split())\nd = list(map(int, input().split()))\nd.sort()\ng, r = map(int, input().split())\n\n# create a adjacency list to store the edges\nadj_list = [[] for _ in range(m)]\nfor i in range(m):\n    for j in range(i+1, m):\n        diff = d[j] - d[i]\n        if diff <= g and diff > 0:\n            adj_list[i].append((j, diff))\n            adj_list[j].append((i, diff))\n\n# using bfs to find shortest path(s)\nINF = int(1e9)\ndist = [[INF] * (g+1) for _ in range(m)] # g+1 is because we don't need to full cycle\nstart_node = 0\ndist[start_node][0] = 0\nqueue = deque([(start_node, 0)])\nwhile queue:\n    u, rem = queue.popleft()\n    for v, weight in adj_list[u]:\n        if rem + weight <= g and dist[v][rem+weight] > dist[u][rem] + weight:\n            dist[v][rem+weight] = dist[u][rem] + weight\n            queue.append((v, rem+weight))\n    if rem == 0: # end of a green cycle\n        for v, weight in adj_list[u]:\n            if g - weight <= r and dist[v][g-weight] > dist[u][rem] + g:\n                dist[v][g-weight] = dist[u][rem] + g\n                queue.append((v, g-weight))\n\nans = INF\nfor i in range(m):\n    if d[i] == n:\n        for j in range(g+1):\n            ans = min(ans, dist[i][j]*g + j)\n        break\n\nprint(ans if ans != INF else -1)"
 ],
 "1936": [
  "import math\n\nt = int(input())\n\nfor _ in range(t):\n    l, r = map(int, input().split())\n    \n    if l*2 > r:\n        print('-1 -1')\n    else:\n        print(l, l*2)"
 ],
 "1937": [
  "n = int(input())\nb = list(map(int, input().split()))\n\na = [0] * (n//2)\n\nfor i in range(n//2):\n    a[i] = b[i] - max(a[:i]+[0]) \n\nfor i in range(n//2):\n    print(a[i], end=\" \")\n    print(b[i]-a[i], end=\" \")"
 ],
 "1938": [
  "MOD = 10**9 + 7\nn, k = map(int, input().split())\n\ndef solve(l, r):\n    if l > r:\n        return 0\n    return (r - l + 1) * (r - l + 2) // 2\n\nintervals = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    intervals.append((l, r))\n\nintervals.sort()\nprefix_min = [intervals[0][0]]\nfor i in range(1, n):\n    prefix_min.append(min(prefix_min[-1], intervals[i][0]))\n\nsuffix_max = [intervals[n-1][1]]\nfor i in range(n-2, -1, -1):\n    suffix_max.append(max(suffix_max[-1], intervals[i][1]))\nsuffix_max.reverse()\n\nans = 0\nfor i in range(n-k+1):\n    l = prefix_min[i]\n    r = suffix_max[i+k-1]\n    ans = (ans + solve(l, r)) % MOD\n\nprint(ans)"
 ],
 "1939": [
  "n, k = map(int, input().split())\nfor i in range(n):\n    row = [str(k//n)] * n\n    row[i] = str(k//n + k%n)\n    print(\" \".join(row))"
 ],
 "1940": [
  "n,k = map(int, input().split())\nw = list(map(int, input().split()))\n\ndays = 0\nfor pebbles in w:\n    days += -(-pebbles // (2*k))\n\nprint(days)"
 ],
 "1941": [
  "A, B, n = map(int, input().split())\n\nfor i in range(n):\n    l, t, m = map(int, input().split())\n    low, high = l, 10 ** 9\n\n    while low < high:\n        mid = (low + high + 1) // 2\n        if A + (mid - l) * B <= t * m + A and (A + (mid - l - 1) * B > t * m + A or (mid - l) * B > t * m):\n            high = mid - 1\n        else:\n            low = mid\n\n    if A + (low - l) * B <= t * m + A and (A + (low - l - 1) * B > t * m + A or (low - l) * B > t * m):\n        print(low)\n    else:\n        print(-1)"
 ],
 "1942": [
  "from math import ceil\n\ndef get_cycle(n, l, r):\n    cycles = ceil((n-1)*2)\n    cycle_len = n*(n-1) + 1\n    pos = l - 1\n    ans = []\n    for i in range(cycles):\n        if pos >= cycle_len:\n            pos -= cycle_len\n        if pos < n-1:\n            ans.append(1 + pos)\n        else:\n            pos -= n-1\n            ans.append(n)\n            ans.append(n-pos)\n        pos += cycles\n    return ans[l-1:r]\n\nt = int(input())\nfor _ in range(t):\n    n, l, r = map(int, input().split())\n    ans = get_cycle(n, l, r)\n    print(*ans)"
 ],
 "1943": [
  "from sys import stdin\nfrom functools import lru_cache\n\n@lru_cache(None)\ndef dp(rnd, s, e):\n    if s == e:\n        return 0 if rnd == 1 else -1e18\n    if rnd > N:\n        return 0\n    m = (s+e)//2\n    res = -1\n    for i in range(s, m+1):\n        for j in range(m+1, e+1):\n            res = max(res, dp(rnd+1, s, m) + dp(rnd+1, m+1, e) + w[i][j][rnd])\n    return res\n\nN = int(stdin.readline().strip())\nP = [list(map(int, stdin.readline().strip().split())) for _ in range(2**N)]\n\nw = [[[0]*(N+1) for _ in range(2**N+1)] for _ in range(2**N+1)]\nfor i in range(1, 2**N):\n    for j in range(i+1, 2**N+1):\n        for rnd in range(1, N+1):\n            m = (i+j)//2\n            w[i][j][rnd] = w[i][j][rnd-1] + max(P[k-1][j-1] for k in range(i, m+1)) \\\n                + max(P[k-1][j-1] for k in range(m+1, j))\n            w[j][i][rnd] = w[i][j][rnd]\n\nprint('{:.10f}'.format(dp(1, 1, 2**N)))"
 ],
 "1944": [
  "n = int(input())\nlaptops = []\nfor i in range(n):\n    price, quality = map(int, input().split())\n    laptops.append((price, quality))\n\nsorted_laptops = sorted(laptops)\n\nfor i in range(n-1):\n    if sorted_laptops[i][1] > sorted_laptops[i+1][1]:\n        print(\"Happy Alex\")\n        break\nelse:\n    print(\"Poor Alex\")"
 ],
 "1945": [
  "n = int(input())\nusers = {}\nroots = {}\n\nfor i in range(n):\n    old, new = input().split()\n    if old not in roots:\n        roots[old] = old\n        users[old] = set()\n    if new not in roots:\n        roots[new] = new\n        users[new] = set()\n    roots[roots[old]] = roots[new]\n    users[new].add(old)\n\nresult = []\nfor user in users:\n    if roots[user] == user:\n        for old in users[user]:\n            result.append((old, user))\n\nprint(len(result))\nfor old, new in result:\n    print(old, new)"
 ],
 "1946": [
  "n = int(input())\na = []\nfor i in range(n):\n    ai, xi = map(int, input().split())\n    a.append((ai, xi))\na.sort()\n\nm = int(input())\nb = []\nfor i in range(m):\n    bj, yj = map(int, input().split())\n    b.append((bj, yj))\nb.sort()\n\ni = 0\nj = 0\nans = 0\nwhile i < n and j < m:\n    if a[i][0] < b[j][0]:\n        ans += a[i][1]\n        i += 1\n    elif a[i][0] > b[j][0]:\n        ans += b[j][1]\n        j += 1\n    else:\n        ans += max(a[i][1], b[j][1])\n        i += 1\n        j += 1\n\nwhile i < n:\n    ans += a[i][1]\n    i += 1\n\nwhile j < m:\n    ans += b[j][1]\n    j += 1\n\nprint(ans)"
 ],
 "1947": [
  "from math import inf\n\n\nclass Node:\n    def __init__(self, l, r, val=0):\n        self.l, self.r, self.val = l, r, val\n        self.left, self.right = None, None\n\n    def create_children(self):\n        mid = (self.l + self.r) // 2\n        if self.l < mid:\n            self.left = Node(self.l, mid)\n        if mid < self.r:\n            self.right = Node(mid, self.r)\n\n    def update(self, l, r, d, pos):\n        if r <= self.l or self.r <= l:\n            return\n        if l <= self.l and self.r <= r:\n            self.val += d\n            return\n        if self.left is None:\n            self.create_children()\n        self.left.update(l, r, d, pos)\n        self.right.update(l, r, d, pos)\n        if self.left.val <= self.right.val:\n            self.val = self.left.val\n            pos[pos.index(self.r)] = self.l\n        else:\n            self.val = self.right.val\n            pos[pos.index(self.l)] = self.r\n\n\nclass Haircut:\n    def __init__(self, n, l, a):\n        self.n, self.l, self.a = n, l, a\n        self.dsu = list(range(n))\n        self.longer = [i for i in range(n) if a[i] > l] + [-1]\n        self.first_cutoff = len(self.longer) - 2\n        self.comp = 0\n        self.pos = list(range(n))\n        self.tree = Node(0, len(self.longer) - 1)\n\n    def find(self, x):\n        if self.dsu[x] == x:\n            return x\n        self.dsu[x] = self.find(self.dsu[x])\n        return self.dsu[x]\n\n    def union(self, x, y):\n        x, y = self.find(x), self.find(y)\n        if x != y:\n            self.dsu[x] = y\n\n    def cut(self, x):\n        if self.a[x] <= self.l:\n            return\n\n        self.a[x], old_val = self.l, self.a[x]\n        i = self.find(x)\n        self.union(i, i + 1)\n        left, right = self.f_eq(i), self.f_eq(i + 1)\n        self.comp -= self.tree.val - self.a[x]\n        self.tree.update(left + 1, right, old_val - self.l, self.pos)\n        self.comp += self.tree.val - self.a[x]\n        self.union(left, right)\n\n    def f_eq(self, v):\n        u = self.longer[v]\n        self.pos[v] = u\n        while u != self.longer[u]:\n            u = self.longer[u]\n            self.pos[self.longer.index(u)] = v\n        return v\n\n    def query(self):\n        if self.comp > 0:\n            return -1\n        return len(self.longer) - self.first_cutoff - 2\n\n\nn, m, l = map(int, input().split())\na = list(map(int, input().split()))\nhaircut = Haircut(n, l, a)\nfor i in range(len(haircut.longer) - 1):\n    if haircut.longer[i] + 1 == haircut.longer[i + 1]:\n        haircut.union(i, i + 1)\n\nfor _ in range(m):\n    query = input().split()\n    if query[0] == '0':\n        print(haircut.query())\n    else:\n        p, d = map(int, query[1:])\n        p -= 1\n        haircut.cut(p)\n        if p + 1 < n and haircut.a[p + 1] > l:\n            haircut.union(haircut.find(p), haircut.find(p + 1))\n        if p > 0 and haircut.a[p - 1] > l:\n            haircut.union(haircut.find(p), haircut.find(p - 1))\n        if d + haircut.a[p] <= l:\n            if p > 0 and p + 1 < n and haircut.a[p + 1] <= l and haircut.a[p - 1] <= l:\n                haircut.comp += 1\n        elif haircut.a[p] > l:\n            if p > 0 and p + 1 < n and haircut.a[p + 1] > l and haircut.a[p - 1] > l:\n                haircut.comp -= 1\n        haircut.a[p] += d\n"
 ],
 "1948": [
  "import sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(v, p, d):\n    global ans\n    for u in tree[v]:\n        if u != p:\n            dfs(u, v, d+1)\n            if u == bob and d > ans and v != bob: # Bob's turn\n                ans = d\n            if v == bob and d > ans: # Alice's turn\n                ans = d\n\nn, bob = map(int, input().split())\ntree = [[] for _ in range(n+1)]\nfor _ in range(n-1):\n    u, v = map(int, input().split())\n    tree[u].append(v)\n    tree[v].append(u)\n\nans = 0\ndfs(1, -1, 0)\nprint(ans*2)"
 ],
 "1949": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\nfor _ in range(k):\n    min_non_zero = float('inf')\n    for i in range(n):\n        if a[i] != 0 and a[i] < min_non_zero:\n            min_non_zero = a[i]\n    if min_non_zero == float('inf'):\n        print(0)\n        continue\n    print(min_non_zero)\n    for i in range(n):\n        if a[i] != 0:\n            a[i] -= min_non_zero"
 ],
 "1950": [
  "n=int(input())\na=list(map(int, input().split()))\na.sort()\ns=sum(a)\nans=s+a[0]*(2*n-2)\nfor i in range(2,n):\n    s-=a[i-2]\n    ans=min(ans, s+a[i-1]*(2*(n-i)))\nprint(ans)"
 ],
 "1951": [
  "n = int(input())\nlst = []\nplaced = set()\nok = True\nfor i in range(2*n):\n    s = input().strip()\n    if s[0] == '-':\n        x = int(s.split()[1])\n        if not lst or lst[0] != x:\n            ok = False\n            break\n        lst.pop(0)\n    else:\n        x = len(placed)+1\n        placed.add(x)\n        lst.append(x)\n\nif ok:\n    print(\"YES\")\n    print(\" \".join(map(str, lst)))\nelse:\n    print(\"NO\")"
 ],
 "1952": [
  "n,k=map(int,input().split())\nsizes=list(map(int,input().split()))\nmax_arr=list(map(int,input().split()))\ncnt=[0]*k\nt=[[] for i in range(k)]\nm=max_arr[:]\nm.insert(0,0)\nm=m[:-1]\nfor s in sizes:cnt[s-1]+=1\ncnt.reverse()\ndef find(x):\n    rest=t[list(m).index(x)]\n    sz=len(rest)\n    for i in range(1,x):\n        while len(rest)<max_arr[m.index(i)] and cnt[i-1]>0:\n            cnt[i-1]-=1\n            rest.append(i)\n    if len(rest)<max_arr[m.index(x)]:return False\n    t[list(m).index(x)]=rest\n    return True\nl,r=1,k+1\nwhile r-l>1:\n    mid=(l+r)//2\n    if all([find(i) for i in range(1,mid+1)]):r=mid\n    else:l=mid\nrest=n-sum([len(i) for i in t])\nfor i in range(rest):t[0].append(1)\nprint(r)\nfor tl in t:\n    print(len(tl),end=' ')\n    for s in tl:print(s,end=' ')\n    print()"
 ],
 "1953": [
  "n = int(input())\ntimes = list(map(int, input().split()))\ntimes.sort()\n\nnot_disappointed = 0\nwait_time = 0\nfor t in times:\n    if t >= wait_time:\n        not_disappointed += 1\n        wait_time += t\n\nprint(not_disappointed)"
 ],
 "1954": [
  "MOD = 1000000007\n\n# Pre-compute factorials and inverse factorials\nfact = [1]\nifact = [1]\nfor i in range(1, 100001):\n    fact.append((fact[-1] * i) % MOD)\n    ifact.append(pow(fact[-1], MOD - 2, MOD))\n\n# Function to compute nCr modulo MOD\ndef nCr(n, r):\n    return (fact[n] * ifact[r] % MOD * ifact[n-r] % MOD) % MOD\n\n# Function to compute number of distributions\n# with condition x not dividing all a_i\ndef compute_num_distributions(n, f, x):\n    # Compute number of ways to distribute n sweets among f friends\n    num_distributions = nCr(n-1, f-1)\n    # Compute number of ways to distribute n sweets among f friends\n    # such that x divides all a_i\n    for i in range(1, f+1):\n        num_distributions -= nCr(f, i) * nCr(n//x - i, f-i) * (-1)**i\n    return num_distributions % MOD\n\n# Read input\nq = int(input())\nqueries = []\nfor i in range(q):\n    n, f = map(int, input().split())\n    queries.append((n, f))\n\n# Compute answers for all queries\nfor n, f in queries:\n    ans = 0\n    # Compute answer by summing over all possible values of x\n    for x in range(2, int(n**0.5)+1):\n        if n % x == 0:\n            ans += compute_num_distributions(n, f, x)\n            ans += compute_num_distributions(n, f, n//x)\n            ans %= MOD\n    # Check case where n is a perfect square\n    if int(n**0.5)**2 == n:\n        ans += compute_num_distributions(n, f, int(n**0.5))\n        ans %= MOD\n    # Subtract the number of distributions where all a_i are equal\n    num_equal_distributions = nCr(n-1, f-1)\n    ans -= num_equal_distributions\n    ans %= MOD\n    # Output answer\n    print(ans)"
 ],
 "1955": [
  "n, m = map(int, input().split())\nexams_day = list(map(int, input().split()))\nexam_prep = list(map(int, input().split()))\n\n# store the indices of non-zero elements in exams_day \nday_exam = [[] for _ in range(m)]\nfor day, exam in enumerate(exams_day):\n    if exam != 0:\n        day_exam[exam-1].append(day)\n\n# check if all exams can be taken\nfor i in range(m):\n    if not day_exam[i]:\n        print(-1)\n        break\nelse:\n    # binary search to find the minimum number of days needed\n    lo, hi = 0, n\n    while lo < hi:\n        mid = (lo+hi)//2\n        # check if all exams can be taken within mid days\n        temp = [0]*m\n        for day in range(mid):\n            if exams_day[day] != 0:\n                temp[exams_day[day]-1] += 1\n        can_take_all = True\n        for i in range(m):\n            if temp[i] < exam_prep[i]:\n                can_take_all = False\n                break\n        if can_take_all:\n            hi = mid\n        else:\n            lo = mid+1\n    print(lo)"
 ],
 "1956": [
  "import sys\n\nt = int(sys.stdin.readline())\nwinner_ind = loser_ind = 0\n\nfor i in range(t):\n    s, e = map(int, sys.stdin.readline().split())\n\n    while e > s:\n        if e % 2 == 1:\n            if (e-1) // 2 >= s:\n                e -= 1\n            else:\n                winner_ind = 1 - winner_ind\n                loser_ind = 1 - loser_ind\n                break\n        else:\n            if e // 2 >= s:\n                e //= 2\n            else:\n                winner_ind = 1 - winner_ind\n                loser_ind = 1 - loser_ind\n                break\n\nprint(winner_ind, loser_ind)"
 ],
 "1957": [
  "n, A, B = map(int, input().split())\ns = list(map(int, input().split()))\nS = sum(s)\ns = [(si, i) for i, si in enumerate(s)]\ns.sort()\nans = n-1\nwhile ans > 0 and s[ans][0]*A/S < B:\n    ans -= 1\nprint(n-ans-1)"
 ],
 "1958": [
  "n, p = map(int, input().split())\napples = 1\nmoney = 0\n\nfor i in range(n):\n    if input() == 'halfplus':\n        money += p * (apples // 2) + p // 2\n    else:\n        money += p * (apples // 2)\n    apples = apples * 2\nprint(money)"
 ],
 "1959": [
  "n, m = map(int, input().split())\ncards = list(map(int, input().split()))\n\neven_count = len([x for x in cards if x%2 == 0])\nodd_count = n - even_count\n\nif even_count > odd_count:\n    target = 1\nelse:\n    target = 0\n\nodd_cards = sorted([x for x in cards if x%2 == target])\n\nexchange_count = 0\nfor i in range(n):\n    if cards[i]%2 != target:\n        for j in range(len(odd_cards)):\n            if odd_cards[j] > cards[i]:\n                odd_cards.pop(j)\n                odd_cards.insert(0, cards[i])\n                exchange_count += 1\n                break\n        else:\n            print(-1)\n            exit()\n\nprint(exchange_count)\nfor i in range(n):\n    if cards[i]%2 == target:\n        print(cards[i], end=\" \")\n    else:\n        print(odd_cards.pop(0), end=\" \")"
 ],
 "1960": [
  "n = int(input())\na = list(map(int, input().split()))\n\ndp = [1] * n\nfor i in range(n):\n    for j in range(i):\n        if a[j] < a[i]:\n            dp[i] = max(dp[i], dp[j] + 1)\n\nlis_length = max(dp)\n\ngroup2_set = set()\nfor i in range(n):\n    if dp[i] == lis_length:\n        group3_set = {a[i]} if i == 0 else group3_set & {x for x in group3_set if x < a[i]} | {a[i]}\n    else:\n        group2_set |= {a[i]}\n\nans = ''\nfor i in range(n):\n    if a[i] not in group3_set:\n        ans += '1'\n    elif len(group2_set & {x for x in group3_set if x < a[i]}) > 0:\n        ans += '2'\n    else:\n        ans += '3'\n\nprint(ans)"
 ],
 "1961": [
  "n, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\n\nfor i in range(1, n-1):\n    for j in range(1, m-1):\n        if all(grid[a][b]=='#' for a in range(i-1, i+2) for b in range(j-1, j+2) if not a==i==j==b):\n            print('YES')\n            exit()\nprint('NO')"
 ],
 "1962": [
  "n, k, l = map(int, input().split())\na = sorted(list(map(int, input().split())))\n\ndef check(val):\n    cnt = 0\n    pos = 0\n    for i in range(n):\n        if a[ pos ] - k < val:\n            if pos + k > len(a):\n                return False\n            pos = pos + k\n        else:\n            cnt = cnt + 1\n            pos = pos + k\n    return cnt >= n\n    \nlow = 1\nhigh = max(a)\n\nwhile low <= high:\n    mid = (low + high) // 2\n    if check(mid):\n        ans = mid\n        low = mid + 1\n    else:\n        high = mid - 1\n\nif ans + l >= max(a):\n    print(sum(ans for i in range(n)))\nelse:\n    print(0)"
 ],
 "1963": [
  "n = int(input())\nlst = list(map(int, input().split()))\n\nmax_val = 0\nfreq = {}\nfor i in range(n):\n    for j in range(i, n):\n        gcd = lst[i]\n        for k in range(i+1, j+1):\n            gcd = math.gcd(gcd, lst[k])\n        if gcd in freq:\n            freq[gcd][1] = j\n            max_val = max(max_val, j - freq[gcd][0])\n        else:\n            freq[gcd] = [i, j]\n\n\nans = []\nfor gcd in freq:\n    if freq[gcd][1] - freq[gcd][0] == max_val:\n        ans.append(str(freq[gcd][0]+1))\n\nprint(len(ans), max_val)\nprint(' '.join(ans))"
 ],
 "1964": [
  "n = int(input())\nk = list(map(int,input().split()))\ntimes = []\nfor i in range(n):\n    m = list(map(int,input().split()))\n    time = sum(m)*5 + k[i]*15\n    times.append(time)\nmin_time = min(times)\nprint(min_time)"
 ],
 "1965": [
  "def min_contests_needed(n, x, a):\n    if all(a_i == x for a_i in a):\n        return 0\n    elif x in a:\n        return 1\n    else:\n        return 2\n\nt = int(input())\nfor _ in range(t):\n    n, x = map(int, input().split())\n    a = list(map(int, input().split()))\n    print(min_contests_needed(n, x, a))"
 ],
 "1966": [
  "n = int(input())\nboard = []\nfor _ in range(4):\n    sub_board = []\n    input()  # empty line\n    for _ in range(n):\n        row = input().strip()\n        sub_board.append([int(c) for c in row])\n    board.append(sub_board)\n\nmin_changes = float('inf')\nfor i in range(n):\n    for j in range(n):\n        for k in range(2):\n            black_count = 0\n            white_count = 0\n            for l in range(4):\n                for x in range(n):\n                    for y in range(n):\n                        color = board[l][(x+i)%n][(y+j)%n]\n                        if (x+y)%2 == k:\n                            if color == 0:\n                                black_count += 1\n                            else:\n                                white_count += 1\n                        else:\n                            if color == 1:\n                                black_count += 1\n                            else:\n                                white_count += 1\n            min_changes = min(min_changes, min(black_count, white_count))\nprint(min_changes)"
 ],
 "1967": [
  "w, h = map(int, input().split())\nimage = [input() for _ in range(h)]\n\nrotated = [''.join(row[::-1]) for row in zip(*image)]\nflipped = [''.join(row) for row in rotated[::-1]]\nzoomed = [''.join([''.join([ch*2 for ch in row]) for _ in range(2)]) for row in flipped]\n\nfor row in zoomed:\n    print(row)\n    print(row)"
 ],
 "1968": [
  "n,v = map(int, input().split())\ncan_deal_with = []\nfor i in range(n):\n    prices = list(map(int, input().split()))[1:]\n    for price in prices:\n        if price < v:\n            can_deal_with.append(i+1)\n            break\nprint(len(can_deal_with))\nif can_deal_with:\n    print(*sorted(can_deal_with))"
 ],
 "1969": [
  "n = int(input())\nM = []\nfor i in range(n):\n    row = input()\n    M.append(row)\ncount = 0\nfor i in range(1,n-1):\n    for j in range(1,n-1):\n        if M[i][j] == 'X' and M[i-1][j-1] == 'X' and M[i-1][j+1] == 'X' and M[i+1][j-1] == 'X' and M[i+1][j+1] == 'X':\n            count += 1\nprint(count)"
 ],
 "1970": [
  "def can_meet(board):\n    k1, k2 = None, None\n    for i in range(8):\n        for j in range(8):\n            if board[i][j] == \"K\":\n                if k1:\n                    k2 = (i, j)\n                else:\n                    k1 = (i, j)\n            elif board[i][j] == \"#\":\n                board[i][j] = -1\n\n    distances = {(k1[0], k1[1], k2[0], k2[1]): 1}\n\n    def add(cells, level):\n        if cells in distances:\n            return\n        distances[cells] = level\n\n    def sub(cells, level):\n        if cells not in distances:\n            return\n        if distances[cells] <= level:\n            return\n        distances[cells] = level\n\n    def can_move(i, j, p, q):\n        if 0 <= i < 8 and 0 <= j < 8 and board[i][j] != -1:\n            add((i, j, p, q), level + 1)\n\n    queue = [k1[0], k1[1], k2[0], k2[1], 1]\n\n    start = 0\n    while start < len(queue):\n        i, j, p, q, level = queue[start:start + 5]\n        # Move k1\n        can_move(i - 2, j - 1, p, q)\n        can_move(i - 2, j + 1, p, q)\n        can_move(i + 2, j - 1, p, q)\n        can_move(i + 2, j + 1, p, q)\n        can_move(i - 1, j - 2, p, q)\n        can_move(i - 1, j + 2, p, q)\n        can_move(i + 1, j - 2, p, q)\n        can_move(i + 1, j + 2, p, q)\n        # Move k2\n        can_move(i, j, p - 2, q - 1)\n        can_move(i, j, p - 2, q + 1)\n        can_move(i, j, p + 2, q - 1)\n        can_move(i, j, p + 2, q + 1)\n        can_move(i, j, p - 1, q - 2)\n        can_move(i, j, p - 1, q + 2)\n        can_move(i, j, p + 1, q - 2)\n        can_move(i, j, p + 1, q + 2)\n        start += 5\n\n    return \"YES\" if distances.get((k2[0], k2[1], k1[0], k1[1])) else \"NO\"\n\n\nt = int(input())\nfor _ in range(t):\n    board = []\n    for _ in range(8):\n        row = input().strip()\n        board.append([x for x in row])\n    input()\n    print(can_meet(board))"
 ],
 "1971": [
  "n = int(input())\np = list(map(int, input().split()))\n\nq = [0] * n\nfor i in range(n):\n    q[p[i]-1] = i+1\n    \nfor i in range(n):\n    if p[q[i]-1] != i+1:\n        print(\"-1\")\n        break\nelse:\n    for i in range(n):\n        print(q[i], end=\" \")"
 ],
 "1972": [
  "n = 500005\nbit = [0] * n\nres = [0] * n\n\ndef update(i, v):\n    while i <= 500000:\n        bit[i] += v\n        i += (i & (-i))\ndef query(i):\n    ret = 0\n    while i > 0:\n        ret += bit[i]\n        i -= (i & (-i))\n    return ret\ndef solve(x):\n    tmp = 0\n    for i in range(x, 500001, x):\n        tmp += query(i) - query(i - x)\n    res[x] = tmp\n\nq = int(input())\nfor _ in range(q):\n    t, x, y = input().split()\n    x,y = int(x), int(y)\n    if t == '1':\n        update(x, y)\n    else:\n        if res[x] == 0:\n            solve(x)\n        print(res[x+y])"
 ],
 "1973": [
  "n = int(input())\ncolors = list(map(int, input().split()))\n\nfrequency = {}\nfor i in range(n):\n  if colors[i] not in frequency:\n    frequency[colors[i]] = 0\n  frequency[colors[i]] += 1\n\nprefix_frequency = {}\nstreak_length = 0\ncandidate_streak = 0\nfor i in range(n):\n  if colors[i] not in prefix_frequency:\n    prefix_frequency[colors[i]] = 0  \n  prefix_frequency[colors[i]] += 1\n  streak_length += 1\n\n  # check if streak can be shortened by one day\n  shortened_streak_length = streak_length - 1\n  possible_shortenings = [k for k in prefix_frequency if\n                          prefix_frequency[k] == \\\n                          (shortened_streak_length+1)//2 -\\\n                          (streak_length+1)//2]\n  if len(possible_shortenings) <= 1:\n    candidate_streak = max(candidate_streak, streak_length)\n\n  # remove a day from the beginning of the streak\n  if prefix_frequency[colors[i - streak_length + 1]] > 1:\n    prefix_frequency[colors[i - streak_length + 1]] -= 1\n  else:\n    del prefix_frequency[colors[i - streak_length + 1]]\n    streak_length -= 1\n\nprint(candidate_streak)"
 ],
 "1974": [
  "n, m = map(int, input().split())\nrobber_positions = [tuple(map(int, input().split())) for _ in range(n)]\nsearchlight_positions = [tuple(map(int, input().split())) for _ in range(m)]\n\ndef is_safe(x: int, y: int) -> bool:\n    return all(a > x or b > y for a, b in robber_positions)\n\ndef can_reach(mid: int) -> bool:\n    for x, y in searchlight_positions:\n        if not is_safe(x + mid, y + mid):\n            continue\n        left, right = 0, mid\n        while left < right:\n            # binary search to find the maximum x-coordinates we can go to \n            # without being seen by this searchlight\n            mid2 = (left + right + 1) // 2\n            if is_safe(x + mid - mid2, y + mid2):\n                left = mid2\n            else:\n                right = mid2 - 1\n        # if we cannot find a position that is safe from this searchlight,\n        # this configuration is not safe\n        if left == mid:\n            return False\n    return True\n\nleft, right = 0, int(2e6)\nwhile left < right:\n    mid = (left + right) // 2\n    if can_reach(mid):\n        right = mid\n    else:\n        left = mid + 1\n\nprint(left)"
 ],
 "1975": [
  "n, m = map(int, input().split())\n\ndances = []\nboys_danced = set()\ngirls_danced = set()\n\nfor i in range(n + m):\n    if len(dances) == min(n, m):\n        break\n    boy = i % n + 1\n    girl = i % m + 1\n    if boy not in boys_danced or girl not in girls_danced:\n        dances.append((boy, girl))\n        boys_danced.add(boy)\n        girls_danced.add(girl)\n\nprint(len(dances))\nfor dance in dances:\n    print(dance[0], dance[1])"
 ],
 "1976": [
  "n, m, k, q = map(int, input().split())\nbroken = {}\nfor _ in range(q):\n    x, y, t = map(int, input().split())\n    broken[(x, y)] = t\n\nlo, hi = 0, 10**9 + 1\nans = -1\nwhile lo <= hi:\n    mid = (lo + hi) // 2\n    found = False\n    for i in range(1, n-k+2):\n        for j in range(1, m-k+2):\n            ok = True\n            for p in range(i, i+k):\n                for q in range(j, j+k):\n                    if (p, q) not in broken or broken[(p, q)] > mid:\n                        ok = False\n                        break\n                if not ok:\n                    break\n            if ok:\n                found = True\n                break\n        if found:\n            break\n    if found:\n        ans = mid\n        hi = mid - 1\n    else:\n        lo = mid + 1\n\nprint(ans)"
 ],
 "1977": [
  "import heapq\n\nn, k = map(int, input().split())\ngrid = [input() for _ in range(n)]\n\ndist = [[float(\"inf\")] * n for _ in range(n)]\ndist[0][0] = 0\n\nheap = [(0, 0, 0)]  # (dist, row, col)\nwhile heap:\n    d, r, c = heapq.heappop(heap)\n    if dist[r][c] != d:\n        continue\n    if r == n - 1 and c == n - 1:\n        break\n\n    for dr, dc in ((1, 0), (0, 1)):\n        nr, nc = r + dr, c + dc\n        if nr < n and nc < n:\n            cost = (grid[nr][nc] != grid[r][c])\n            nd = d + cost\n            if nd < dist[nr][nc]:\n                dist[nr][nc] = nd\n                heapq.heappush(heap, (nd, nr, nc))\n\nans = []\nr, c = n - 1, n - 1\nwhile k >= 0 and r >= 0 and c >= 0:\n    ans.append(grid[r][c])\n    if r == 0 and c == 0:\n        break\n\n    if r == 0:\n        c -= 1\n    elif c == 0:\n        r -= 1\n    else:\n        if dist[r - 1][c] < dist[r][c - 1]:\n            r -= 1\n        else:\n            c -= 1\n        if grid[r][c] != grid[r + 1][c] and k > 0:\n            ans[-1] = \"a\"\n            k -= 1\n\nprint(\"\".join(reversed(ans)))  "
 ],
 "1978": [
  "import sys\n\nn = int(input())\ngraph = [list(map(int, input())) for _ in range(n)]\nm = int(input())\npath = list(map(int, input().split()))\n\n# Let's build an inverted index of vertices in the path\npath_indices = {v: [i for i in range(m) if path[i] == v] for v in range(1, n + 1)}\n\n# We'll use dynamic programming to find the shortest good subsequence\n# dp[i][j] will contain the length of the shortest good subsequence ending with path[i] and containing path[j]\n# Initialize the array with infinity, except for dp[0][0] = 0\ndp = [[float('inf')] * m for _ in range(m)]\ndp[0][0] = 0\n\nfor i in range(1, m):\n    for j in range(i):\n        pj = path[j]\n        pi = path[i]\n        if graph[pj - 1][pi - 1]:\n            # option 1: append pi to a good subsequence ending with pj\n            dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1)\n        if pj != pi and pj in path_indices:\n            # option 2: insert a good subsequence containing all indices between j and i\n            for k in path_indices[pj]:\n                if k > j and k < i and graph[pi - 1][pj - 1]:\n                    dp[i][k] = min(dp[i][k], dp[i][j] + 1)\n\n# Find the minimum value in the last row of the dp table\nmin_value = min(dp[-1])\n\n# Find index i of the last vertex in the shortest good subsequence\ni = dp[-1].index(min_value)\n\n# Reconstruct the shortest good subsequence by following the recurrence relation\nresult = [path[i]]\nfor j in range(i - 1, -1, -1):\n    if path[j] != path[i] and dp[i][j] == min_value:\n        result.append(path[j])\n        i, min_value = j, dp[i][j]\n\n# Reverse the result and print it\nresult.reverse()\nprint(len(result))\nprint(*result)"
 ],
 "1979": [
  "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# find the position of each element in b\npos_b = {val: idx for idx, val in enumerate(b)}\n\n# try shifting a and count the number of matching pairs\nans = 0\nfor i in range(n):\n    cnt = 0\n    for j in range(n):\n        if a[j] == b[(i+j)%n]:\n            cnt += 1\n    ans = max(ans, cnt)\n\nprint(ans)"
 ],
 "1980": [
  "n,a=map(int,input().split())\np=[list(map(int,input().split())) for i in range(n)]\nt=[0]*n\nm=[]\nc=d=i=0\nwhile i<n:\n    while m and m[-1][0]>=p[i][0]:\n        c-=m.pop()[1]\n    m.append([p[i][0],p[i][1]])\n    c+=p[i][1]\n    while d<i and (p[i][0]-p[d][0])**2>a*(c-t[d]):\n        c-=p[d][1]\n        t[d]=c\n        d+=1\n    m[-1][1]-=t[i-1]-t[d-1]\n    c-=m[-1][1]\n    t[i]=c\n    i+=1\nprint(max(t))"
 ],
 "1981": [
  "n, m = map(int, input().split())\ncats = list(map(int, input().split()))\nadj_list = {i:[] for i in range(1, n+1)}\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n\ndef dfs(node, parent, count):\n    if cats[node-1] == 1:\n        count += 1\n    else:\n        count = 0\n    if count > m:\n        return 0\n    if len(adj_list[node]) == 1 and node != 1:\n        return 1\n    ans = 0\n    for child in adj_list[node]:\n        if child != parent:\n            ans += dfs(child, node, count)\n    return ans\n\nprint(dfs(1, -1, 0))"
 ],
 "1982": [
  "t = int(input())\nfor i in range(t):\n    n, k = map(int, input().split())\n    if k<=n**(1/2) and k%2==n%2:\n        print(\"YES\")\n    else:\n        print(\"NO\")"
 ],
 "1983": [
  "from bisect import bisect_left\n\ndef longest_increasing_subsequence(lst):\n    seq = []\n    for num in lst:\n        pos = bisect_left(seq, num)\n        if pos == len(seq):\n            seq.append(num)\n        else:\n            seq[pos] = num\n    return len(seq)\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(longest_increasing_subsequence(a) * n)"
 ],
 "1984": [
  "from collections import defaultdict\n\nn, m, k, w = map(int, input().split())\n\nfields = []\nfor _ in range(k):\n    field = [input() for _ in range(n)]\n    fields.append(field)\n\n# function for finding the difference between two fields\ndef find_diff(field1, field2):\n    diff = 0\n    for i in range(n):\n        for j in range(m):\n            if field1[i][j] != field2[i][j]:\n                diff += 1\n    return diff\n\n# initialize variables\ntotal_bytes = n * m * k\ntransfers = [(i+1, 0) for i in range(k)]\nprev_fields = defaultdict(list)\n\n# iterate through fields and try to find the smallest difference with previous fields\nfor i in range(k):\n    min_diff = n * m\n    min_diff_index = -1\n    for j in range(i):\n        diff = find_diff(fields[i], fields[j])\n        if diff < min_diff:\n            min_diff = diff\n            min_diff_index = j\n    if min_diff_index != -1:\n        total_bytes += min_diff * w\n        transfers[i] = (i+1, min_diff_index+1)\n        prev_fields[i] = prev_fields[min_diff_index] + [min_diff_index]\n    else:\n        prev_fields[i] = []\n\n# print output\nprint(total_bytes)\nfor i in range(k):\n    print(transfers[i][0], transfers[i][1])"
 ],
 "1985": [
  "k, n = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\npossible_scores = set()\nfor i in range(k):\n    possible_scores.add(b[0] - sum(a[:i+1]))\nfor i in range(1, n):\n    new_possible_scores = set()\n    for j in range(k):\n        score = b[i] - sum(a[:j+1])\n        if score in possible_scores:\n            new_possible_scores.add(score)\n    possible_scores = new_possible_scores\n\nprint(len(possible_scores))"
 ],
 "1986": [
  "n, k = map(int, input().split())\nmax_joy = float('-inf')\nfor _ in range(n):\n    f, t = map(int, input().split())\n    if t > k:\n        joy = f - (t-k)\n    else:\n        joy = f\n    if joy > max_joy:\n        max_joy = joy\nprint(max_joy)"
 ],
 "1987": [
  "n, c1, c2 = map(int, input().split())\nvisitors = list(map(int, input().strip()))\n\n# creating list of indices of adult visitors\nadults_indices = [i for i in range(n) if visitors[i] == 1]\nnum_adults = len(adults_indices)\n\n# function to calculate total cost given size of group of visitors\ndef cost(x):\n    return c1 + c2 * (x - 1) ** 2\n\n# utility function to calculate cost for splitting visitors into groups of size x\ndef cost_for_size(x):\n    # number for groups and remainder after dividing visitors into groups of size x\n    groups, remainder = divmod(n, x)\n    # if remainder != 0, we can add one more group with remainder visitors\n    if remainder != 0:\n        groups += 1\n    # check if each group has at least one adult visitor\n    for i in range(groups):\n        group_start = i * x\n        group_end = min((i+1) * x, n)\n        if all(visitors[j] == 0 for j in range(group_start, group_end)):\n            return float('inf')\n    # calculate total cost for each group and return sum of all costs\n    return sum(cost(x) for i in range(groups))\n\n# ternary search to find optimal group size\nlow, high = 1, n\nwhile low < high:\n    mid1 = low + (high - low) // 3\n    mid2 = high - (high - low) // 3\n    if cost_for_size(mid1) < cost_for_size(mid2):\n        high = mid2 - 1\n    else:\n        low = mid1 + 1\n    \n# find optimal cost based on optimal group size\noptimal_group_size = low\ntotal_cost = cost_for_size(optimal_group_size)\nprint(total_cost)"
 ],
 "1988": [
  "t = int(input())\nfor i in range(t):\n    n = int(input())\n    s = input()\n    ans = s\n    k = 1\n    for j in range(2, n+1):\n        cur = s[:j-1][::-1] + s[j-1:]\n        if cur < ans:\n            ans = cur\n            k = j\n        for l in range(j, n):\n            cur = cur[:l-j+1] + \\\n                cur[l-j+1:l+1][::-1] + cur[l+1:]\n            if cur < ans:\n                ans = cur\n                k = j\n    print(ans)\n    print(k)"
 ],
 "1989": [
  "n = int(input())\na = list(map(int, input().split()))\n\nleft_count = {}\nright_count = {}\nfor i in range(n):\n    if a[i] not in left_count:\n        left_count[a[i]] = [0, i+1]\n    left_count[a[i]][0] += 1\n\nfor i in range(n-1, -1, -1):\n    if a[i] not in right_count:\n        right_count[a[i]] = [0, n-i]\n    right_count[a[i]][0] += 1\n\nans = 0\nfor num in left_count:\n    if num in right_count:\n        ans += left_count[num][0] * right_count[num][0]\n\nprint(sum(left_count[num][0] * right_count[num][0] for num in left_count if num not in right_count) + ans*(ans-1)//2)"
 ],
 "1990": [
  "n = int(input())        \ns = input()\nstack = [] \ncolors = 0\nans = []\nfor char in s:\n    if char == 'L':\n        if stack:\n            colors = max(colors, stack.pop()[1])\n    elif char == 'R':\n        if stack:\n            colors = max(colors, stack[len(stack)-1][1])\n            stack.pop()\n    else:\n        if char == '(':\n            colors += 1\n            stack.append((char, colors))\n        elif char == ')':\n            if not stack:\n                ans.append(-1)\n                continue\n            if stack[len(stack)-1][0] != '(':\n                ans.append(-1)\n                continue\n            else:\n                ans.append(stack.pop()[1])\n        else:\n            stack.append(('L', colors))\n        if not stack:\n            ans.append(0)\n        else:\n            ans.append(-1)\nfor a in ans:\n    print(a, end=\" \")"
 ],
 "1991": [
  "from collections import defaultdict\n \ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    pos = defaultdict(list)\n    for i, x in enumerate(a):\n        pos[x].append(i) # store the position of each number in the array\n    cur_pos = -1\n    res = 0\n    for i in range(1, n+1):\n        if not pos[i]: # if i is not in the array, skip\n            continue\n        if pos[i][0] > cur_pos: # if i is in the right order, update the cur_pos\n            cur_pos = pos[i][-1]\n            continue\n        left = pos[i][0]\n        right = cur_pos\n        for j in range(left, right+1): # check if it is possible to reorder this subarray\n            if a[j] > i or a[j] < a[left]:\n                res += 1\n        cur_pos = pos[i][-1]\n    print(res)\n \nt = int(input())\nfor _ in range(t):\n    solve()"
 ],
 "1992": [
  "n, m, k = map(int, input().split())\napps = list(map(int, input().split()))\n\ncnt_gesture = 0\nprev = 1\n\nfor i in range(m):\n    app = int(input())\n    app_idx = apps.index(app)\n    curr = (app_idx // k) + 1\n    cnt_gesture += curr - prev + (app_idx % k) // k\n    apps[app_idx] = apps[max(0, app_idx - 1)]\n    apps[max(0, app_idx - 1)] = app\n    prev = curr\n\nprint(cnt_gesture)"
 ],
 "1993": [
  "n, m = map(int, input().split())\nfield = [input() for _ in range(n)]\nadj = [[] for _ in range(n * m)]\nfor i in range(n):\n    for j in range(m):\n        if field[i][j] == \"*\":\n            continue\n        p = i * m + j\n        if j > 0 and field[i][j-1] == \".\":\n            adj[p].append(p-1)\n            adj[p-1].append(p)\n        if i > 0 and field[i-1][j] == \".\":\n            adj[p].append(p-m)\n            adj[p-m].append(p)\n\nvis = [False] * (n * m)\nsz = [0] * (n * m)\ndef dfs(i, cnt):\n    vis[i] = True\n    sz[i] = cnt\n    for j in adj[i]:\n        if not vis[j]:\n            dfs(j, cnt)\n\nfor i in range(n):\n    for j in range(m):\n        if field[i][j] == \"*\":\n            res = set()\n            p = i * m + j\n            for q in adj[p]:\n                if field[q//m][q%m] == \".\":\n                    res.add(sz[q])\n            print((sum(res) + 1) % 10, end='')\n        else:\n            print(\".\", end='')\n    print()"
 ],
 "1994": [
  "s = input()\nn = len(s)\nz = [0] * n\n\nl, r = 0, 0\nfor i in range(1, n):\n    if i <= r:\n        z[i] = min(r - i + 1, z[i-l])\n    while i+z[i] < n and s[z[i]] == s[i+z[i]]:\n        z[i] += 1\n    if i+z[i]-1 > r:\n        l, r = i, i+z[i]-1\n        \np = [0] * n\nfor i in range(1, n):\n    j = z[i]\n    if j == 0:\n        continue\n    p[j-1] += 1\n\nfor i in range(n-2, -1, -1):\n    p[i] += p[i+1]\n\nans = []\nfor i in range(1, n):\n    if z[n-i] == i:\n        ans.append((i, p[i]))\n        \nprint(len(ans))\nfor x in ans:\n    print(f\"{x[0]} {x[1]}\")"
 ],
 "1995": [
  "s = input()\nm = int(input())\n\nfor _ in range(m):\n    l, r, k = map(int, input().split())\n    k %= (r - l + 1) # bring k in range [0, r-l+1)\n    s = s[:l-1] + s[r-k:r] + s[l-1:r-k] # performing cyclic shift\n    \nprint(s)"
 ],
 "1996": [
  "n = int(input())\n\nwords = []\nshocks = []\nguesses = []\n\nfor i in range(n):\n    action = input().split()\n    if action[0] == '!':\n        shocks.append(action[1])\n    elif action[0] == '.':\n        words.append(action[1])\n    else:\n        guesses.append(action[1])\n\nselected_letter = None\npossible_letters = set('abcdefghijklmnopqrstuvwxyz')\nfor shock in shocks:\n    possible_letters &= set(shock)\n    if len(possible_letters) == 1:\n        selected_letter = possible_letters.pop()\n        break\n\nexcessive_shocks = 0\nfor i in range(len(words)):\n    if selected_letter and selected_letter in words[i]:\n        excessive_shocks += 1\n    elif not selected_letter:\n        for letter in possible_letters.copy():\n            if letter in words[i]:\n                possible_letters.remove(letter)\n                if len(possible_letters) == 1:\n                    selected_letter = possible_letters.pop()\n                    break\n\nfor i in range(len(guesses)):\n    if selected_letter == guesses[i]:\n        break\n    elif selected_letter and selected_letter in guesses[i]:\n        excessive_shocks += 1\n    elif not selected_letter:\n        possible_letters.discard(guesses[i])\n        if len(possible_letters) == 1:\n            selected_letter = possible_letters.pop()\n            break\n\nprint(excessive_shocks)"
 ],
 "1997": [
  "n = int(input())              \nadj_list = [[] for i in range(n)]\nfor i in range(n-1):  \n    a, b = list(map(int, input().split()))    \n    adj_list[a-1].append(b-1)\n    adj_list[b-1].append(a-1)\ndp = [None]*n \ndef dfs(u, p):\n    if dp[u] is not None:\n        return dp[u]\n    if len(adj_list[u]) == 1 and adj_list[u][0] == p:\n        return 0\n    max_ans = 0\n    min_ans = float('inf')\n    for v in adj_list[u]:\n        if v != p:\n            ans_v = dfs(v, u)\n            max_ans = max(max_ans, ans_v)\n            min_ans = min(min_ans, ans_v)\n    dp[u] = max_ans + min_ans + 1\n    return dp[u]\ndfs(0, 0)\nleaves = [i for i in range(n) if len(adj_list[i]) == 1]\nmax_ans = 0\nmin_ans = float('inf')\nfor leaf in leaves:\n    ans_leaf = dfs(leaf, leaf)\n    max_ans = max(max_ans, ans_leaf)\n    min_ans = min(min_ans, ans_leaf)\nprint(max_ans, min_ans)"
 ],
 "1998": [
  "n, a, b, k = map(int, input().split())\ns = input().strip()\nshoots = []\ncurr_ship = 0\nfor i in range(n):\n    if s[i] == '0':\n        curr_ship += 1\n    if curr_ship == b:\n        curr_ship = 0\n    elif s[i] == '1':\n        curr_ship = 0\n    elif i == n-1:\n        curr_ship += 1\n    if curr_ship == 0 and s[i] == '0':\n        shoots.append(i+1)\n\nprint(len(shoots))\nprint(*shoots)"
 ],
 "1999": [
  "n = int(input())\na = list(map(int, input().split()))\n\nd = {}\nfor i in range(n):\n    if a[i] not in d:\n        d[a[i]] = []\n    d[a[i]].append(i)\n\nwhile True:\n    mx = -1\n    for key in d:\n        if len(d[key]) > 1:\n            mx = max(mx, key)\n    if mx == -1:\n        break\n    l, r = d[mx][0], d[mx][1]\n    a[l+1:r+1] = []\n    a[l] = 2*mx\n    d[mx] = d[mx][2:]\n    if len(d[mx]) > 0:\n        d[2*mx] = []\n        for idx in d[mx]:\n            d[2*mx].append(idx)\n    del d[mx]\n    \nprint(len(a))\nprint(*a)"
 ]
}