{
 "3000": [
  "n = int(input())\ns = input().split()\ns.reverse()\n\nstack = []\nMOD = 10**9 + 7\n\nfor i in s:\n    if i == '(':\n        res = 0\n        while stack[-1] != ')':\n            res = (res + int(stack.pop())) % MOD\n        stack.pop() # remove the ')'\n        stack.append(str(res))\n    else:\n        stack.append(i)\n\nprint(stack[0])"
 ],
 "3001": [
  "n = input()\ns = list(n)\nd = len(s)\nans = 0\nfor i in range((d+1)//2):\n    j = d - i - 1\n    while j > i and s[i] == s[j]:\n        j-=1\n    if s[i] != s[j]:\n        s[j] = s[i]\n        if j < d - i - 1:\n            ans += 1\n    ans += min(int(s[i]), 10 - int(s[i]))\n    s[j] = s[i]\nprint(ans)"
 ],
 "3002": [
  "from datetime import date\n\ne = int(input())\ns = []\nfor i in range(e):\n    y, m, o = map(int, input().split())\n    s.append((date(y, m, 1), o))\n\nfor i in range(1, e):\n    prev_y, prev_m, prev_o = s[i-1]\n    curr_y, curr_m, curr_o = s[i]\n    \n    # Check if odometer has been tampered with\n    if curr_o < prev_o:\n        print(\"tampered odometer\")\n        break\n    elif curr_o == prev_o:\n        if curr_y != prev_y or curr_m != prev_m:\n            print(\"tampered odometer\")\n            break\n    elif curr_y <= prev_y and curr_m <= prev_m:\n        print(\"tampered odometer\")\n        break\n        \n    # Check if service is sufficient\n    time_diff = (curr_y - prev_y) * 12 + (curr_m - prev_m)\n    dist_diff = curr_o - prev_o\n    if dist_diff / time_diff >= 2000 and dist_diff / time_diff <= 20000:\n        continue\n    elif dist_diff >= 30000:\n        continue\n    else:\n        print(\"insufficient service\")\n        break\nelse:\n    print(\"seems legit\")"
 ],
 "3003": [
  "n = int(input())\nadj = [[] for _ in range(n)]\nfor i in range(n):\n    adj[i] = list(map(int, input().split()))[1:]\n\ncolor = [0] * n\nans = 1\n\nfor i in range(n):\n    used = set()\n    for j in adj[i]:\n        used.add(color[j])\n    while True:\n        if ans not in used:\n            break\n        ans += 1\n    color[i] = ans\n\nprint(ans)"
 ],
 "3004": [
  "n = int(input())\noffers = []\nfor i in range(n):\n    color, a, b = input().split()\n    offers.append((color, int(a), int(b)))\n\n# Sort offers by start section\noffers.sort(key=lambda x: x[1])\n\n# Check if there are any gaps between offers or if colors exceed 3\nprevious_to = 0\ncurrent_color_set = set()\naccepted_offers = []\nfor offer in offers:\n    if offer[1] > previous_to + 1 or len(current_color_set) > 3:\n        print(\"IMPOSSIBLE\")\n        break\n    previous_to = max(previous_to, offer[2])\n    current_color_set.add(offer[0])\n    accepted_offers.append(offer)\nelse:\n    if previous_to < 10000 and len(current_color_set) == 3:\n        print(\"IMPOSSIBLE\")\n    else:\n        print(len(accepted_offers))"
 ],
 "3005": [
  "s = input()\nn = len(s)\ndp = [n+1 for _ in range(n+1)]\ndp[0] = 0\nfor i in range(1,n+1):\n    for j in range(i):\n        if s[j:i] in s[:j]:\n            dp[i] = min(dp[i],dp[j]+(i-j)//len(s[j:i]))\n        else:\n            dp[i] = min(dp[i],dp[j]+i-j)\nprint(dp[n])"
 ],
 "3006": [
  "class LongLongString:\n    def __init__(self, s):\n        self.s = s\n    \n    def ins(self, p, c):\n        self.s = self.s[:p] + c + self.s[p:]\n    \n    def delete(self, p):\n        self.s = self.s[:p] + self.s[p+1:]\n\ndef compare_programs(p1, p2):\n    s1, s2 = LongLongString(''), LongLongString('')\n    for line in p1:\n        if line[0] == 'I':\n            s1.ins(int(line.split()[1])-1, line.split()[2])\n        else:\n            s1.delete(int(line.split()[1])-1)\n    for line in p2:\n        if line[0] == 'I':\n            s2.ins(int(line.split()[1])-1, line.split()[2])\n        else:\n            s2.delete(int(line.split()[1])-1)\n    if s1.s == s2.s:\n        print('0')\n    else:\n        print('1')\n\np1 = []\nwhile True:\n    line = input()\n    if line == 'E':\n        break\n    p1.append(line)\n\np2 = []\nwhile True:\n    line = input()\n    if line == 'E':\n        break\n    p2.append(line)\n\ncompare_programs(p1, p2)"
 ],
 "3007": [
  "d, b, f, t0, t1, t2 = map(int, input().split())\n\nmax_bling = b\n\n# Simulate the game day by day\nfor day in range(1, d+1):\n    # Sell all the fruits\n    max_bling += f * 100\n    f = 0\n    \n    # Harvest trees\n    f += t2\n    t2 = t1\n    t1 = t0\n    t0 = 0 if day < 3 else f\n    \n    # Buy exotic fruit if possible\n    if max_bling >= 400:\n        max_bling -= 400\n        f += 1\n        \n    # Harvest exotic fruit trees\n    if day >= 3 and f > 0:\n        max_bling += f * 500\n        f = 0\n    \nprint(max_bling)"
 ],
 "3008": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\npairs = sorted(zip(a, b))\nmax_rank = 1\nprev_rank = 1\nprev_a, prev_b = pairs[0]\nfor i in range(1, n):\n    a_i, b_i = pairs[i]\n    if a_i - prev_a > k or b_i - prev_b > k:\n        prev_rank += 1\n        max_rank += 1\n    else:\n        max_rank += prev_rank\n    prev_a, prev_b = a_i, b_i\nprint(max_rank)"
 ],
 "3009": [
  "import sys\nfrom itertools import combinations\nfrom math import isclose\n\ndef abc(a, b): \n    return (b[1] - a[1], a[0] - b[0], a[0] * b[1] - b[0] * a[1] )\n\ndef side(a, b, c):\n    return ((b[0] - a[0]) * (c[1] - a[1])) - ((b[1] - a[1]) * (c[0] - a[0]))\n\ndef side_sign(a,b,c):\n    return 0 if isclose(side(a, b, c), 0, abs_tol=1e-9) else 1 if side(a, b, c) < 0 else -1\n\ndef crossing(a, b, c, d):\n    cc1, cc2, cc3, cc4 = (side_sign(a,c,d), side_sign(b,c,d), side_sign(c,a,b), side_sign(d,a,b))\n    p12 = cc1 != cc2\n    p34 = cc3 != cc4\n    if p12 and p34: return True\n    if not (p12 or p34): return False\n    if cc1 == 0 and onsegment(a, b, c): return True\n    if cc2 == 0 and onsegment(a, b, d): return True\n    if cc3 == 0 and onsegment(c, d, a): return True\n    if cc4 == 0 and onsegment(c, d, b): return True\n    return False\n\ndef onsegment(a, b, c):\n    return isclose(dist(a,c) + dist(c,b), dist(a,b), abs_tol=1e-9)    \n\ndef dist(a,b):\n    return ((b[0] - a[0])**2 + (b[1] - a[1])**2)**0.5\n\ndef shortest_point(a,b,c):\n    cross_ab = sorted([i for i in range(len(c)) if crossing(a, b, c[i], c[(i+1)%len(c)])])\n    n = len(c)\n    if not cross_ab: return dist(a,b)\n    z = [cross_ab[0], cross_ab[-1]] + [i for i in range(n) if side(a, b, c[i]) == 0 and onsegment(a, b, c[i])]\n    w = sorted(x for x in z if x in cross_ab)\n    edges = []\n    for i in range(len(w)-1):\n        ia, ib = w[i], w[i+1]\n        if not (ib-ia == 1 or ib+1-ia == n):\n            edges.append((c[ia], c[ib]))\n    if not edges:\n        l = dist(a,b)\n    else:\n        coedges = [(abc(*e), e) for e in edges]\n        feasible = []\n        for i,j in combinations(range(len(coedges)), 2):\n            if dist(coedges[i][0], coedges[j][0]) > 1e-9:\n                feasible.append((coedges[i][1], coedges[j][1]))\n        if not feasible:\n            l = dist(a, b)\n        else:    \n            l = min(dist(*e) for e in feasible)\n    return l\n\nn = int(input())\npos = [(int(x),int(y)) for x,y,e in [input().split() for t in range(n)] if int(e) > 0]\nneg = [(int(x),int(y)) for x,y,e in [input().split() for t in range(n)] if int(e) < 0]\nm = len(pos)\nl = []\nfor i in range(m):\n    for j in range(i+1,m):\n        l.append(shortest_point(pos[i], pos[j], neg))\n        if not l[-1]:\n            print(\"IMPOSSIBLE\")\n            sys.exit()\nif not l:\n    print(0)\nelse:\n    print(\"{:.9f}\".format(min(l)))"
 ],
 "3010": [
  "n = int(input())\nlines = []\nfor i in range(n):\n    x0, y0, x1, y1 = map(int, input().split())\n    lines.append((x0, y0, x1, y1))\n\npoints = set()\nfor i in range(n):\n    for j in range(i+1, n):\n        x0, y0, x1, y1 = lines[i]\n        x2, y2, x3, y3 = lines[j]\n        det = ((x1-x0)*(y3-y2) - (y1-y0)*(x3-x2))\n        if det == 0:\n            if (x0,y0) == (x2,y2) or (x0,y0) == (x3,y3) or (x1,y1) == (x2,y2) or (x1,y1) == (x3,y3):\n                points.add((min(x0,x1,x2,x3), min(y0,y1,y2,y3)))\n            else:\n                continue\n        else:\n            t1 = ((y2-y3)*(x0-x2) + (x3-x2)*(y0-y2)) / det\n            t2 = ((y0-y1)*(x0-x2) + (x1-x0)*(y0-y2)) / (-det)\n            if 0 <= t1 <= 1 and 0 <= t2 <= 1:\n                points.add((x1*t1 + x0*(1-t1), y1*t1 + y0*(1-t1)))\n\nif len(points) == 0:\n    print(0)\nelif len(points) == float(\"inf\"):\n    print(-1)\nelse:\n    print(len(points))"
 ],
 "3011": [
  "n=input()\nif len(n)<2:\n    print(n)\nelse:\n    if sorted(set(list(n)))==list(n):\n        print((int(n)*(int(n)-1)//2)+1)\n    elif sorted(set(list(n)),reverse=True)==list(n):\n        print(-1)\n    else:\n        index=0\n        for i in range(len(n)-1):\n            if n[i]<n[i+1]:\n                index=i+1\n        for i in range(index,len(n)-1):\n            if n[i]>n[i+1]:\n                print(-1)\n                break\n        else:\n            a,b,c=0,0,0\n            for i in n[:index]:\n                a=a*10+int(i)\n            for i in n[index:]:\n                if i==n[index]:\n                    b=b*10+int(i)\n                else:\n                    break\n            for i in n[index:]:\n                if i==n[index]:\n                    c=c*10+int(i)\n                else:\n                    break\n            ans=a*(c+1)*(c)//2+(a+b-1)*b//2\n            print(ans)"
 ],
 "3012": [
  "a11,a12,a21,a22,n=map(int,input().split())%mod=1000000007\nans=0\nx=[0]*4\nx[0]=1\nfor i in range (n-1):\n    x[i%4],x[(i+1)%4],x[(i+2)%4],x[(i+3)%4]=((a11*x[(i+3)%4] + a12*x[(i+2)%4])%mod,(a21*x[(i+1)%4]+a22*x[i%4])%mod,x[i % 4],x[(i+1) % 4])\n\nans=x[(n-1)%4]\nprint(ans)"
 ],
 "3013": [
  "import math\n\nb, tx, ty = map(float, input().split())\n\nphi = math.sqrt(tx**2 + ty**2) / b\nx = b * phi * math.cos(phi)\ny = b * phi * math.sin(phi)\n\nprint(f\"{x:.8f} {y:.8f}\")"
 ],
 "3014": [
  "import sys\nfrom collections import deque\n\nn, m = map(int, input().split())\n\ngraph = [[] for _ in range(n+1)]\nin_degree = [0 for _ in range(n+1)]\nedges = []\n\nfor i in range(m):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n    in_degree[v] += 1\n    edges.append((u, v))\n\nqueue = deque()\n\nfor i in range(1, n+1):\n    if in_degree[i] == 0:\n        queue.append(i)\n\nvisited_edge = [False for _ in range(m)]\nremoved_edges = []\nwhile queue:\n    u = queue.popleft()\n    for v in graph[u]:\n        for i, (x, y) in enumerate(edges):\n            if not visited_edge[i] and u == x and v == y:\n                visited_edge[i] = True\n                in_degree[v] -= 1\n                if in_degree[v] == 0:\n                    queue.append(v)\n                break\n        else:\n            removed_edges.append(i+1)\n            in_degree[v] -= 1\n            if in_degree[v] == 0:\n                queue.append(v)\n\n            if len(removed_edges) == m//2:\n                print(len(removed_edges))\n                print(*removed_edges)\n                sys.exit()\n\nprint(len(removed_edges))\nprint(*removed_edges)"
 ],
 "3015": [
  "import heapq\nINF=10**12\nn,m,s,t=map(int,input().split())\ngraph=[[]for i in range(n)] # list to store the graph\nfor i in range(m): # taking input\n  x,y,w=map(int,input().split())\n  graph[x].append((y,w))\ns1=[INF]*n # stores best distance for each node for 1st path\ns2=[INF]*n # stores best distance for each node for 2nd path\nvisit1=[False]*n # visited list for path 1\nvisit2=[False]*n # visited list for path 2\nQ=[] # heap for maintaining closest nodes\nheapq.heappush(Q,(0,s)) # adding starting point ans it's weight to heap for path 1\ns1[s]=0 # intialising 1st path starting point distance as 0\nwhile Q:\n    D,v=heapq.heappop(Q) # taking best resting point\n    if visit1[v]: \n        continue\n    visit1[v]=True\n    for next in graph[v]: # updating distances of all nodes which are directly connected to node v while traversing path 1 \n        if s1[next[0]]>D+next[1]:\n            s1[next[0]]=D+next[1]\n            heapq.heappush(Q,(s1[next[0]],next[0]))\nQ=[] # heap for maintaining closest nodes\nheapq.heappush(Q,(0,t)) # adding end point ans it's weight to heap for path 2\ns2[t]=0 # intialising 2nd path end point distance as 0\nwhile Q:\n    D,v=heapq.heappop(Q) # taking best resting point\n    if visit2[v]: \n        continue\n    visit2[v]=True\n    for next in graph[v]: # updating distances of all nodes which are directly connected to node v while traversing path 2\n        if s2[next[0]]>D+next[1]:\n            s2[next[0]]=D+next[1]\n            heapq.heappush(Q,(s2[next[0]],next[0]))\nres=s1[t] # setting total distance to infnity intially\nfor i in range(n): # updating total elpased time based on optimal distance form both paths\n    for edges in graph[i]:\n        u,v,w= i,edges[0],edges[1]\n        if s1[u]!=INF and s2[v]!=INF and s1[u]+w+s2[v]<res:\n            res=s1[u]+w+s2[v] # updating total distance\nif res==INF:\n    print('infinity') # if there is no path to reach from s to t\nelse:\n    print(res) # if there exists a path"
 ],
 "3016": [
  "MOD = 1000000007\n\n# Read input\nn, *a = map(int, input().split())\nk, *b = map(int, input().split())\nl, *s = map(int, input().split())\n\n# Compute the max number of times the sequence can occur\nf = min(freq for i, freq in enumerate(a, 1) if i in s)\n\n# Compute dp array\ndp = [[0] * (n + 1) for _ in range(f + 1)]\ndp[0] = [1] * (n + 1)\n\nfor i in range(1, f + 1):\n    for j in range(1, n + 1):\n        if j in b:\n            dp[i][j] = 0\n        else:\n            for k in range(1, n + 1):\n                if j != k:\n                    dp[i][j] += dp[i - 1][k]\n                    dp[i][j] %= MOD\n\n# Compute answer using the dp array\nans = 0\nfor i in range(1, n + 1):\n    if i in s:\n        ans += f * dp[f][i]\n    else:\n        ans += dp[f][i]\n    ans %= MOD\n\nprint(ans)"
 ],
 "3017": [
  "n, e = map(int, input().split())\n\ncount = 0\npower = str(2**e)\nfor i in range(n+1):\n    if power in str(i):\n        count += 1\n        \nprint(count)"
 ],
 "3018": [
  "from collections import defaultdict\n\nK, T = map(int,input().split())\ndices = list(map(int,input().split()))\n\ndp = [0]*(T + 1)\ndp[0] = 1\n\nfor dice in dices:\n    next_dp = [0]*(T + 1)\n    for j in range(dice,T+1):\n        next_dp[j] = dp[j - dice]\n        next_dp[j] += next_dp[j - 1] if j > 0 else 0\n        next_dp[j] -= dp[j - dice - 1] if j - dice - 1 >= 0 else 0\n    dp = next_dp\n\nans = 0\nmax_prob = 0\nfor i in range(T,K*6 + 1):\n    if dp[i] > max_prob:\n        ans = i - T\n        max_prob = dp[i]\n\nprint(ans)"
 ],
 "3019": [
  "from math import ceil\nfrom functools import cache\n# A decorator to cache the output/result of a function and reuse it when needed.\n\n@cache\ndef f(i, state, sum_s, prime_set):\n    if i == len(state):\n        # Check if the sum of special properties of the pieces of data sold to a customer is 0\n        if sum_s == 0:\n            # Count the number of distinct prime factors in a set and return it\n            cnt = 0\n            for p in prime_set:\n                cnt += 1\n            return cnt\n        else:\n            return 0\n\n    # Try selling the ith piece of data to each of the customers and check which gives the highest revenue\n    ans = 0\n    for j in range(len(state[i])):\n        nxt_s = state[i][j]\n        nxt_prime_set = set()\n        for p in prime_set:\n            nxt_prime_set.add(p)\n        for k in range(2, nxt_s + 1):\n            # Check for prime factors and add them to the set\n            if nxt_s % k == 0:\n                nxt_prime_set.add(k)\n        ans = max(ans, f(i + 1, state, sum_s + nxt_s, nxt_prime_set))\n\n    return ans\n\nN = int(input())\ndata = list(map(int, input().split()))\n\n# Generate all possible combinations of selling all data pieces to the customers.\nstate = []\nfor i in range(1, 2 ** N):\n    cur_state = []\n    for j in range(N):\n        if i & (1 << j):\n            cur_state.append(data[j])\n    state.append(cur_state)\n\nans = 0\nfor s in state:\n    # Calculate the sum of special properties of the data pieces sold to a customer.\n    sum_s = sum(s)\n    # Call the function f to count the number of distinct prime factors in a set for a given sum sum_s.\n    ans = max(ans, f(0, [x for x in state if x != s], sum_s, set()))\n\nprint(ans)"
 ],
 "3020": [
  "def carryless_add(num1, num2):\n    res = ''\n    for i in range(len(num1)):\n        res += str((int(num1[i])+int(num2[i]))%10)\n    return res\n\ndef carryless_mult(num1, num2):\n    res = '0'\n    for i in range(len(num2)):\n        temp = ''\n        for j in range(len(num1)):\n            temp += '0'\n        carry = 0\n        for j in range(len(num1)):\n            prod = (int(num1[j])*int(num2[i])+carry)%10\n            temp = temp[:len(temp)-j]+str(prod)+temp[len(temp)-j+1:]\n            carry = (int(num1[j])*int(num2[i])+carry)//10\n        if carry != 0:\n            temp = str(carry)+temp\n        res = carryless_add(res, temp)\n    return res\n\ndef find_a(n):\n    for i in range(int(n**(0.5))+1):\n        if str(i*i) == n:\n            return i\n        elif carryless_mult(str(i), str(i)) == n:\n            return i\n    return -1\n\nn = input()\nprint(find_a(n))"
 ],
 "3021": [
  "from collections import defaultdict\n\ndef topsort():\n    for v in range(26):\n        if not in_degrees[v]:\n            S.append(v)\n\n    while S:\n        v = S.pop()\n        order.append(v)\n\n        for succ in adj_list[v]:\n            in_degrees[succ] -= 1\n            if not in_degrees[succ]:\n                S.append(succ)\n\n    if len(order) == 26:\n        return \"\".join(chr(c+ord('a')) for c in order)\n    elif visited: \n        return \"AMBIGUOUS\"\n\n    return \"IMPOSSIBLE\"\n\nL, N = input().split()\nN = int(N)\n\nadj_list = [[] for _ in range(26)]\nin_degrees = [0]*26\nalpha = []\n\nfor _ in range(N):\n    string = input().strip()\n\n    for char in string:\n        if char not in alpha:\n            alpha.append(char)\n\n    for i in range(len(string)):\n        if i == len(string)-1: \n            break\n\n        u = ord(string[i])-ord('a')\n        v = ord(string[i+1])-ord('a')\n\n        if u == v: \n            continue\n\n        # checking the existence of edge (u->v)\n        if v not in adj_list[u]:\n            adj_list[u].append(v)\n            in_degrees[v] += 1\n            break\n\nS = []\norder = []\nvisited = defaultdict(bool)\n\nfor v in range(26):\n    if not in_degrees[v] and chr(v+ord('a')) in alpha:\n        visited[v] = True\n        S.append(v)\n\nwhile S:\n    u = S.pop()\n    visited[u] = True\n\n    for v in adj_list[u]:\n        if visited[v]:\n            return \"IMPOSSIBLE\"\n        in_degrees[v] -= 1\n        if not in_degrees[v]: \n            S.append(v)\n\nprint(topsort())"
 ],
 "3022": [
  "n,a,b,c=map(int,input().split())\nif a>b:\n    if a>c:\n        if b>c:\n            print(min(n-2,c+b))\n        else:\n            print(min(n-2,a+b))\n    else:\n        print(min(n-2,a+c))\nelse:\n    if b>c:\n        if a>c:\n            print(min(n-2,c+a))\n        else:\n            print(min(n-2,b+a))\n    else:\n        print(min(n-2,b+c))"
 ],
 "3023": [
  "import math\n\ndef distance(x1,y1,x2,y2):\n    return ((x1-x2)**2+(y1-y2)**2)**0.5\n\nn,m,r = map(int,input().split())\ncandles = []\nfor i in range(n):\n    x,y = map(int,input().split())\n    candles.append((x,y))\n    \nlines = []\nfor i in range(m):\n    a,b,c = map(int,input().split())\n    lines.append((a,b,c))\n\ncandles_on_lines_count = [0]*m\nfor i in range(n):\n    for j in range(m):\n        x,y = candles[i]\n        a,b,c = lines[j]\n        if (a*x + b*y + c) == 0:\n            candles_on_lines_count[j] += 1\n\nfor i in range(m):\n    if candles_on_lines_count[i] != 1:\n        print(\"no\")\n        exit()\n\nfor i in range(m):\n    for j in range(i+1,m):\n        a1,b1,c1 = lines[i]\n        a2,b2,c2 = lines[j]\n        det = a1*b2 - a2*b1\n        if det== 0:\n            print(\"no\")\n            exit()\n        x = (b2*c1 - b1*c2)/det\n        y = (a1*c2 - a2*c1)/det\n        if (not (-1e-4 < x < r+1e-4)) or (not (-1e-4 < y < r+1e-4)):\n            print(\"no\")\n            exit()\n\n        count1 = 0    # number of candles to the left of line i and j in same half plane\n        count2 = 0    # number of candles to the right of line i and j in same half plane\n        for k in range(n):\n            dist = distance(candles[k][0],candles[k][1],x,y)\n            if dist == 0:\n                continue\n            dot1 = a1*candles[k][0] + b1*candles[k][1] + c1\n            dot2 = a2*candles[k][0] + b2*candles[k][1] + c2\n            if (dot1 > 0 and dot2 > 0) or (dot1 < 0 and dot2 < 0):\n                if dot1 > 0:\n                    count1 += 1\n                else:\n                    count2 += 1\n        if count1 != count2:\n            print(\"no\")\n            exit()\n\nprint(\"yes\")"
 ],
 "3024": [
  "s = input()\nn = len(s)\nk = 1\nfor i in range(n//2):\n    if s[i] != s[n-1-i]:\n        k = 2\n        break\nfor i in range(2,n+1):\n    if n%i == 0:\n        flag = True\n        for j in range(i//2):\n            if s[j:i+j] != s[i-1-j:i-j]:\n                flag = False\n                break\n        if flag:\n            k = max(k,i)\nprint(k)"
 ],
 "3025": [
  "from collections import deque\n\ndef BFS(i, cost, edges):\n    visited = [False for _ in range(n+1)]\n    q = deque([i])\n    gold_stolen = [0 for _ in range(n+1)]\n    traversal_weight = [0 for _ in range(n+1)]\n    traversal_pred = [0 for _ in range(n+1)]\n    visited[i] = True\n    while q:\n        current = q.popleft()\n        for neighbor, weight in edges[current]:\n            if not visited[neighbor]:\n                q.append(neighbor)\n                visited[neighbor] = True\n                traversal_weight[neighbor] = weight\n                traversal_pred[neighbor] = current\n            elif traversal_weight[neighbor] < weight:\n                traversal_weight[neighbor] = weight\n                traversal_pred[neighbor] = current\n    while i != 0:\n        gold_stolen[traversal_pred[i]] += min(cost[traversal_pred[i]], traversal_weight[i])\n        gold_stolen[i] -= min(cost[traversal_pred[i]], traversal_weight[i])\n        i = traversal_pred[i]\n    return gold_stolen[1] if visited[1] else 0\n\n\nn, m = map(int, input().split())\ncost = [0] + list(map(int, input().split())) + [0]\nedges = [[] for _ in range(n+1)]\nfor _ in range(m):\n    a, b = map(int, input().split())\n    edges[a].append((b, cost[b]))\n    edges[b].append((a, cost[a]))\n\nans = 0\nfor i in range(2, n+1):\n    stolen = BFS(i, cost, edges)\n    if stolen > ans:\n        ans = stolen\n\nprint(ans)\n"
 ],
 "3026": [
  "n = int(input())\nseq = list(map(int, input().split()))\ncritical = []\nfor i in range(n):\n    removed = seq[:i] + seq[i+1:]\n    if len(removed) == len(set(removed)):  # check if removing the element reduces the length of LIS\n        critical.append(seq[i])\nif critical:\n    print(*sorted(critical))\nelse:\n    print(\"-1\")"
 ],
 "3027": [
  "def minimum_nubs(n, m, mark):\n    stamps = []\n    for dx in range(-(n-1), n):\n        for dy in range(-(m-1), m):\n            if dx == dy == 0:\n                continue\n            stamp = set()\n            valid = True\n            for i in range(n):\n                for j in range(m):\n                    if mark[i][j] == '#':\n                        x = i + dx\n                        y = j + dy\n                        if not (0 <= x < n and 0 <= y < m):\n                            valid = False\n                            break\n                        if (x, y) in stamp:\n                            valid = False\n                            break\n                        stamp.add((x, y))\n                if not valid:\n                    break\n            if valid and len(stamp) == 2 * mark.count('#'):\n                stamps.append(stamp)\n    ans = float('inf')\n    for i in range(len(stamps)):\n        for j in range(len(stamps)):\n            if i == j:\n                continue\n            ans = min(ans, len(stamps[i] | stamps[j]))\n    return ans\n                \n\nn, m = map(int, input().split())\nmark = []\nfor _ in range(n):\n    mark.append(input().strip())\n    \nprint(minimum_nubs(n, m, mark))"
 ],
 "3028": [
  "def shift(r,c): #helper function to shift a row and a column\n    moves=[]\n    for i in range(c):\n        moves.append((1,i+1))\n    for i in range(r):\n        moves.append((i+1,c))\n    for i in range(1,r):\n        for j in range(1,c):\n            moves.append((i,j))\n    return moves\n\nn,m,p=map(int,input().split())\ngrid=[]\nfor i in range(n):\n    grid.append(list(map(int,input().split())))\npos=[[0 for j in range(m)] for i in range(n)] #matrix to store how far a square is from p\nfor i in range(n):\n    for j in range(m):\n        pos[i][j]=min(p-grid[i][j],grid[i][j]) #how far from p in two directions\nflag=0\nfor k in range(p): #iterate from 0 to p-1\n    res=[]\n    for i in range(n):\n        for j in range(m):\n            if ((i+j)%p==k): #squares with this property will have k in them eventually\n                val=((k-grid[i][j])%p+p)%p  #how much to increment\n                if (val!=0):\n                    res.append((val,i,j))\n    if (len(res)>0): #we have moves\n        moves=[t[0] for t in res]\n        print(len(moves))\n        for t in res:\n            i,j=t[1:]\n            cur=pos[i][j] #current distance from p\n            ri=[pos[i2][j] for i2 in range(n)] #distances from p of the same column\n            ci=[pos[i][j2] for j2 in range(m)] #distances from p of the same row\n            shift_dist=min((p-cur)%p,cur) #how much the variables have to be shifted by to get more squares to max out\n            for k2 in range(shift_dist):\n                moves=shift(1,moves)\n                pos=[ri]+pos[:-1] #shift the variables down\n                res=[t if t[1]<=i else (t[0],t[1]+1,t[2]) if t[1]==i+1 else t for t in res] #update positions of the moves in the same column\n            while (max(ri+ci)<cur): #shift until at least one other variable matches the current variable\n                moves=shift(1,moves)\n                pos=[ri]+pos[:-1] #shift the variables down\n                res=[t if t[1]<=i else (t[0],t[1]+1,t[2]) if t[1]==i+1 else t for t in res] #update positions of the moves in the same column\n                cur-=1\n                ri=[pos[i2][j] for i2 in range(n)]\n                ci=[pos[i][j2] for j2 in range(m)]\n            left=(cur-sum(1 for val in ri+ci if val==cur))//2 #leftover moves\n            add_moves=[(1,j+1) for i2 in range(left) for j in range(m)]+[(i2+1,1) for i2 in range(left) for j in range(n)]\n            moves=add_moves+moves\n            for i2 in range(n):\n                for j2 in range(m):\n                    if (i==i2 or j==j2):\n                        grid[i2][j2]=(grid[i2][j2]+cur)%p #update the board\n            for r2 in range(n):\n                for c2 in range(m):\n                    pos[r2][c2]=min(p-grid[r2][c2],grid[r2][c2]) #update distances from p\n        print(' '.join(str(x[0])+str(x[1]) for x in moves))\n        flag=1\n        break\nif (flag==0):\n    print(-1)"
 ],
 "3029": [
  "import sys\nsys.setrecursionlimit(1000000)\nmod = 11092019\n\ndef dfs(u):\n    global longest, numPaths\n    candidateLength, numPathsHere = 0, 1\n    for v in adj[u]:\n        dfs(v)\n        # update candidate length and number of paths\n        if len(jumpingPaths[u]) < len(jumpingPaths[v]):\n            candidateLength, numPathsHere = len(jumpingPaths[v]), ways[v]\n        elif len(jumpingPaths[u]) == len(jumpingPaths[v]):\n            candidateLength, numPathsHere = max(candidateLength, len(jumpingPaths[v])), numPathsHere + ways[v]\n    # add u to longest jumping path and count number of paths\n    here = []\n    for x in jumpingPaths[u]:\n        i = bisect_left(jumpingPaths[x], nums[u])\n        if i < len(jumpingPaths[x]) and jumpingPaths[x][i] == nums[u]:\n            here.append(x[i])\n    jumpingPaths[u] = [nums[u]] + here\n    if len(jumpingPaths[u]) == 1:\n        here = [1] * numPathsHere\n    else:\n        here = [0] * len(ways)\n        for v in adj[u]:\n            if len(jumpingPaths[u]) == len(jumpingPaths[v]) + 1:\n                for p in range(len(ways)):\n                    if jumpingPaths[v][-1] >= jumpingPaths[u][p]:\n                        here[p] += ways[v]\n            elif len(jumpingPaths[u]) == len(jumpingPaths[v]) and candidateLength == len(jumpingPaths[v]):\n                for p in range(len(ways)):\n                    if jumpingPaths[v][-1] >= jumpingPaths[u][p]:\n                        here[p] += ways[v]\n    ways[u] = sum(here) % mod\n    longest = max(longest, len(jumpingPaths[u]))\n\ninput = __import__('sys').stdin.readline\nbisect_left = __import__('bisect').bisect_left\nn = int(input())\nnums = [int(input()) for _ in range(n)]\nways = [0] * n\nlongest, adj, jumpingPaths = 1, [[] for _ in range(n)], [[] for _ in range(n)]\nfor i in range(1, n):\n    p = int(input()) - 1\n    adj[p].append(i)\ndfs(0)\n\nprint(longest, ways[0])"
 ],
 "3030": [
  "import sys\n\ndef read_int():\n    return int(sys.stdin.readline().strip())\n\ndef read_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\nn = read_int()\nvalues = [-1]*(n+1)\nparent = [-1]*(n+1)\n\nfor i in range(1, n+1):\n    v, p = read_ints()\n    values[i] = v\n    parent[i] = p\n\nroot = 1\nans = 0\n\ndef dfs(node):\n    global ans\n    take = 1\n    for child in graph[node]:\n        take += dfs(child)\n    children = len(graph[node])\n    if children > 0:\n        l = [0]*children\n        for i, ch in enumerate(graph[node]):\n            l[i] = values[ch]\n        l = sorted(l, reverse=True)\n        for i in range(1, children):\n            if l[i] < l[i-1]:\n                l[i] = l[i-1]\n        j = 0\n        for i, child in enumerate(graph[node]):\n            c_best = l[j]\n            if values[child] < c_best:\n                take -= 1\n            else:\n                j += 1\n    ans = max(ans, take)\n    return take\n\ngraph = [[] for i in range(n+1)]\nfor i in range(2, n+1):\n    graph[parent[i]].append(i)\n    \ndfs(root)\nprint(ans)"
 ],
 "3031": [
  "import sys\n\ndef dfs(v, p, mx1, mx2, graph, good_nodes):\n    leaf = True\n    for u, c in graph[v]:\n        if u == p:\n            continue\n        leaf = False\n        if c != mx1 and c != mx2 and not dfs(u, v, c, mx1, graph, good_nodes):\n            return False\n    if leaf:\n        good_nodes.append(v)\n        return True\n    return True\n\nn = int(input())\ngraph = [[] for _ in range(n + 1)]\nfor i in range(n-1):\n    a, b, c = map(int, input().split())\n    graph[a].append((b, c))\n    graph[b].append((a, c))\n\ngood_nodes = []\nfor i in range(1, n+1):\n    has_good_node = dfs(i, -1, -1, -1, graph, good_nodes)\n    \nprint(len(good_nodes))\nfor i in sorted(good_nodes):\n    print(i)"
 ],
 "3032": [
  "from collections import defaultdict\nimport sys\ninput_ = sys.stdin.readlines()\nb, s = map(int, input_[0].split())\n\nprogram = input_[1].split()\n\ndef get_val(var):\n    return (var - 1) % s, (var - 1) // s\n\nbanks = [defaultdict(int) for _ in range(b)]\n\ndef run_program(program):\n    pc = 0\n    instructions = 0\n    while pc < len(program):\n        if program[pc][0] == 'V':\n            var = int(program[pc][1:])\n            b_idx, idx = get_val(var)\n            if banks[b_idx][idx] == 0:\n                instructions += 1\n            banks[b_idx][idx] += 1\n            pc += 1\n        elif program[pc][0] == 'R':\n            rep = int(program[pc][1:])\n            pc += 1\n            sub_instr = []\n            rep_pc = pc\n            while program[rep_pc] != 'E':\n                sub_instr.append(program[rep_pc])\n                rep_pc += 1\n            rep_pc += 1\n            inner_instructions = run_program(sub_instr)\n            for idx in range(s):\n                for bank_idx in range(b):\n                    cnt = banks[bank_idx][idx]\n                    if cnt > 0:\n                        if cnt % rep == 0:\n                            current_instructions = (((cnt // rep) - 1) * inner_instructions) + 1\n                        else:\n                            current_instructions = (((cnt // rep)) * inner_instructions) + 1 + inner_instructions\n                        if current_instructions > 1:\n                            instructions += 1\n            pc = rep_pc\n        else:\n            aa, f = get_val(int(program[pc + 1][1:]))\n            if program[pc] == 'A0':\n                instructions += 1\n                banks[aa][f] += 1\n            else:\n                bb = int(program[pc + 2][1:])\n                bank = banks[aa][f]\n                if bank // s != bb:\n                    instructions += 2\n                    banks[aa][f] += 1\n                    banks[aa] = defaultdict(int)\n                    banks[aa][(bb * s) + f] = 1\n                pc += 1\n            pc += 2\n    return instructions\n\nprint(run_program(program))\n\n"
 ],
 "3033": [
  "from math import log10\nB, N = map(int, input().split())\nres = -1\nfor X in range(1, 10000):\n    prod = 1\n    Y = X\n    while Y > 0:\n        digit = Y % B\n        if digit == 0:\n            prod = 0\n            break\n        prod *= digit\n        Y //= B\n    if prod == N:\n        res = X\n        break\nif res == -1:\n    print(\"impossible\")\nelse:\n    print(res)"
 ],
 "3034": [
  "from heapq import heappush, heappop\nfrom collections import defaultdict\n\ndef dijkstra(graph, start, end):\n    dist = {vert: float('inf') for vert in graph}\n    dist[start] = 0\n\n    heap = [(0, start)]\n    while heap:\n        cost, curr_vert = heappop(heap)\n\n        if cost > dist[curr_vert]:\n            continue\n        if curr_vert == end:\n            return dist[end]\n\n        for neighbor, weight in graph[curr_vert].items():\n            new_cost = dist[curr_vert] + weight\n            if new_cost < dist[neighbor]:\n                dist[neighbor] = new_cost\n                heappush(heap, (new_cost, neighbor))\n\n    return -1\n\nd, t, c, r = map(int, input().split())\nclouds = []\nfor i in range(c):\n    cloud = list(map(float, input().split()))\n    clouds.append(cloud)\n\nroofs = []\nfor i in range(r):\n    roof = list(map(int, input().split()))\n    roofs.append(roof)\n\n# calculate the coverage of each cloud for each second that it is raining\ncoverage = defaultdict(int)\nfor cloud in clouds:\n    prob, amount = cloud[2], cloud[3]\n    for sec in range(cloud[0], cloud[1]):\n        coverage[sec] += prob * amount\n\n# calculate the time taken to reach the bus stop without stopping under a roof\ntime = d\n\n# find the minimum expected amount of rain by trying all possible stopping points under a roof\nmin_rain = sum([coverage[sec] for sec in range(t)])\nfor roof in roofs:\n    start, end = roof[0], roof[1]\n\n    # how much time can be spent under this roof before reaching the bus stop\n    time_under_roof = min(end - start, t - time)\n\n    # calculate the expected amount of rain under this roof\n    expected_rain = 0\n    for sec in range(time, time + time_under_roof):\n        expected_rain += coverage[sec]\n    expected_rain /= time_under_roof\n\n    # find the time taken to reach the bus stop after stopping under this roof\n    new_time = time + time_under_roof + (d - end)\n    # find the expected amount of rain after stopping under this roof and reaching the bus stop\n    new_expected_rain = expected_rain + sum([coverage[sec] for sec in range(new_time, t)])\n    # update the minimum expected amount of rain if this value is smaller\n    if new_expected_rain < min_rain:\n        min_rain = new_expected_rain\n\nprint(\"{:.5f}\".format(min_rain))"
 ],
 "3035": [
  "n = int(input())\nadj = [[] for _ in range(n+1)]\nfor i in range(n):\n    a, b, r = input().split()\n    r = float(r)\n    adj[i].append((a, r))\n    adj[i+1].append((b, 1/r))\n\ndist = {k:0 for k in adj[0]}\ndist['blue'] = 1.0\npq = [(1.0, 'blue')]\nvis = set()\n\nwhile len(pq):\n    while len(pq) and pq[0][1] in vis:\n        heapq.heappop(pq)\n    if not len(pq):\n        break\n    d, u = heapq.heappop(pq)\n    vis.add(u)\n    \n    for v, w in adj[u]:\n        if v not in vis:\n            if dist[v] < d*w:\n                dist[v] = d*w\n                heapq.heappush(pq, (dist[v], v))\n\nprint(\"{:.6f}\".format(min(dist['pink'], 10.0)))"
 ],
 "3036": [
  "from itertools import product\nfrom functools import reduce\nfrom collections import deque\n\n# read input\nr, s, m, d, n = map(int, input().split())\nbs = list(map(int, input().split()))\n\ndishes = []\nfor i in range(s + m + d):\n    k, *ingredients = map(int, input().split())\n    dishes.append(ingredients)\n\nbad_pairs = [[] for _ in range(s + m + d)]\nfor _ in range(n):\n    a, b = map(int, input().split())\n    bad_pairs[a-1].append(b-1)\n    bad_pairs[b-1].append(a-1)\n\n# precompute which brands of each ingredient can be used in each dish\nvalid_brands = []\nfor dish in dishes:\n    valid = []\n    for ingredient in dish:\n        valid.append(set(range(bs[ingredient])))\n    valid_brands.append(valid)\n\n\n# get all possible sets of dishes\nsets_of_dishes = list(product(range(s), range(m), range(d)))\n\n\n# helper function to check if a set of dishes is valid\ndef is_valid(dish_set):\n    for i in range(3):\n        for j in range(i + 1, 3):\n            if dish_set[i] in bad_pairs[dish_set[j]]:\n                return False\n    return True\n\n\n# count the number of valid sets of dishes and brands\ncount = 0\n\n# tuple of chosen dish for each dish type\nchosen_dishes = [-1] * 3\n\n# queue to hold the search state\nqueue = deque([([], [], [])])\n\nwhile queue:\n    chosen_i, chosen_j, chosen_k = queue.pop()\n    if len(chosen_i) == s and len(chosen_j) == m and len(chosen_k) == d:\n        # we have chosen a complete set of dishes, so count this if it's valid\n        if is_valid(chosen_i + chosen_j + chosen_k):\n            # get the set of valid brands for each chosen ingredient\n            chosen_brands = []\n            for dish, dish_brands in zip(chosen_i + chosen_j + chosen_k, valid_brands):\n                chosen_brands.append(dish_brands[dishes[dish].index(chosen_i + chosen_j + chosen_k)])\n\n            # count the number of combinations of valid brands\n            product_size = reduce(lambda x, y: x * y, [len(s) for s in chosen_brands])\n            if count + product_size > 10**18:\n                print(\"too many\")\n                exit()\n            count += product_size\n    else:\n        # add the next dish of each type to the queue\n        next_dish_is = [i for i in range(s) if i not in chosen_i]\n        next_dish_js = [j for j in range(m) if j not in chosen_j]\n        next_dish_ks = [k for k in range(d) if k not in chosen_k]\n\n        # iterate over all possible combinations of next dishes\n        for next_i in next_dish_is:\n            chosen_i_copy = chosen_i.copy()\n            chosen_i_copy.append(next_i)\n            if is_valid(chosen_i_copy + chosen_j + chosen_k):\n                queue.append((chosen_i_copy, chosen_j, chosen_k))\n        for next_j in next_dish_js:\n            chosen_j_copy = chosen_j.copy()\n            chosen_j_copy.append(next_j)\n            if is_valid(chosen_i + chosen_j_copy + chosen_k):\n                queue.append((chosen_i, chosen_j_copy, chosen_k))\n        for next_k in next_dish_ks:\n            chosen_k_copy = chosen_k.copy()\n            chosen_k_copy.append(next_k)\n            if is_valid(chosen_i + chosen_j + chosen_k_copy):\n                queue.append((chosen_i, chosen_j, chosen_k_copy))\n\nprint(count)"
 ],
 "3037": [
  "from collections import deque\n\nh, w, n = input().split()\nh, w, n = int(h), int(w), int(n)\nboard = [input() for i in range(h)]\nqueries = [input().split() for i in range(n)]\n\n# initialization of variables\nr_dry = [w + 1] * (h + 1)\nl_dry = [-1] * (h + 1)\nu_dry = [h + 1] * (w + 1)\nd_dry = [-1] * (w + 1)\n\n# computing the earliest and latest time when marker can run out of ink\ndef compute_range(board, query):\n    time = 0\n    direc, dist = query\n    dist = int(dist)\n    if direc == \"up\":\n        for i in range(dist):\n            time += 1\n            for j in range(1, w + 1):\n                if board[h - i - 2][j - 1] == \"#\":\n                    u_dry[j] = min(u_dry[j], time)\n                else:\n                    return max(u_dry[j] - 1, time), min(u_dry[j] + 1, time)\n    elif direc == \"down\":\n        for i in range(dist):\n            time += 1\n            for j in range(1, w + 1):\n                if board[i + 1][j - 1] == \"#\":\n                    d_dry[j] = max(d_dry[j], time)\n                else:\n                    return max(d_dry[j] - 1, time), min(d_dry[j] + 1, time)\n    elif direc == \"left\":\n        for j in range(dist):\n            time += 1\n            for i in range(1, h + 1):\n                if board[h - i][w - j - 1] == \"#\":\n                    l_dry[h - i + 1] = max(l_dry[h - i + 1], time)\n                else:\n                    return max(l_dry[h - i + 1] - 1, time), min(l_dry[h - i + 1] + 1, time)\n    else:  # direc == \"right\"\n        for j in range(dist):\n            time += 1\n            for i in range(1, h + 1):\n                if board[h - i][j] == \"#\":\n                    r_dry[h - i + 1] = min(r_dry[h - i + 1], time)\n                else:\n                    return max(r_dry[h - i + 1] - 1, time), min(r_dry[h - i + 1] + 1, time)\n    return -1, -1\n\n# getting minimum and maximum time for marker to run out of ink and still end with same drawing\nmin_time, max_time = float(\"inf\"), float(\"-inf\")\nfor query in queries:\n    mn, mx = compute_range(board, query)\n    if mn == -1:\n        print(\"-1 -1\")\n        break\n    min_time, max_time = min(min_time, mn), max(max_time, mx)\nelse:\n    print(min_time, max_time)"
 ],
 "3038": [
  "def dfs(i, new_sum, rev_filled):\n    if i == k:\n        if new_sum >= B:\n            need = list(map(sum, rev_filled))\n            if min(need) >= total_min:\n                return False\n            for s in range(B, new_sum + 1):\n                if notes[s - B]:\n                    cur_pack = []\n                    for p in filled:\n                        if p:\n                            for j in p:\n                                if notes[s - B][j] + s <= new_sum:\n                                    return False\n                                else:\n                                    cur_pack.append(j)\n                    ans_packs = need_to_pack(cur_pack, s)\n                    if ans_packs:\n                        return True\n            return False\n        return False\n\n    for j in range(len(size[i])):\n        cur_pack = []\n        notes = [[0] * len(size[i]) for _ in range(size[i][j] - size[i][0] + 2)]\n        for ind in range(j, len(size[i])):\n            filled[ind - j].append(i)\n            for s in range(size[i][ind] - size[i][j] + 1):\n                notes[s][ind - j] = sum(size[i][j:ind + 1])\n        new_rev_filled = copy.deepcopy(rev_filled)\n        new_rev_filled[i] = filled[::-1]\n        if dfs(i + 1, new_sum + size[i][j], new_rev_filled):\n            return True\n        filled[ind - j].pop()\n    return False\n\n\ndef need_to_pack(packs, need_num):\n    need_pack = []\n    length = len(packs)\n\n    def f(i, cur):\n        if i == length:\n            if cur >= need_num:\n                need_pack.append(cur)\n            return\n        f(i + 1, cur)\n        f(i + 1, cur + packs[i])\n\n    f(0, 0)\n    if need_pack:\n        return sorted(need_pack)[0]\n    else:\n        return False\n\nB = int(input())\nk = int(input())\nsize = []\nfor i in range(k):\n    size.append(list(map(int, input().split()))[1:])\ntotal_min = 999999\nfilled = [[] for _ in range(k)]\nif dfs(0, 0, [[] for _ in range(k)]):\n    print(total_min)\nelse:\n    print('impossible')"
 ],
 "3039": [
  "layout = [input() for i in range(6)]\nif layout.count('#') != 6:\n    print('cannot fold')\nelse:\n    row_counts = [row.count('#') for row in layout]\n    col_counts = [col.count('#') for col in zip(*layout)]\n    if sorted(row_counts) == sorted(col_counts) == [1, 2, 3]:\n        print('can fold')\n    else:\n        print('cannot fold')"
 ],
 "3040": [
  "s = input()\nans = ''\nfor i in range(1,len(s)):\n    if s[i:] == s[:-i] and s[i:] not in ans:\n        ans = s[i:]\n        break\nfor i in range(len(s)):\n    for j in range(i+1,len(s)):\n        if s[i:j] in s[j:] and len(s[i:j]) > len(ans):\n            ans = s[i:j]\n        elif s[i:j] in s[j:] and len(s[i:j]) == len(ans) and s[i:j] < ans:\n            ans = s[i:j]\nprint(ans)"
 ],
 "3041": [
  "import heapq\n\nn = int(input())\ntrips = []\nfor i in range(n):\n    zone, t = map(int, input().split())\n    trips.append((t, zone))\n\ncoupons = 0\nvalid_ticket = None\nheap = []\n\nfor t, zone in trips:\n    if valid_ticket and valid_ticket[0] < t:\n        heapq.heappush(heap, valid_ticket)\n        valid_ticket = None\n    \n    cheapest_ticket = (2 + abs(heap[0][1] - zone), t + 10000)\n    if not valid_ticket or cheapest_ticket[0] < valid_ticket[0]:\n        coupons += cheapest_ticket[0]\n        valid_ticket = cheapest_ticket\n    else:\n        heapq.heappush(heap, cheapest_ticket)\n\nprint(coupons)"
 ],
 "3042": [
  "MOD = 1000000007\nn = int(input())\na = list(map(int, input().split()))\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\ndef dfs(idx, l, r):\n    if idx == n:\n        return 1\n    res = 0\n    # Try to put a[idx] to the left subtree\n    if l % a[idx] == 0:\n        res += dfs(idx+1, l, lcm(r,a[idx])) % MOD\n    # Try to put a[idx] to the right subtree\n    if r % a[idx] == 0:\n        res += dfs(idx+1, lcm(l,a[idx]), r) % MOD\n    return res % MOD\n    \n# Driver code\nans = dfs(2, a[0], a[1]) % MOD\nans += dfs(2, a[1], a[0]) % MOD\nprint(ans % MOD)"
 ],
 "3043": [
  "from queue import Queue\n\n# function to check whether a cell is safe to move or not\ndef is_safe(i, j, grid, visited):\n    if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]):\n        return False # out of bounds\n    if visited[i][j]:\n        return False # already visited\n    if grid[i][j] == \"#\":\n        return False # river, cannot pass through\n    return True\n\n# function to calculate the minimum number of days needed to reach the treasure\ndef find_minimum_days(grid, start_i, start_j, treasure_i, treasure_j, k):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] # possible directions to move\n    q = Queue() # queue for BFS traversal\n    visited = [[False for j in range(len(grid[0]))] for i in range(len(grid))] # keep track of visited cells\n    q.put((start_i, start_j, k, 0)) # starting cell, stamina points, and current day (0)\n    visited[start_i][start_j] = True # mark starting cell as visited\n    while not q.empty():\n        i, j, stamina, day = q.get() # get the next cell from the queue\n        if i == treasure_i and j == treasure_j: # if we have reached the treasure\n            return day # return the current day\n        for d in directions: # check all possible directions to move\n            new_i, new_j = i + d[0], j + d[1]\n            if is_safe(new_i, new_j, grid, visited):\n                cost = 1 if grid[new_i][new_j] == '.' else (2 if grid[new_i][new_j] == 'F' else 3) # calculate stamina cost for moving to new cell\n                if cost <= stamina: # we can move to new cell with remaining stamina\n                    q.put((new_i, new_j, stamina - cost, day)) # we stay on the same day\n                else: # we cannot move to new cell with remaining stamina\n                    q.put((i, j, k - cost, day + 1)) # we camp and rest for one day, and stamina is fully replenished\n                visited[new_i][new_j] = True # mark new cell as visited\n    return -1 # could not reach the treasure\n\n# read input values\nn, m, k = map(int, input().split())\ngrid = [input() for i in range(n)]\n\n# find starting and ending cell indices\nstart_i, start_j, treasure_i, treasure_j = None, None, None, None\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 'S':\n            start_i, start_j = i, j\n        elif grid[i][j] == 'G':\n            treasure_i, treasure_j = i, j\n\n# calculate minimum number of days needed to reach the treasure\nmin_days = find_minimum_days(grid, start_i, start_j, treasure_i, treasure_j, k)\n\n# print the result\nprint(min_days)"
 ],
 "3044": [
  "import heapq\n\n# Read input values\nh, w = map(int, input().split())\ngrid = [input() for _ in range(h)]\ncommands = input()\n\n# Find start and goal positions\nstart = None\ngoal = None\nfor i in range(h):\n    for j in range(w):\n        if grid[i][j] == 'S':\n            start = (i, j)\n        elif grid[i][j] == 'G':\n            goal = (i, j)\n\n# Define helper function to check if a position is valid\ndef is_valid(x, y):\n    return 0 <= x < h and 0 <= y < w and grid[x][y] != '#'\n\n# Define helper function to simulate robot movement\ndef simulate(command):\n    x, y = start\n    for c in command:\n        if c == 'L':\n            y -= 1\n        elif c == 'R':\n            y += 1\n        elif c == 'U':\n            x -= 1\n        elif c == 'D':\n            x += 1\n        if not is_valid(x, y):\n            return False, None\n        if (x, y) == goal:\n            return True, None\n    return False, (x, y)\n\n# Define helper function to compute minimum changes needed\ndef min_changes():\n    # Check if original command string works\n    if simulate(commands)[0]:\n        return 0\n    # Try deleting one character at a time\n    for i in range(len(commands)):\n        new_command = commands[:i] + commands[i+1:]\n        if simulate(new_command)[0]:\n            return 1\n    # Try inserting one character at a time\n    for i in range(len(commands)+1):\n        for c in 'LRUD':\n            new_command = commands[:i] + c + commands[i:]\n            if simulate(new_command)[0]:\n                return 1\n    # Try replacing one character at a time\n    for i in range(len(commands)):\n        for c in 'LRUD':\n            if commands[i] == c:\n                continue\n            new_command = commands[:i] + c + commands[i+1:]\n            if simulate(new_command)[0]:\n                return 1\n    # Compute minimum changes needed using Dijkstra's algorithm\n    distances = {(0, commands): 0}\n    heap = [(0, commands)]\n    while heap:\n        dist, command = heapq.heappop(heap)\n        if simulate(command)[0]:\n            return dist\n        for i in range(len(command)+1):\n            for c in 'LRUD':\n                new_command = command[:i] + c + command[i:]\n                if new_command in distances:\n                    continue\n                if simulate(new_command)[0]:\n                    return dist + 1\n                distances[new_command] = dist + 1\n                heapq.heappush(heap, (dist + 1, new_command))\n\n# Print output\nprint(min_changes())"
 ],
 "3045": [
  "import sys\n \ndef read(): return sys.stdin.readline().strip()  # function to take input without whitespace characters\n \nN = int(read())\nX = []\nY = []\nD = []\n \nfor i in range(N):\n    x,y,d = map(int, read().split())\n    X.append(x)\n    Y.append(y)\n    D.append(d)\n \nx_low = max(0, min(X) - max(D))\nx_high = min(1000000, max(X) + max(D))\ny_low = max(0, min(Y) - max(D))\ny_high = min(1000000, max(Y) + max(D))\n \nsolution_set = set()\n \nfor i in range(x_low, x_high+1):\n    for j in range(y_low, y_high+1):\n        possible = True\n        for k in range(N):\n            if abs(X[k]-i) + abs(Y[k]-j) != D[k]:\n                possible = False\n                break\n        if possible:\n            solution_set.add((i,j))\n \nif len(solution_set) == 0:\n    print('impossible')\nelif len(solution_set) == 1:\n    print(*solution_set.pop())\nelse:\n    print('uncertain')"
 ],
 "3046": [
  "n = int(input())\ntop_corners = []\nbottom_corners = []\nfor i in range(n):\n    r, c = map(int, input().split())\n    top_corners.append((r, c, i))\nfor i in range(n):\n    r, c = map(int, input().split())\n    bottom_corners.append((r, c, i))\n\ntop_corners.sort()\nbottom_corners.sort()\n\nstack = []\nidx_bottom = 0\nresult = [-1]*n\n\nfor r, c, i in top_corners:\n    while idx_bottom < n and (bottom_corners[idx_bottom][0] < r or bottom_corners[idx_bottom][1] < c):\n        if not stack or stack[-1] != bottom_corners[idx_bottom][2]:\n            print(\"syntax error\")\n            exit()\n        stack.pop()\n        idx_bottom += 1\n    \n    if idx_bottom >= n:\n        print(\"syntax error\")\n        exit()\n    \n    result[i] = bottom_corners[idx_bottom][2]\n    stack.append(i)\n\nprint(\"\\n\".join(str(x+1) for x in result))"
 ],
 "3047": [
  "# Importing the combinations class from the itertools module\nfrom itertools import combinations\n\n# Reading the input\ntop_row = input().split()\nbottom_row = input().split()\n\n# Creating a dictionary to hold the partial information\npartial_info = {}\nfor i in range(10):\n    if top_row[i] != '_':\n        partial_info[i] = int(top_row[i])\n    if bottom_row[i] != '_':\n        partial_info[i+10] = int(bottom_row[i])\n\n# Defining a function to check if an arrangement is consistent with the partial information\ndef is_consistent(arrangement):\n    # Looping through each monster's plate\n    for i in range(5):\n        # Calculating the indices and proportions of the other items for the current monster\n        item_indices = [i*2, i*2+1]\n        other_items = [j for j in range(10) if j not in item_indices]\n        proportions = [arrangement[j]/arrangement[item_indices[0]] for j in other_items]\n        # Checking if the proportions match for all monsters\n        for j in range(5):\n            if j != i:\n                item_indices2 = [j*2, j*2+1]\n                other_items2 = [k for k in range(10) if k not in item_indices2]\n                proportions2 = [arrangement[k]/arrangement[item_indices2[0]] for k in other_items2]\n                if proportions != proportions2:\n                    return False\n    return True\n\n# Creating a list of the indices of empty slots\nempty_slots = [i for i in range(20) if i not in partial_info.keys()]\n\n# Creating a list of candidate values for an empty slot\ncandidates = [i for i in range(1, 201)]\n\n# Looping through all combinations of candidate values for the empty slots\ncount = 0\nfor combo in combinations(candidates, len(empty_slots)):\n    # Creating a dictionary mapping empty slots to candidate values\n    candidate_info = {empty_slots[i]:combo[i] for i in range(len(empty_slots))}\n    # Combining the partial information with the candidate information\n    arrangement = {**partial_info, **candidate_info}\n    # Checking if the arrangement is consistent with the partial information\n    if is_consistent(arrangement):\n        count += 1\n\n# Outputting the result\nif count == 0:\n    print('many')\nelse:\n    print(count)"
 ],
 "3048": [
  "from collections import defaultdict\n\nn = int(input())\ngraph = defaultdict(list)\n\nfor _ in range(n-1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n    graph[v].append(u)\n\ncount = 0\nfor u in range(1, n+1):\n    for v in graph[u]:\n        for w in graph[v]:\n            if w != u and w not in graph[u]:\n                count += 1\n\nprint(count//2)"
 ],
 "3049": [
  "encrypted_msg = input().strip()\nfragment = input().strip()\nn = len(encrypted_msg)\nm = len(fragment)\nfreq = {}\nfor i in range(n):\n    if encrypted_msg[i] not in freq:\n        freq[encrypted_msg[i]] = []\n    freq[encrypted_msg[i]].append(i)\nunique_pos = 0\nfor pos in freq.get(fragment[0], []):\n    if n - pos < m:\n        break\n    found = True\n    for i in range(1, m):\n        if fragment[i] not in freq or not any(p > pos+i or p < pos for p in freq[fragment[i]]):\n            found = False\n            break\n    if found:\n        unique_pos += 1\n        if unique_pos > 1:\n            break\nif unique_pos == 1:\n    print(encrypted_msg[pos:pos+m])\nelse:\n    print(unique_pos)"
 ],
 "3050": [
  "def is_finite(n, prog, grid):\n  visited = set()\n  r, c = None, None\n  for i in range(n):\n    for j in range(n):\n      if grid[i][j] == 'R':\n        r, c = i, j\n        break\n    if r is not None:\n      break\n  # i, j, direction\n  state = (r, c, 0)\n  cycles = []\n  while True:\n    if state in visited:\n      # finite\n      return 1\n    visited.add(state)\n    i, j, d = state\n    ni, nj = None, None\n    if prog[d] == '<':\n      nj = j - 1\n      if grid[i][nj] != '#':\n        state = (i, nj, (d + 1) % len(prog))\n    elif prog[d] == '>':\n      nj = j + 1\n      if grid[i][nj] != '#':\n        state = (i, nj, (d + 1) % len(prog))\n    elif prog[d] == 'v':\n      ni = i + 1\n      if grid[ni][j] != '#':\n        state = (ni, j, (d + 1) % len(prog))\n    else:  # prog[d] == '^'\n      ni = i - 1\n      if grid[ni][j] != '#':\n        state = (ni, j, (d + 1) % len(prog))\n    if ni is not None and nj is not None:\n      print(\"Error: ni and nj are both not None\")\n      return -1\n    if state in visited:\n      # found a cycle\n      idx = cycles.index(state)\n      cycles = cycles[idx:]\n      # cycle length is len(visited) - idx\n      return len(visited) - idx\n    cycles.append(state)\n\nn = int(input())\nprog = input()\ngrid = []\nfor i in range(n):\n  grid.append(input())\n\nx = is_finite(n, prog, grid)\nprint(x)"
 ],
 "3051": [
  "from queue import PriorityQueue\n\nn = int(input())\nfogs = []\nfor i in range(n):\n    m, d, l, r, h, dd, dx, dh = map(int, input().split())\n    for j in range(m):\n        pos_l = l + j * dx\n        pos_r = r + j * dx\n        pos_h = h + j * dh\n        fog = (d + j*dd, pos_l, pos_r, pos_h)\n        fogs.append(fog)\nfogs.sort()\n\nmissed_fogs = 0\nend = float('-inf')\nq = PriorityQueue()\nfor fog in fogs:\n    day, l, r, h = fog\n    if day > end:\n        missed_fogs += len(q)\n        end = day\n        q = PriorityQueue()\n    q.put((h, r))\n    while not q.empty() and q.queue[0][0] < h:\n        q.get()\nprint(missed_fogs)"
 ],
 "3052": [
  "from math import sqrt, inf\nXA, YA, XB, YB = map(float, input().split())\nn = int(input())\nminTime = abs(XA - XB) + abs(YA - YB)\nfor i in range(n):\n    x1, y1, x2, y2 = map(float, input().split())\n    onBelt = (XA <= x1 and XB >= x2 and y1 == y2) or (XA >= x1 and XB <= x2 and y1 == y2) or (YA <= y1 and YB >= y2 and x1 == x2) or (YA >= y1 and YB <= y2 and x1 == x2)\n    if onBelt:\n        vel = 2 if (XA < XB and x1 < x2) or (XA > XB and x1 > x2) or (YA < YB and y1 < y2) or (YA > YB and y1 > y2) else -2\n        dist = vel * ((XB - XA) * (y2 - y1) - (YB - YA) * (x2 - x1))\n        if dist > 0:\n            minTime = min(minTime, dist / 2)\n    else:\n        minTime = min(minTime, sqrt((XA - x1) ** 2 + (YA - y1) ** 2) + sqrt((XB - x2) ** 2 + (YB - y2) ** 2))\nprint(minTime)"
 ],
 "3053": [
  "import string\nn, k, p = map(int, input().split())\nif k > p or n < 2 * p - 1: print(\"IMPOSSIBLE\")\nelse:\n    s = ['a'] * n\n    for i in range(p):\n        s[i] = string.ascii_lowercase[i % k]\n        s[n - i - 1] = s[i]\n    print(''.join(s))"
 ],
 "3054": [
  "import re\n\ndef count_syllables(word: str) -> int:\n    # Counts the number of syllables in a word\n    word = word.upper()\n    if word[-2:] == \"ES\":\n        if not re.search(\"[AEIOUY]\", word[-3]):\n            word = word[:-2]\n    elif word[-1] == \"E\":\n        if word[-2] == \"L\":\n            pass\n        else:\n            word = word[:-1]\n    word = re.sub(\"[^AEIOUY]+\", \"-\", word)\n    return len(word.split(\"-\"))\n\ndef divide_into_haiku(line: str) -> str:\n    words = re.findall(r\"[\\w']+|[^\\w\\s]+\", line)\n    haiku = []\n    curr_line = \"\"\n    curr_syllables = 0\n    line_syllables = [5, 7, 5]\n    for word in words:\n        # If the current word makes the line exceed syllable limit, \n        # append the current line to haiku and start a new line\n        if curr_syllables + count_syllables(word) > line_syllables[len(haiku)]:\n            haiku.append(curr_line[:-1])\n            curr_line = \"\"\n            curr_syllables = 0\n        curr_line += word + \" \"\n        curr_syllables += count_syllables(word)\n    # Append the last line to haiku\n    haiku.append(curr_line[:-1])\n    # If the haiku has 3 lines with correct number of syllables, return it\n    if len(haiku) == 3 and \\\n       count_syllables(haiku[0]) == line_syllables[0] and \\\n       count_syllables(haiku[1]) == line_syllables[1] and \\\n       count_syllables(haiku[2]) == line_syllables[2]:\n        return \"\\n\".join(haiku)\n    # Otherwise return the original line\n    else:\n        return line\n\n# Taking input from STDIN\nline = input()\nprint(divide_into_haiku(line))"
 ],
 "3055": [
  "n = int(input())\nnames = []\nfor i in range(n):\n    names.append(input())\n\nthore_index = names.index('ThoreHusfeldt')\n\nif thore_index == 0:\n    print(\"Thore is awesome\")\nelse:\n    for i in range(thore_index-1, -1, -1):\n        if names[i].startswith('ThoreHusfeld'):\n            print(names[thore_index][:len(names[i])+1])\n            break\n    else:\n        print(\"Thore sucks\")"
 ],
 "3056": [
  "def dfs(node, walk):\n    if not walk:\n        return node\n    if walk[0] == 'L':\n        return dfs(node * 2, walk[1:])\n    elif walk[0] == 'R':\n        return dfs(node * 2 + 1, walk[1:])\n    else:\n        return dfs(node, walk[1:]) + dfs(node, walk[1:] + 'L') + dfs(node, walk[1:] + 'R')\n\ns = input().strip()\nprint(dfs(1, s))"
 ],
 "3057": [
  "import collections\nimport sys\n\nsys.setrecursionlimit(1000000)\n\n# recursive function to find the root of the word\ndef find(k):\n    if k in root:\n        return find(root[k])\n    return k\n\n# function to check if the word can still be rhymed with the given pattern\ndef check_rhyme(w1, w2):\n    n = min(3, len(w1), len(w2))\n    return w1[-n:] == w2[-n:]\n\nn = int(input())\nroot = {} # dictionary to store the root of each word\nfor i in range(n):\n    s = input().split()\n    x, y = s[0], s[-1]\n    x_root, y_root = find(x), find(y)\n    \n    if s[1] == \"is\":\n        # if both have different roots, make one root of the other\n        if x_root != y_root:\n            root[x_root] = y_root\n    else:\n        # if both rhymes with each other, but belong to different roots, then it is a contradiction\n        if check_rhyme(x, y) and x_root != y_root:\n            print(\"wait what?\")\n            sys.exit()\n\n# dictionary to store the number of elements in each root\nnum_elems = collections.defaultdict(int)\nfor word in root:\n    num_elems[find(word)] += 1\n\n# if there are multiple roots, it is a contradiction\nif len(num_elems) > 1:\n    print(\"wait what?\")\nelse:\n    print(\"yes\")"
 ],
 "3058": [
  "n = int(input())\nlive_species = input().strip()\nfossils = [input().strip() for i in range(n)]\n\npath1 = set()\npath2 = set()\n\nfor f in fossils:\n    # Check if the fossil is a mutation of the live species\n    # If it is, add it to path1\n    if len(set(f).difference(set(live_species))) == 1:\n        path1.add(f)\n    # Check if the fossil is a mutation of any sequence in path1\n    # If it is, add it to path2\n    elif any(len(set(f).difference(set(p))) == 1 for p in path1):\n        path2.add(f)\n    # If the fossil is not a mutation of the live species or path1,\n    # it cannot belong to either path and the parallel evolution\n    # hypothesis is not consistent\n    else:\n        print(\"impossible\")\n        exit()\n\n# Check if any sequence belongs to both paths\nif any(s in path1 and s in path2 for s in fossils):\n    print(\"impossible\")\n    exit()\n\n# Display the example of the two evolutionary paths\nprint(len(path1), len(path2))\nfor p in sorted(path1):\n    print(p)\nfor p in sorted(path2):\n    print(p)"
 ],
 "3059": [
  "from decimal import Decimal\nimport sys\n\ndef solve(n, r, m, tricks):\n    dp = [Decimal(0) for i in range(n+1)]\n    dp[n] = Decimal(1)\n    trick_idx = 0\n    for i in range(n-1, -1, -1):\n        if trick_idx < m and tricks[trick_idx][0] == i:\n            p, d = tricks[trick_idx][1], tricks[trick_idx][2]\n            retry_p = 1  # probability of having to retry the trick\n            fail_p = 1 - p\n            expected = Decimal(d) * fail_p + dp[i+1] * p  # the expected time spent if you fail and retry or just continue\n            for j in range(1, 1001):\n                if i + j >= r:  # it's impossible to break the record now\n                    expected += Decimal(j) * retry_p * fail_p\n                    break\n                retry_p *= fail_p\n                fail_p *= p\n                expected += Decimal(j) * retry_p * fail_p * (d + dp[i+j+1])\n                if expected >= dp[i]:\n                    break\n            dp[i] = expected\n            trick_idx += 1\n        else:\n            dp[i] = dp[i+1] + 1\n            if i < r:\n                dp[i] = min(dp[i], dp[r])\n    return '{:.10f}'.format(float(dp[0]))\n\nn, r, m = map(int, input().strip().split())\ntricks = []\nfor i in range(m):\n    t, p, d = input().strip().split()\n    tricks.append((int(t), Decimal(p), int(d)))\nprint(solve(n, r, m, tricks))"
 ],
 "3060": [
  "n, k = map(int, input().split())\n\n# Count number of valid sequences of certain length\ndef count_seq(length):\n    if length == 0:\n        return 1\n    if length == 1:\n        return n-1\n    # dp[i][j] is the number of valid sequences of length i ending with j petals\n    dp = [[0 for _ in range(n)] for _ in range(length)]\n    for j in range(n):\n        dp[0][j] = 1\n    for i in range(1, length):\n        for j in range(n):\n            for p in range(1, n):\n                if (j+p) % n != 0: # avoid multiples of n\n                    dp[i][j] += dp[i-1][(j+p)%n]\n    return sum(dp[length-1])\n\n\nseq = []\nwhile n > 1:\n    for i in range(1, n):\n        # Calculate the number of valid sequences starting with i petals\n        cnt = count_seq(n-2)\n\n        # If the kth sequence is in this range, set the first flower to i and break\n        if k <= cnt:\n            seq.append(i)\n            n -= 1\n            break\n\n        # Otherwise, subtract the count and continue to the next value of i\n        else:\n            k -= cnt\n    else:\n        raise Exception(\"Loop should not terminate\")\n\n# Append the remaining petal count to the sequence\nseq.append(k%n if k%n!=0 else n)\nprint(*seq)"
 ],
 "3061": [
  "from collections import defaultdict\nINF = int(1e9)\n\ndef dfs(i,k,adj,s,d,vis):\n    if k==i:#already considered this element\n        return\n    if vis[k]==1:# If Have already visited this node\n        if s==k:\n            #if it is the starting node or we have already completed a cycle\n            #and are back to starting node\n            ans.append(d[k])\n        return \n    vis[k] = 1\n    d[k] = s# this is added just as an additional optimisation \n    #to keep track of nodes visited while rolling back of dfs search\n    for u in adj[k]:\n        #visit each node\n        dfs(i,u,adj,s,d,vis)\n\ndef solve():\n    n,m = map(int, input().split())\n    adj = defaultdict(list)\n    for i in range(m):\n        u,v = map(int,input().split())\n        adj[u].append(v)\n    ans = []\n    d = [INF for i in range(n+1)]\n    for i in range(1,n+1):\n        vis = [0 for j in range(n+1)]\n        d[i] = 0\n        dfs(i,i,adj,i,d,vis)\n    for i in range(1,n+1):\n        w = d[i]# previous optimal path distance\n        for j in adj[i]:\n            #remove this edge and calculate the path\n            if d[i]!=d[j]:\n                w = max(w,d[i]+d[j]+1)\n        ans.append(w)\n    print(min(ans))\n\nif __name__=='__main__':\n    solve()"
 ],
 "3062": [
  "import math\n\nx, y = map(int, input().split())\nv, w = map(float, input().split())\n\nangle = math.atan2(y, x)\ndistance = math.sqrt(x*x + y*y)\n\nif angle < 0: angle += 2*math.pi\n\nif angle <= math.pi/2:\n    target_angle = angle\nelse:\n    target_angle = 2*math.pi - angle\n    \ntime_to_rotate = target_angle/w\ntime_to_travel = distance/v\ntotal_time = time_to_rotate + time_to_travel\n\nprint(\"{0:.8f}\".format(total_time))"
 ],
 "3063": [
  "import sys\n\ndef dfs(u):\n    vis[u] = 1\n    res = owe[u]\n    for v, w in G[u]:\n        if not vis[v]: \n            x = dfs(v)\n            if x > 0: res += x\n        if w > owe[v]:  # v owes more than what A has\n            res += w - owe[v]\n            owe[v] = w  # give A's money to v, v now owes 0\n    return res - give[u]  # A owe res, A get give[u]\n\nn = int(input())\nG = [[] for i in range(n)]\nowe = [0] * n\ngive = [0] * n\n\nfor i in range(n):\n    u, w = map(int, input().split())\n    G[u-1].append((i, w))\n    owe[i] = w\n    give[u-1] += w\n\nans = 0\nvis = [0] * n\nfor i in range(n):\n    if not vis[i]:\n        ans += dfs(i)\n\nprint(ans)"
 ],
 "3064": [
  "from collections import defaultdict\n\ndef dfs(u, p=-1):\n    max1, max2 = 0, 0\n    for v in g[u]:\n        if v == p:\n            continue\n        val = dfs(v, u)\n        if val > max1:\n            max2 = max1\n            max1 = val\n        elif val > max2:\n            max2 = val\n    paths[u] = max1 + max2 + 1\n    return max1 + 1\n\nn, m = map(int, input().split())\ng = defaultdict(list)\nfor i in range(m):\n    a, b = map(int, input().split())\n    g[a].append(b)\n    g[b].append(a)\n\npaths = [0] * (n+1)\ndfs(1)\n\nprint(max(paths))"
 ],
 "3065": [
  "from collections import deque\nimport sys\ninput=sys.stdin.readline\n\nN = int(input())\nL = int(input())\nwalk = list(map(int, input().split()))\n\nneighbours = [[] for _ in range(N)]\nfor i in range(N):\n    lst = list(map(int, input().split()))[1:]\n    neighbours[i] = lst\n\ntransitions = [[[1/len(neighbours[i])]*len(neighbours[i]) for _ in range(N)] for __ in range(N)]\n\nfor a in range(N):\n    for b in neighbours[a]:\n        for c in neighbours[b]:\n            transitions[a][c][b] = [1/len(neighbours[b])]*len(neighbours[a])\n\n        if b in neighbours[c]:\n            transitions[a][c][b] = [1 if b == c else 0 for _ in range(len(neighbours[a]))]\n        transitions[a][b][b] = [1 if b == c else 0 for c in neighbours[b]]\n        \n        \n\nstart = walk[0]\nend = walk[-1]\np = [0]*N\np[start] = 1\n\nfor node in walk[:-1]:\n    new_p = [0]*N\n    for i in range(N):\n        for j in range(N):\n            new_p[i] += p[j]*transitions[node][i][j][node == end]\n    p = new_p\n\nprint(\"{:.10f}\".format(p[end]))"
 ],
 "3066": [
  "n = int(input())\ncolors = list(map(int, input().split()))\ncolor_positions = {}\nfor i in range(n):\n    color = colors[i]\n    if color in color_positions:\n        color_positions[color].append(i)\n    else:\n        color_positions[color] = [i]\ninstructions = []\nfor color in sorted(color_positions.keys()):\n    positions = color_positions[color]\n    if len(positions) > len(set(colors[positions[0]:positions[-1]+1])):\n        print(\"IMPOSSIBLE\")\n        break\n    else:\n        instructions.append((positions[0]+1, positions[-1]+1, color))\nelse:\n    print(len(instructions))\n    for instr in instructions:\n        print(\" \".join(map(str, instr)))"
 ],
 "3067": [
  "n = int(input())\nsequences = [list(map(int, input().split()))[1:] for _ in range(n)]\nsolution = []\n\nwhile sum(len(seq) for seq in sequences) > 0:\n    smallest_index = 0\n    for i in range(1, n):\n        if len(sequences[i]) > 0 and (len(sequences[smallest_index]) == 0 or sequences[i][0] < sequences[smallest_index][0]):\n            smallest_index = i\n    solution.append(sequences[smallest_index][0])\n    sequences[smallest_index] = sequences[smallest_index][1:]\n\nprint(*solution)"
 ],
 "3068": [
  "from itertools import combinations\n\nsuspects = set(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n\nn = int(input())\n\nplayer1_info = {s: 0 for s in suspects}\nplayer2_info = {s: 0 for s in suspects}\n\nfor i in range(n):\n  s1, s2, player, reply = input().split()\n  reply = int(reply)\n  \n  if player == \"1\":\n    if reply == 0:\n      player1_info[s1] = -1\n      player1_info[s2] = -1\n    elif reply == 2:\n      player1_info[s1] = 1\n      player1_info[s2] = 1\n  else:\n    if reply == 0:\n      player2_info[s1] = -1\n      player2_info[s2] = -1\n    elif reply == 2:\n      player2_info[s1] = 1\n      player2_info[s2] = 1\n\npossible_suspects = suspects - set(k for k, v in player1_info.items() if v == 1) - set(k for k, v in player2_info.items() if v == 1)\n\ncount = 0\n\nfor combo in combinations(possible_suspects, 3):\n  if all(player1_info[s] != 1 for s in combo) and all(player2_info[s] != 1 for s in combo):\n    count += 1\n\nprint(count)"
 ],
 "3069": [
  "s = input()\n\nleft, right = 0, 0\nfor c in s:\n    if c == '(':\n        left += 1\n    else:\n        if left > 0:\n            left -= 1\n        else:\n            right += 1\n\nif left == 0 and right <= 1:\n    print(\"possible\")\nelse:\n    print(\"impossible\")"
 ],
 "3070": [
  "n, m = map(int, input().split())\n\n# For each starting station, we will keep a list of trains\ntrains = [[] for _ in range(n)]\n\nfor _ in range(m):\n    x, s, t, l = map(int, input().split())\n    trains[x - 1].append((s, t, l))\n\n# We will try to find the earliest start time by checking all possible starting trains\nearliest_start_time = float(\"inf\")\n\nfor train in trains[0]:\n    # We will keep track of the latest arrival time at each station in the current journey\n    current_arrival_times = [train[1] - train[2], train[1]]\n    \n    for i in range(1, n):\n        # We will find the next train that starts after the latest arrival time at the previous station\n        next_train = None\n        for candidate_train in trains[i]:\n            if candidate_train[0] >= current_arrival_times[i - 1]:\n                next_train = candidate_train\n                break\n        \n        # If we couldn't find a suitable train, we can't complete the journey in time\n        if next_train is None:\n            earliest_start_time = \"impossible\"\n            break\n        \n        # Otherwise, we update the latest arrival time at the current station and continue to the next station\n        current_arrival_times.append(max(next_train[1] - next_train[2], current_arrival_times[-1]) + (next_train[1] - next_train[0]))\n    else:\n        # If we successfully reached the last station without exceeding the 30 minute delay, we update the earliest start time\n        earliest_start_time = min(earliest_start_time, train[0] - (current_arrival_times[-1] - train[1]))\n    \nprint(earliest_start_time)"
 ],
 "3071": [
  "n, m = map(int, input().split())\nif m % 2:\n  m += 1\nteams = list(range(m))\nfor i in range(m-1):\n  mid = m // 2\n  l1 = teams[:mid]\n  l2 = teams[mid:]\n  l2.reverse()\n  round = []\n  for j in range(mid):\n    t1 = l1[j]\n    t2 = l2[j]\n    for k in range(n):\n      round.append(f\"{chr(t1+65)}{k+1}-{chr(t2+65)}{k+1+n*(t1%2==t2%2)}\")\n  print(\" \".join(round))\n  teams = [teams[0]] + [teams[-1]] + teams[1:-1]"
 ],
 "3072": [
  "R, C = map(int, input().split())\napartment = [input() for _ in range(R)]\n\ncount = 0\nfor i in range(R):\n    for j in range(C):\n        if apartment[i][j] == '.':\n            # check for table placement\n            if i == 0 or i == R-1 or j == 0 or j == C-1:\n                count += 2\n            else:\n                count += 4\n\nprint(count)"
 ],
 "3073": [
  "import heapq\n\n# Reading input\nn = int(input())\ncards = []\nfor _ in range(n):\n    r, c, a, b, p = map(int, input().split())\n    cards.append((r, c, a, b, p))\n\n# Creating adjacency list\nadj_list = {}\nfor i, card in enumerate(cards):\n    adj_list[i] = []\n    for j, next_card in enumerate(cards):\n        if i == j:\n            continue\n        dist = abs(next_card[0] - card[0]) + abs(next_card[1] - card[1])\n        if dist == abs(card[2] - next_card[2]) + abs(card[3] - next_card[3]):\n            adj_list[i].append((j, next_card[4]))\n\n# Dijkstra's Algorithm\npq = [(0, 0)]\ndist = [float('inf')] * n\ndist[0] = 0\nwhile pq:\n    cost, u = heapq.heappop(pq)\n    if u == n-1:\n        print(cost)\n        break\n    if cost > dist[u]:\n        continue\n    for v, price in adj_list[u]:\n        if dist[v] > cost + price:\n            dist[v] = cost + price\n            heapq.heappush(pq, (dist[v], v))\nelse:\n    print(-1)"
 ],
 "3074": [
  "MOD = 10**9 + 7\n\nn = int(input().strip())\ns = input().strip()\n\ndp = [0] * 3\ndp[0] = 1\n\nans = 0\nfor c in s:\n    if c == '0':\n        dp = [x*3 for x in dp]\n    else:\n        x = int(c)\n        dp = [(dp[(j-x)%3] + dp[j]) % MOD for j in range(3)]\n    ans += dp[0]\n\nprint(ans%MOD)"
 ],
 "3075": [
  "n, g = map(int, input().split())\nstations = []\nfor i in range(n):\n    d, c = map(int, input().split())\n    stations.append((d, c))\n\nfuel = g\ncost = prev = idx = 0\npq = []\nwhile True:\n    while idx < n and stations[idx][0] - stations[prev][0] <= fuel:\n        heappush(pq, stations[idx][1])\n        idx += 1\n    if idx == n:\n        cost += (fuel - stations[-1][0] + 0.0) / g * stations[-1][1]\n        print('%.0f' % cost)\n        break\n    if not pq:\n        print('cancel road trip')\n        break\n    cheapest = heappop(pq)\n    buy = min(g - fuel, (stations[idx][0] - stations[prev][0]) / (0.0 + g))\n    cost += buy * cheapest\n    fuel -= buy * g\n    prev = idx"
 ],
 "3076": [
  "from bisect import bisect_right\n\nn, k = map(int, input().split())\njewels = [(0, 0)] + [tuple(map(int, input().split())) for _ in range(n)]\n\ndp = [0] * (k+1)\nfor i in range(1, n+1):\n    size, value = jewels[i]\n    for j in range(k, size-1, -1):\n        dp[j] = max(dp[j], dp[j-size] + value)\n\nfor i in range(1, k+1):\n    dp[i] += dp[i-1]\n\nans = [0] * k\nfor i in range(1, k+1):\n    pos = bisect_right(dp, dp[i-1])\n    ans[i-1] = pos * dp[i-1] - dp[pos-1]\n\nprint(\" \".join(map(str, ans)))"
 ],
 "3077": [
  "import math\n\ndef canAttack(x, y, village_list, r):\n    \"\"\"Checks if Liam can attack at (x, y) without hitting any of his villages.\"\"\"\n    for village in village_list:\n        d = math.sqrt((village[0]-x)**2 + (village[1]-y)**2)\n        if d < r or d-village[2] < r: # check if the distance between (x,y) and village is less than r, or if the village lies inside the attack area\n            return False\n    return True\n\n# input\nn, m, r = map(int, input().split())\nvillage_list = [list(map(int, input().split())) for i in range(n)]\nminion_list = [list(map(int, input().split())) for i in range(m)]\n\n# loop over all possible attack centers\nmax_kills = 0\nfor x in range(-20000, 20001):\n    for y in range(-20000, 20001):\n        kills = 0\n        for minion in minion_list:\n            d = math.sqrt((minion[0]-x)**2 + (minion[1]-y)**2) # distance between attack center and minion\n            if d <= r and canAttack(x, y, village_list, d): # check if minion is inside attack area and Liam can attack without hitting any of his villages\n                kills += 1\n        max_kills = max(max_kills, kills)\n\n# output\nprint(max_kills)"
 ],
 "3078": [
  "n, s = map(int, input().split())\na = [int(input()) for _ in range(n)]\nleft_sum = [0] * n\nright_sum = [0] * n\nleft = right = 0\n\nfor i in range(n):\n    left_sum[i] = left\n    left += a[i]\n    if i >= n // 2:\n        right_sum[i] = right\n        right += a[i]\n\nfor i in range(n):\n    low = 0\n    high = n // 2\n    ans = 0\n    while low <= high:\n        mid = (low + high + 1) // 2\n        l = i - mid\n        r = i + mid - 1\n        if r >= n or l < 0:\n            high = mid - 1\n            continue\n        if left_sum[r] - left_sum[l] + a[l] <= s and right_sum[l] - right_sum[r] + a[r] <= s:\n            ans = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    print(ans)"
 ],
 "3079": [
  "n = int(input())\nseq = list(input().strip())\nslavko_seq = []\n\nwhile len(seq) > 0:\n    if len(seq) == 1:\n        slavko_seq.append(seq.pop(0))\n    else:\n        left, right = seq[0], seq[-1]\n        if left < right:\n            slavko_seq.append(seq.pop())\n        else:\n            slavko_seq.append(seq.pop(0))\n\nslavko_word = ''.join(slavko_seq)\nmirko_word = ''.join(seq)\n\nif slavko_word < mirko_word:\n    print(\"DA\")\n    print(slavko_word)\nelse:\n    print(\"NE\")"
 ],
 "3080": [
  "# Standard Input Reading\nn, m, q = map(int, input().split())\n\n# Dictionary for saving graph\ngraph = {i+1: set() for i in range(n)}\n\n# Reading all edges in the form of `x y`\nfor i in range(m):\n    x, y = map(int, input().split())\n    graph[x].add(y)\n\n# DFS to calculate same ski paths for all areas\ndp = [set() for _ in range(n+1)]\ndp[1].add(1)\n\nfor i in range(1, n+1):\n\n    for j in graph[i]:\n        dp[j].update(dp[i])\n\n# Reading queries\nfor i in range(q):\n\n    k, a, *areas = map(int, input().split())\n    favorite = set(areas)\n\n    # Checking if required area is in the same ski path\n    # If yes, increment count because all snack of this\n    # guest can be at nodes on the same path\n    count = 0\n    for node in dp[1]:\n        can_have_favorite = True\n        snack_stands = set()\n\n        # Check that snack of this visitor is unique\n        # in all favourite areas\n        for area in favorite:\n\n            can_have_obj = False\n\n            for j in dp[area]-dp[node]:\n                if j not in snack_stands:\n                    snack_stands.add(j)\n                    can_have_obj = True\n                    break\n\n            can_have_favorite &= can_have_obj\n\n        # If all favourite areas can have snack counters\n        # with this snack stand, increment the count\n        if can_have_favorite and len(snack_stands) == k:\n            count += 1\n\n    print(count)"
 ],
 "3081": [
  "import heapq\n\nn, m = map(int, input().split())\ninspect = list(map(int, input().split()))\n\nINF = float('inf')\ndist = [[0 if i == j else INF for i in range(n)] for j in range(n)]\nfor i in range(n):\n    dist[i] = list(map(int, input().split()))\n\nflight_times = []\nfor _ in range(m):\n    s, f, t = map(int, input().split())\n    flight_times.append((s-1, f-1, t))\n\nflight_times.sort(key=lambda x: x[2])\nheap = []\nplanes = 0\nfor s, f, t in flight_times:\n    while heap and heap[0][0] <= t:\n        temp, end = heapq.heappop(heap)\n        planes += 1\n        if end > t:\n            heapq.heappush(heap, (temp, end))\n            break\n    else:\n        if not heap:\n            planes += 1\n\n    if heap:\n        temp, end = heapq.heappop(heap)\n        heapq.heappush(heap, (max(temp, dist[end][f]+t) + inspect[f], f))\n    heapq.heappush(heap, (dist[s][f]+inspect[f]+t, f))\n\nprint(planes + len(heap))"
 ],
 "3082": [
  "import sys\n\nd, target_w = map(int, input().split())\n\ndishes = []\n\nfor i in range(d):\n    temp = input().split()\n    if temp[0] == 'D':\n        dishes.append(('D', int(temp[1]), int(temp[2]), int(temp[3])))\n    else:\n        dishes.append(('C', int(temp[1]), int(temp[2])))\n\n\ndef T(w):\n    if w < 0:\n        return float('-inf')\n    best_tasti = 0\n    for dish in dishes:\n        dish_type, t, dt = dish[0], dish[1], dish[-1]\n        if dish_type == 'D':\n            pieces = w // dish[1]\n            temp = (2 * t + (pieces - 1) * (-1 * dt)) * pieces // 2\n            best_tasti += max(0, temp)\n        else:\n            lo, hi = 0, w\n            for _ in range(100):\n                m1 = lo + (hi - lo) / 3\n                m2 = hi - (hi - lo) / 3\n                score1 = (t * m1 - dt * m1 * m1 / 2)\n                score2 = (t * m2 - dt * m2 * m2 / 2)\n                if score1 > score2:\n                    hi = m2\n                else:\n                    lo = m1\n            best_tasti += max(0, (score1 + score2) / 2 * (hi - lo))\n    return best_tasti\n\ndef ternary_search(lo,hi):\n    for _ in range(100):\n        m1 = lo + (hi - lo) / 3\n        m2 = hi - (hi - lo) / 3\n        if T(m1) > T(m2):\n            hi = m2\n        else:\n            lo = m1\n    res = T((lo + hi) / 2)\n    return res\n\nres = ternary_search(0, target_w)\n\nif res > 0:\n    print(round(res, 9))\nelse:\n    print('impossible')"
 ],
 "3083": [
  "n = int(input().strip())\n\n# Build graph\ngraph = {i: [] for i in range(1, n+1)}\nfor i in range(1, n+1):\n    artist, t, *s = input().split()\n    s = list(map(int, s))\n    for j in s:\n        graph[i].append(j)\n\n# Check all possible playlists\ndef check_playlist(playlists, current_playlist):\n    if len(current_playlist) == 9:\n        playlists.append(current_playlist[:])\n        return\n    for song in graph[current_playlist[-1]]:\n        if all(song not in p for p in playlists) and all(song != p for p in current_playlist):\n            current_playlist.append(song)\n            check_playlist(playlists, current_playlist)\n            current_playlist.pop()\n\nplaylists = []\nfor i in range(1, n+1):\n    check_playlist(playlists, [i])\n\n# Print valid playlist or fail\nvalid_playlists = [p for p in playlists if len(set([graph[p[i]][j-1] for i in range(8) for j in range(min(len(graph[p[i]]), len(graph[p[i+1]])))]) == 8]\nif valid_playlists:\n    print(' '.join(map(str, valid_playlists[0])))\nelse:\n    print('fail')"
 ],
 "3084": [
  "from collections import deque\n\n# Utility function to get all the neighboring valid times\ndef get_neighbors(time):\n    neighbors = []\n    # Clock digit positions\n    positions = [(0, 1), (1, 0), (2, 0), (3, 0)]\n    # Iterate over each position\n    for pos in positions:\n        neighbor_time = list(time)\n        # Increase digit\n        if neighbor_time[pos[0]] != '9':\n            neighbor_time[pos[0]] = str((int(neighbor_time[pos[0]]) + 1) % 10)\n            # If new time is valid, add to neighbors\n            if int(''.join(neighbor_time[:2])) <= 23 and int(''.join(neighbor_time[2:])) <= 59:\n                neighbors.append(''.join(neighbor_time))\n        # Decrease digit\n        if neighbor_time[pos[0]] != '0':\n            neighbor_time = list(time)\n            neighbor_time[pos[0]] = str((int(neighbor_time[pos[0]]) - 1) % 10)\n            # If new time is valid and not already present, add to neighbors\n            if int(''.join(neighbor_time[:2])) <= 23 and int(''.join(neighbor_time[2:])) <= 59 and ''.join(neighbor_time) not in neighbors:\n                neighbors.append(''.join(neighbor_time))\n    return neighbors\n\n# Read input\nt1 = input().strip()\nt2 = input().strip()\n\n# Breadth-first search to find all valid times\nvisited = set()\nqueue = deque([t1])\nwhile queue:\n    curr_time = queue.popleft()\n    # If we have already visited this time, skip it\n    if curr_time in visited:\n        continue\n    visited.add(curr_time)\n    # If we have reached the target time, break out of loop\n    if curr_time == t2:\n        break\n    # Add all neighboring valid times to queue\n    for neighbor_time in get_neighbors(curr_time):\n        if neighbor_time not in visited:\n            queue.append(neighbor_time)\n\n# Output results\nprint(len(visited))\nfor time in visited:\n    print(t1)\n    print(time)"
 ],
 "3085": [
  "s = input()\n\nstack = []\nheader = {}\n\nfor i, c in enumerate(s):\n    if c == '(':\n        stack.append(i)\n    else:\n        j = stack.pop()\n        header[j] = i\n        \n        if j-1 in header and header[j-1] == j+1:\n            header[j-1] = i\n\nres = ''\n\nfor start in sorted(header):\n    if start not in header:\n        continue\n    end = header[start]\n    res += f\"{start+len(str(start))},{end+len(str(end))}:\"\n    del header[start:end+1]\n\nprint(res)"
 ],
 "3086": [
  "n, m = map(int, input().split())\n#initialize start times\nstart_days = []\nstart_months = []\n\n#initialize end times\nend_days = []\nend_months = []\n\n#initialize frequency of events\nevents = [0] * m\n\nfor i in range(n):\n    data = list(map(int, input().split()))\n    start_days.append(data[0])\n    start_months.append(data[1])\n    end_days.append(data[2])\n    end_months.append(data[3])\n    events = [events[j]+data[4+j] for j in range(m)]\n\nMAX_DAYS = 365\nMAX_TRIES = 10*MAX_DAYS\n\nfound = False\nfor event_duration in range(1, MAX_DAYS+1):\n    possible = True\n    for k in range(n):\n        # Calculating days difference starting and ending of the event\n        start_day = start_days[k]\n        start_month = start_months[k]\n        end_day = end_days[k]\n        end_month = end_months[k]\n        duration = 0\n        while start_month != end_month or start_day != end_day:\n            start_day += 1\n            duration += 1\n            #if it is a new month\n            if start_day > days_in_month[start_month]:\n                start_day = 1\n                start_month += 1\n            #if it is a new year\n            if start_month > 12:\n                start_month = 1\n            if duration > MAX_TRIES:\n                possible = False\n                break\n        if duration % event_duration != 0:\n            possible = False\n            break\n    if possible:\n        #if there is any duration possible with the given data\n        found = True\n        result = [event_duration for i in range(m)]\n        break\nif found:\n    print(\" \".join(map(str, result)))\nelse:\n    print(-1)"
 ],
 "3087": [
  "n,k=map(int,input().split())\na=[0]+list(map(int,input().split()))\nans=[0]*(n+1)\nf=[0]*(n+1)\nd=1\nfor i in range(1,n+1):\n    if f[i]:\n        continue\n    x,y=i,a[i]\n    while f[x]==0:\n        f[x]=d\n        x=a[x]\n        y=a[y]\n        f[y]=d\n        y=a[y]\n    d+=1\nfor i in range(1,n+1):\n    if k<f[i]:\n        ans[a[i]]=i\n    elif (k-f[i])%(d-f[i])==0:\n        z=(k-f[i])//(d-f[i])\n        x=i\n        for _ in range(z):\n            x=a[x]\n        ans[a[i]]=x\n    else:\n        continue\n    for j in range(1,n+1):\n        if ans[j]==0:\n            ans[j]=a[j]\n    print (*ans[1:])\n    exit(0)\nprint(\"Impossible\")"
 ],
 "3088": [
  "n, k = input().split()\nn = list(n)\nk = int(k)\n\nfor i in range(len(n)):\n    if k == 0:\n        break\n    max_digit = max(n[i:])\n    if max_digit > n[i]:\n        max_index = n[i:].index(max_digit) + i\n        n[i], n[max_index] = n[max_index], n[i]\n        k -= 1\n\nprint(\"\".join(n))"
 ],
 "3089": [
  "import math\nx, y = [], []\nn, ans = int(input()), 0\nfor i in range(n):\n    xi, yi = map(int, input().split())\n    x.append(xi)\n    y.append(yi)\nfor i in range(n):\n    ans += math.hypot(x[i]-x[(i+1)%n], y[i]-y[(i+1)%n])\nfor i in range(n-2):\n    ans -= 2 * area(x[0], y[0], x[i+1], y[i+1], x[i+2], y[i+2])\nans /= n\nprint(ans)"
 ],
 "3090": [
  "import sys\nfrom heapq import heappush, heappop\n\nINF = sys.maxsize\ndx = [-1, 1, 0, 0]\ndy = [0, 0, -1, 1]\n\n\ndef dijkstra(graph, start):\n    pq = [(0, start)]\n    dist = [INF] * len(graph)\n    dist[start] = 0\n\n    while pq:\n        d, u = heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, w in graph[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                heappush(pq, (dist[v], v))\n\n    return dist\n\n\nn, m, k = map(int, input().split())\ncosts = []\nfor _ in range(n):\n    row = list(map(int, input().split()))\n    costs.append(row)\n\ngraph = [[] for _ in range(n * m)]\n\nfor i in range(n):\n    for j in range(m):\n        u = i * m + j\n        for d in range(4):\n            ni = i + dx[d]\n            nj = j + dy[d]\n            if ni < 0 or ni >= n or nj < 0 or nj >= m:\n                continue\n            v = ni * m + nj\n            if costs[i][j] == 0 or costs[ni][nj] == 0:\n                graph[u].append((v, k))\n            else:\n                graph[u].append((v, costs[i][j] + costs[ni][nj]))\n\ntotal_cost = 0\nfor i in range(n * m):\n    dist = dijkstra(graph, i)\n    for d in range(4):\n        ni = (i // m) + dx[d]\n        nj = (i % m) + dy[d]\n        if ni < 0 or ni >= n or nj < 0 or nj >= m:\n            continue\n        v = ni * m + nj\n        if dist[v] == INF:\n            total_cost += k\n            break\n\nprint(total_cost)"
 ],
 "3091": [
  "n, m, t, op = input().split()\nn, m, t = int(n), int(m), int(t)\nsquares = []\nfor i in range(m):\n    r, c = map(int, input().split())\n    squares.append((r, c))\n\nops = {'+': lambda x, y: x + y,\n       '-': lambda x, y: x - y,\n       '*': lambda x, y: x * y,\n       '/': lambda x, y: x / y if x % y == 0 else None}\n\ndef dfs(idx, total, used):\n    if idx == m:\n        return 1 if total == t else 0\n    ans = 0\n    for num in range(1, n+1):\n        if num in used:\n            continue\n        new_total = ops[op](total, num) if idx > 0 else num\n        ans += dfs(idx + 1, new_total, used | {num})\n    return ans\n\nprint(dfs(0, 0, set()))"
 ],
 "3092": [
  "import heapq\n\nMOD = 10**9 + 7\n\nclass Edge:\n    def __init__(self, dest, weight, idx):\n        self.dest = dest\n        self.weight = weight\n        self.idx = idx\n\n\nN, M = map(int, input().split())\ngraph = [[] for _ in range(N)]\nedges = []\nfor i in range(M):\n    a, b, w = map(int, input().split())\n    edges.append((a-1, b-1, w))\n    graph[a-1].append(Edge(b, w, i))\n    \ndef dijkstra(start):\n    dist = [float('inf') for _ in range(N)]\n    cnt = [0 for _ in range(N)]\n    dist[start] = 0\n    cnt[start] = 1\n    heap = [(0, start)]\n    while heap:\n        d, u = heapq.heappop(heap)\n        if dist[u] < d:\n            continue\n        for edge in graph[u]:\n            v = edge.dest\n            new_dist = dist[u] + edge.weight\n            if dist[v] < new_dist:\n                continue\n            if dist[v] == new_dist:\n                cnt[v] = (cnt[v] + cnt[u]) % MOD\n            else:\n                dist[v] = new_dist\n                cnt[v] = (cnt[u]) % MOD\n            heapq.heappush(heap,(dist[v], v))\n                \nfor a, b, w in edges:\n    dijkstra(a)\n    print(sum(cnt[b] for b in range(N) if dist[b] == dist[b]) % MOD)"
 ],
 "3093": [
  "mod = 1000000007\nn, k = map(int, input().split())\nf = list(map(int, input().split()))\nused = [0] * n\ncycles = []\nfor i in range(n):\n    if used[i]:\n        continue\n    length = 0\n    j = i\n    while not used[j]:\n        used[j] = 1\n        length += 1\n        j = f[j]-1\n    if length > 0:\n        cycles.append(length)\n\nans = 1\nfor cycle in cycles:\n    ans = ans * pow(k, cycle, mod) % mod\nans = ans * pow(k, n-sum(cycles), mod) % mod\nprint(ans)"
 ],
 "3094": [
  "MOD = int(1e9)+7\n\nn = int(input())\nt = list(map(int, input().split()))\n\ncycles = []\nvis = [0]*n\nfor i in range(n):\n    if not vis[i]:\n        cycle = []\n        vis[i] = 1\n        j = t[i]-1\n        cycle.append(i)\n        while not vis[j]:\n            cycle.append(j)\n            vis[j] = 1\n            j = t[j]-1\n        cycles.append(sorted(cycle))\n\nans = 1\nfor cycle in cycles:\n    l = len(cycle)\n    ans *= pow(2,l-2,MOD)\n    ans %= MOD\n\nprint(ans)"
 ],
 "3095": [
  "from itertools import accumulate\n\nR, C = map(int, input().split())\nA = [list(map(int, input().split())) for _ in range(R)]\n\n# function to check if a matrix is cool\ndef is_cool(matrix):\n    r, c = len(matrix), len(matrix[0])\n    return A[0][0] + A[r-1][c-1] <= A[0][c-1] + A[r-1][0]\n\n# function to calculate prefix sums along rows and columns\ndef prefix_sums(matrix):\n    row_sums = [list(accumulate(row)) for row in matrix]\n    col_sums = [list(accumulate(col)) for col in zip(*matrix)]\n    return row_sums, col_sums\n\n# function to calculate sum of a submatrix using prefix sums\ndef submatrix_sum(row_sums, col_sums, r1, c1, r2, c2):\n    return row_sums[r2][c2] - row_sums[r2][c1-1] - row_sums[r1-1][c2] + row_sums[r1-1][c1-1] \\\n           + col_sums[c2][r2] - col_sums[c1-1][r2] - col_sums[c2][r1-1] + col_sums[c1-1][r1-1]\n\n# calculate prefix sums for the input matrix\nrow_sums, col_sums = prefix_sums(A)\n\n# variables to keep track of the largest extremely cool submatrix\nmax_size = 0\nL = min(R, C) # maximum length of a submatrix\nfor l in range(2, L+1):\n    for i in range(R-l+1):\n        for j in range(C-l+1):\n            sub = submatrix_sum(row_sums, col_sums, i+1, j+1, i+l-1, j+l-1)\n            if is_cool([[A[i+x][j+y] for y in range(l)] for x in range(l)]):\n                max_size = max(max_size, l*l)\n\nprint(max_size)"
 ],
 "3096": [
  "from collections import defaultdict,deque\n\nn = int(input())\ntype_of_jokes = [0]+list(map(int, input().split()))\ng = defaultdict(list)\nfor i in range(n-1):\n    parent, child = map(int, input().split())\n    g[parent].append(child)\n\ndef check_consecutive(s):\n    return all(b-a==1 for a,b in zip(s, s[1:]))\n    \ntotal_sets = 0\n\n# consider each node as root\nfor root in range(1,n+1):\n    q = deque([root])\n    jokes_set = {type_of_jokes[root]}\n    visited = {root}\n    \n    while q:\n        curr_node = q.popleft()\n        for child in g[curr_node]:\n            if child not in visited:\n                # check if the joke type in child's company jokes set\n                # are consecutive and not present in current jokes set\n                child_jokes_set = set()\n                child_q = deque([child])\n                while child_q:\n                    child_node = child_q.popleft()\n                    child_jokes_set.add(type_of_jokes[child_node])\n                    for grandchild in g[child_node]:\n                        if grandchild not in visited:\n                            visited.add(grandchild)\n                            child_q.append(grandchild)\n                            \n                if check_consecutive(sorted(child_jokes_set)) and child_jokes_set.isdisjoint(jokes_set):\n                    jokes_set = jokes_set.union(child_jokes_set)\n                    q.append(child)\n                    \n    total_sets += len(jokes_set)\n    \nprint(total_sets)"
 ],
 "3097": [
  "from collections import defaultdict\n\n# function to calculate the value in a cell\ndef get_value(i, j):\n    if j == 1:\n        return i\n    prev = get_value(i, j-1)\n    return prev + int(str(prev)[::-1])\n\n# precompute the counts of all numbers in the table up to 10^10\ncounts = defaultdict(int)\nfor i in range(1, 10006):\n    for j in range(1, 10006):\n        value = get_value(i, j)\n        if value > 10**10:\n            break\n        counts[value] += 1\n\n# process the queries\nq = int(input())\nfor _ in range(q):\n    a, b = map(int, input().split())\n    ans = sum(counts[x] for x in counts if a <= x <= b)\n    print(ans)"
 ],
 "3098": [
  "import math\nn,k = map(int, input().split())\nvertices = []\nfor i in range(n):\n    x,y = map(float, input().split())\n    vertices.append((x,y))\n\ndef area(a:tuple, b:tuple, c:tuple)->float:\n    return abs((b[0]-a[0])*(c[1]-a[1]) - (c[0]-a[0])*(b[1]-a[1])) / 2\n\nans = 0\nfor i in range(n):\n    j, l = (i+1)%n, (i+2)%n\n    \n    while j != i:\n        area_jl = area(vertices[i],vertices[j],vertices[l])\n        area_ikj, area_ikl = [], []\n\n        for idx in range(n):\n            if idx==i or idx==j or idx==l:\n                continue\n            area_ik = area(vertices[i], vertices[k], vertices[idx])\n            if area_ikj:\n                area_ikl.append(area_ikj[-1] - area(idx,vertices[k],vertices[j]))\n            area_ikj.append(area_ik + area(idx,vertices[k],vertices[j]))\n            \n        ans_j = max(area(vertices[i], vertices[j], vertices[k]) + max(area_ikj) + max(area_ikl), area_jl)\n        ans += ans_j\n        \n        j = (j+1)%n\n    \nprint('%.8f' % (ans/(math.comb(n,k))))"
 ],
 "3099": [
  "import queue\nS,E,C=map(int,input().split())    #taking inputs\ngraph=[[] for _ in range(S)]    #initializing a list of S empty sublists\nfor i in range(C):    #for each of the C connections\n    a,b=map(int,input().split())    #take input\n    graph[a].append(b)    #append the connecting node to a's sublist\n\nenemies=list(map(int,input().split()))    #take the list of enemies\nque=queue.Queue()    #initialize a queue\nvisited=[-1]*S    #initialize a list of S -1 (unread) values\nfor en in enemies:    #for each enemy\n    visited[en]=0    #mark their index as visited\n    for connections in graph[en]:    #breadth first search\n        visited[connections]=0   #setting the visited nodes to 0\n        que.put(connections)    #put the nodes to the queue\nwhile que.qsize()!=0:    #if there are nodes present in the queue (doing BFS)\n    actual_node=que.get()    #pop the first element from the queue\n    for connections in graph[actual_node]:    #see all the connections\n        if visited[connections]==-1:    #if the node is not visited\n            visited[connections]=visited[actual_node]+1    #add current node's number with 1\n            que.put(connections)    #put them in the queue\nprint(max(visited)+1)    #print the max of visted values + 1 (because spy is also there) as the result"
 ],
 "3100": [
  "a, c, m = map(int, input().split())\nmod = 10**9+7\n\nif abs(a-c) > 1 or abs(c-m) > 1 or abs(a-m) > 1:\n    print(0)\nelse:\n    if a == c == m:\n        ans = 6\n        for i in range(2, a+1):\n            ans = ans * i % mod\n        print(ans*ans*ans % mod)\n    elif a == c != m:\n        ans = 6\n        for i in range(2, a+1):\n            ans = ans * i % mod\n        print(ans*(a+1)*a//2 % mod)\n    elif a == m != c:\n        ans = 6\n        for i in range(2, a+1):\n            ans = ans * i % mod\n        print(ans*(a+1)*a//2 % mod)\n    elif c == m != a:\n        ans = 6\n        for i in range(2, c+1):\n            ans = ans * i % mod\n        print(ans*(c+1)*c//2 % mod)\n    elif a > c and a > m:\n        ans1, ans2 = 1, 1\n        for i in range(2, a+1):\n            ans1 = ans1 * i % mod\n        for i in range(1, m+c+1):\n            ans2 = ans2 * i % mod\n        print(ans1*ans2 % mod)\n    elif c > a and c > m:\n        ans1, ans2 = 1, 1\n        for i in range(2, c+1):\n            ans1 = ans1 * i % mod\n        for i in range(1, m+a+1):\n            ans2 = ans2 * i % mod\n        print(ans1*ans2 % mod)\n    elif m > a and m > c:\n        ans1, ans2 = 1, 1\n        for i in range(2, m+1):\n            ans1 = ans1 * i % mod\n        for i in range(1, c+a+1):\n            ans2 = ans2 * i % mod\n        print(ans1*ans2 % mod)"
 ],
 "3101": [
  "n = int(input())\na = list(map(int, input().split()))\nfor i in range(1, n):\n    if a[i] < a[i-1]:\n        digits = list(str(a[i]))\n        for j in range(len(digits)):\n            for k in range(10):\n                new_digit = str(k)\n                if new_digit != digits[j]:\n                    new_num = int(str(a[i])[:j] + new_digit + str(a[i])[j+1:])\n                    if new_num >= a[i-1] and (j != 0 or new_digit != \"0\"):\n                        print(\" \".join(map(str, a[:i-1] + [new_num] + a[i:])))\n                        exit()\n        print(\"impossible\")\n        exit()\nprint(\" \".join(map(str, a)))"
 ],
 "3102": [
  "mod = 10**9 + 7\nl, r = input().split()\nn_l, n_r = len(l), len(r)\n\ndp = [[[[0] * 2 for _ in range(2)] for _ in range(2)] for _ in range(n_r+1)]\ndp[0][0][0][0] = 1\n\nfor i in range(n_r):\n    for j in range(2):\n        for k in range(2):\n            for t in range(2):\n                lim = 9 if j else int(r[i])\n                for d in range(lim + 1):\n                    nj = j or d < int(r[i])\n                    nk = k or d == 6\n                    nt = t or d == 8\n                    if d == 4:\n                        continue\n                    dp[i+1][nj][nk][nt] += dp[i][j][k][t]\n                    dp[i+1][nj][nk][nt] %= mod\n\nres = 0\nfor i in range(2):\n    for j in range(2):\n        res += dp[n_r][i][j][i == j]\n        res %= mod\n\nif n_l > 1:\n    dp = [[[[0] * 2 for _ in range(2)] for _ in range(2)] for _ in range(n_l+1)]\n    dp[0][0][0][0] = 1\n\n    for i in range(n_l-1):\n        for j in range(2):\n            for k in range(2):\n                for t in range(2):\n                    lim = 9 if j else int(l[i])\n                    for d in range(lim + 1):\n                        nj = j or d < int(l[i])\n                        nk = k or d == 6\n                        nt = t or d == 8\n                        if d == 4:\n                            continue\n                        dp[i+1][nj][nk][nt] += dp[i][j][k][t]\n                        dp[i+1][nj][nk][nt] %= mod\n\n    for i in range(2):\n        for j in range(2):\n            res -= dp[n_l-1][i][j][i == j]\n            res %= mod\n\nprint(res)"
 ],
 "3103": [
  "MOD = 1000003\n\n\ndef dfs(r, c, north_flag):\n    if r < 0 or r >= Y or c < 0 or c >= X or grid[r][c] == '#' or visited[r][c]:\n        return 0\n    if grid[r][c] == '@':\n        return 1 if not north_flag else 0\n\n    visited[r][c] = True\n    if grid[r][c] in ['>', '<']:\n        move = 1 if grid[r][c] == '>' else -1\n        next_c = c + move\n        while 0 <= next_c < X and grid[r][next_c] == '~':\n            next_c += move\n        res = dfs(r, next_c, False)\n    else:\n        res = dfs(r - 1, c, True)  # go north\n        if not north_flag:\n            res = (res + dfs(r, c + 1, False)) % MOD  # go east\n            res = (res + dfs(r, c - 1, False)) % MOD  # go west\n    visited[r][c] = False\n    return res\n\n\n# read input\nY, X, x_init = map(int, input().split())\ngrid = [input() for _ in range(Y)]\n\n# initialize\nvisited = [[False] * X for _ in range(Y)]\n\n# find the starting column\nfor r in range(Y):\n    if grid[r][x_init] != '#':\n        break\n\n# dfs from the bottom of the grid with north_flag = True\nif dfs(r, x_init, True) == 0:\n    print(\"begin repairs\")\nelse:\n    print(dfs(r, x_init, True))"
 ],
 "3104": [
  "A, S = input().split('=')\nS = int(S)\nN = len(A)\nnums = [int(A[i:N-j]) for i in range(N) for j in range(i+1, N)]\nfor i in range(1, len(nums)):\n    for comb in itertools.combinations(range(len(nums)), i):\n        if sum(nums[j] for j in comb) == S:\n            exp = A[:N-len(str(nums[comb[0]]))]\n            for j in comb:\n                exp += '+' + str(nums[j]).zfill(N-j-1)\n            print(exp + '=' + str(S))\n            exit()"
 ],
 "3105": [
  "n = int(input())\narr = [int(input()) for _ in range(n)]\n\nindices = {}\nfor i in range(n):\n    val = arr[i]\n    if val in indices:\n        indices[val].append(i)\n    else:\n        indices[val] = [i]\n        \na, b, c, d = -1, -1, -1, -1\nfor i in range(n):\n    if arr[i] != a and arr[i] != b:\n        if arr[i] in indices and len(indices[arr[i]]) > 1:\n            x, y = indices[arr[i]]\n            if (a == -1 and b == -1) or (d < x):\n                c, d = x, y\n                a, b = arr[i], arr[c]\n            elif y < d:\n                c, d = x, y\n                a, b = arr[i], arr[c]\n\nif a == -1:\n    print(-1)\nelse:\n    print(a, b)"
 ],
 "3106": [
  "from queue import Queue\n\ndef get_state(s):\n    return tuple(int(i) for i in s)\n\ndef turn_light(n, state, pos):\n    state = list(state)\n    state[pos] = 1 - state[pos]\n    for i in range(1, n - pos):\n        if state[pos + i] == state[pos]:\n            state[pos + i] = 1 - state[pos + i]\n        else:\n            break\n    for i in range(1, pos + 1):\n        if state[pos - i] == state[pos]:\n            state[pos - i] = 1 - state[pos - i]\n        else:\n            break\n    return tuple(state)\n\ndef get_time(s):\n    n = len(s)\n    start = get_state(s)\n    if all(s):\n        return 0 # return 0 if all lights are already on\n    q = Queue()\n    q.put((start, 0))\n    visited = {start}\n    while not q.empty():\n        state, time = q.get()\n        for i in range(n):\n            new_state = turn_light(n, state, i)\n            if new_state not in visited:\n                visited.add(new_state)\n                if all(new_state):\n                    return time + 1\n                else:\n                    q.put((new_state, time + 1))"
 ],
 "3107": [
  "from bisect import bisect_left, bisect_right\n\nN, M = map(int, input().split())\nroutes = []\nmin_start, max_end = 10**9 + 1, -1\nfor i in range(N):\n    k, *cities = map(int, input().split())\n    route = [(city, 2*i+1) for city in cities[1::2]]\n    if cities[0] < cities[1]:\n        route = route[::-1]\n    min_start = min(min_start, route[0][0])\n    max_end = max(max_end, route[-1][0])\n    routes += route\nroutes.sort()\n\nstart_idx, end_idx = [0]*N, [0]*N\nfor i in range(N):\n    idxs = [idx for idx in range(len(routes)) if routes[idx][1] == 2*i+1]\n    start_idx[i], end_idx[i] = idxs[0], idxs[-1]\n\nfor _ in range(M):\n    a, b = map(int, input().split())\n    a, b = a-1, b-1\n    if start_idx[a] > start_idx[b]:\n        a, b = b, a\n        \n    l, r = 0, len(routes)-1\n    while l < r:\n        mid = (l+r)//2\n        if routes[mid][0] >= min_start + end_idx[a][mid] - start_idx[b][mid]:\n            r = mid\n        else:\n            l = mid + 1\n    l_end_idx = n_left = r\n    \n    l, r = 0, len(routes)-1\n    while l < r:\n        mid = (l+r+1)//2\n        if routes[mid][0] <= max_end - start_idx[b][mid] + end_idx[a][mid]:\n            l = mid\n        else:\n            r = mid - 1\n    r_start_idx = r\n    \n    if n_left <= r_start_idx:\n        print(r_start_idx - n_left + 1)\n    else:\n        print(0)"
 ],
 "3108": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\nprefix_sum = [0] * (n + 1)\nfor i in range(1, n + 1):\n    prefix_sum[i] = prefix_sum[i - 1] + a[i - 1]\n\ndef check(mid):\n    for i in range(mid, n + 1):\n        if prefix_sum[i] - prefix_sum[i - mid] >= k * mid:\n            return True\n    return False\n\nleft, right = 1, n\nwhile left < right:\n    mid = (left + right + 1) // 2\n    if check(mid):\n        left = mid\n    else:\n        right = mid - 1\n\nans = format(prefix_sum[left] - k * left, \".6f\")\nprint(ans)"
 ],
 "3109": [
  "from scipy.optimize import minimize_scalar\n\nn, m, w, h = map(int, input().split())\nv = list(map(float, input().split()))\nx = [0] + list(map(float, input().split())) + [w]\nmins = [list(map(float, input().split())) for _ in range(n)]\nmaxs = [list(map(float, input().split())) for _ in range(n)]\n\ndef objective_func(factor):\n    heights = []\n    for i in range(n):\n        section_vol = (x[i+1]-x[i]) * factor * h\n        section_v = [0] * m\n        for j in range(m):\n            section_v[j] = max(mins[i][j], min(maxs[i][j], v[j] * section_vol / sum(v)))\n        heights.append(sum(section_v) / sum(v))\n    return max(heights) - min(heights)\n\nmin_factor = minimize_scalar(lambda x: objective_func(x), bounds=(0, w), method='bounded').x\nmin_heights = []\nfor i in range(n):\n    section_vol = (x[i+1]-x[i]) * min_factor * h\n    section_v = [0] * m\n    for j in range(m):\n        section_v[j] = max(mins[i][j], min(maxs[i][j], v[j] * section_vol / sum(v)))\n    min_heights.append(sum(section_v) / sum(v))\nprint(round(max(min_heights)-min(min_heights), 3))"
 ],
 "3110": [
  "import itertools\n\n# function to check if rules are being followed\ndef checkRules(grid):\n    m, n = len(grid), len(grid[0])\n    for i in range(m):\n        for j in range(n):\n            # check rule for product\n            if i > 0 and j < n-1 and grid[i][j] != 0 and grid[i-1][j] * grid[i][j+1] != grid[i-1][j+1]:\n                return False\n            # check rule for sum\n            if i > 0 and j < n-1 and grid[i][j] != 0 and grid[i-1][j] + grid[i][j+1] != grid[i-1][j+1]:\n                return False\n            # check rule for difference\n            if i > 0 and j < n-1 and grid[i][j] != 0 and (grid[i-1][j] - grid[i][j+1] != grid[i-1][j+1] and grid[i][j+1] - grid[i-1][j] != grid[i-1][j+1]):\n                return False\n            # check rule for quotient\n            if i > 0 and j < n-1 and grid[i][j] != 0 and (grid[i-1][j] / grid[i][j+1] != grid[i-1][j+1] and grid[i][j+1] / grid[i-1][j] != grid[i-1][j+1]):\n                return False\n    return True\n\n# function to generate all possible complete codes\ndef generateCompleteCodes(grid):\n    m, n = len(grid), len(grid[0])\n    digits = \"123456789\"\n    completeCodes = set()\n    for code in itertools.product(digits, repeat=m*n):\n        # ignore codes with repeated digits in any row\n        index = 0\n        valid = True\n        for i in range(m):\n            row = code[index:index+n]\n            if len(set(row)) != n:\n                valid = False\n                break\n            index += n\n        if not valid:\n            continue\n        # fill in known digits in the code\n        index = 0\n        tempGrid = [[0]*n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] != 0:\n                    tempGrid[i][j] = int(grid[i][j])\n                else:\n                    tempGrid[i][j] = int(code[index])\n                    index += 1\n        # check if rules are being followed\n        if checkRules(tempGrid):\n            completeCodes.add(\"\".join(code))\n    return len(completeCodes)\n\n# read input and generate complete codes for each test case\nwhile True:\n    try:\n        m, n = map(int, input().split())\n        grid = [input().split() for _ in range(m)]\n        print(generateCompleteCodes(grid))\n    except:\n        break"
 ],
 "3111": [
  "n, m = map(int, input().split())\ndials = list(map(int, input().strip()))\nsummation = 0\nfor _ in range(m):\n    a, b = map(int, input().split())\n    for i in range(a - 1, b):\n        summation += dials[i]\n    print(summation)\n    for i in range(a - 1, b):\n        dials[i] = (dials[i] + 1) % 10\n    summation = 0"
 ],
 "3112": [
  "from collections import deque, defaultdict\n\ndef bfs(G, s, t, parent):\n    for u in G.keys():\n        parent[u] = None\n    parent[s] = -1\n    queue = deque()\n    queue.append(s)\n    while queue:\n        node = queue.popleft()\n        for neigh in G[node]:\n            if parent[neigh] is None:\n                if neigh == t:\n                    parent[neigh] = node\n                    return True\n                parent[neigh] = node\n                queue.append(neigh)\n    return False\n\nn, k, m = map(int, input().split())\nedges = []\nfor _ in range(m):\n    u, v = map(int, input().split())\n    edges.append((u,v))\none_path = [False]*(n+1)\nfor i in range(1,k+1):\n    visited = [False]*(n+1)\n    visited[i] = True\n    end = i\n    while True:\n        nxt = None\n        for u,v in edges:\n            if u == end and not visited[v]:\n                nxt = v\n                visited[v] = True\n        if nxt is None:\n            break\n        end = nxt\n    if end == n:\n        curr = i\n        while curr != end:\n            one_path[curr] = True\n            for u,v in edges:\n                if v == curr:\n                    curr = u\n                    break\n                \ndef check_num_producers(num):\n    if num == 0:\n        return bfs(G, 1, n, [-1]*(n+1))\n    G = defaultdict(set)\n    for u,v in edges:\n        for i in range(num):\n            if one_path[u] and not one_path[v]:\n                u, v = v, u\n            elif not one_path[u] and one_path[v]:\n                pass\n            else: # both on path or both not on path\n                G[(u,i)].add((v,i))\n                G[(v,i)].add((u,i))\n    parent = [-1]*(n+1)\n    while bfs(G, (1,0), (n,0), parent):\n        flow = float('inf')\n        v = (n, 0)\n        while v != (1, 0):\n            u = parent[v]\n            flow = min(flow, len(G[u]) - G[u].index(v) - 1)\n            v = u\n        v = (n, 0)\n        while v != (1, 0):\n            u = parent[v]\n            G[u].remove(v)\n            G[v].add(u)\n            v = u\n        if flow == float('inf'):\n            break\n    return len(G[(1,0)]) == 0\n\nlo, hi = 0, k\nwhile lo < hi:\n    mid = (lo+hi+1)//2\n    if check_num_producers(mid):\n        lo = mid\n    else:\n        hi = mid-1\nprint(lo)"
 ],
 "3113": [
  "from collections import defaultdict\n\nn = int(input())\ngarry = []\nfor i in range(n):\n    x1, y1, x2, y2, x3, y3 = map(int, input().split())\n    garry.append(((x1, y1), (x2, y2), (x3, y3)))\n\nm = int(input())\njerry = []\nfor i in range(m):\n    x1, y1, x2, y2, x3, y3 = map(int, input().split())\n    jerry.append(((x1, y1), (x2, y2), (x3, y3)))\n\ndef sort_vertices(t:tuple):\n    return tuple(sorted(t))\n\ngarry_dict = defaultdict(int)\nfor triangle in garry:\n    triangle = [sort_vertices(t) for t in triangle]\n    triangle = tuple(sorted(triangle))\n    garry_dict[triangle] += 1\n\njerry_dict = defaultdict(int)\nfor triangle in jerry:\n    triangle = [sort_vertices(t) for t in triangle]\n    triangle = tuple(sorted(triangle))\n    jerry_dict[triangle] += 1\n\nif garry_dict == jerry_dict:\n    print('yes')\nelse:\n    print('no')"
 ],
 "3114": [
  "from collections import deque\n\ndef topological_sort(graph):\n    n = len(graph)\n    in_degrees = [0] * n\n    \n    # get in-degrees\n    for u in range(n):\n        for v in graph[u]:\n            in_degrees[v] += 1\n    \n    # initialize queue with nodes with in-degree 0\n    queue = deque([u for u in range(n) if in_degrees[u] == 0])\n    \n    order = []\n    \n    # perform topological sorting\n    while queue:\n        u = queue.popleft()\n        order.append(u)\n        for v in graph[u]:\n            in_degrees[v] -= 1\n            if in_degrees[v] == 0:\n                queue.append(v)\n    \n    # check if all nodes were visited\n    if len(order) != n:\n        return None\n    \n    return order\n\n# read input\nn, m = map(int, input().split())\n\n# build undirected graph\ngraph = [[] for _ in range(n)]\nfor i in range(m):\n    u, v = map(int, input().split())\n    u -= 1\n    v -= 1\n    graph[u].append(v)\n    graph[v].append(u)\n\n# perform topological sort\norder = topological_sort(graph)\n\nif order is None:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    for u in range(n):\n        for v in graph[u]:\n            if order.index(u) < order.index(v):\n                print(u+1, v+1)"
 ],
 "3115": [
  "n, m = map(int, input().split())\nwins = [set() for _ in range(n)]\ndraws = [set() for _ in range(n)]\nfor i in range(m):\n    a, op, b = input().split()\n    a, b = int(a), int(b)\n    if op == \"=\":\n        draws[a].add(b)\n        draws[b].add(a)\n    else:\n        wins[a].add(b)\ndef inconsistent(a, b):\n    return (a in wins[b]) or (b in wins[a]) or \\\n           any([len(wins[a] & wins[x]) > 0 and len(draws[b] & wins[x]) > 0 for x in draws[a]]) or \\\n           any([len(wins[b] & wins[x]) > 0 and len(draws[a] & wins[x]) > 0 for x in draws[b]])\nif any([inconsistent(i, j) for i in range(n) for j in range(i + 1, n)]):\n    print(\"inconsistent\")\nelse:\n    print(\"consistent\")"
 ],
 "3116": [
  "`import math`\n\n`def cylinder_volume(points):\n    def get_normal(p1, p2, p3):\n        v1 = [p2[i] - p1[i] for i in range(3)]\n        v2 = [p3[i] - p1[i] for i in range(3)]\n        nx = v1[1]*v2[2] - v1[2]*v2[1]\n        ny = v1[2]*v2[0] - v1[0]*v2[2]\n        nz = v1[0]*v2[1] - v1[1]*v2[0]\n        mag = math.sqrt(nx**2 + ny**2 + nz**2)\n        return [i/mag for i in [nx, ny, nz]]\n\n    def get_diameter(p1, p2):\n        return math.sqrt((p1[0]-p2[0])**2 + (p1[1]-p2[1])**2 + (p1[2]-p2[2])**2)\n\n    def get_center(p1, p2, p3):\n        normal = get_normal(p1, p2, p3)\n        sum_x = sum_y = sum_z = 0\n        for p in [p1, p2, p3]:\n            sum_x += p[0]\n            sum_y += p[1]\n            sum_z += p[2]\n        centroid = [sum_x/3.0, sum_y/3.0, sum_z/3.0]\n        d = normal[0]*centroid[0] + normal[1]*centroid[1] + normal[2]*centroid[2]\n        return normal, centroid, d\n\n    def get_plane(p1, p2, p3):\n        normal, centroid, d = get_center(p1, p2, p3)\n        return normal[0], normal[1], normal[2], d\n\n    def get_furthest_candidate(points, plane):\n        max_distance, furthest_point = -1, None\n        a, b, c, d = plane\n        for p in points:\n            distance = abs(a*p[0] + b*p[1] + c*p[2] - d)\n            if distance > max_distance:\n                max_distance, furthest_point = distance, p\n        return furthest_point\n\n    def get_cylinder(p1, p2, p3):\n        plane = get_plane(p1, p2, p3)\n        p4 = get_furthest_candidate(points, plane)\n        center = get_center(p1, p2, p3)[1]\n        radius = get_diameter(center, p4)/2.0\n        height = get_diameter(p1, p2)\n        return math.pi*radius*radius*height\n\n    points = [list(map(int, input().split())) for _ in range(n)]\n    combinations = [[points[i], points[j], points[k]] for i in range(n)\n                                                      for j in range(i+1, n)\n                                                      for k in range(j+1, n)]\n    return min([get_cylinder(*combination) for combination in combinations])`"
 ],
 "3117": [
  "L = int(input())\nstring = input()\nmax_length = 0\nfor i in range(L):\n    for j in range(i + 1, L):\n        if string[i:j] in string[j:]:\n            max_length = max(max_length, j - i)\nprint(max_length)"
 ],
 "3118": [
  "n=int(input())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\nx=sorted(list(range(1,n+1)),key=lambda i:a[b[i-1]-1])\ny=sorted(list(range(1,n+1)),key=lambda i:b[a[i-1]-1])\nif x==y:\n    print(1)\nelse:\n    cnt=0\n    while True:\n        cnt+=1\n        x=[y[i-1] for i in a]\n        if cnt==10**12:\n            print('huge')\n            break\n        if x==y:\n            print(cnt+1)\n            break\n        y=[x[i-1] for i in b]\n        if cnt==10**12:\n            print('huge')\n            break\n        if x==y:\n            print(cnt+1)\n            break"
 ],
 "3119": [
  "from heapq import heappush, heappop\nn, p = map(int, input().split())\nt = list(map(int, input().split()))\ns = []\ne = []\nfor i in range(p):\n    start, end = map(int, input().split())\n    s.append(start)\n    e.append(end)\n\ndp = [0] * (n+1)\nj = 0\nh = []\nfor i in range(n):\n    while j < p and s[j] <= t[i]:\n        heappush(h, -e[j])\n        j += 1\n\n    if h:\n        val = -h[0]\n        if val > t[i]:\n            dp[i+1] = dp[i] + 2\n            continue\n\n    dp[i+1] = max(dp[i] + 1, dp[i-1] + 2) # option 1\n    dp[i+1] = max(dp[i+1], dp[i-2] + 2) # option 2\n\nprint(dp[n])"
 ],
 "3120": [
  "from collections import deque\nfrom random import shuffle as rd_shuffle\n\ndef execute(program: str, L: list):\n    stack = deque()\n    cur = []\n    i = 0\n    while i < len(program):\n        if program[i].isdigit():\n            j = i\n            while j < len(program) and program[j].isdigit():\n                j += 1\n            x = int(program[i:j])\n            cur.append(x)\n            i = j\n        elif program[i] == \"[\":\n            cur.append(\"[\")\n            i += 1\n        elif program[i] == \"]\":\n            cur.append(\"]\")\n            stack.append(cur)\n            cur = []\n            i += 1\n        elif program[i:i + 6] == \"concat\":\n            stack.append(\"concat\")\n            i += 6\n        elif program[i:i + 6] == \"shuffle\":\n            stack.append(\"shuffle\")\n            i += 7\n        elif program[i:i + 6] == \"sorted\":\n            stack.append(\"sorted\")\n            i += 6\n        elif program[i] == \")\":\n            op = stack.pop()\n            if op == \"concat\":\n                x = stack.pop()\n                y = stack.pop()\n                res = y + x\n                stack.append(res)\n            elif op == \"shuffle\":\n                x = stack.pop()\n                res = list(x)\n                rd_shuffle(res)\n                stack.append(res)\n            elif op == \"sorted\":\n                x = stack.pop()\n                res = sorted(x)\n                stack.append(res)\n            elif op == \"[\":\n                stack.append(cur[:])\n                cur = []\n            i += 1\n    return stack.pop() == L\n\nA = input()\nB = input()\n\n# determine whether A and B are equivalent for any possible list of length L\nfor i in range(50):\n    L = [i+1 for i in range(10)]\n    if not execute(A, L) == execute(B, L):\n        print(\"not equal\")\n        exit()\n\nprint(\"equal\")"
 ],
 "3121": [
  "from heapq import heappush, heappop\n\nINF = int(1e18)\n\ndef dijkstra(n, adj, attack, initial_health):\n    \n    dist = [INF] * n\n    dist[0] = initial_health\n    \n    pq = [(dist[0], 0)] # priority queue\n    # (distance, vertex) - keeps track of minimum distance\n    \n    while pq:\n        curr_dist, u = heappop(pq)\n        \n        # unwanted visit\n        if curr_dist != dist[u]:\n            continue\n        \n        # traversing adjacent vertices\n        for v, (enemy_attack, enemy_health) in adj[u]:\n            turns_to_win = (enemy_health + attack - 1) // attack\n            turns_to_lose = (dist[u] + enemy_attack - 1) // enemy_attack\n            \n            if turns_to_win <= turns_to_lose - 1: # winnable\n                if dist[u] + (turns_to_win * enemy_attack) < dist[v]:\n                    dist[v] = dist[u] + (turns_to_win * enemy_attack)\n                    heappush(pq, (dist[v], v))\n    \n    if dist[n-1] == INF:\n        return \"Oh no\"\n    else:\n        return dist[n-1] // attack + (dist[n-1] % attack != 0)\n\nA, H = map(int, input().split())\nn, m = map(int, input().split())\n\n# adjacency list [(vertex, (enemy_attack, enemy_health))]\nadj = [[] for _ in range(n)]\nfor _ in range(m):\n    e, b, a, h = map(int, input().split())\n    adj[e-1].append((b-1, (a, h)))\n\nprint(dijkstra(n, adj, A, H))"
 ],
 "3122": [
  "import sys\nfrom collections import defaultdict\n\nn, m = map(int, input().split())\n\n# Create a graph using a defaultdict\ngraph = defaultdict(list)\nfor i in range(m):\n    a, b, c = map(int, input().split())\n    graph[a].append((b, c))\n    graph[b].append((a, c))\n\n# Use DFS to check if the graph is connected\nvisited = [False] * (n + 1)\ndef dfs(node):\n    visited[node] = True\n    for neighbor, _ in graph[node]:\n        if not visited[neighbor]:\n            dfs(neighbor)\n\ndfs(1)\nif False in visited[1:]:\n    print(\"impossible\")\n    sys.exit()\n\n# Use a greedy approach to assign lounges\nlounge_counts = [0] * (n + 1)\nfor node in graph:\n    num_lounges = sum(count for _, count in graph[node])\n    if num_lounges % 2 == 0:\n        lounge_counts[node] = num_lounges // 2\n        for neighbor, count in graph[node]:\n            lounge_counts[neighbor] = count - lounge_counts[node]\n            if lounge_counts[neighbor] < 0:\n                print(\"impossible\")\n                sys.exit()\n    else:\n        print(\"impossible\")\n        sys.exit()\n\nprint(sum(lounge_counts))"
 ],
 "3123": [
  "n = int(input())\na = list(map(int, input().split()))\n\ncurr_quote = 0\nmax_k = 0\n\nfor i in range(len(a)):\n    if a[i] % 2 == 1:\n        if curr_quote == 0:\n            k = (a[i] - 1) // 2\n            max_k = max(max_k, k)\n        else:\n            if a[i] != curr_quote:\n                print(\"no quotation\")\n                break\n            else:\n                curr_quote = 0\n    else:\n        if curr_quote == 0:\n            print(\"no quotation\")\n            break\n        else:\n            if a[i] != curr_quote - 2:\n                print(\"no quotation\")\n                break\n            else:\n                curr_quote -= 2\nelse:\n    if curr_quote != 0:\n        print(\"no quotation\")\n    else:\n        print(max_k)"
 ],
 "3124": [
  "N = int(input())\nnums = list(map(int, input().split()))\n\ncount = 0\n\nfor i in range(N):\n    odd_count = 0\n    even_count = 0\n    player = 1\n    for j in range(i, i+N):\n        if player == 1:\n            if nums[j%N] % 2 != 0:\n                odd_count += 1\n            else:\n                even_count += 1\n            player = 2\n        elif player == 2:\n            if nums[j%N] % 2 != 0:\n                odd_count += 1\n            else:\n                even_count += 1\n            player = 1\n    if odd_count > even_count:\n        count += 1\n\nprint(count)"
 ],
 "3125": [
  "input_string = input().strip()\noutput_string = input().strip()\n\ndef get_possible_encodings():\n    apostrophe_encoding = []\n    double_quote_encoding = []\n    for i in range(len(input_string)):\n        if input_string[i] == '+':\n            if output_string[i] == '-':\n                return [\"corrupted\"]\n            else:\n                apostrophe_encoding.append(output_string[i])\n        elif input_string[i] == '-':\n            if output_string[i] == '+':\n                return [\"corrupted\"]\n            else:\n                double_quote_encoding.append(output_string[i])\n    if len(apostrophe_encoding) == 0:\n        apostrophe_encoding = [\"<empty>\"]\n    if len(double_quote_encoding) == 0:\n        double_quote_encoding = [\"<empty>\"]\n    if len(apostrophe_encoding) == 1 and len(double_quote_encoding) == 1:\n        return [apostrophe_encoding[0]+\" \"+double_quote_encoding[0]]\n    else:\n        return [\"<any> <any>\"]\n\nprint(\" \".join(get_possible_encodings()))"
 ],
 "3126": [
  "from bisect import bisect_left\nn, t = map(int, input().split())\np = sorted(list(map(int, input().split())))\nd = []\nfor i in range(n):\n    a = []\n    for j in range(i):\n        a.append(p[i] - p[j])\n    d.append([0] + [2**60] * (i))\n    for j in range(1, i+1):\n        k = bisect_left(p, p[j] - d[-1][j])\n        while k < i and p[k+1] - p[j] <= d[-1][j]:\n            k += 1\n        d[-1][j] = p[j] - p[k]\nfor i in range(n - 1):\n    for j in range(n):\n        if p[i] < p[j] < t:\n            d[j].append(p[i] - p[bisect_left(p, p[j] - d[i][j])])\nd.append([0] + [2**60] * (n-1))\nfor i in range(n - 1):\n    d[-1].append(p[-1] - p[i])\nanswer = sum([d[i][-1] for i in range(n)])\nfor _ in range(int(input())):\n    op, pos = input().split()\n    pos = int(pos)\n    if op == \"+\":\n        k = bisect_left(p, pos)\n        i = len(p)\n        p.insert(k, pos)\n        d.insert(k, [])\n        for j in range(k):\n            d[k].append(pos - p[j])\n            d[j].append(p[j] - pos)\n        d[k].append(0)\n        for j in range(k+1, len(p)):\n            d[k].append(p[j] - pos)\n            if j == i:\n                continue\n            d[j].append(p[j] - p[k])\n        d.append([0] * (len(d) - 1) + [2**60])\n        for j in range(len(d) - 2):\n            if j == k:\n                continue\n            if p[j] < pos:\n                d[j].append(pos - p[j])\n            elif p[j] > pos:\n                d[k].append(p[j] - pos)\n            else:\n                d[j].append(0)\n                d[k].append(0)\n    elif op == \"-\":\n        k = bisect_left(p, pos)\n        i = len(p)\n        p.remove(pos)\n        d.pop(k)\n        for j in range(k):\n            d[j].pop(k)\n            d[k - 1].pop(j)\n        d[k - 1].pop(-1)\n        for j in range(k, len(p)):\n            d[j][k-1] = d[k-1][j] = p[j] - p[k-1]\n            if j == i - 1:\n                continue\n            d[k - 1].pop(j)\n            d[j].pop(k - 1)\n        d.pop(-1)\n    else:\n        answer = sum([d[i][bisect_left(p, pos)] for i in range(n)])\n    print(answer)"
 ],
 "3127": [
  "from queue import PriorityQueue\n\ndef get_path(Graph, edge, start, end):\n    # Dijkstra's Algorithm, to get the shortest path\n    pq = PriorityQueue()\n    dist_dict, path_dict = dict(), dict()\n    pq.put(start, 0)\n    dist_dict[start] = 0\n    path_dict[start] = [start]\n    while not pq.empty():\n        curr = pq.get()\n        for next_node, weight in Graph[curr].items():\n            if next_node not in dist_dict or dist_dict[curr] + weight < dist_dict[next_node]:\n                dist_dict[next_node] = dist_dict[curr] + weight\n                path_dict[next_node] = path_dict[curr] + [next_node]\n                pq.put(next_node, dist_dict[next_node])\n    return path_dict.get(end, [])\n\nn, m = map(int, input().split())\nedges = []\nGraph = {i: {} for i in range(1, n+1)}\nfor i in range(m):\n    a, b, length = map(int, input().split())\n    edges.append((a, b, length))\n    Graph[a][b] = length\n    Graph[b][a] = length\n\npath = get_path(Graph, edges, 1, n)\n\nmemo = set(path)\nfor i in range(len(path)-1):\n    a = path[i]\n    b = path[i+1]\n    Graph[a].pop(b)\n    Graph[b].pop(a)\n    new_path = get_path(Graph, edges, 1, n)\n    if len(new_path) > len(path):\n        memo |= set(new_path)\n    Graph[a][b] = edges[i][2]\n    Graph[b][a] = edges[i][2]\n\nans = sorted(list(set(range(1, n+1)) - memo))\nprint(len(ans))\nprint(*ans)"
 ],
 "3128": [
  "class FenwickTree: \n    def __init__(self, n): \n        self.tree = [0] * (n+1) \n\n    def update(self, idx, val): \n        while idx < len(self.tree): \n            self.tree[idx] += val \n            idx += idx & (-idx) \n\n    def query(self, idx): \n        res = 0 \n        while idx > 0: \n            res += self.tree[idx] \n            idx -= idx & (-idx) \n        return res \n\nn = int(input()) \ncreations = [0] * (n+1) \nplots = [0] * (n+1) \ntree = FenwickTree(n) \n\nfor i in range(1, n+1): \n    tree.update(i, 1) \n    creations[i] = i \n    plots[i] = i \n\nc = n \nfor _ in range(n): \n    q, x = map(int, input().split()) \n    if q == 1: \n        plots[x], c = c+1, c+1 \n        creations[c] = x \n        tree.update(c, 1) \n    else: \n        lo, hi = 1, n \n        while lo < hi: \n            mid = (lo + hi) // 2 \n            if tree.query(mid) < x: \n                lo = mid + 1 \n            else: \n                hi = mid \n        print(creations[lo])"
 ],
 "3129": [
  "s = input()\ncount = 0\nfor i in range(len(s)-2):\n    if s[i:i+3] != 'CCC' and 'P' in s[i:i+3]:\n        count += 1\nprint(count)"
 ],
 "3130": [
  "D, M, N = map(int, input().split())\nevidence = set(int(input()) for _ in range(N))\ncauses = {i: set() for i in range(1, D+1)}\nfor _ in range(M):\n    A, B = map(int, input().split())\n    causes[B].add(A)\n\nknown = set()\nwhile True:\n    new_known = set()\n    for event, event_causes in causes.items():\n        if event in known or event in evidence:\n            continue\n        if event_causes.issubset(known):\n            new_known.add(event)\n    if not new_known:\n        break\n    known |= new_known\n\nprint(*sorted(known | evidence))"
 ],
 "3131": [
  "Solution:\n\nn, k = map(int, input().split())\na = sorted(list(map(int, input().split())))\n\nmod = 1000000007\n\nans = 0\nfor i in range(n-k+1):\n    prod = 1\n    for j in range(k):\n        prod = (prod*(a[i+j]%mod))%mod\n    ans = (ans + prod)%mod\n\nprint(ans)"
 ],
 "3132": [
  "R, C = map(int, input().split())\n\ngrid = [input() for _ in range(R)]\n\n# Find the first building\nr1, c1, size1 = None, None, None\nfor i in range(R):\n    for j in range(C):\n        if grid[i][j] == 'x':\n            for size in range(1, min(R-i, C-j)+1):\n                if all(grid[i+k][j+size-1] == 'x' for k in range(size)) and all(grid[i+size-1][j+k] == 'x' for k in range(size)):\n                    r1, c1, size1 = i+1, j+1, size\n                    break\n            if size1:\n                break\n        if size1:\n            break\n\n# Find the second building\nr2, c2, size2 = None, None, None\nfor i in range(R):\n    for j in range(C):\n        if grid[i][j] == 'x' and not (i <= r1-1 < i+size1 and j <= c1-1 < j+size1):\n            for size in range(1, min(R-i, C-j)+1):\n                if all(grid[i+k][j+size-1] == 'x' for k in range(size)) and all(grid[i+size-1][j+k] == 'x' for k in range(size)):\n                    r2, c2, size2 = i+1, j+1, size\n                    break\n            if size2:\n                break\n        if size2:\n            break\n\nprint(f\"{r1} {c1} {size1}\")\nprint(f\"{r2} {c2} {size2}\")"
 ],
 "3133": [
  "n, a, b = map(int, input().split())\na_path = [a]\nb_path = [b]\ngraph = [[] for _ in range(n)]\nfor i in range(n):\n    l, r, t = map(int, input().split())\n    graph[i] = [l, r, t]\nwhile True:\n    if graph[a_path[-1]][2] != graph[b_path[-1]][2]:\n        print(len(a_path) + len(b_path) - 2)\n        break\n    elif graph[a_path[-1]][0] == a_path[-2]:\n        a_path.append(graph[a_path[-1]][1])\n    elif graph[a_path[-1]][1] == a_path[-2]:\n        a_path.append(graph[a_path[-1]][0])\n    elif graph[b_path[-1]][0] == b_path[-2]:\n        b_path.append(graph[b_path[-1]][1])\n    elif graph[b_path[-1]][1] == b_path[-2]:\n        b_path.append(graph[b_path[-1]][0])\n    else:\n        print(\"indistinguishable\")\n        break"
 ],
 "3134": [
  "from itertools import product\n\nR = input().strip()\nC = input().strip()\n\nn, m = len(R), len(C)\n\n# check if it's even possible to have a valid matrix\nif (n % 2 == 1 and R.count('1') % 2 == 1) or (m % 2 == 1 and C.count('1') % 2 == 1):\n    print(\"-1\")\nelse:\n    res = [['0' for _ in range(m)] for __ in range(n)]\n    for i, r in enumerate(R):\n        if r == '0':\n            res[i] = ['1' if c == '1' else '0' for c in C]\n        else:\n            for j, c in enumerate(C):\n                if c == '1':\n                    res[i][j] = '1'\n                    \n    # check all possible variations to maximize number of ones\n    variations = []\n    for row in res:\n        variations.append(row)\n        variations.append(['1' if c == '0' else '0' for c in row])\n    best_variation = None\n    max_ones = -1\n    for v in variations:\n        ones = sum(v.count('1') for v in variations)\n        if ones > max_ones:\n            max_ones = ones\n            best_variation = v\n    \n    # output the best variation\n    for row in best_variation:\n        print(\"\".join(row))"
 ],
 "3135": [
  "n = input().strip()\nif n == '0':\n    print(0)\nelse:\n    result = []\n    for i in range(len(n)):\n        if n[i] == '0':\n            result.append('0')\n        elif (i == 0 or result[-1] != '-'):\n            result.append('+')\n        else:\n            for j in range(len(result) - 1, -1, -1):\n                if result[j] == '-':\n                    result[j] = '+'\n                    break\n            else:\n                result.append('+')\n    print(''.join(result))"
 ],
 "3136": [
  "import heapq\n\nn, m, s, t = map(int, input().split())\na, b = map(int, input().split())\nemployees = list(map(int, input().split()))\nclients = list(map(int, input().split()))\n\ngraph = [{} for _ in range(n+1)]\nfor _ in range(m):\n    u, v, d = map(int, input().split())\n    graph[u][v] = d\n    graph[v][u] = d\n\ndef dijkstra(graph, start):\n    dist = {start: 0}\n    heap = [(0, start)]\n    while heap:\n        (d, u) = heapq.heappop(heap)\n        if u not in graph: continue\n        for v, weight in graph[u].items():\n            if v not in dist or dist[u] + weight < dist[v]:\n                dist[v] = dist[u] + weight\n                heapq.heappush(heap, (dist[v], v))\n    return dist\n\ndist_warehouses = dijkstra(graph, a)\ndist_warehouses[b] = 0\ndist_employees = [dijkstra(graph, employee) for employee in employees]\ndist_clients = [dijkstra(graph, client) for client in clients]\n\nmin_distance = float('inf')\nfor i in range(s):\n    employee = employees[i]\n    for j in range(t):\n        client = clients[j]\n        distance = dist_warehouses[employee] + dist_warehouses[b] + min(dist_employees[i][employee] + dist_clients[j][b], dist_employees[i][b] + dist_clients[j][employee])\n        min_distance = min(min_distance, distance)\n\nprint(min_distance)"
 ],
 "3137": [
  "# Taking Input\nn,m,k=map(int, input().split())\nx,y=map(int, input().split())\n\nblocks=[]\nfor i in range(k):\n    row,col,direction= input().split()\n    row, col = int(row)-1, int(col)-1\n    blocks.append({'row': row, 'col': col, 'facing': direction})\n\nnums = [list(map(int, input().strip())) for _ in range(n)]\nsteps = [[0]*m for _ in range(n)]\n\n# Defining a function to simulate the bacteria movement\ndef simulate(time):\n    for i in range(len(blocks)):\n        x = blocks[i]['row']\n        y = blocks[i]['col']\n        facing = blocks[i]['facing']\n\n        # get the current number at the cell\n        num = nums[x][y]\n\n        # update facing direction\n        if num == 1:\n            if facing == 'R':\n                facing = 'D'\n            elif facing == 'D':\n                facing = 'L'\n            elif facing == 'L':\n                facing = 'U'\n            elif facing == 'U':\n                facing = 'R'\n        elif num == 2:\n            if facing == 'R':\n                facing = 'L'\n            elif facing == 'D':\n                facing = 'U'\n            elif facing == 'L':\n                facing = 'R'\n            elif facing == 'U':\n                facing = 'D'\n        elif num == 3:\n            if facing == 'R':\n                facing = 'U'\n            elif facing == 'D':\n                facing = 'R'\n            elif facing == 'L':\n                facing = 'D'\n            elif facing == 'U':\n                facing = 'L'\n        elif num == 4:\n            if facing == 'R':\n                facing = 'U'\n            elif facing == 'D':\n                facing = 'L'\n            elif facing == 'L':\n                facing = 'D'\n            elif facing == 'U':\n                facing = 'R'\n\n        # update position\n        if facing == 'R':\n            y += 1\n        elif facing == 'D':\n            x += 1\n        elif facing == 'L':\n            y -= 1\n        elif facing == 'U':\n            x -= 1\n\n        # check for out of bounds\n        if x < 0 or x >= n or y < 0 or y >= m:\n            blocks[i]['facing'] = facing\n            blocks[i]['row'] = x\n            blocks[i]['col'] = y\n            continue\n\n        # update facing direction for out of bounds cells\n        if nums[x][y] == 0:\n            if facing == 'R':\n                facing = 'L'\n            elif facing == 'D':\n                facing = 'U'\n            elif facing == 'L':\n                facing = 'R'\n            elif facing == 'U':\n                facing = 'D'\n        elif nums[x][y] > 4:\n            continue\n\n        # update position and time taken\n        blocks[i]['facing'] = facing\n        blocks[i]['row'] = x\n        blocks[i]['col'] = y\n        steps[x][y] += 1\n        if steps[x][y] == time:\n            return False\n    return True\n\n# Initializing variables\nmax_time = 1000000\ntime_taken = 0\nterminate = False\n\n# loop over simulation steps from 1 to max_time\nfor t in range(1, max_time+1):\n    terminate = simulate(t)\n    time_taken = t\n    if not terminate:\n        break\n\n# check if game will never end\nif not terminate:\n    print(-1)\nelse:\n    print(time_taken)"
 ],
 "3138": [
  "n = int(input())\na = list(map(int, input().split()))\nprefix_sum = [0] * (n + 1)\nprefix_product = [1] * (n + 1)\n\nfor i in range(n):\n    prefix_sum[i + 1] = prefix_sum[i] + a[i]\n    prefix_product[i + 1] = prefix_product[i] * a[i]\n    \nanswer = 0\nfor i in range(1, n):\n    if prefix_sum[i] == prefix_product[i]:\n        answer += 1\n    for j in range(i + 1, n + 1):\n        if prefix_sum[j] - prefix_sum[i] == prefix_product[j] // prefix_product[i]:\n            answer += 1\nprint(answer)"
 ],
 "3139": [
  "from bisect import bisect_left\n\ndata = []\nfor _ in range(int(input())):\n    query = input().split()\n    if query[0] == 'D':\n        data.append((int(query[1]), int(query[2]), _+1))\n    else:\n        index = int(query[1]) - 1\n        not_found = True\n        for offset in range(3):\n            candidates = [i for i in data if i[offset] >= data[index][offset]]\n            if candidates:\n                candidates.sort()\n                index_to_ask = bisect_left(candidates, data[index])\n                if index_to_ask < len(candidates):\n                    print(candidates[index_to_ask][2])\n                    not_found = False\n                    break\n        if not_found:\n            print('NE')"
 ],
 "3140": [
  "from collections import deque\n\ndef maximize_fishing_points():\n    \n    r,c,k,l = map(int, input().split())\n    x0,y0 = map(int , input().split())\n    ts = [list(map(int,input().split())) for _ in range(r)]\n    \n    queue = deque()\n    queue.append((x0,y0,1))\n    max_points = 0\n    \n    dirs = [(1,0),(-1,0),(0,1),(0,-1)]\n    visited = [[False] * c for _ in range(r)]\n    \n    while queue:\n        x,y,t = queue.popleft()\n        \n        if visited[x][y]:\n            continue\n        visited[x][y] = True\n        \n        if t > l:\n            break\n            \n        if ts[x][y] <= t <= ts[x][y]+k:\n            max_points += 1\n            \n        for dx,dy in dirs:\n            xx = x+dx\n            yy = y+dy\n            \n            if xx < 0 or xx >= r or yy < 0 or yy >= c:\n                continue\n                \n            tt = max(t+1,ts[xx][yy])\n            \n            if tt <= l:\n                queue.append((xx,yy,tt))\n                \n    print(max_points)\n    \nmaximize_fishing_points()"
 ],
 "3141": [
  "import math\n\ndef dist(x1, y1, z1, x2, y2, z2):\n    return math.sqrt((x1-x2)**2 + (y1-y2)**2 + (z1-z2)**2)\n\nn = int(input())\n\nmax_dist = 0\nfor i in range(n):\n    x, y, z = map(float, input().split())\n    for j in range(i+1, n):\n        x2, y2, z2 = map(float, input().split())\n        d = dist(x, y, z, x2, y2, z2)\n        if d > max_dist:\n            max_dist = d\n\nprint('{:.10f}'.format(max_dist / 2)) "
 ],
 "3142": [
  "# Taking Input\na, b, s = map(int, input().split())\n\n# Declaring a function to find digit sum\ndef dig_sum(n):\n    sum = 0\n    while n > 0:\n        sum += n % 10\n        n //= 10\n    return sum\n\n# Finding the count of integers with digit sum equal to s\ncount = 0\nfor i in range(a, b+1):\n    if dig_sum(i) == s:\n        count += 1\n\n# Finding the smallest such integer\nfor i in range(a, b+1):\n    if dig_sum(i) == s:\n        print(count)\n        print(i)\n        break"
 ],
 "3143": [
  "from collections import deque\n\nn, m = map(int, input().split())\nlst = list(map(int, input().split()))\nstudents = deque(list(map(int, input().split())))\ncount = 0\nmoves = []\n\nwhile lst:\n    curr = lst[0]\n    if curr == students[0]:\n        lst.pop(0)\n        students.popleft()\n    else:\n        if curr in students:\n            idx = students.index(curr)\n            if idx <= len(students) // 2:\n                # move left\n                for i in range(idx):\n                    moves.append(1)\n                    students.append(students.popleft())\n                count += idx\n            else:\n                # move right\n                for i in range(len(students)-idx):\n                    moves.append(len(students))\n                    students.appendleft(students.pop())\n                count += len(students)-idx\n        else:\n            # student not in the line, remove from the list\n            lst.pop(0)\n\nprint(count)\nprint(*moves)"
 ],
 "3144": [
  "from collections import defaultdict\n\ndef dfs(d, g, n, k, p, dp):\n    if p == n:\n        return d\n    if dp[p][g][k] != -1:\n        return dp[p][g][k]\n    res = 0\n    if p < n - k:\n        for i in range(1, d + 1):\n            if i <= g:\n                res = max(res, dfs(d - i, g - i, n, k, p + 1, dp))\n            else:\n                res = max(res, g + dfs(i - g - 1, 0, n, k, p + 1, dp))\n    else:\n        res = g + dfs(g, 0, n, k, p + 1, dp)\n    dp[p][g][k] = res\n    return res\n\nd, g, n, k = map(int, input().split())\ndp = [[[ -1 for _ in range(k + 1)] for _ in range(g + 1)] for _ in range(n)]\nprint(dfs(d, g, n, k, 0, dp))"
 ],
 "3145": [
  "X, A, B = map(int, input().split())\nallowed_digits = set(input().strip())\n\ncount = 0\nfor num in range(A, B+1):\n    if num % X == 0:\n        if set(str(num)).issubset(allowed_digits):\n            count += 1\n\nprint(count)"
 ],
 "3146": [
  "import heapq\n\nn, t = map(int, input().split())\nin_store = []\nremote = []\nend_time = 0\n\nfor i in range(n):\n    d, location, time = input().split()\n    d = int(d)\n    time = int(time)\n    if location == 'S':\n        heapq.heappush(in_store, (d, time))\n    else:\n        heapq.heappush(remote, (d, time))\n\ncurr_time = [0] * t\nin_store_time, remote_time = 0, 0\n\nwhile in_store or remote:\n    for i in range(t):\n        if in_store and (not remote or in_store[0][0] <= remote[0][0]):\n            start_time, time_to_fill = heapq.heappop(in_store)\n        elif remote:\n            start_time, time_to_fill = heapq.heappop(remote)\n        else:\n            break\n        start_time = max(start_time, max(curr_time))\n        end_time = start_time + time_to_fill\n        curr_time[i] = end_time\n\n        if location == 'S':\n            in_store_time += end_time - start_time\n        else:\n            remote_time += end_time - start_time\n\nin_store_time /= len(in_store)\nremote_time /= len(remote) if len(remote) else 1\nprint(\"{:.6f} {:.6f}\".format(in_store_time, remote_time))"
 ],
 "3147": [
  "from collections import defaultdict\n\ndef is_killer(memory, r, c, size):\n    for i in range(r, r+size):\n        for j in range(c, c+size):\n            if memory[i][j] != memory[2*r+size-i-1][2*c+size-j-1]:\n                return False\n    return True\n\nR, C = map(int, input().split())\nmemory = [input() for _ in range(R)]\n\nlargest_killer = -1\nfor size in range(2, min(R, C)+1):\n    for i in range(R - size + 1):\n        for j in range(C - size + 1):\n            if is_killer(memory, i, j, size):\n                largest_killer = size\n\nprint(largest_killer)"
 ],
 "3148": [
  "n = int(input())\nswimmers = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    swimmers.append((x,y))\n\nswimmers.sort()\nmid = n // 2\n\nif n % 2 == 0:\n    x1 = swimmers[mid-1][0]\n    y1 = (swimmers[mid-1][1] + swimmers[mid][1]) // 2\n    x2 = swimmers[mid][0]\n    y2 = (swimmers[mid-1][1] + swimmers[mid][1]) // 2\n\nelse:\n    x1 = swimmers[mid][0]\n    y1 = swimmers[mid][1]\n    x2 = swimmers[mid][0]\n    y2 = swimmers[mid][1]\n\nprint(x1, y1)\nprint(x2, y2)"
 ],
 "3149": [
  "import math\n\n# Read input\nn, omega, v0, theta, w = map(float, input().split())\nn = int(n)\ncorners = []\nfor i in range(n):\n    x, y = map(float, input().split())\n    corners.append((x, y))\n\n# Compute corner velocities and angular velocities\nvelocities = []\nangular_velocities = []\nfor i in range(n):\n    x1, y1 = corners[i]\n    x2, y2 = corners[(i+1)%n]\n    dx = x2 - x1\n    dy = y2 - y1\n    vel = (dx*math.sin(theta*math.pi/180) + dy*math.cos(theta*math.pi/180))*v0\n    vel_angular = -omega*math.sqrt(dx**2 + dy**2)\n    velocities.append(vel)\n    angular_velocities.append(vel_angular)\n\n# Compute time when each corner hits the wall\ntimes = []\nfor i in range(n):\n    x, y = corners[i]\n    vx, vy = velocities[i]*math.cos(theta*math.pi/180), velocities[i]*math.sin(theta*math.pi/180)\n    r_angular = math.sqrt(x**2 + y**2)\n    vy_angular = r_angular*omega\n    a = 0.5*9.81\n    b = vy + 0.5*a\n    c = y - r_angular\n    t1 = (-b + math.sqrt(b**2-4*a*c))/(2*a)\n    t2 = (-b - math.sqrt(b**2-4*a*c))/(2*a)\n    t = max(t1, t2)  # take the larger time since that's when the corner hits the wall\n    times.append(t)\n\n# Find which corner hits the wall first and at what time\nfirst_hit = min(range(n), key=lambda i: times[i])\nprint(first_hit+1, '{:.6f}'.format(times[first_hit]))"
 ],
 "3150": [
  "# Importing math library\nfrom math import comb\n\n# Reading the number of trenches\nn = int(input())\n\n# Reading the coordinates of the trenches\ntrenches = []\nfor i in range(n):\n    x1, y1, x2, y2 = map(int, input().split())\n    trenches.append((x1, y1, x2, y2))\n\n# Function to check if two guards can see each other\ndef can_see(p1, p2):\n    for x1, y1, x2, y2 in trenches:\n        if (p1[0] - x1) * (p2[1] - y1) == (p1[1] - y1) * (p2[0] - x1) and (p1[0] - x2) * (p2[1] - y2) == (p1[1] - y2) * (p2[0] - x2):\n            return False\n    return True\n\n# Counting the number of ways to place the guards\ncount = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        for k in range(j + 1, n):\n            if can_see(trenches[i][:2], trenches[j][:2]) and can_see(trenches[i][:2], trenches[k][:2]) and can_see(trenches[j][:2], trenches[k][:2]):\n                count += 1\n\n# Outputting the result\nprint(count)"
 ],
 "3151": [
  "n = int(input())\nfound = False\n\nfor k in range(1,n): \n    m_square = n + k*k\n    m = int(m_square**0.5)\n    if m*m == m_square:\n        print(m,k)\n        found = True\n        break\n\nif not found:\n    print('impossible')"
 ],
 "3152": [
  "n = int(input())\na = [int(input()) for i in range(n)]\n\ndef calc_price(start,end):\n    min_val = min(a[start:end+1])\n    max_val = max(a[start:end+1])\n    length = end-start+1\n    return (min_val*max_val*length)%1000000000\n\ntotal_sum = 0\nfor i in range(n):\n    for j in range(i,n):\n        total_sum += calc_price(i,j)\n\nprint(total_sum%1000000000)"
 ],
 "3153": [
  "n, m = map(int, input().split())\ncards = list(map(int, input().split()))\n\ntotal_purchases = []\n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    for i in range(3):\n        for j in range(3):\n            cards_copy = cards.copy()\n            cards_copy[a-1] -= i\n            cards_copy[b-1] -= j\n            if sum(cards_copy) == sum(cards) - i - j:\n                if i > j:\n                    total_purchases.append((a, b, i))\n                elif i < j:\n                    total_purchases.append((a, b, j))\n                else:\n                    total_purchases.append((a, b, 1))\n\n                    break\n\nprint(len(total_purchases))\nfor p in total_purchases:\n    print(p[0], p[1], p[2])\n"
 ],
 "3154": [
  "from queue import PriorityQueue\nimport sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nd, e = map(int, input().split())\n\n# simulate toy swaps and \"playing with no toys\" to determine each child's preference\ntoys = [[] for _ in range(m+1)]\nplay_count = [[0 for _ in range(m+1)] for _ in range(n+1)]\nplaying_with = [0]*(n+1)\nfor i in range(e):\n    s, k, t = map(int, input().split())\n    if t == 0: # stop playing with any toy\n        toys[playing_with[k]].append((s,i,k))\n        playing_with[k] = 0\n    else:\n        if playing_with[k] != 0:\n            toys[playing_with[k]].append((s,i,k))\n        playing_with[k] = t\ntoys[playing_with[k]].append((d,i,k)) # end last playtime\nfor j in range(1,m+1):\n    if toys[j]:\n        toys[j].append((d+1,0,0)) # end last playtime\n        j_swaps = []\n        j_ind = 0\n        for i in range(1,n+1):\n            if playing_with[i] == j:\n                play_count[i][j] += d - toys[j][j_ind][0]\n                for start, ind, kid in toys[j][j_ind+1:]:\n                    play_count[i][j] += start - toys[j][j_ind][0]\n                    j_ind += 1\n                    if play_count[i][j] < 0: # this kid might cry\n                        j_swaps.append(1000000010)\n                        break\n                else:\n                    # friendliest with considerate players\n                    j_swaps.append((play_count[i][j], -max([toys[a][-1][1] for a in range(1,m+1) if a != j and play_count[i][a] >= play_count[i][j]], default=-1), i))\n                    j_swaps[-1][1] = -j_swaps[-1][1]\n                    j_ind += 1\n            else:\n                # friendliest, unplayed\n                j_swaps.append((1e16, -j, i))\n        j_swaps.sort()\n        for _, _, i in j_swaps:\n            if playing_with[i] == 0: # swap for an unplayed toy first\n                playing_with[i] = j\n                break\n        else: # no unplayed toy, swap for least crying\n            _, _, i = j_swaps[0]\n            playing_with[i] = j\n        j_ind = 0\n\n# check for crying kids\ntoys = [[] for _ in range(m+1)]\nfor i in range(e):\n    s, k, t = map(int, input().split())\n    if t == 0:\n        toys[playing_with[k]].append((s,i,k))\n        playing_with[k] = 0\n    else:\n        if playing_with[k] != 0:\n            toys[playing_with[k]].append((s,i,k))\n        playing_with[k] = t\ntoys[playing_with[k]].append((d+1,i,k))\npq = PriorityQueue()\nfor i in range(1,n+1):\n    if playing_with[i] != 0:\n        toys[playing_with[i]].append((d+1,e+1,k))\nfor j in range(1,m+1):\n    if len(toys[j]) > 0:\n        toys[j].append((0,0,0))\n        j_swaps = []\n        j_ind = 0\n        for i in range(1,n+1):\n            if playing_with[i] == j:\n                play_count = 0\n                for start, ind, kid in toys[j][j_ind+1:]:\n                    play_count += start - toys[j][j_ind][0]\n                    j_ind += 1\n                    if play_count < 0:\n                        pq.put((start,kid))\n        j_ind = 0\nprint(\"impossible\" if not pq.empty() else \" \".join([str(x) for x in playing_with[1:]]))"
 ],
 "3155": [
  "import math\n \ndef findBinomialCoefficient(X):\n    n = int(math.sqrt(X * 2))\n    if n * (n + 1) != 2 * X:\n        n += 1\n    k = X - n * (n - 1) // 2\n    return n, k\n \nX = int(input())\nn, k = findBinomialCoefficient(X)\nprint(n, k)"
 ],
 "3156": [
  "from collections import defaultdict\n\nn = int(input())\nk = int(input())\n\n#initialize the dictionaries to store the item and store bought at\nitems = defaultdict(list)\nstores = defaultdict(list)\n\n#fill in the dictionaries\nfor i in range(k):\n    x, y = input().split()\n    items[y].append(x)\n    stores[x].append(y)\n\nm = int(input())\ngroceries = []\n\n#fill in the groceries list\nfor i in range(m):\n    groceries.append(input().strip())\n\n#initialize variables for the algorithm\nprev_store = items[groceries[0]]\npossible_stores = prev_store.copy()\n\n#loop through the groceries list\nfor item in groceries[1:]:\n\n    #initialize variables for each loop\n    new_possible_stores = []\n\n    #check if item is available in any stores\n    if item not in items:\n        print(\"impossible\")\n        exit()\n\n    #check if item can be bought at any of the possible stores\n    for possible_store in possible_stores:\n        if possible_store in items[item]:\n            new_possible_stores.extend(items[item][possible_store])\n\n    #if the item cannot be bought at any of the possible stores, it is impossible\n    if not new_possible_stores:\n        print(\"impossible\")\n        exit()\n\n    #update the possible stores list for the next iteration\n    if len(new_possible_stores) > 1:\n        possible_stores = new_possible_stores.copy()\n    else:\n        prev_store = new_possible_stores.copy()\n        possible_stores = stores[new_possible_stores[0]].copy()\n\n#check if there is a unique path or not\nif len(prev_store) == 1 and prev_store[0] in possible_stores:\n    print(\"unique\")\nelse:\n    print(\"ambiguous\")"
 ],
 "3157": [
  "n, k, m = map(int, input().split())\nmod = 2 ** m\n\nif k == 0 and n == 1:\n    print(1)\nelif n == 1:\n    print(0)\nelse:\n    count = 0\n    for i in range(97, 123):\n        temp_k = ((k * 33) ^ i) % mod\n        if temp_k == 0:\n            temp_count = 1\n        else:\n            temp_count = 0\n        for j in range(n-2):\n            temp_k = ((temp_k * 33) % mod)\n            if temp_k == 0 and j == n-3:\n                temp_count += 1\n            elif temp_k in [294, 296, 270, 285, 297, 307, 345, 318, 339, 359, 413, 364, 377, 394, 482, 441, 498, 533, 630, 656]:\n                temp_count += 1\n        count += temp_count\n    print(count)    "
 ],
 "3158": [
  "# read the input images\nimage1 = []\nimage2 = []\nfor i in range(15):\n    line = input()\n    image1.append(line[:30])\n    image2.append(line[31:])\n\n# function to calculate touch point from the image\ndef get_touch_point(image):\n    count = 0\n    x_sum = 0\n    y_sum = 0\n    for i in range(15):\n        for j in range(30):\n            if image[i][j] == 'X':\n                count += 1\n                x_sum += j\n                y_sum += i\n    x_avg = x_sum / count\n    y_avg = y_sum / count\n    return x_avg, y_avg\n\n# get the touch points and grip spread for both initial and final grips\ntouch_points1 = []\ntouch_points2 = []\ngrip_spread1 = 0\ngrip_spread2 = 0\nfor i in range(5):\n    if i < len(image1) and image1[i].count('X') > 0:\n        x, y = get_touch_point(image1)\n        touch_points1.append((x, y))\n        for m in range(15):\n            for n in range(30):\n                if image1[m][n] == 'X':\n                    grip_spread1 += ((n-x)**2 + (m-y)**2)**0.5\n    if i < len(image2) and image2[i].count('X') > 0:\n        x, y = get_touch_point(image2)\n        touch_points2.append((x, y))\n        for m in range(15):\n            for n in range(30):\n                if image2[m][n] == 'X':\n                    grip_spread2 += ((n-x)**2 + (m-y)**2)**0.5\n\n# calculate the grip point and grip rotation for both grips\ngrip_point1 = [sum([x[0] for x in touch_points1]) / len(touch_points1), sum([x[1] for x in touch_points1]) / len(touch_points1)]\ngrip_point2 = [sum([x[0] for x in touch_points2]) / len(touch_points2), sum([x[1] for x in touch_points2]) / len(touch_points2)]\ntouch_vectors1 = []\ntouch_vectors2 = []\ngrip_rotation1 = 0\ngrip_rotation2 = 0\nfor i in range(len(touch_points1)):\n    x1, y1 = touch_points1[i]\n    x2, y2 = touch_points2[i]\n    touch_vectors1.append([(x1-grip_point1[0]), (y1-grip_point1[1])])\n    touch_vectors2.append([(x2-grip_point2[0]), (y2-grip_point2[1])])\n    grip_rotation1 += atan2((y1-grip_point1[1]), (x1-grip_point1[0]))\n    grip_rotation2 += atan2((y2-grip_point2[1]), (x2-grip_point2[0]))\ngrip_rotation1 /= len(touch_points1)\ngrip_rotation2 /= len(touch_points2)\n\n# calculate the distances for pan, zoom, and rotation gestures\npan_distance = ((grip_point1[0]-grip_point2[0])**2 + (grip_point1[1]-grip_point2[1])**2)**0.5\ngrip_spread1 /= len(touch_points1)\ngrip_spread2 /= len(touch_points2)\nzoom_distance = grip_spread2 - grip_spread1\ntouch_rotation = 0\nfor i in range(len(touch_vectors1)):\n    touch_rotation += atan2(touch_vectors2[i][1], touch_vectors2[i][0]) - atan2(touch_vectors1[i][1], touch_vectors1[i][0])\ntouch_rotation /= len(touch_points1)\nif grip_spread2 < grip_spread1:\n    zoom_direction = 'in'\nelse:\n    zoom_direction = 'out'\nif touch_rotation < -pi:\n    touch_rotation += 2*pi\nelif touch_rotation > pi:\n    touch_rotation -= 2*pi\nrotation_distance = abs(touch_rotation * grip_spread1)\n\n# classify the gesture based on distance\ndistances = sorted([(pan_distance, 'pan'), (zoom_distance, f'zoom {zoom_direction}'), (rotation_distance, f'rotate {\"clockwise\" if touch_rotation > 0 else \"counter-clockwise\"}')])\nprint(f'{len(touch_points1)} {distances[-1][1]}')"
 ],
 "3159": [
  "from queue import Queue\n\n# read input\nh, w = map(int, input().split())\nimage_ids = {}\nimages = []\n\n# determine whether char is allowed in image\ndef is_allowed(c):\n    return c.isalnum() or c == '?' or c == '!' or c == ',' or c == '.' or c == ' '\n\n# create images\nfor i in range(1, h + 1):\n    row = input()\n    for j in range(1, w + 1):\n        if row[j - 1] == '+':\n            if i <= 2 or j <= 2:\n                print('+', end='')\n            else:\n                # new image found\n                new_id = len(images)\n                image_ids[(i, j)] = new_id\n                image = []\n                # BFS to find all characters in the image\n                q = Queue()\n                q.put((i, j))\n                while not q.empty():\n                    r, c = q.get()\n                    if (r, c) in image_ids or not is_allowed(row[c - 1]):\n                        continue\n                    image_ids[(r, c)] = new_id\n                    image.append((r, c))\n                    for nr, nc in [(r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)]:\n                        if 1 <= nr <= h and 1 <= nc <= w and (nr, nc) not in image_ids:\n                            q.put((nr, nc))\n                images.append(image)\n        else:\n            print(row[j - 1], end='')\n    print()\n\n# remove ads by finding smallest image with banned character\nfor banned_char in ['$', '%', '^', '&', '*', '(', ')', '_', '-', '=', '|', '\\\\', '/', '<', '>', ';', ':', '[', ']', '{', '}', '@', '#']:\n    best_area = float('inf')\n    best_image = None\n    for image in images:\n        has_banned_char = False\n        min_row, min_col, max_row, max_col = float('inf'), float('inf'), 0, 0\n        for r, c in image:\n            if not is_allowed(row[c - 1]):\n                has_banned_char = True\n                min_row = min(min_row, r)\n                max_row = max(max_row, r)\n                min_col = min(min_col, c)\n                max_col = max(max_col, c)\n        if has_banned_char:\n            area = (max_row - min_row + 1) * (max_col - min_col + 1)\n            if area < best_area:\n                best_area = area\n                best_image = image\n    if best_image is not None:\n        for r, c in best_image:\n            row = r - 1\n            col = c - 1\n            if row == 0 or row == h - 1 or col == 0 or col == w - 1:\n                print('+', end='')\n            elif image_ids.get((r, c), -1) != image_ids.get((r - 1, c - 1), -2) or image_ids.get((r, c - 2), -1) != image_ids.get((r - 1, c - 3), -2) or image_ids.get((r - 2, c), -1) != image_ids.get((r - 3, c - 1), -2) or image_ids.get((r - 2, c - 2), -1) != image_ids.get((r - 3, c - 3), -2):\n                print('+', end='')\n            else:\n                print(' ', end='')\n        print()"
 ],
 "3160": [
  "s = input()\nn = s.count('?')\nh = s.count('H')\nt = len(s) - n - h\nif n == 0:\n    if h == 0:\n        print(0)\n    else:\n        print(1)\nelse:\n    print((1 << n) - (n + 1) % 2)"
 ],
 "3161": [
  "n = int(input())\npixels = []\nfor i in range(n):\n    row = input().strip()\n    pixels.append(row)\n\ndef paint(pixels):\n    if len(pixels) == 1:\n        return pixels[0][0]\n    n = len(pixels)\n    half = n // 2\n    q1 = [row[:half] for row in pixels[:half]]\n    q2 = [row[half:] for row in pixels[:half]]\n    q3 = [row[:half] for row in pixels[half:]]\n    q4 = [row[half:] for row in pixels[half:]]\n    colors = [paint(q1), paint(q2), paint(q3), paint(q4)]\n    black_count = colors.count('1')\n    white_count = colors.count('0')\n    max_color = '1' if black_count > white_count else '0'\n    min_diff = black_count if black_count < white_count else white_count\n    result_pixels = []\n    for i in range(n):\n        row = ''\n        for j in range(n):\n            if (i < half and j < half) or (i >= half and j >= half):\n                row += colors[0]\n            else:\n                row += colors[1] if colors[1] != max_color else colors[2]\n        result_pixels.append(row)\n    return (min_diff, result_pixels)\n\nresult = paint(pixels)\nprint(result[0])\nfor row in result[1]:\n    print(row)"
 ],
 "3162": [
  "n = int(input())\nhor_pulses = {}\nver_pulses = {}\nfor i in range(n):\n    arr = list(input().split(\" \"))\n    arr[1], arr[2], arr[3] = int(arr[1]), int(arr[2]), int(arr[3])\n    if arr[0] == 'h':\n        if arr[3] in hor_pulses:\n            hor_pulses[arr[3]].append([arr[1], arr[2]])\n        else:\n            hor_pulses[arr[3]] = [[arr[1], arr[2]]]\n    else:\n        if arr[3] in ver_pulses:\n            ver_pulses[arr[3]].append([arr[1], arr[2]])\n        else:\n            ver_pulses[arr[3]] = [[arr[1], arr[2]]]\n            \ncount = 0\nfor i in range(1, max(max(hor_pulses.keys()), max(ver_pulses.keys()))+1):\n    horizontal = hor_pulses.get(i, [])\n    vertical = ver_pulses.get(i, [])\n    hor_idx = 0\n    ver_idx = 0\n    while hor_idx < len(horizontal) and ver_idx < len(vertical):\n        if horizontal[hor_idx][1] < vertical[ver_idx][0]:\n            hor_idx += 1\n        elif vertical[ver_idx][1] < horizontal[hor_idx][0]:\n            ver_idx += 1\n        else:\n            count += 1\n            if horizontal[hor_idx][1] < vertical[ver_idx][1]:\n                hor_idx += 1\n            else:\n                ver_idx += 1\nprint(count)"
 ],
 "3163": [
  "n, m = map(int, input().split())\ns = [list(map(int, input().split())) for i in range(n)]\nw = [list(map(int, input().split())) for i in range(n)]\nidxs = [[] for i in range(n)]\nfor i in range(n):\n    for j in range(m):\n        if s[i][j] == 0: \n            continue\n        idxs[i].append(s[i][j] - 1)\nbook_idx = [None for i in range(n * m)]\nfor i in range(n):\n    for j in range(m):\n        if s[i][j] == 0:\n            continue\n        book_idx[s[i][j] - 1] = (i, j)\nans = 0\nfor i in range(n):\n    for j in range(m):\n        if w[i][j] == 0:\n            continue\n        if idxs[i][0] == w[i][j] - 1:\n            idxs[i] = idxs[i][1:]\n            idxs.append([w[i][j] - 1])\n            book_idx[w[i][j] - 1] = (len(idxs) - 1, 0)\n            ans += i + len(idxs) - 2\n        else:\n            pos = book_idx[w[i][j] - 1]\n            ans += abs(i - pos[0]) + abs(j - pos[1])\n            idxs[pos[0]].remove(w[i][j] - 1)\n            idxs[i].append(w[i][j] - 1)\n            book_idx[w[i][j] - 1] = (i, len(idxs[i]) - 1)\n        if not idxs[i]:\n            idxs.pop(i)\n            n -= 1\n    if not idxs:\n        break\n    idxs = idxs[-1:] + idxs[:-1]\n    ans += 1\nelse:\n    ans = -1\nprint(ans)"
 ],
 "3164": [
  "n = int(input())\narr = list(map(int, input().split()))\nfreq = {}\nleft = 0\nmaxLength = 0\n\nfor right in range(n):\n    if arr[right] not in freq:\n        freq[arr[right]] = 0\n    freq[arr[right]] += 1\n    while freq[arr[right]] > 2:\n        freq[arr[left]] -= 1\n        if freq[arr[left]] == 0:\n            freq.pop(arr[left])\n        left += 1\n    if len(freq) == (right - left + 1)//2:\n        maxLength = max(maxLength, right - left + 1)\n\nprint(maxLength)"
 ],
 "3165": [
  "from collections import defaultdict\nn, k, p = map(int, input().split())\n\n# get the rooks' positions and their powers\nrook_pos = defaultdict(int)\nrook_row = defaultdict(set)\nrook_col = defaultdict(set)\nfor _ in range(k):\n    r, c, x = map(int, input().split())\n    rook_pos[(r, c)] = x\n    rook_row[r].add(x)\n    rook_col[c].add(x)\n\n# define a function to calculate the number of attacked fields\ndef count_attacked(rook_row, rook_col, attacked):\n    cnt = 0\n    for r in rook_row:\n        for c in rook_col:\n            if (r, c) not in attacked:\n                xor_val = 0\n                for x in rook_row[r]:\n                    xor_val ^= x\n                for x in rook_col[c]:\n                    xor_val ^= x\n                if xor_val > 0:\n                    cnt += 1\n                    attacked.add((r, c))\n    return cnt\n\n# calculate the initial number of attacked fields\nattacked = set()\nans = count_attacked(rook_row, rook_col, attacked)\nprint(ans)\n\n# process the moves and update the number of attacked fields\nfor _ in range(p):\n    r1, c1, r2, c2 = map(int, input().split())\n    x = rook_pos.pop((r1, c1))\n    rook_pos[(r2, c2)] = x\n    rook_row[r1].remove(x)\n    rook_row[r2].add(x)\n    rook_col[c1].remove(x)\n    rook_col[c2].add(x)\n    if (r1, c1) in attacked:\n        attacked.remove((r1, c1))\n        cnt1 = count_attacked(rook_row, rook_col, attacked)\n    else:\n        cnt1 = ans\n    \n    cnt2 = count_attacked(rook_row, rook_col, attacked)\n    ans = cnt2 - cnt1\n    print(ans)"
 ],
 "3166": [
  "# Reading input\nn, k = map(int, input().split())\ngraph = [list(map(int, input().split())) for _ in range(n)]\ndisqualified = set(map(int, input().split()))\n\n# Helper function to check if a set of players is valid\ndef is_valid(players):\n    for i in range(n):\n        if i not in players and graph[i][i] == 0:\n            for j in range(n):\n                if j not in players and graph[j][j] == 0:\n                    if graph[i][j] == 1 and j in players:\n                        break\n                    elif graph[i][j] == 0 and j not in players:\n                        break\n            else:\n                return False\n    return True\n\n# Checking all subsets of size strictly less than k\nfor i in range(1, k):\n    for subset in combinations(range(n), i):\n        if disqualified.intersection(subset):  # Skip if any disqualified player is already in the subset\n            continue\n        if is_valid(subset):\n            print(i)\n            exit()\nprint(\"impossible\")"
 ],
 "3167": [
  "n, k = map(int, input().split())\nseq = [0]*n\nfor _ in range(k):\n    jump = int(input())\n    i = 0\n    while i < n:\n        seq[i] += 1\n        i += jump\n\nq = int(input())\nfor _ in range(q):\n    l, r = map(int, input().split())\n    print(sum(seq[l:r+1]))"
 ],
 "3168": [
  "import bisect\n\nn = int(input())\na = []\ncnt = 0\n\nfor i in range(n):\n    num = int(input())\n    pos = bisect.bisect_left(a,num)\n    cnt += pos\n    a.insert(pos,num)\n    print(cnt)"
 ],
 "3169": [
  "import heapq\n\nn = int(input())\n\nsticks = []\nfor i in range(n):\n    x1, y1, x2, y2 = map(int, input().split())\n    if x1 > x2:\n        x1, y1, x2, y2 = x2, y2, x1, y1\n    sticks.append((min(y1, y2), max(y1, y2), x1, i+1))\n\nsticks.sort(reverse=True)\n\npositions = []\nans = []\nfor pos in range(10001):\n    while sticks and sticks[-1][0] <= pos:\n        _, y2, x2, i = sticks.pop()\n        heapq.heappush(positions, (-x2, i))\n    while positions and -positions[0][0] < pos:\n        heapq.heappop(positions)\n    if positions:\n        _, i = heapq.heappop(positions)\n        ans.append(i)\n    else:\n        ans.append(sticks.pop()[3])\n\nprint(*ans)"
 ],
 "3170": [
  "deck = input()\n\ntheta_cards = []\nfriend_cards = []\n\n# deal cards to players\nfor i in range(10):\n    theta_cards.append(deck[i])\n    friend_cards.append(deck[10+i])\n\ndeck = deck[20:]\ndiscard_pile = []\n\n# return number of unfilled slots\ndef count_unfilled(cards):\n    return 10 - len(set(cards))\n\ntheta_turn = True\nwhile True:\n    if theta_turn:\n        turn_cards = theta_cards\n    else:\n        turn_cards = friend_cards\n\n    # check if all slots are filled\n    if count_unfilled(turn_cards) == 0:\n        if theta_turn:\n            print(\"Theta wins\")\n        else:\n            print(\"Theta loses\")\n        break\n\n    # draw a card\n    card_drawn = deck.pop(0)\n\n    # attempt to fill slots with drawn card or wildcard (jack)\n    filled = False\n    for i in range(len(turn_cards)):\n        if turn_cards[i] == card_drawn or card_drawn == \"J\":\n            # check if slot has already been filled\n            if turn_cards[i] not in discard_pile:\n                # remove face-down card from slot and put drawn card in slot\n                turn_cards[i] = card_drawn\n                # check for remaining wildcards and fill lowest-numbered unfilled slot\n                while \"J\" in turn_cards:\n                    j_pos = turn_cards.index(\"J\")\n                    min_unfilled_pos = -1\n                    for k in range(len(turn_cards)):\n                        if turn_cards[k] != \"J\" and turn_cards[k] != card_drawn and turn_cards[k] not in discard_pile:\n                            if min_unfilled_pos == -1 or k < min_unfilled_pos:\n                                min_unfilled_pos = k\n                    if min_unfilled_pos == -1:\n                        break\n                    turn_cards[j_pos] = turn_cards[min_unfilled_pos]\n                    turn_cards[min_unfilled_pos] = \"J\"\n                    i = j_pos\n                filled = True\n                break\n\n    # if the card cannot fill a slot, add it to the discard pile\n    if not filled:\n        discard_pile.append(card_drawn)\n\n    # switch turns if player cannot or chooses not to draw again\n    if not filled or turn_cards[i] == \"J\" or (count_unfilled(turn_cards) == 0 and card_drawn != \"J\"):\n        theta_turn = not theta_turn"
 ],
 "3171": [
  "N, K = [int(x) for x in input().split()]\n\ntruth_dict = [None]*(N+1)\nfab_dict = [None]*(N+1)\n\nfor _ in range(K):\n    name, proposition, *args = input().split()\n    if proposition == \"truther\":\n        truth_dict[int(args[0])] = int(name)\n    elif proposition == \"fabulist\":\n        fab_dict[int(args[0])] = int(name)\n    elif proposition == \"charlatan\":\n        i = 0\n        while args[i] != \"not\":\n            i += 1\n            if i >= len(args):\n                break\n        i += 1\n        while i < len(args):\n            candidate = int(args[i])\n            if truth_dict[candidate] is not None:\n                break\n            i += 1\n        else:\n            for candidate in range(1, N+1):\n                if candidate == int(name):\n                    continue\n                if fab_dict[candidate] is not None and truth_dict[candidate] is None:\n                    truth_dict[candidate] = int(name)\n        for candidate in range(1, N+1):\n            if candidate == int(name):\n                continue\n            if fab_dict[candidate] is not None and truth_dict[candidate] is None and candidate not in [int(a) for a in args]:\n                truth_dict[candidate] = int(name)\n    elif proposition == \"xor\":\n        candidate1 = int(args[1])\n        candidate2 = int(args[2])\n        if (truth_dict[candidate1] is not None or fab_dict[candidate1] is not None) and (truth_dict[candidate2] is None and fab_dict[candidate2] is None):\n            truth_dict[candidate2] = truth_dict[candidate1]\n            fab_dict[candidate2] = fab_dict[candidate1]\n        elif (truth_dict[candidate2] is not None or fab_dict[candidate2] is not None) and (truth_dict[candidate1] is None and fab_dict[candidate1] is None):\n            truth_dict[candidate1] = truth_dict[candidate2]\n            fab_dict[candidate1] = fab_dict[candidate2]\n\nfor i in range(1, N+1):\n    if truth_dict[i] is not None:\n        print(\"truther\")\n    elif fab_dict[i] is not None:\n        print(\"fabulist\")\n    else:\n        print(\"charlatan\")"
 ],
 "3172": [
  "import math\nn = int(input())\nF = []\nfor i in range(n):\n    x,y = map(float, input().split()) \n    F.append((x,y))\n    \ndef max_fruits_sliced(F):\n    ans = 1\n    for i in range(n):\n        for j in range(i+1, n):\n            slice_count = 0\n            for k in range(n):\n                if (F[k][0]-F[i][0])*(F[j][1]-F[i][1]) == (F[j][0]-F[i][0])*(F[k][1]-F[i][1]): \n                    slice_count += 1\n            ans = max(ans, slice_count)\n    return ans\n\nprint(max_fruits_sliced(F))"
 ],
 "3173": [
  "from collections import defaultdict\nR, C, K = map(int, input().split())\ngrid = [input() for _ in range(R)]\nscores = list(map(int, input().split()))\n\nbottoms = [-1] * C\nfor i in range(C):\n    for j in range(R-1, -1, -1):\n        if grid[j][i] == '?':\n            bottoms[i] = j\n            break\n        elif grid[j][i] == 'X':\n            break\nassert all(x >= 0 for x in bottoms)\n\nstart_score = 0\npos = (0, C-1)\ncrossed = 0\nwhile pos[0] < R:\n    if crossed > int(1e18):  # prevent infinite loop\n        break\n    r, c = pos\n    cell = grid[r][c]\n    if cell == '.':\n        pass\n    elif cell == 'X':\n        break\n    elif cell == 'L':\n        c -= 1\n    elif cell == 'R':\n        c += 1\n    else:  # cell == '?'\n        bot = bottoms[c]\n        if bot == -1 or bot > r:\n            c += 1\n        elif bottoms[c-1] == bot:  # if ball hits wall on the left of conveyor\n            c -= 1\n        else:\n            c += 1\n    if r == R-1:\n        start_score += scores[c]\n        break\n    pos = (r+1, c)\n    crossed += 1\n\nassert crossed <= int(1e18)\ndp = defaultdict(int)\ndp[(0, C-1)] = start_score\n\nfor k in range(1, K+1):\n    for r in range(R):\n        for c in range(C):\n            cell = grid[r][c]\n            s = scores[c] if r == R-1 else 0\n            if cell == 'X':\n                continue\n            elif cell == 'L':\n                pos = (r, c-1)\n            elif cell == 'R':\n                pos = (r, c+1)\n            else:  # cell == '?'\n                pos = (r, c-1)\n                if bottoms[c] == r:\n                    pos = (r, c+1)\n            score = s + dp.get(pos, 0)\n            dp[(r, c)] = max(dp[(r, c)], score)\n\nprint(max(dp.values()))"
 ],
 "3174": [
  "from math import sqrt\nfrom collections import deque\n\ndef bfs(u, cut, adj):\n    q, seen, nodes = deque(), {u}, {u}\n    if k[u]%cut == 0:\n        return True\n    q.append(u)\n    while len(q):\n        u = q.popleft()\n        for v in adj[u]:\n            if v in seen:\n                continue\n            seen.add(v)\n            if k[v]%cut == 0:\n                return True\n            nodes.add(v)\n            q.append(v)\n    s = sum(k[i] for i in nodes)\n    if s%cut == 0:\n        return True\n    else:\n        return False\n\ndef check(d, cut, adj):\n    for i in range(n):\n        for j in adj[i]:\n            if dist[i][j] <= d:\n                continue\n            mid = (k[i]+k[j])//2\n            if mid%cut == 0:\n                return True\n            found = False\n            for c in range(1, cut):\n                if bfs(i, c*mid, adj) and bfs(j, (cut-c)*mid, adj):\n                    found = True\n                    break\n            if found:\n                return True\n    return False\n\nn, cut = map(int, input().split())\np = [tuple(map(int, input().split())) for i in range(n)]\nx, y, k = zip(*p)\nadj = [[] for i in range(n)]\nfor i in range(n):\n    for j in range(i+1, n):\n        dx, dy = x[i]-x[j], y[i]-y[j]\n        dist = sqrt(dx*dx+dy*dy)\n        if dist <= d:\n            adj[i].append(j)\n            adj[j].append(i)\n\nlo, hi = 0, 200000000\nwhile lo+0.0001 < hi:\n    mid = (lo+hi)/2\n    if check(mid, cut, adj):\n        hi = mid\n    else:\n        lo = mid\nprint(\"{:.3f}\".format(lo))"
 ],
 "3175": [
  "import math\n\nn, *lengths = map(int, input().split())\nmaxLength = max(lengths)\nperimeter = sum(lengths)\n\nif perimeter - maxLength > maxLength:\n    s = perimeter / 2\n    area = math.sqrt(s * (s-lengths[0]) * (s-lengths[1]) * (s-lengths[2]))\n    print(round(area, 3))\nelse:\n    print(0)"
 ],
 "3176": [
  "import heapq\n\nn, k = map(int, input().split())\nplants = []\nenergy = [0] * (n+1)\ngraph = [[] for _ in range(n+1)]\nfor i in range(1, n+1):\n    x, y, f = map(int, input().split())\n    plants.append((x, y, f))\nplants.sort()\nfor i in range(n):\n    for j in range(i+1, n):\n        x1, y1, _ = plants[i]\n        x2, y2, _ = plants[j]\n        if y1 == y2 and x2 > x1:\n            graph[i+1].append((j+1, (x2-x1)*f))\n        elif x1 == x2 and y2 > y1:\n            graph[i+1].append((j+1, (y2-y1)*f))\n\npq = [(0, 1)]\nvisited = set()\nwhile pq:\n    c_energy, loc = heapq.heappop(pq)\n    if loc == n:\n        break\n    if loc in visited:\n        continue\n    visited.add(loc)\n    energy[loc] = c_energy\n    for nxt, cost in graph[loc]:\n        if nxt in visited:\n            continue\n        heapq.heappush(pq, (c_energy - k - cost, nxt))\n\nsequence = []\nnow = 1\nsequence.append(now)\nwhile now != n:\n    min_nxt = None\n    for nxt, cost in graph[now]:\n        if energy[nxt] + cost + k == energy[now]:\n            if min_nxt is None or plants[nxt-1][2] > plants[min_nxt-1][2]:\n                min_nxt = nxt\n    sequence.append(min_nxt)\n    now = min_nxt\n\nprint(energy[n])\nprint(len(sequence))\nfor loc in sequence:\n    print(plants[loc-1][0], plants[loc-1][1])"
 ],
 "3177": [
  "from itertools import permutations\n\ndef dfs(perm,used,allowed_swaps):\n    if perm == sorted(range(1,n+1)): return 0\n    min_swaps = float('inf')\n    for swap in allowed_swaps:\n        if not used[swap[0]-1] and not used[swap[1]-1]:\n            new_perm = perm.copy()\n            new_perm[swap[0]-1], new_perm[swap[1]-1] = new_perm[swap[1]-1], new_perm[swap[0]-1]\n            used[swap[0]-1], used[swap[1]-1] = True, True\n            min_swaps = min(min_swaps, dfs(new_perm,used,allowed_swaps)+1)\n            used[swap[0]-1], used[swap[1]-1] = False, False\n    return min_swaps\n\nn,m = map(int,input().split())\ninitial_perm = tuple(map(int,input().split()))\nallowed_swaps = [tuple(map(int,input().split())) for _ in range(m)]\nmin_swaps = float('inf')\nfor perm in permutations(initial_perm):\n    used = [False]*n\n    min_swaps = min(min_swaps,dfs(list(perm),used,allowed_swaps))\nprint(min_swaps)"
 ],
 "3178": [
  "from collections import deque\n\nn, m = map(int, input().split())\n\ngraph = [[] for i in range(n)]\n\ncosts = [[-1 for i in range(n)] for i in range(n)]\n\nfor i in range(m):\n    a, b = map(int, input().split())\n    graph[a - 1].append(b - 1)\n    graph[b - 1].append(a - 1)\n    costs[a - 1][b - 1] = 0\n    costs[b - 1][a - 1] = 0\n\nqueue = deque()\n\nfor i in range(n):\n    queue.append(i)\n    visited = [False for i in range(n)]\n    visited[i] = True\n    while len(queue) != 0:\n        cur_node = queue.popleft()\n        for neighbor in graph[cur_node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                costs[i][neighbor] = (costs[i][cur_node] + 1) % 3\n                queue.append(neighbor)\n\ninfinity = float(\"inf\")\ndp = [[infinity for j in range(3)] for i in range(n)]\n\nfor i in range(3):\n    dp[0][i] = i\n\nfor i in range(1, n):\n    for j in range(3):\n        for k in range(3):\n            if (j + k) % 3 != 1:\n                dp[i][j] = min(dp[i][j], dp[i - 1][k] + costs[i - 1][i] + j)\n\nanswer = infinity\nfor i in range(3):\n    answer = min(answer, dp[n - 1][i])\n\nif answer == infinity:\n    answer = -1\n\nprint(answer)"
 ],
 "3179": [
  "import math\n\nn,k=map(int,input().split())\nx=[0]*n\ny=[0]*n\nfor i in range(n):\n    x[i],y[i]=map(int,input().split())\n\n# Functions to calculate area of polygon and to check if all sides of polygon can be represented by a square of given side length\ndef polyarea(x, y):\n    area = 0.0\n    for i in range(-1, len(x) - 1):\n        area += x[i] * (y[i + 1] - y[i - 1])\n    return abs(area) / 2.0\n\ndef check(mid):\n    left=0\n    for i in range(1,n):\n        dist=math.sqrt((x[i]-x[left])**2 +(y[i]-y[left])**2)\n        while dist<=mid:\n            i+=1\n            if i>=n: return True\n            dist=math.sqrt((x[i]-x[left])**2 +(y[i]-y[left])**2)\n        left=i-1\n    return False\n\n# Binary search to find minimum square size\nlo,hi=0,polyarea(x,y)\nwhile hi-lo>1e-2:\n    mid=(lo+hi)/2\n    if check(mid):\n        hi=mid\n    else:\n        lo=mid\n\nprint(f\"{hi:.2f}\")"
 ],
 "3180": [
  "n, k, m = map(int, input().split())\n\ncanvas = [[1] * n for _ in range(n)] # initialize the canvas with white color\n\nstack = [] # to maintain the list of saved canvas\n\nfor _ in range(m):\n    command = input().split()\n    if command[0] == \"PAINT\":\n        c, x1, y1, x2, y2 = map(int, command[1:])\n        for i in range(x1, x2+1):\n            for j in range(y1, y2+1):\n                if canvas[i][j] == 1: # the cell is not painted yet\n                    canvas[i][j] = c\n                elif canvas[i][j] == -1*c: # the cell is already painted with the checkerboard color\n                    canvas[i][j] = 1\n                else: # the cell is painted with a different color\n                    stack.append((i, j, canvas[i][j])) # save the coordinates and previous color in the stack\n                    canvas[i][j] = -1*c # mark the cell as painted with the checkerboard color\n    elif command[0] == \"SAVE\":\n        stack.append([row[:] for row in canvas]) # make a deep copy of the canvas before saving it\n        \n    elif command[0] == \"LOAD\":\n        canvas = stack[int(command[1]) - 1] # load the canvas from the stack\n\nfor row in canvas:\n    print(*row)"
 ],
 "3181": [
  "n, k = map(int, input().split())\nif k > (n+1)//2:\n    print(-1)\nelse:\n    seq = list(range(1, k+1)) + list(range(k-1, 0, -1))\n    seq += list(range(k+1, n+1))\n    print(*seq)"
 ],
 "3182": [
  "n = int(input())\npoints = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    points.append((x, y))\n\ncount = 0\nfor i in range(n):\n    for j in range(i+1, n):\n        for k in range(j+1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            x3, y3 = points[k]\n            if (x2-x1)*(x3-x1) + (y2-y1)*(y3-y1) == 0 or (x1-x2)*(x3-x2) + (y1-y2)*(y3-y2) == 0 or (x1-x3)*(x2-x3) + (y1-y3)*(y2-y3) == 0:\n                count += 1\n                \nprint(count)           "
 ],
 "3183": [
  "import sys\nfrom heapq import *\nfrom math import inf\n\n\ndef dijkstra(edges, N, s, t):\n    res = 0\n    cost = 0\n    prev_v = [-1 for i in range(N)]\n    prev_e = [-1 for i in range(N)]\n    pot = [0 for i in range(N)]\n    h = [(0, s)]\n    \n    while len(h) > 0:\n        d, v = heappop(h)\n        if d > pot[v]:\n            continue\n        for i, (to, cap, cost) in enumerate(edges[v]):\n            cap_residual = cap - d\n            if cap_residual <= 0:\n                continue\n            w = cost + pot[v] - pot[to]\n            if d + w + pot[to] < pot[t]:\n                pot[t] = d + w + pot[to]\n            if pot[v] + w >= pot[to]:\n                continue\n            heappush(h, (d + w, to))\n            pot[to] = pot[v] + w\n            prev_v[to] = v\n            prev_e[to] = i\n    \n    if pot[t] == inf:\n        return (-1, -1)\n    \n    f = inf\n    v = t\n    while v != s:\n        f = min(f, edges[prev_v[v]][prev_e[v]][1] - pot[prev_v[v]] + pot[v])\n        v = prev_v[v]\n    \n    v = t\n    while v != s:\n        e = edges[prev_v[v]][prev_e[v]]\n        res += f\n        cost += f * e[2]\n        edges[prev_v[v]][prev_e[v]][1] -= f\n        edges[v][e[3]][1] += f\n        v = prev_v[v]\n    \n    return (res, cost)\n\n\nif __name__ == '__main__':\n    N, M, s, t = map(int, input().split())\n    edges = [[] for _ in range(N)]\n    for i in range(M):\n        u, v, c, w = map(int, input().split())\n        edges[u].append([v, c, w, len(edges[v])])\n        edges[v].append([u, 0, -w, len(edges[u])-1])\n    pot = [0 for i in range(N)]\n    for i in range(N-1):\n        for v in range(N):\n            for e in edges[v]:\n                if e[1] is not 0:\n                    pot[e[0]] = min(pot[e[0]], pot[v] + e[2])\n    \n    res = 0\n    cost = 0\n    while True:\n        r = dijkstra(edges, N, s, t)\n        if r[0] == -1:\n            break\n        res += r[0]\n        cost += r[1]\n    print(res, cost)"
 ],
 "3184": [
  "n, k = map(int, input().split())\nwalls = [False] * n\n\nfor i in range(k):\n    a, b = map(int, input().split())\n    if a <= b:\n        for j in range(a-1, b):\n            walls[j] = True\n    else:\n        for j in range(a-1, n):\n            walls[j] = True\n        for j in range(b):\n            walls[j] = True\n\nif all(walls):\n    print(1)\nelse:\n    count = 0\n    for i in range(n):\n        if not walls[i]:\n            if i == n-1:\n                if not walls[0]:\n                    count += 1\n            else:\n                if not walls[i+1]:\n                    count += 1\n    if count > 0:\n        print(count)\n    else:\n        print(\"impossible\")"
 ],
 "3185": [
  "import math\nfact = int(input())\nn = 0\nwhile fact > 1:\n    fact //= math.factorial(fact)\n    n += 1\nprint(n)"
 ],
 "3186": [
  "n, m, k = map(int, input().split())\nmod = 1000007\nfac = [1] * (n*m+1)\ninv = [1] * (n*m+1)\nfor i in range(2, n*m+1):\n    fac[i] = (fac[i-1]*i) % mod\n    inv[i] = inv[mod%i] * (mod-mod//i) % mod\n    # By euler's theorem, mod-inverse of a number\n    # modulo prime p, is a^(p-2) modulo p\n    fac[i] = (fac[i]*fac[i-1]) % mod\n    inv[i] = (inv[i]*inv[i-1]) % mod\nres = (fac[n*m] * inv[k] % mod * inv[n*m-k]) % mod\nres = (res * pow(fac[m], n, mod)) % mod\nprint(res)"
 ],
 "3187": [
  "from bisect import bisect_left\n\nn = int(input())\nx_coords, y_coords = [], []\n\nfor i in range(n):\n    x, y = map(int, input().split())\n    x_coords.append(x)\n    y_coords.append(y)\n\nd = int(input())\n\nx_coords.sort()\ny_coords.sort()\n\ndef distance(x, y):\n    return sum(abs(xi-x) + abs(yi-y) for xi,yi in zip(x_coords, y_coords))\n\ndef feasible(mid):\n    for i in range(n):\n        x_idx = bisect_left(x_coords, x_coords[i] - mid)\n        y_idx = bisect_left(y_coords, y_coords[i] - mid)\n        if x_idx == n or x_coords[x_idx] - x_coords[i] > mid:\n            continue\n        if y_idx == n or y_coords[y_idx] - y_coords[i] > mid:\n            continue\n        if distance(x_coords[x_idx], y_coords[y_idx]) - abs(x_coords[x_idx] - x_coords[i]) - abs(y_coords[y_idx] - y_coords[i]) <= mid:\n            return True\n    return False\n\nleft, right = 0, max(max(x_coords), max(y_coords))\n\nwhile left < right:\n    mid = (left + right) // 2\n    if feasible(mid):\n        right = mid\n    else:\n        left = mid + 1\n\nif feasible(right):\n    print(right)\nelse:\n    print(\"impossible\")"
 ],
 "3188": [
  "import sys\n    \ndef main():\n    n = int(input().strip())\n    x = []\n    y = []\n    z = []\n    for i in range(n):\n        xi, yi, zi = map(int, input().split())\n        x.append(xi)\n        y.append(yi)\n        z.append(zi)\n    x.sort()\n    y.sort()\n    z.sort()\n    print(max(x[n - 1] - x[0], y[n - 1] - y[0], z[n - 1] - z[0]))\nif __name__ == '__main__':\n    main()"
 ],
 "3189": [
  "n, m = map(int, input().split())\nnums = []\nfor i in range(m):\n    switch = input().strip()\n    light = input().strip()\n    nums.append((switch, light))\ncount = 0\nfor i in range(n):\n    on_switches = set([j for j in range(m) if nums[j][0][i] == \"1\"]) # set of switches that are on in the ith position\n    on_lights = set([j for j in range(m) if nums[j][1][i] == \"1\"]) # set of lights that are on in the ith position\n    if len(on_lights) == 0 or len(on_switches) == 0: # if no light is on or no switch is on in ith position\n        continue\n    elif on_switches == on_lights: # if every light that is on has a switch that is on too\n        count += 1\n    else:\n        break\nprint(count % 1000003)"
 ],
 "3190": [
  "n = int(input())\na = list(map(int, input().split()))\np = int(input())\n\ncount = 0\ns = 0\nj = 0\n\nfor i in range(n):\n    while j < n and (s+a[j])/(j-i+1) >= p:\n        s += a[j]\n        j += 1\n    count += j - i\n    s -= a[i]\n\nprint(count)"
 ],
 "3191": [
  "n, r, p = map(int, input().split())\nlo = 0\nhi = r - 1\nans = r\nwhile lo <= hi:\n    mid = (lo + hi) // 2\n    if (mid + 1) * p >= r:\n        ans = mid\n        hi = mid - 1\n    else:\n        lo = mid + 1\nprint(ans)"
 ],
 "3192": [
  "from collections import deque\n\nn = int(input())\nnames = input().split()\ngraph = {name: [] for name in names}\n\n# Build the graph\nfor i in range(n):\n    file_name, num_dependencies = input().split()\n    num_dependencies = int(num_dependencies)\n    dependencies = input().split()[1:]\n    for dependency in dependencies:\n        graph[file_name].append(dependency)\n\n# Check for cycles\nfor start_node in names:\n    queue = deque([start_node])\n    visited = set()\n    parent_map = {start_node: None}  # Keep track of parents to find the actual cycle\n    while queue:\n        curr_node = queue.popleft()\n        visited.add(curr_node)\n        for neighbor in graph[curr_node]:\n            if neighbor in visited:  # Cycle detected!\n                cycle = [curr_node, neighbor]\n                parent = curr_node\n                while parent_map[parent] != neighbor:\n                    cycle.append(parent_map[parent])\n                    parent = parent_map[parent]\n                cycle.append(neighbor)\n                print(' '.join(cycle))\n                exit()\n            else:\n                parent_map[neighbor] = curr_node\n                queue.append(neighbor)\n\nprint(\"SHIP IT\")  # No cycle found"
 ],
 "3193": [
  "from sympy.parsing.sympy_parser import (parse_expr, standard_transformations,\n                                        implicit_multiplication_application)\ntransformations = (standard_transformations +\n                   (implicit_multiplication_application,))\nA = input()\nP, M = map(int, input().split())\nexpr = parse_expr(A.replace('x', '*x'), transformations=transformations)\nprint(min(x % M for x in range(M) if expr.subs(x, 0) % M == P))"
 ],
 "3194": [
  "n, t = map(int, input().split())\nphotographs = []\nfor _ in range(n):\n    a, b = map(int, input().split())\n    photographs.append((a, b))\nphotographs.sort()\ncurrent_time = photographs[0][0]\nfor i in range(n):\n    if current_time + t < photographs[i][0]:\n        print('no')\n        break\n    current_time = max(current_time + t, photographs[i][0])\nelse:\n    if current_time + t <= photographs[-1][1]:\n        print('yes')\n    else:\n        print('no')"
 ],
 "3195": [
  "from bisect import bisect_left\n\nGREEN, YELLOW, RED = range(3)\n\nTg, Ty, Tr = map(int, input().split())\nn = int(input())\nts, states = [], []\nfor i in range(n):\n    t, state = input().split()\n    ts.append(int(t))\n    if state == 'green':\n        states.append(GREEN)\n    elif state == 'yellow':\n        states.append(YELLOW)\n    else:\n        states.append(RED)\ntq, cq = input().split()\ntq = int(tq)\nif cq == 'green':\n    cq = GREEN\nelif cq == 'yellow':\n    cq = YELLOW\nelse:\n    cq = RED\n\nperiod = Tg + Ty + Tr\ncan_be_greens = []\nfor i in range(period):\n    can_be_green = True\n    for j in range(n-1):\n        time_since_last_observation = (ts[j+1] - ts[j]) % period\n        if states[j] == GREEN:\n            if i <= time_since_last_observation < Tg+i:\n                pass\n            elif Tg+i <= time_since_last_observation < Tg+Ty+i:\n                can_be_green = False\n                break\n            else:\n                break\n        elif states[j] == YELLOW:\n            if not (Tg+i <= time_since_last_observation < Tg+Ty+i):\n                can_be_green = False\n                break\n        else:\n            if not (Tg+Ty+i <= time_since_last_observation < period+i):\n                can_be_green = False\n                break\n    can_be_greens.append(can_be_green)\n\nif all(c != cq for c in states) or cq == YELLOW and Tr == 0:\n    print(0)\nelse:\n    time_since_last_observation = (tq - ts[-1]) % period\n    i = bisect_left(ts, tq)\n    if i == n:\n        if states[-1] != RED:\n            print(1)\n        else:\n            print(int(can_be_greens[time_since_last_observation]))\n    else:\n        if states[i] == cq:\n            print(1 if time_since_last_observation >= period - Tr else 0)\n        elif cq == GREEN:\n            print(int(can_be_greens[time_since_last_observation]))\n        else:\n            print(int(not can_be_greens[time_since_last_observation]))"
 ],
 "3196": [
  "from collections import deque\n\nn, m = map(int, input().split())\nedges = [[] for _ in range(n)]\n\nfor i in range(m):\n    a, b = map(int, input().split())\n    edges[a-1].append(b-1)\n\ncounts = [0] * n\ncounts[0] = 1\nq = deque([0])\n\nwhile q:\n    u = q.popleft()\n    for v in edges[u]:\n        counts[v] += counts[u]\n        counts[v] %= 10**9\n        if v == 1 and counts[v] >= 10**9:\n            print(\"inf\")\n            exit()\n        if counts[v] != 0:\n            q.append(v)\n\nprint(counts[1])"
 ],
 "3197": [
  "n, k = map(int, input().split())\nx = list(map(int, input().split()))\n\ncount = [0] * (n+1)\nfor i in range(n):\n    count[x[i]] += 1\n\nans = k\nfor i in range(1, n+1):\n    if count[i] > k:\n        ans += k - count[i]\n    else:\n        ans -= k - count[i] if k - count[i] < ans - count[i] else 0\n\nprint(ans)"
 ],
 "3198": [
  "n = int(input())\nwords = []\nfor i in range(n):\n    words.append(input())\ntypos = []\nfor i in range(n):\n    word = words[i]\n    for j in range(len(word)):\n        if word[:j] + word[j+1:] in words:\n            typos.append(word)\n            break\nif len(typos) == 0:\n    print(\"NO TYPOS\")\nelse:\n    for word in typos:\n        print(word)"
 ],
 "3199": [
  "A, B = map(int, input().split())\nL = int(input())\n\n# calculate total vaults\ntotal_vaults = L * (A +1 +B)\n\n# initialize counts\ninsecure_count = 0\nsecure_count = 0\nsuper_secure_count = 0\n\nfor i in range(1, L+1):\n    for j in range(-A, B+1):\n        # calculate number of vaults blocking line of sight for both guards\n        left_vaults = i - 1 - max(0, j + A)\n        right_vaults = total_vaults - left_vaults - 1\n        \n        if left_vaults == 0 or right_vaults == 0:\n            super_secure_count += 1\n        elif left_vaults == 1 or right_vaults == 1:\n            secure_count += 1\n        else:\n            insecure_count += 1\n\n# print results\nprint(insecure_count)\nprint(secure_count)\nprint(super_secure_count)"
 ],
 "3200": [
  "import math\n\nn = int(input())\nlights = []\nfor i in range(n-1):\n    t, g, r = map(int, input().split())\n    lights.append((t, g, r))\n\ndist = 1000 * n\ntime = [float('inf')] * (dist + 1)\ntime[0] = 0\n\nfor i in range(dist):\n    if time[i] == float('inf'):\n        continue\n    speed = 0\n    for j in range(n-1):\n        light_pos = 1000 * (j+1)\n        light_t, light_g, light_r = lights[j]\n        light_state = (time[i] + i // light_pos) % (light_g + light_r)\n        if light_state < light_g:\n            wait_time = 0\n        else:\n            wait_time = light_g + light_r - light_state\n        speed += wait_time\n    for accel_time in range(1, 32+1):\n        if speed + accel_time > 200:\n            break\n        new_speed = speed + accel_time\n        new_pos = i + new_speed + accel_time // 2\n        if new_pos >= dist:\n            new_pos = dist\n            time[new_pos] = min(time[new_pos], time[i] + accel_time + (dist-i)/new_speed)\n            break\n        time[new_pos] = min(time[new_pos], time[i] + accel_time + math.sqrt(2*new_pos/new_speed))\nprint(\"{:.10f}\".format(time[dist]))"
 ],
 "3201": [
  "import sys\ninput = sys.stdin.readline\n\nn,k,b,m = map(int,input().split())\na = list(map(int,input().split()))\n\nB = [1]*(n+1)\nfor i in range(1,n+1):\n    B[i] = B[i-1]*b%m\n\nS = [[0]*(n+1) for _ in range(n+1)]\nfor i in range(1,n+1):\n    for j in range(i,n+1):\n        S[i][j] = (S[i][j-1]*b%m + a[j-1])%m\n\nh = [0]*(2**n)\nfor i in range(n):\n    h[1<<i] = a[i]\n\nfor i in range(1,2**n):\n    if h[i]:\n        continue\n    x = i&-i\n    h[i] = (h[i^x]*B[len(bin(x))-2]+S[len(bin(x))-1][i.bit_length()-1])%m\n\nfor i in range(1,k+1):\n    print(h[i])"
 ],
 "3202": [
  "n, k = map(int, input().split())\nmarbles = list(map(int, input().split()))\n\ncount = 0\nprev_color = None\nfor color in marbles:\n    if color == prev_color:\n        count += 1\n        if count == k:\n            count = 0\n            n += 1\n    else:\n        count = 1\n    prev_color = color\n\nprint(n - len(marbles))"
 ],
 "3203": [
  "import itertools\n\nn = int(input())\nprobs = []\nfor i in range(n):\n    probs.append(list(map(int, input().split())))\n\nmax_prob = 0\nfor arrangement in itertools.permutations(range(n)):\n    prob = 1\n    for i, j in enumerate(arrangement):\n        prob *= probs[i][j] / 100\n    max_prob = max(max_prob, prob)\n\nprint(max_prob * 100)"
 ],
 "3204": [
  "n = int(input())\nboats = []\nfor i in range(n):\n    boats.append(int(input()))\n\ntime_wasted = 0\nbridge_available = boats[0] + 30\nfor i in range(n-1):\n    if bridge_available <= boats[i+1]:\n        # raise and lower the bridge and update bridge_available\n        time_wasted += 60\n        bridge_available = boats[i+1] + 30\n    else:\n        # let the boats pass one by one and update bridge_available\n        time_wasted += 20\n        bridge_available += 20\n\nprint(time_wasted)"
 ],
 "3205": [
  "from collections import defaultdict\n\nm, n = map(int, input().split())\n\nbalance = [0] * m\n\nfor _ in range(n):\n    a, b, p = map(int, input().split())\n    balance[a] -= p\n    balance[b] += p\n\npos_bal = [b for b in balance if b > 0]\nneg_bal = [-b for b in balance if b < 0]\n\npos_bal.sort()\nneg_bal.sort()\n\nnum_transactions = 0\n\nwhile pos_bal and neg_bal:\n    sender = neg_bal.pop()\n    receiver = pos_bal.pop()\n    transfer = min(sender, receiver)\n    sender -= transfer\n    receiver -= transfer\n    num_transactions += 1\n    if sender > 0:\n        neg_bal.append(sender)\n    if receiver > 0:\n        pos_bal.append(receiver)\n\nprint(num_transactions)"
 ],
 "3206": [
  "import itertools\n\nn, s = map(int, input().split())\nblocks = list(map(int, input().split()))\nbuilding_heights = list(map(int, input().split()))\n\npossible_combinations = []\nfor i in range(1, n+1):\n    for combination in itertools.combinations(range(n), i):\n        if sum(blocks[j] for j in combination) in building_heights:\n            possible_combinations.append(combination)\n            \nif len(possible_combinations) < s:\n    print(-1)\nelse:\n    for i in range(s):\n        for j, combination in enumerate(possible_combinations):\n            if sum(blocks[k] for k in combination) == building_heights[i]:\n                print(len(combination), end=' ')\n                for index in combination:\n                    print(index+1, end=' ')\n                print()\n                possible_combinations.pop(j)  # remove used combination\n                break  # move to next building"
 ],
 "3207": [
  "from collections import deque\nimport sys\n\nn, k, L = map(int, input().split())\n\nleft_chameleons = [deque() for _ in range(k)]\nright_chameleons = [deque() for _ in range(k)]\npositions = [0] * n\ncolors = [0] * n\ndirections = [''] * n\nfor i in range(n):\n    position, color, direction = input().split()\n    positions[i] = int(position)\n    colors[i] = int(color)\n    directions[i] = direction\n    if direction == 'L':\n        left_chameleons[color].append(positions[i])\n    else:\n        right_chameleons[color].append(positions[i])\n\ntotal_trips = [0] * k\nfor color in range(k):\n    while left_chameleons[color] or right_chameleons[color]:\n        if left_chameleons[color]:\n            curr_position = left_chameleons[color].popleft()\n            total_trips[color] += curr_position - sum(positions[:i] for i, p in enumerate(right_chameleons[color]) if p < curr_position)\n            if right_chameleons[color]:\n                color_right = colors[n - 1 - len(right_chameleons[color])]\n                right_chameleons[color].popleft()\n                new_color = (color + color_right) % k\n                left_chameleons[new_color].append(L - curr_position)\n                colors.append(new_color)\n                directions.append('R')\n                positions.append(L - curr_position)\n        if right_chameleons[color]:\n            curr_position = right_chameleons[color].popleft()\n            total_trips[color] += L - curr_position - sum(L - positions[i] for i, p in enumerate(left_chameleons[color]) if p > curr_position)\n            if left_chameleons[color]:\n                color_left = colors[len(left_chameleons[color]) - 1]\n                left_chameleons[color].popleft()\n                new_color = (color + color_left) % k\n                right_chameleons[new_color].append(L - curr_position)\n                colors.append(new_color)\n                directions.append('L')\n                positions.append(L - curr_position)\n\nfor t in total_trips:\n    print(\"{:.1f}\".format(t))"
 ],
 "3208": [
  "import itertools\n\nknown_words = {\"be\", \"our\", \"rum\", \"will\", \"dead\", \"hook\", \"ship\", \"blood\", \"sable\", \"avenge\", \"parrot\", \"captain\"}\n\nencrypted_text = input()\nunique_letters = set(encrypted_text)\n\nfor subset in itertools.combinations(known_words, 3):\n    letters = set(\"\".join(subset))\n    if len(letters) != len(unique_letters):\n        continue\n    mapping = dict(zip(letters, unique_letters))\n    decrypted_text = encrypted_text.translate(str.maketrans(mapping))\n    if all(word in decrypted_text for word in subset):\n        print(decrypted_text)\n        break\nelse:\n    print(\"Impossible\")"
 ],
 "3209": [
  "import heapq\n\n########################\n# HELPER FUNCTIONS\n########################\n\n# convert time in minutes to HH:MM format\ndef format_time(minutes: int) -> str:\n    hours = minutes // 60\n    minutes %= 60\n    return f\"{hours:02}:{minutes:02}\"\n\n# convert time in HH:MM format to minutes\ndef convert_time(time_str: str) -> int:\n    hours, minutes = map(int, time_str.split(\":\"))\n    return hours*60 + minutes\n\n########################\n# MAIN FUNCTION\n########################\n\ndef main():\n    # read input\n    origin, destination = input().split()\n    n = int(input())\n    trains = {}\n    for i in range(n):\n        s, e, dep, duration, delay_pct, delay_max = input().split()\n        dep = convert_time(dep)\n        duration = int(duration)\n        delay_pct = int(delay_pct)/100\n        delay_max = int(delay_max)\n        if s not in trains:\n            trains[s] = {}\n        if e not in trains:\n            trains[e] = {}\n        trains[s][e] = (dep, duration, delay_pct, delay_max)\n\n    # initialize data structures for Dijkstra's algorithm\n    INF = float(\"inf\")\n    visited = {origin: {0: 0.0}}\n    heap = [(0.0, 0, origin)]  # (expected duration, minutes delayed, location)\n\n    while heap:\n        exp_duration, minutes_delayed, curr = heapq.heappop(heap)\n        if curr == destination:\n            print(f\"{exp_duration:.6f}\")\n            return\n        if curr not in trains:\n            continue\n        for nxt, (dep, duration, delay_pct, delay_max) in trains[curr].items():\n            # calculate expected duration and minutes delayed for next location\n            if delay_pct == 0:\n                exp_duration_nxt = exp_duration + duration\n                minutes_delayed_nxt = minutes_delayed\n            else:\n                prob_nxt_delayed = delay_pct * min(1, (minutes_delayed+1)/delay_max)\n                exp_duration_nxt = exp_duration + (1-prob_nxt_delayed)*duration + prob_nxt_delayed*(duration+delay_max)\n                minutes_delayed_nxt = min(minutes_delayed+1, delay_max)\n            # check if next location has already been visited with lower expected duration\n            if nxt in visited and (minutes_delayed_nxt in visited[nxt]) and (exp_duration_nxt >= visited[nxt][minutes_delayed_nxt]):\n                continue\n            # add next location to heap\n            if nxt not in visited:\n                visited[nxt] = {}\n            visited[nxt][minutes_delayed_nxt] = exp_duration_nxt\n            heapq.heappush(heap, (exp_duration_nxt, minutes_delayed_nxt, nxt))\n\n    # output \"IMPOSSIBLE\" if destination is not reachable\n    print(\"IMPOSSIBLE\")\n\n\nif __name__ == \"__main__\":\n    main()"
 ],
 "3210": [
  "from collections import deque\nn = int(input())\ngrid = [input() for _ in range(2*n-1)]\n\ndef bfs(x, y):\n    color = [[None]*n for _ in range(n)]\n    queue = deque([(x, y)])\n    color[x][y] = True\n    score = 0\n    while queue:\n        x, y = queue.popleft()\n        if x-1 >= 0 and y-1 >= 0 and grid[2*x-1][2*y-2] == '-' \\\n        and grid[2*x-2][2*y-1] == '|' and grid[2*x-1][2*y] == '-' and color[x-1][y-1] is None:\n            queue.append((x-1, y-1))\n            color[x-1][y-1] = not color[x][y]\n        if x-1 >= 0 and y+1 < n and grid[2*x-1][2*y] == '-' \\\n        and grid[2*x-2][2*y+1] == '|' and grid[2*x-1][2*y+2] == '-' and color[x-1][y+1] is None:\n            queue.append((x-1, y+1))\n            color[x-1][y+1] = not color[x][y]\n        if x+1 < n and y-1 >= 0 and grid[2*x+1][2*y-2] == '-' \\\n        and grid[2*x][2*y-1] == '|' and grid[2*x+1][2*y] == '-' and color[x+1][y-1] is None:\n            queue.append((x+1, y-1))\n            color[x+1][y-1] = not color[x][y]\n        if x+1 < n and y+1 < n and grid[2*x+1][2*y] == '-' \\\n        and grid[2*x][2*y+1] == '|' and grid[2*x+1][2*y+2] == '-' and color[x+1][y+1] is None:\n            queue.append((x+1, y+1))\n            color[x+1][y+1] = not color[x][y]\n        \n    score = sum(1 for i in range(n) for j in range(n) if color[i][j])\n    return (score, score*n*n - (n*n - 2*n + 1 - score*2))\n\ncount = 0\nfor i in range(n):\n    for j in range(n):\n        if grid[2*i][2*j] == '.':\n            score, move = bfs(i, j)\n            if score == 0:\n                count = max(count, move)\nprint(count)"
 ],
 "3211": [
  "n = int(input())\ns = input().strip()\nparty_1_votes = s.count('1')\nif party_1_votes * 2 > n:\n    print(0)\nelif party_1_votes * 2 == n:\n    print('impossible')\nelse:\n    teller_indices = [i for i in range(n) if s[i] == '0']\n    num_tellers = len(teller_indices)\n    num_swaps = 0\n    while party_1_votes <= n/2 and num_tellers > 0:\n        next_teller_idx = teller_indices[-num_tellers]\n        next_citizen_idx = next_teller_idx + 1\n        while next_citizen_idx < n and s[next_citizen_idx] == '2':\n            next_citizen_idx += 1\n        if next_citizen_idx == n:\n            break\n        s_list = list(s)\n        s_list[next_teller_idx], s_list[next_citizen_idx] = s_list[next_citizen_idx], s_list[next_teller_idx]\n        s = ''.join(s_list)\n        num_swaps += 1\n        num_tellers -= 1\n        party_1_votes += 1\n    if party_1_votes * 2 > n:\n        print(num_swaps)\n    else:\n        print('impossible')"
 ],
 "3212": [
  "from math import sqrt\n\ndef can_reach(x1, y1, x2, y2, d, n):\n    \"\"\"\n    Check if Bill can travel from (x1,y1) to (x2,y2) without being bitten\n    by any of the snakes given in the first n lines of input\n    \"\"\"\n    for i in range(n):\n        xi, yi, di = map(int, input().split())\n        # Calculate the distance between the line connecting (x1,y1) and (x2,y2) and the current snake\n        dist = abs((y2-y1)*xi - (x2-x1)*yi + x2*y1 - y2*x1) / sqrt((y2-y1)**2 + (x2-x1)**2)\n        # If the distance is less than the snake's strike distance, Bill will be bitten\n        if dist < di:\n            return False\n    return True\n\nn = int(input())\nfound = False\nmin_y = float('inf')\nfor i in range(1001):\n    if can_reach(0, 1000, 1000, i, 0, n):\n        found = True\n        if i < min_y:\n            min_y = i\n            enter_coords = (0, 1000-i)\nfor i in range(1001):\n    if can_reach(0, 0, 1000, 1000-i, 0, n):\n        found = True\n        if 1000-i < min_y:\n            min_y = 1000-i\n            leave_coords = (1000, 1000-i)\nif found:\n    print(f\"Bill enters at {enter_coords[0]:.2f}, {enter_coords[1]:.2f} and leaves at {leave_coords[0]:.2f}, {leave_coords[1]:.2f}.\")\nelse:\n    print(\"Bill will be bitten.\")"
 ],
 "3213": [
  "m, s = map(int, input().split())\nsteps = input()\n\nP = [1] * (m+1)\nCP = [1] * (m+1)\nfor i in range(1, m+1):\n    P[i] = 2 * P[i-1] if steps[i-1] == 'x' else P[i-1] + 1\n    CP[i] = P[i] % (1 << s)\n\nIS = [0] * (m+1)\nLS = [0] * (m+1)\nirs = irsl = 0\nfor i in range(m, -1, -1):\n    IS[i] = irs\n    LS[i] = irsl\n    if CP[i] == 0:\n        irs = i\n        irsl = 0\n    if LS[i] == 0:\n        irsl = i\n\nans = []\nfor i in range(m):\n    if steps[i] == 'x':\n        if LS[i] <= IS[i+1]:\n            ans.append('o')\n        else:\n            ans.append('x')\n    else:\n        if CP[i+1] != 0 and LS[i] != 0:\n            ans.append('o')\n        else:\n            ans.append('+')\n\nprint(''.join(ans))"
 ],
 "3214": [
  "from typing import List\nimport re\n\n\ndef get_core(word: str) -> str:\n    return re.sub('[^a-zA-Z]', '', word.lower())\n\n\ndef get_similar_words(text: List[str]) -> dict:\n    word_freq = {}\n    for line in text:\n        words = re.findall('[a-zA-Z]+', line)\n        for word in words:\n            core = get_core(word)\n            if core not in word_freq:\n                word_freq[core] = {word}\n            else:\n                word_freq[core].add(word)\n\n            for i in range(len(word)):\n                # delete one character\n                new_word = word[:i] + word[i+1:]\n                new_core = get_core(new_word)\n                if new_core not in word_freq:\n                    word_freq[new_core] = {word}\n                else:\n                    word_freq[new_core].add(word)\n\n                for letter in 'abcdefghijklmnopqrstuvwxyz':\n                    # insert one character\n                    new_word = word[:i] + letter + word[i:]\n                    new_core = get_core(new_word)\n                    if new_core not in word_freq:\n                        word_freq[new_core] = {word}\n                    else:\n                        word_freq[new_core].add(word)\n\n                    # replace one character\n                    if word[i] != letter:\n                        new_word = word[:i] + letter + word[i+1:]\n                        new_core = get_core(new_word)\n                        if new_core not in word_freq:\n                            word_freq[new_core] = {word}\n                        else:\n                            word_freq[new_core].add(word)\n\n                    # transpose adjacent characters\n                    if i < len(word) - 1 and word[i+1] != word[i]:\n                        new_word = word[:i] + word[i+1] + word[i] + word[i+2:]\n                        new_core = get_core(new_word)\n                        if new_core not in word_freq:\n                            word_freq[new_core] = {word}\n                        else:\n                            word_freq[new_core].add(word)\n\n    return {k: sorted(list(v - {k})) for k, v in word_freq.items() if len(v - {k}) > 0}\n\n\ntext = []\nwhile True:\n    line = input()\n    if line == '***':\n        break\n    text.append(line)\n\nsimilar_words = get_similar_words(text)\nif not similar_words:\n    print('***')\nelse:\n    for core in sorted(similar_words.keys()):\n        print(f'{core}: {\" \".join(similar_words[core])}')"
 ],
 "3215": [
  "n = int(input())\ncards = list(map(int, input().split()))\n\ndef min_shuffles(cards):\n    halves = []\n    iterations = 0\n    while True:\n        iterations += 1\n        halflen = (len(cards) + 1) // 2\n        halves = [cards[:halflen], cards[halflen:]]\n        cards = []\n        for i in range(halflen):\n            try:\n                cards.append(halves[0][i])\n            except IndexError:\n                break\n            try:\n                cards.append(halves[1][i])\n            except IndexError:\n                break\n        if iterations > 5:\n            break\n    return iterations\n\nprint(min_shuffles(cards))"
 ],
 "3216": [
  "from fractions import Fraction\ns, r = input().split()\nr = int(r)\na, b = s.split('.')\nn = len(b)\nif r == n: \n    x = int(a+b)\nelse:\n    x = int(a+b[0:n-r] + b[n-r+1:n])\ny = int('9'*(n-r) + '0'*r)\ngcd_value = Fraction(x,y).denominator\nprint(Fraction(x//gcd_value,y//gcd_value))"
 ],
 "3217": [
  "from itertools import product\n\nn = int(input())\ncoords = set(tuple(map(int, input().split())) for _ in range(n))\n\n# handle cases where there are no failing cells or only one failing cell\nif n <= 1:\n    print(6 if n == 1 else 0)\nelse:\n    # create a set of all possible neighboring cells\n    neighbors = set((x+i,y+j,z+k) for x,y,z in coords for i,j,k in product((-1,0,1), repeat=3))\n    # subtract the set of failing cells from the set of neighboring cells to get the set of potential panels\n    panels = neighbors - coords\n    # count the number of potential panels\n    print(len(panels))"
 ],
 "3218": [
  "from collections import deque\n\ndef dfs(c, v, p, g, loop):\n    v[c] = True\n    loop[c] = True\n    for d in g[c]:\n        if not v[d]:\n            dfs(d, v, c, g, loop)\n        elif d != p and loop[d]:\n            v[0] = True\n\ndef count_loops(g):\n    n = len(g)\n    v = [False] * n\n    loops = 1\n    for i in range(n):\n        if not v[i]:\n            loop = [False] * n\n            dfs(i, v, -1, g, loop)\n            if v[0]:\n                return -1\n            edges = sum(len(g[c]) for c in range(n) if loop[c]) // 2\n            loops *= 3 ** max(0, edges - len(loop) + 1)\n    return loops\n\nn = int(input())\na = [tuple(map(int, input().split())) for _ in range(n)]\n\nc = 0\ng = []\nfor i in range(n):\n    row = []\n    for j in range(n - abs(n // 2 - i)):\n        row.append(c)\n        c += 1\n    g.append(row)\n\nfor i in range(n):\n    for j in range(n - abs(n // 2 - i)):\n        if a[i][j] != -1:\n            for dy, dx in [(i % 2, 1), (i % 2, -1 if j == 0 else 1), (1, 0)]:\n                y, x = i + dy, j + dx\n                if y >= n or x >= n - abs(n // 2 - y) or x < 0:\n                    continue\n                if a[y][x] == -1:\n                    continue\n                g[g[i][j]].append(g[y][x])\n                g[g[y][x]].append(g[i][j])\n\nprint(count_loops(g))"
 ],
 "3219": [
  "MOD = 1000000009\n\ndef main():\n    s = input().strip()\n    n = len(s)\n\n    f = [0]*(n+1)\n    f[0] = 1\n\n    for i in range(n):\n        if s[i] == '0':\n            f[i+1] = f[i]\n        elif s[i] == '1':\n            f[i+1] = f[i]*2\n        else:\n            f[i+1] = f[i]*2 + f[i-1]\n\n        f[i+1] %= MOD\n\n    print(f[n])\n\nif __name__ == '__main__':\n    main()"
 ],
 "3220": [
  "n = int(input())\np = list(map(int, input().split()))\n\nans = [None]*n\n\nfor i in range(n):\n    if ans[i]:\n        continue\n        \n    dir = ['L', 'R']\n    visited = {i}\n    pos = i\n    while True:\n        next_pos = (pos + p[pos]) % n\n        if next_pos in visited:\n            ans[pos] = 'L'\n            ans[next_pos] = 'R'\n            for j in visited:\n                if ans[j] is None:\n                    ans[j] = 'L'\n                    ans[(j + p[j]) % n] = 'R'\n            break\n        \n        visited.add(next_pos)\n        pos = next_pos\n        dir.remove('L' if p[pos] > 0 else 'R')\n        if not dir:\n            print('no dance')\n            exit()\n        ans[pos] = dir[0]\n\nprint(''.join(ans))"
 ],
 "3221": [
  "import sys\nfrom heapq import *\nfrom collections import defaultdict\n\nclass MinHeap():\n    def __init__(self):\n        self.heap = []\n    \n    def push(self, val):\n        heappush(self.heap, val)\n    \n    def pop(self):\n        return heappop(self.heap)\n    \n    def __bool__(self):\n        return bool(self.heap)\n    \n    def __len__(self):\n        return len(self.heap)\n\ndef solve():\n    N, M, alpha = map(int, input().split())\n    adj_list = defaultdict(list)\n    for i in range(M):\n        u, v, c = map(int, input().split())\n        adj_list[u].append((v, c))\n        adj_list[v].append((u, c))\n    \n    visited = [False] * (N+1)\n    def dfs(node, parent, path):\n        nonlocal max_candies\n        nonlocal max_depth\n        visited[node] = True\n        path.append(node)\n        \n        if len(path) > 1:\n            candies = [adj_list[path[-2]][i][1] for i in range(len(adj_list[path[-2]])) if adj_list[path[-2]][i][0] == node][0]\n            max_candies = max(max_candies, candies)\n        \n        for neighbor, _ in adj_list[node]:\n            if neighbor == parent:\n                continue\n            if visited[neighbor]:\n                # back edge, cycle!\n                global cycle_vertices\n                cycle_vertices = set()\n                idx = path.index(neighbor)\n                cycle_vertices.update(path[idx:])\n                cycle_vertices.add(node)\n                \n                for j in range(idx, len(path)-1):\n                    candies = [adj_list[path[j]][i][1] for i in range(len(adj_list[path[j]])) if adj_list[path[j]][i][0] == path[j+1]][0]\n                    max_candies = max(max_candies, candies)\n                \n                # update max_depth only if cycle is of odd length\n                cycle_len = len(cycle_vertices)\n                if cycle_len % 2 == 1:\n                    max_depth = max(max_depth, cycle_len//2+1)\n                \n                continue\n            dfs(neighbor, node, path)\n            path.pop()\n    \n    max_depth = 0\n    max_candies = 0\n    cycle_vertices = set()\n    for i in range(1, N+1):\n        if not visited[i]:\n            dfs(i, -1, [])\n            if cycle_vertices:\n                print(\"Poor girl\")\n                return\n    \n    # find maximum matching using greedy algorithm\n    matched = set()\n    heap = MinHeap()\n    for vertex in cycle_vertices:\n        for neighbor, candies in adj_list[vertex]:\n            if neighbor not in cycle_vertices:\n                heap.push((candies, vertex, neighbor))\n    while heap:\n        candies, a, b = heap.pop()\n        if a in matched or b in matched:\n            continue\n        matched.add(a)\n        matched.add(b)\n    \n    # calculate answer\n    if len(cycle_vertices) % 2 == 1:\n        # odd cycle length\n        ans = max_candies**2 + alpha*max_depth\n    elif len(matched) == len(cycle_vertices):\n        # all vertices in cycle are matched, can form Eulerian circuit\n        ans = sum(adj_list[v][i][1] for v in matched for i in range(len(adj_list[v])) if adj_list[v][i][0] in matched)\n        ans += alpha*(len(cycle_vertices)//2)\n        ans += 2*max_candies**2\n        ans -= max_candies**2\n    else:\n        # some vertices are unmatched, cannot form Eulerian circuit\n        ans = sum(adj_list[v][i][1] for v in matched for i in range(len(adj_list[v])) if adj_list[v][i][0] in matched)\n        ans += alpha*((len(cycle_vertices)-len(matched))//2)\n        ans += (len(matched)//2)*2*max_candies**2\n        ans += max_candies**2\n    print(ans)\n\nif __name__ == \"__main__\":\n    sys.setrecursionlimit(2*10**5)\n    solve()"
 ],
 "3222": [
  "n, m = map(int, input().split())\n\nedges = [[] for _ in range(n)]    # adjacency list to store the directed edges\n\nfor _ in range(m):\n    u, v = map(int, input().split())\n    edges[u].append(v)\n\nindegree = [0] * n   # list to store the indegree of each vertex\n\nfor u in range(n):\n    for v in edges[u]:\n        indegree[v] += 1 \n\n# topological sort\norder = []\nstack = [u for u in range(n) if indegree[u] == 0]\nwhile stack:\n    u = stack.pop()\n    order.append(u)\n    for v in edges[u]:\n        indegree[v] -= 1\n        if indegree[v] == 0:\n            stack.append(v)\n\nif len(order) < n:\n    print(\"Yeah!\")   # not possible to split the places into trips\nelse:\n    pos = 0\n    ans = []\n    while pos < n:\n        trip = []\n        # find the next unvisited vertex\n        while pos < n and indegree[order[pos]] == 0:\n            trip.append(order[pos])\n            pos += 1\n\n        if not trip:    # if we couldn't find an unvisited vertex, it means we've already visited all of them\n            break\n\n        # mark all vertices in the current trip as visited\n        for v in trip:\n            indegree[v] = -1\n\n        # traverse the current trip in reverse order and add the visited vertices to ans\n        for v in trip[::-1]:\n            ans.append(v)\n\n    print(len(ans) // n)\n    for i in range(0, len(ans), n):\n        print(n)\n        print(*ans[i:i+n])"
 ],
 "3223": [
  "from collections import deque\n\nV = int(input())\ndegrees = list(map(int, input().split()))\n\nif sum(degrees) % 2 != 0:\n    print(\"IMPOSSIBLE\")\nelse:\n    edges = []\n    q = deque(range(V))\n    while q:\n        u = q.popleft()\n        while degrees[u] > 0 and q:\n            v = q.popleft()\n            if degrees[v] > 0:\n                edges.append((u+1, v+1))\n                degrees[u] -= 1\n                degrees[v] -= 1\n                if degrees[v] > 0:\n                    q.append(v)\n            else:\n                q.append(v)\n        if degrees[u] > 0:\n            print(\"IMPOSSIBLE\")\n            break\n    else:\n        print(\"POSSIBLE\")\n        for u, v in edges:\n            print(u, v)"
 ],
 "3224": [
  "from math import sqrt\nfrom itertools import combinations  \n\npoints = [list(map(int, input().split())) for _ in range(4)]  # Taking four points as input\n\n# Function to calculate distance between two points\ndef dist(p1, p2):\n    x1, y1, z1 = p1\n    x2, y2, z2 = p2\n    return ((x2-x1)**2 + (y2-y1)**2 + (z2-z1)**2)**0.5\n\n# Generating a list of all possible pairs of points\npairs = combinations(points, 2)\n\n# Initializing variables to store the center and radius of the sphere\nxc, yc, zc = 0,0,0\nr = 0\n\n# Finding the center and radius of the sphere by solving the equations of sphere\nfor pair in pairs:\n    p1 = pair[0]\n    p2 = pair[1]\n    d = dist(p1, p2)\n    xm = (p1[0] + p2[0]) / 2\n    ym = (p1[1] + p2[1]) / 2\n    zm = (p1[2] + p2[2]) / 2\n    if d > r:\n        r = d / 2\n        xc = xm\n        yc = ym\n        zc = zm\n\n# Printing the coordinates of the center of the sphere\nprint(\"{:.10f} {:.10f} {:.10f}\".format(xc, yc, zc))"
 ],
 "3225": [
  "n = int(input())\nqueue = list(map(int, input().split()))\n\nminutes = []\nwhile True:\n    left = False\n    to_remove = set()\n    for i in range(1, n-1):\n        if queue[i-1] > queue[i] or queue[i+1] > queue[i]:\n            to_remove.add(i)\n            left = True\n    if not left:\n        break\n    for index in sorted(to_remove, reverse=True):\n        minutes.append(queue.pop(index))\n        n -= 1\n    minutes.append('\\n')\nminutes.append(queue)\n\nprint(len(minutes)-1)\nfor minute in minutes[:-1]:\n    print(' '.join(map(str, minute)))\nprint(' '.join(map(str, minutes[-1])))"
 ],
 "3226": [
  "import heapq\n\nclass Edge:\n    def __init__(self, to, weight):\n        self.to = to\n        self.weight = weight\n\nclass Dijkstra:\n    def __init__(self, num_nodes, start):\n        self.num_nodes = num_nodes\n        self.start = start\n        self.edges = [[] for _ in range(num_nodes)]\n        self.distances = [float('inf') for _ in range(num_nodes)]\n        \n    def add_edge(self, u, v, w):\n        self.edges[u].append(Edge(v, w))\n        self.edges[v].append(Edge(u, w))\n        \n    def solve(self):\n        pq = []\n        self.distances[self.start] = 0\n        heapq.heappush(pq, (self.distances[self.start], self.start))\n        \n        while pq:\n            current_distance, current_node = heapq.heappop(pq)\n            if current_distance > self.distances[current_node]:\n                continue\n            for edge in self.edges[current_node]:\n                distance = current_distance + edge.weight\n                if distance < self.distances[edge.to]:\n                    self.distances[edge.to] = distance\n                    heapq.heappush(pq, (distance, edge.to))\n        \nn, m, e = map(int, input().split())\ndij_brother = Dijkstra(n+1, int(input())-1)\nfor i in range(m):\n    a, b, l = map(int, input().split())\n    dij_brother.add_edge(a-1,b-1,l)\n    \nexit_points = list(map(int, input().split()))\ndij_exit = Dijkstra(n+1, exit_points[0]-1)\nfor exit_point in exit_points:\n    dij_exit.add_edge(n, exit_point-1, 0)\ndij_exit.add_edge(n, dij_brother.start, 0)    \n\nbrother_exit_dist = dij_exit.distances[dij_brother.start]\n\nif brother_exit_dist == float('inf'):\n    print(\"IMPOSSIBLE\")\nelse:\n    time = brother_exit_dist / (160 - dij_brother.distances[dij_exit.start])\n    print(\"{:.7f}\".format(time))"
 ],
 "3227": [
  "n, e = map(int, input().split())\ngraph = [[] for _ in range(n)]\nfor _ in range(e):\n    a, b = map(int, input().split())\n    graph[a-1].append(b-1)\n    graph[b-1].append(a-1)\n\ncolor = [-1]*n\ndef dfs(node, c):\n    color[node] = c\n    for v in graph[node]:\n        if color[v] == -1:\n            dfs(v, c^1)\n        elif color[v] == c:\n            print(0)\n            exit()\n\nfor i in range(n):\n    if color[i] == -1:\n        dfs(i, 0)\n\nfor c in color:\n    print(c+1)"
 ],
 "3228": [
  "n, t, g = map(int, input().split())\narrival = [int(input()) for _ in range(n)]\nvisited = [False] * (max(arrival) + t + 1)  # create a list to track when a cab is visiting the station\n\nqueue = [(0, 0)]  # initialize the queue with the starting time and number of cabs available\nvisited[0] = True\n\nwhile queue:\n    time, cabs = queue.pop(0)  # get the earliest time in the queue and number of available cabs \n    if time > max(arrival) + t:  # stop searching further when we have passed the latest arrival time\n        break\n    if cabs < g:  # if there are less than g cabs available, add a cab and update the time\n        if not visited[time + 1]:\n            visited[time + 1] = True\n            queue.append((time + 1, cabs + 1))\n    if time + t <= max(arrival) + t:  # if a cab can reach the hill-top before the latest arrival time, calculate the waiting time for all skiers that arrive before the cab's departure time\n        waiting_time = sum([min(arrival[i] - time, t) for i in range(n) if not visited[arrival[i]] and arrival[i] >= time])\n        if waiting_time < g and not visited[time + t]:\n            visited[time + t] = True\n            queue.append((time + t, cabs))\n            \nfor i in range(max(arrival), max(arrival) + t + 1):  # iterate through the time slots between the latest arrival time and the latest possible boarding time\n    if visited[i]:\n        print(i - max(arrival))\n        break\nelse:  # if no valid time slot is found, print -1\n    print(-1)"
 ],
 "3229": [
  "import heapq\n\nn, m = map(int, input().split())\ncontest_scores = []\nfor _ in range(m):\n    scores = list(map(int, input().split()))\n    contest_scores.append(scores)\n    # add onsite scores\n    scores_sum = sum(scores)\n    if n > 1:\n        max_score = max(scores)\n        if max_score == 0:\n            scores_sum += 1\n        else:\n            second_max = heapq.nlargest(2, scores)[1]\n            if max_score == second_max:\n                scores_sum += 1\n    else:\n        scores_sum += 1\n    contest_scores[-1] = scores_sum\n\n# calculate your aggregate score\nscores = contest_scores[0]\naggregate_score = sum(heapq.nlargest(4, scores))\n\n# calculate other contestants' aggregate scores\nother_aggregate_scores = []\nfor i in range(1, m):\n    scores = contest_scores[i]\n    aggregate_score = sum(heapq.nlargest(4, scores))\n    other_aggregate_scores.append(aggregate_score)\nother_aggregate_scores.sort(reverse=True)\n\n# calculate your rank\nyour_rank = 1 + sum(score > aggregate_score for score in other_aggregate_scores)\n\n# calculate the lowest rank you can get\nlowest_rank = your_rank\nfor i in range(1, 102):\n    aggregate_score = sum(heapq.nlargest(3, [i] + scores))\n    if sum(score > aggregate_score for score in other_aggregate_scores) >= 15:\n        lowest_rank = max(lowest_rank, 16)\n\nprint(lowest_rank)"
 ],
 "3230": [
  "from math import sqrt\n\nR, C = map(int, input().split())\ntram = []\nx_positions = []\nl_positions = []\nfor i in range(R):\n    row = input().strip()\n    tram.append(row)\n    # find positions of X and L\n    for j in range(C):\n        if row[j] == 'X':\n            x_positions.append((i, j))\n        elif row[j] == 'L':\n            l_positions.append((i, j))\n\n# function to calculate Euclid distance between two cells\ndef distance(cell1, cell2):\n    return sqrt((cell1[0]-cell2[0])**2 + (cell1[1]-cell2[1])**2)\n\nexplosions = 0\n# for each L position, find the closest X position\nfor l_pos in l_positions:\n    closest_x_pos = x_positions[0]\n    for x_pos in x_positions[1:]:\n        if distance(l_pos, x_pos) < distance(l_pos, closest_x_pos):\n            closest_x_pos = x_pos\n    # check if there are other X positions at the same distance\n    same_distance = [closest_x_pos]\n    for x_pos in x_positions:\n        if distance(l_pos, x_pos) == distance(l_pos, closest_x_pos) and x_pos != closest_x_pos:\n            same_distance.append(x_pos)\n    # if there's only one X at the closest distance, mark it as seated ('.')\n    if len(same_distance) == 1:\n        x, y = closest_x_pos\n        tram[x] = tram[x][:y] + '.' + tram[x][y+1:]\n    # otherwise, explosion occurs\n    else:\n        explosions += 1\n        for x, y in same_distance:\n            tram[x] = tram[x][:y] + '.' + tram[x][y+1:]\n\nprint(explosions)"
 ],
 "3231": [
  "from collections import deque\n\ndef bfs(graph, start):\n    queue = deque([start])\n    visited = set([start])\n\n    group = 0\n    color = {start: group}\n\n    while queue:\n        current = queue.popleft()\n        for neighbor in graph[current]:\n            if neighbor not in color:\n                color[neighbor] = group\n                queue.append(neighbor)\n            elif color[neighbor] != group:\n                return None\n        if not queue:\n            group += 1\n            if group > P:\n                return None\n            for i in range(N):\n                if i not in color:\n                    color[i] = group\n                    queue.append(i)\n\n    return color\n\n\nN, P, Q = map(int, input().split())\nfriends = []\nfor _ in range(N):\n    friends.append(set(map(int, input().split()[1:])))\n\n# Check if there is a pair of friends with different groups\nfor i in range(N):\n    for j in range(i+1, N):\n        if i in friends[j] and j in friends[i]:\n            continue\n        if len(friends[i].union(friends[j])) > Q:\n            print(\"detention\")\n            exit()\n\n# Build graph\ngraph = [[] for _ in range(N)]\nfor i in range(N):\n    for j in friends[i]:\n        graph[i].append(j)\n        graph[j].append(i)\n\n# Assign groups\ncolor = bfs(graph, 0)\nif color is None:\n    print(\"detention\")\nelse:\n    print(\"home\")\n    groups = [[] for _ in range(P)]\n    for i, c in color.items():\n        groups[c].append(i)\n    print(P)\n    for g in groups:\n        print(len(g), *g)"
 ],
 "3232": [
  "from collections import Counter\ns = input()\nc = Counter(s)\nfor i in c:\n    if c[i] > len(s)//2:\n        print(-1)\n        break\nelse:\n    n = len(s)\n    mid = n//2\n    s = sorted(s, key=lambda x: -c[x])\n    ans = [None]*n\n    ans[::2] = s[:mid]\n    ans[1::2] = s[mid:]\n    ans = \"\".join(ans)\n    print(ans)"
 ],
 "3233": [
  "n = int(input())\narr = list(map(int, input().split()))\n\ncount = n  # All subarrays of length 1 are scary\nfor i in range(2, n+1):\n    for j in range(n-i+1):\n        sub_arr = arr[j:j+i]\n        sub_arr.sort()\n        median = sub_arr[(i-1)//2] if i % 2 == 1 else (sub_arr[i//2-1] + sub_arr[i//2]) / 2\n        if sub_arr[0] == median:\n            count += 1\n\nprint(count)"
 ],
 "3234": [
  "# Reading input\nn = int(input())\n\n# Handling base cases\nif n <= 2:\n    print(0)\nelif n == 3:\n    print(1)\nelse:\n    # Finding the best box dimensions\n    best_diff = float('inf')\n    best_W, best_H = 0, 0\n    for h in range(1, int(n ** 0.5) + 1):\n        for w in range(h * 2, int(n / h) * 2 + 1):\n            if h / 2 <= w <= 2 * h and n <= w * h:\n                diff = w * h - n\n                if diff < best_diff:\n                    best_diff = diff\n                    best_H, best_W = h, w\n    print(best_diff)"
 ],
 "3235": [
  "import sys\n\ndef get_input():\n    return [list(map(int, line.split())) for line in sys.stdin.readlines()]\n\ndef settle_iou(n, ious):\n    balances = [0] * n\n    for a, b, c in ious:\n        balances[a] -= c\n        balances[b] += c\n\n    for i in range(n):\n        if balances[i] > 0:\n            for j in range(n):\n                if balances[j] < 0:\n                    settle = min(-balances[j], balances[i])\n                    balances[i] -= settle\n                    balances[j] += settle\n                    print(i, j, settle)\n\nif __name__ == '__main__':\n    n, m = get_input()[0]\n    ious = get_input()[1:]\n    settle_iou(n, ious)"
 ],
 "3236": [
  "n, m = map(int, input().split())\nmansion_heights = list(map(int, input().split()))\nadj_list = {i:[] for i in range(n)}\nfor _ in range(m):\n    a, b = map(int, input().split())\n    adj_list[a-1].append(b-1)\n    adj_list[b-1].append(a-1)\n\nMAX_N = max(mansion_heights)\nfibo = [1, 1]\nwhile fibo[-1] + fibo[-2] <= MAX_N:\n    fibo.append(fibo[-1]+fibo[-2])\n\nindices = {}\nfor i in range(n):\n    if mansion_heights[i] in indices:\n        indices[mansion_heights[i]].append(i)\n    else:\n        indices[mansion_heights[i]] = [i]\n\nvis = [False for _ in range(n)]\ndist = [-1 for _ in range(n)]\npivot_nodes = [-1 for _ in range(n)]\n\nfor i in range(n):\n    if not vis[i]:\n        a, b = 0, 1\n        if mansion_heights[i] == fibo[0]: a = 1\n        elif mansion_heights[i] != 1: continue\n        vis[i] = True\n        dist[i] = a\n        pivot_nodes[i] = i\n        stack = [i]\n        while stack:\n            u = stack.pop()\n            for v in adj_list[u]:\n                c = a+b\n                if dist[v] == -1:\n                    if mansion_heights[v] not in indices:\n                        a, b = 0, 1\n                        if mansion_heights[i] == fibo[0]: a = 1\n                        elif mansion_heights[i] != 1: continue\n                        dist[v] = a\n                        pivot_nodes[v] = i\n                        vis[v] = True\n                    else:\n                        if c > MAX_N: continue\n                        if mansion_heights[v] != c: continue\n                        dist[v] = dist[u] + 1\n                        pivot_nodes[v] = i\n                        a, b = b, c\n                        vis[v] = True\n                        stack.append(v)\n        if dist[pivot_nodes[i]] > 1: # Fibonacci sequence of length > 2\n            pivot_nodes[i] = -1\n\nmax_len = 0\nfor i in range(n):\n    if pivot_nodes[i] == -1: continue\n    u = i\n    length = 0\n    while True:\n        length += 1\n        v = pivot_nodes[u]\n        if v == u: break\n        u = v\n    max_len = max(max_len, length)\n\nprint(max_len)"
 ],
 "3237": [
  "MOD = int(1e9) + 7\n\ndef primeFactorization(s):\n    primeFactor = {}\n    n = len(s)\n    idx = 0\n    while idx < n:\n        prime = int(s[idx: idx + 2])\n        idx += 2\n        if prime in primeFactor:\n            primeFactor[prime] += 1\n        else:\n            primeFactor[prime] = 1\n    return primeFactor\n\ndef findCost(primeFactor, baseCost):\n    maxCount = max(primeFactor.values())\n    cost = baseCost\n    inc = 1\n    while maxCount > 1:\n        while (baseCost + inc) % maxCount != 0:\n            inc += 1\n        cost = (cost * (baseCost + inc) // maxCount) % MOD\n        maxCount //= 2\n    return cost\n\nif __name__ == \"__main__\":\n    s = input().strip()\n    primeFactor = primeFactorization(s)\n    baseCost = sum(primeFactor.keys())\n    cost = findCost(primeFactor, baseCost)\n    print(cost)"
 ],
 "3238": [
  "n, m = map(int, input().split())\nmatrix = [input() for i in range(n)]\n\ndef get_segments(row, char):\n    '''Returns the start and end indices of contiguous segments of `char` in a row'''\n    segments = []\n    segment_start = None\n    for i, ch in enumerate(row):\n        if ch == char:\n            if segment_start is None:\n                segment_start = i\n        elif segment_start is not None:\n            segments.append((segment_start, i-1))\n            segment_start = None\n    if segment_start is not None:\n        segments.append((segment_start, n-1))\n    return segments\n\ndef get_fold_indices(arr, invert=False):\n    '''Returns the indices where the fold goes through, given an array of True/False values.\n    If invert=True, returns the indices where the fold goes through the negation of the array.'''\n    if invert:\n        arr = [not x for x in arr]\n    s = \"\".join([\"#\" if b else \".\" for b in arr])\n    fold_idx = s.find(\"#\" * (n//2))\n    if fold_idx == -1:\n        return None\n    return (max(0, fold_idx - (n//2 - 1)), min(n-1, fold_idx + (n//2)))\n\nrow_segments = [(i, get_segments(matrix[i], \"#\")) for i in range(n)]\n\ncandidate_folds = []\nfor r1, segments1 in row_segments:\n    for r2, segments2 in row_segments:\n        if r1 >= r2:\n            continue\n        seg1 = segments1[-1]\n        seg2 = segments2[0]\n        if seg1[0] <= seg2[1] and seg1[1] >= seg2[0]:\n            intersect = [x for x in range(seg1[0], seg1[1]+1) if matrix[r2][x] == \"#\"]\n            if len(intersect) == 0:\n                continue\n            candidate_folds.append((r1, r2, intersect[0]))\n\ndef check_fold(r1, r2, c):\n    top_half = [matrix[i][c] == \"#\" for i in range(r1)]\n    bottom_half = [matrix[i][c] == \"#\" for i in range(r2, n)]\n    top_intersect = get_fold_indices(top_half)\n    bottom_intersect = get_fold_indices(bottom_half, invert=True)\n    return top_intersect is not None and bottom_intersect is not None\n\nfor r1, r2, c in candidate_folds:\n    if check_fold(r1, r2, c):\n        print(r1+1, c+1, r2+1, c+1)\n        break"
 ],
 "3239": [
  "import math\nn, p = map(float, input().split())\np = round(p, 3)\nans = 0\nfor i in range(1,int(n)+1):\n    q = pow(1-p, i-1) * p\n    ans += 5 * ((1-q)**(i-1)) * q * math.ceil(i/100)\nprint(\"{:.9f}\".format(ans))"
 ],
 "3240": [
  "from itertools import product\n\nk, v = map(int, input().split())\nprobs = []\nballots = []\nfor i in range(v-1):\n    p, b = input().split()\n    probs.append(float(p))\n    ballots.append(int(b))\n\n\nmax_yraglac = -1\nmax_ballots = -1\n\nfor num_ballots in product(range(2**k), repeat=v-1):\n    # Calculate the probability that Yraglac will win each position\n    prob_yraglac_win = [0] * k\n    for pos in range(k):\n        prob_yraglac_win[pos] = sum((num_ballots[i] >> pos) & 1) * probs[i] + ((1-probs[i]) / 2)\n    \n    # Calculate the expected number of positions won by Yraglac\n    expected_yraglac_wins = sum(1 for i in prob_yraglac_win if i < 0.5)\n    \n    if expected_yraglac_wins > max_yraglac:\n        max_yraglac = expected_yraglac_wins\n        max_ballots = num_ballots\n\nprint(max_ballots[-1])"
 ],
 "3241": [
  "n = int(input())\nab = [list(map(int, input().split())) for _ in range(n)]\n\ntotal_kilos = sum([ab[i][0] for i in range(n)])\nranking = sorted([ab[i][0] for i in range(n)], reverse=True)\n\nham_allocation = []\ntotal_ham = 0\n\nfor i in range(n):\n    if ranking[i] == 0:\n        continue\n    ratio = ab[i][1]\n    if sum(ham_allocation) == 0:\n        if ratio != 0:\n            total_ham = ranking[i]/ratio\n        ham_allocation.append(ranking[i]/ratio)\n        continue\n    extra_ham = ranking[i]/ratio - sum(ham_allocation)\n    if extra_ham < 0:\n        print(-1)\n        break\n    ham_allocation.append(extra_ham)\nelse:\n    for a, h in zip(ab, ham_allocation):\n        total_kilos += h * a[1]\n    print(total_ham)"
 ],
 "3242": [
  "from heapq import heappush, heappop\n\nn, p = map(float, input().split())\nboxes = [list(map(float, input().split())) for _ in range(int(n))]\n\n# define a bisect search function\ndef bisect_search(total_probability):\n    # check edge case\n    if total_probability >= p:\n        return True\n    # create a list to store the best energy for each step\n    best_energy = [float(\"inf\")] * int(n+1)\n    # initialize\n    best_energy[0] = 0\n    # create a heap for bi-section optimization\n    heap = [(0, 0)]\n    # define the search logic\n    while heap:\n        curr_energy, curr_probability = heappop(heap)\n        if curr_probability >= total_probability:\n            return True\n        if best_energy[curr_energy + 1] > curr_probability:\n            best_energy[curr_energy + 1] = curr_probability\n            heappush(heap, (curr_energy + boxes[curr_energy][0], curr_probability + boxes[curr_energy][1]))\n    return False\n\n# use bisect search to get the minimum energy needed\nleft, right = 0, sum(box[0] for box in boxes)\nwhile abs(right - left) > 10**(-5):\n    mid = (left + right) / 2\n    if bisect_search(sum(max(0, p-box[1]) for box in boxes if box[0] <= mid)):\n        right = mid\n    else:\n        left = mid\n\nprint(int(right))"
 ],
 "3243": [
  "from queue import Queue\n\nn, m, k = map(int, input().split())\nc = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n)]\nfor _ in range(m):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n    graph[v].append(u)\n\nvisited = [False] * n\nregions = []\nfor i in range(n):\n    if not visited[i]:\n        region = []\n        q = Queue()\n        q.put(i)\n        visited[i] = True\n        region.append(i)\n        while not q.empty():\n            curr = q.get()\n            for neighbor in graph[curr]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    q.put(neighbor)\n                    region.append(neighbor)\n        regions.append(region)\n\ntotal_sockets = sum(c)\nfor region in regions:\n    total_sockets -= sum(c[i] for i in region)\n\nif total_sockets < 0 or len(regions) > k:\n    print(\"no\")\nelse:\n    print(\"yes\")"
 ],
 "3244": [
  "n = int(input())\nb = list(map(int, input().split()))\na = [0]*n\na[0] = (b[0] - b[2])//2\na[1] = b[1]-a[0]\na[-1] = b[-1]-a[0]\nfor i in range(2, n):\n    a[i] = b[i-1]-a[i-2]\nfor ai in a:\n    print(ai)"
 ],
 "3245": [
  "n = int(input())\ncommands = []\nprefix = ''\nfor i in range(n):\n    line = input().strip()\n    if '^' in line:\n        idx = line.index('^')\n        line = prefix + line[idx+1:]\n    if line:\n        commands.append(line)\n        prefix = ''\n\n    elif commands:\n        prefix = commands[-1]\n\nfor command in commands:\n    print(command)"
 ],
 "3246": [
  "word = input().strip()\nn = int(input())\nwords = [input().strip() for _ in range(n)]\n\n# Finding the valid words that can be formed by keeping the first and last letters of word\nvalid_words = [w for w in words if w[0] == word[0] and w[-1] == word[-1] and len(w) == len(word)]\n\n# If no valid words found, it is impossible to decipher\nif not valid_words:\n    print(\"impossible\")\n\n# If only one valid word found, that's our answer\nelif len(valid_words) == 1:\n    print(valid_words[0])\n\n# If multiple valid words are found, it is ambiguous\nelse:\n    print(\"ambiguous\")"
 ],
 "3247": [
  "MOD = 1000000009\n\n# Function to calculate the modular inverse of a number\ndef mod_inv(n: int) -> int:\n    return pow(n, MOD-2, MOD)\n\n# Function to calculate n choose k modulo MOD\ndef nCr_mod(n: int, k: int) -> int:\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    num = 1  # To store n*(n-1)*...*(n-k+1)\n    den = 1  # To store k*(k-1)*...*1\n    for i in range(k):\n        num = (num * (n-i)) % MOD\n        den = (den * (i+1)) % MOD\n    return (num * mod_inv(den)) % MOD\n\n# Main function\ndef main():\n    n, m = map(int, input().split())\n    if n > m:\n        n, m = m, n\n    if n == 1:\n        ans = pow(2, m, MOD)\n    elif n == 2:\n        ans = ((2 * pow(3, m-1, MOD)) % MOD - pow(2, m-3, MOD) + MOD) % MOD\n    elif n == 3:\n        ans = (4 * pow(3, m-1, MOD) % MOD - 2 * pow(2, m-3, MOD) + 4 * pow(26, m-3, MOD) % MOD - 2 * pow(7, m-2, MOD) + 2 * pow(3, m-3, MOD) * nCr_mod(m-1, 2)) % MOD\n    else:\n        ans = (2 * pow(3, m-1, MOD) % MOD - pow(2, m-2, MOD) + 2 * pow(26, m-3, MOD) % MOD - pow(7, m-2, MOD) + pow(3, m-4, MOD) * (6 * nCr_mod(m-2, 2) % MOD + 6 * nCr_mod(m-2, 1) % MOD + nCr_mod(m-2, 0))) % MOD\n    print(ans)\n\nif __name__ == '__main__':\n    main()"
 ],
 "3248": [
  "n = int(input())\nstreet = input()\nm = int(input())\ntiles = [input() for _ in range(m)]\n\n# create a set of all untileable cells\nuntileable = set(range(n))\n\nfor tile in tiles:\n    # find all occurrences of the tile pattern in the street\n    start = 0\n    while True:\n        idx = street.find(tile, start)\n        if idx == -1:\n            break\n        # remove all cells covered by this tile occurrence\n        for i in range(idx, idx + len(tile)):\n            untileable.discard(i)\n        start = idx + 1\n\n# output the number of untileable cells\nprint(len(untileable))"
 ],
 "3249": [
  "from bisect import bisect\n\ndef bulkhead_placement(C, hull):\n    def calc_area(p1, p2):\n        \"\"\"\n        Compute the area of the trapezoid formed by two points and x-axis\n        \"\"\"\n        x1, y1 = p1\n        x2, y2 = p2\n        return (x2 - x1) * (y1 + y2) / 2\n\n    # Compute the cumulative sum of areas from left to right\n    n = len(hull)\n    areas = [calc_area(hull[i-1], hull[i]) for i in range(n)]\n    cum_areas = [0] + list(accumulate(areas))\n\n    # Total area of the hull\n    total_area = cum_areas[-1]\n\n    # Compute the area of one bulkhead\n    area_thres = total_area / C\n\n    # Find the indices of the points where bulkheads should be placed\n    idxs = [bisect(cum_areas, i * area_thres) for i in range(1, C)]\n\n    return [hull[i-1][0] + (hull[i][0] - hull[i-1][0]) * \\\n               (i * area_thres - cum_areas[i-1]) / areas[i-1] for i in idxs], len(idxs)+1\n\nC = int(input())\nN = int(input())\nhull = [tuple(map(int, input().split())) for _ in range(N)]\n\nplacements, num_bulkheads = bulkhead_placement(C, hull)\n\nprint(num_bulkheads)\nprint(\"\\n\".join(\"{:.6f}\".format(p) for p in placements))"
 ],
 "3250": [
  "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\nb, d = map(int, input().split())\nfor m in range(1, d):\n    if b**m % d == 1:\n        valid = True\n        for i in range(1, m):\n            if b**i % d == 1:\n                valid = False\n                break\n        if valid and gcd(m, d-1) == 1:\n            print(\"yes\")\n            break\nelse:\n    print(\"no\")"
 ],
 "3251": [
  "n = int(input())\nintervals = [list(map(int, input().split())) for _ in range(n)]\nintervals.sort()\nsequences = []\nsequence = [intervals[0]]\nfor i in range(1, n):\n    if sequence[-1][1] < intervals[i][0]:\n        sequences.append(sequence)\n        sequence = [intervals[i]]\n    elif sequence[-1][1] < intervals[i][1]:\n        sequence.append(intervals[i])\nsequences.append(sequence)\nlongest_sequence = max(sequences, key=len)\nprint(len(longest_sequence))\nfor interval in longest_sequence:\n    print(interval[0], interval[1])"
 ],
 "3252": [
  "from itertools import combinations\nn,k = map(int,input().split())\ncards = []\nfor i in range(n):\n    w,h,q = map(int,input().split())\n    cards += [(w,h,q)]\n#one envelope\nans1 = float('inf')\nfor i in range(n):\n    w,h,q = cards[i]\n    waste = sum([max((w-cards[j][0])*(h-cards[j][1])*cards[j][2],0) for j in range(n) if j != i])\n    if waste < ans1:\n        ans1 = waste\n \n#two envelopes\nans2 = float('inf')\nfor i,j in combinations(range(n),2):\n    common_dim = set(cards[i][:2]).intersection(set(cards[j][:2]))\n    for k in common_dim:\n        if k == cards[i][0] or k == cards[i][1]:\n            first_w,first_h = cards[i][:2]\n            second_w,second_h = cards[j][:2]\n        else:\n            first_w,first_h = cards[j][:2]\n            second_w,second_h = cards[i][:2]\n        waste = sum([max((first_w-cards[m][0])*(first_h-cards[m][1])*cards[m][2],0) for m in range(n) if instances[m]!=0 and (cards[m][0] not in [first_w,second_w] or cards[m][1] not in [first_h,second_h])])\n        waste += sum([max((second_w-cards[m][0])*(second_h-cards[m][1])*cards[m][2],0) for m in range(n) if instances[m]!=0 and (cards[m][0] not in [first_w,second_w] or cards[m][1] not in [first_h,second_h])])\n        if waste < ans2:\n            ans2 = waste\n\n#three envelopes\n        \nif k >= 3:\n    ans3 = float('inf')\n    for i,j,l in combinations(range(n),3):\n        common_dims = set(cards[i][:2]).intersection(set(cards[j][:2])).intersection(set(cards[l][:2]))\n        for trio in common_dims:\n            if trio == cards[i][0] or trio == cards[i][1]:\n                first_w,first_h = cards[i][:2]\n                if trio == cards[j][0] or trio == cards[j][1]:\n                    second_w,second_h = cards[j][:2]\n                    third_w,third_h = cards[l][:2]\n                else:\n                    second_w,second_h = cards[l][:2]\n                    third_w,third_h = cards[j][:2]\n            elif trio == cards[j][0] or trio == cards[j][1]:\n                first_w,first_h = cards[j][:2]\n                if trio == cards[i][0] or trio == cards[i][1]:\n                    second_w,second_h = cards[i][:2]\n                    third_w,third_h = cards[l][:2]\n                else:\n                    second_w,second_h = cards[l][:2]\n                    third_w,third_h = cards[i][:2]\n            else:\n                first_w,first_h = cards[l][:2]\n                if trio == cards[i][0] or trio == cards[i][1]:\n                    second_w,second_h = cards[i][:2]\n                    third_w,third_h = cards[j][:2]\n                else:\n                    second_w,second_h = cards[j][:2]\n                    third_w,third_h = cards[i][:2]\n            waste = sum([max((first_w-cards[m][0])*(first_h-cards[m][1])*cards[m][2],0) for m in range(n) if instances[m]!=0 and (cards[m][0] not in [first_w,second_w,third_w] or cards[m][1] not in [first_h,second_h,third_h])])\n            waste += sum([max((second_w-cards[m][0])*(second_h-cards[m][1])*cards[m][2],0) for m in range(n) if instances[m]!=0 and (cards[m][0] not in [first_w,second_w,third_w] or cards[m][1] not in [first_h,second_h,third_h])])\n            waste += sum([max((third_w-cards[m][0])*(third_h-cards[m][1])*cards[m][2],0) for m in range(n) if instances[m]!=0 and (cards[m][0] not in [first_w,second_w,third_w] or cards[m][1] not in [first_h,second_h,third_h])])\n            if waste < ans3:\n                ans3 = waste\nelse:\n    ans3 = float('inf')\n\n#four envelopes\nif k >= 4:\n    ans4 = float('inf')\n    for i,j,l,m in combinations(range(n),4):\n        common_dims = set(cards[i][:2]).intersection(set(cards[j][:2])).intersection(set(cards[l][:2])).intersection(set(cards[m][:2]))\n        if common_dims:\n            if len(common_dims) > 2:\n                continue\n            common_dim = common_dims.pop()\n            if common_dim == cards[i][0] or common_dim == cards[i][1]:\n                first_w,first_h = cards[i][:2]\n            elif common_dim == cards[j][0] or common_dim == cards[j][1]:\n                first_w,first_h = cards[j][:2]\n            elif common_dim == cards[l][0] or common_dim == cards[l][1]:\n                first_w,first_h = cards[l][:2]\n            else:\n                first_w,first_h = cards[m][:2]\n\n            other_dims = set([cards[i][:2],cards[j][:2],cards[l][:2],cards[m][:2]]) - set([(first_w,first_h),(first_h,first_w)])\n            second_w,second_h = next(iter(other_dims))\n            third_w,third_h = next(iter(other_dims-set([(second_w,second_h),(second_h,second_w)])))\n            fourth_w,fourth_h = common_dim, first_w+first_h-second_w-second_h-third_w-third_h\n\n            waste = sum([max((first_w-cards[x][0])*(first_h-cards[x][1])*cards[x][2],0) for x in range(n) if instances[x]!=0 and cards[x][0] not in [first_w,second_w,third_w,fourth_w] and cards[x][1] not in [first_h,second_h,third_h,fourth_h]])\n            waste += sum([max((second_w-cards[x][0])*(second_h-cards[x][1])*cards[x][2],0) for x in range(n) if instances[x]!=0 and cards[x][0] not in [first_w,second_w,third_w,fourth_w] and cards[x][1] not in [first_h,second_h,third_h,fourth_h]])\n            waste += sum([max((third_w-cards[x][0])*(third_h-cards[x][1])*cards[x][2],0) for x in range(n) if instances[x]!=0 and cards[x][0] not in [first_w,second_w,third_w,fourth_w] and cards[x][1] not in [first_h,second_h,third_h,fourth_h]])\n            waste += sum([max((fourth_w-cards[x][0])*(fourth_h-cards[x][1])*cards[x][2],0) for x in range(n) if instances[x]!=0 and cards[x][0] not in [first_w,second_w,third_w,fourth_w] and cards[x][1] not in [first_h,second_h,third_h,fourth_h]])\n\n            if waste < ans4:\n                ans4 = waste\nelse:\n    ans4 = float('inf')\n\n#five envelopes\nif k == 5:\n    ans5 = float('inf')\n    env_sizes = [(12,12),(8,16),(16,8),(6,24),(24,6)]\n    for envelope_assignment in permutations(env_sizes):\n        waste = 0\n        for i in range(n):\n            w,h = cards[i][:2]\n            assignment = [x in [w,h] for x in envelope_assignment]\n            assigned_env = set([j for j in range(5) if assignment[j]])\n            if len(assigned_env) == 1:\n                env_size = envelope_assignment[assignment.index(True)]\n                waste += max((env_size[0]-w)*(env_size[1]-h)*cards[i][2],0)\n        if waste < ans5:\n            ans5 = waste\nelse:\n    ans5 = float('inf')\n    \nprint(min(ans1,ans2,ans3,ans4,ans5))"
 ],
 "3253": [
  "s = int(input())\ndelegates = 0\nc_votes = 0\nf_votes = 0\nu_votes = 0\n\nfor i in range(s):\n    d, c, f, u = map(int, input().split())\n    delegates += d\n    c_votes += c\n    f_votes += f\n    u_votes += u\n    \nhalf_delegates = (delegates + 1) // 2\n\nif c_votes + u_votes <= f_votes:\n    print(\"impossible\")\nelif c_votes >= half_delegates:\n    print(0)\nelse:\n    needed_votes = half_delegates - c_votes\n    if needed_votes > u_votes:\n        print(\"impossible\")\n    else:\n        print(needed_votes)"
 ],
 "3254": [
  "P = float(input())\na = [int(P) for i in range(5)]\nr = P - int(P)\nif r == 0.0:\n    print(*a)\nelse:\n    r = round(r * 1000000)\n    while r > 0 and (r % 500000 != 0 or a[4] == 0):\n        if r >= 500000 and a[0] < 2:\n            a[0] += 1\n            r -= 500000\n        elif r >= 400000 and a[1] < 2:\n            a[1] += 1\n            r -= 400000\n        elif r >= 300000 and a[2] < 2:\n            a[2] += 1\n            r -= 300000\n        elif r >= 200000 and a[3] < 2:\n            a[3] += 1\n            r -= 200000\n        elif a[4] < 2:\n            a[4] += 1\n            r -= 100000\n        else:\n            break\n    print(*a)"
 ],
 "3255": [
  "n, D, M = map(int, input().split())\na = list(map(int, input().split()))\n\ndp = [1] * n\nans = 1\nfor i in range(n):\n    for j in range(i-1, max(-1, i-D-1), -1):\n        if abs(a[i]-a[j]) <= M:\n            dp[i] = max(dp[i], dp[j]+1)\n    ans = max(ans, dp[i])\n\nprint(ans)"
 ],
 "3256": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\ns, e = 0, pow(2, 31)\nwhile s < e:\n    mid = ((s + e) >> 1) + 1\n    counts = [0] * (n + 1)\n    for i in range(n):\n        counts[i + 1] = counts[i] + (a[i] >= mid)\n    if counts[n] < k:\n        e = mid - 1\n    else:\n        max_and = 0\n        for i in range(n):\n            if counts[i + 1] < k:\n                continue\n            # Calculate the power of each section\n            power = 0\n            for j in range(i + 1):\n                if counts[i + 1] == k and counts[j] == 0:\n                    continue\n                power |= a[j]\n            for j in range(n - (i + 1)):\n                n_j = j + i + 1\n                if counts[n] - counts[n_j] + counts[i + 1] < k:\n                    continue\n                if counts[n] - counts[n_j] == 0 and counts[i + 1] < k:\n                    continue\n                power |= a[n_j]\n            max_and = max(max_and, power)\n        if max_and < mid:\n            e = mid - 1\n        else:\n            s = mid\nprint(s - 1)"
 ],
 "3257": [
  "import math\na, b, c = map(float, input().split())\nif a+b>c and b+c>a and a+c>b:\n    s = (a+b+c)/2\n    area = math.sqrt(s*(s-a)*(s-b)*(s-c))\n    print(\"%.6f\" % area)\nelse:\n    print(\"-1\")"
 ],
 "3258": [
  "from math import hypot\nfrom itertools import permutations\n\nn = int(input())\nmice = []\nfor i in range(n):\n    x, y, s = map(int, input().split())\n    mice.append((x, y, s))\n\nm = float(input())\n\ndef can_eat_order(order, v0):\n    v = v0\n    last_t = 0\n    for i in order:\n        (x, y, t) = mice[i]\n        d = hypot(x, y)\n        need_t = d/v\n        if t < last_t + need_t:\n            return False\n        v = v*m\n        last_t = last_t + need_t\n    return True\n\nbest_v = float(\"inf\")\nfor order in permutations(range(n)):\n    lo, hi = 0.0, best_v\n    while hi - lo > 1e-9:\n        v0 = (hi + lo) / 2\n        if can_eat_order(order, v0):\n            hi = v0\n        else:\n            lo = v0\n    best_v = min(best_v, hi)\n\nprint(\"{:.10f}\".format(best_v))"
 ],
 "3259": [
  "from math import ceil, log2\n\ndef build_segment_tree(array, tree, node, start, end):\n    if start == end:\n        tree[node] = array[start]\n    else:\n        mid = (start + end) // 2\n        build_segment_tree(array, tree, 2*node, start, mid)\n        build_segment_tree(array, tree, 2*node+1, mid+1, end)\n        tree[node] = tree[2*node] + tree[2*node+1]\n\ndef update_segment_tree(tree, node, start, end, index, value):\n    if start == end:\n        tree[node] = value\n    else:\n        mid = (start + end) // 2\n        if start <= index <= mid:\n            update_segment_tree(tree, 2*node, start, mid, index, value)\n        else:\n            update_segment_tree(tree, 2*node+1, mid+1, end, index, value)\n        tree[node] = tree[2*node] + tree[2*node+1]\n\ndef query_segment_tree(tree, node, start, end, left, right):\n    if right < start or end < left:\n        return 0\n    if left <= start and end <= right:\n        return tree[node]\n    mid = (start + end) // 2\n    left_sum = query_segment_tree(tree, 2*node, start, mid, left, right)\n    right_sum = query_segment_tree(tree, 2*node+1, mid+1, end, left, right)\n    return left_sum + right_sum\n\nn, q = map(int, input().split())\n\narray = [0] * (n+1)\nsegment_tree = [0] * (4 * n)\n\nbuild_segment_tree(array, segment_tree, 1, 1, n)\n\nfor i in range(q):\n    query = list(map(int, input().split()))\n    if query[0] == 1:\n        L, R, A, B = query[1:]\n        for j in range(L, R+1):\n            update_segment_tree(segment_tree, 1, 1, n, j, (j-L+1)*A % B)\n    else:\n        L, R = query[1:]\n        print(query_segment_tree(segment_tree, 1, 1, n, L, R))"
 ],
 "3260": [
  "n, k, p = map(int, input().split())\n\ndp = [[0] * (n+1) for _ in range(k+1)]\ndp[0] = [1] * (n+1)\n\nfor i in range(1, k+1):\n    for j in range(1, n+1):\n        for t in range(j):\n            dp[i][j] += dp[i-1][t] % p * (j-t) % p\n            dp[i][j] %= p\n\nans = sum(dp[i][n] for i in range(k+1)) % p\nprint(ans)"
 ],
 "3261": [
  "r, c = map(int, input().split())\nk = int(input())\n\nif k == 1:\n    print(0)\nelse:\n    # determine the starting position based on k\n    if k % 2 == 0:\n        i = k // 2 - 1\n        j = 1\n    else:\n        i = k // 2\n        j = 0\n    \n    # determine the number of grey cells visited in one complete zigzag\n    grey_per_zigzag = r // 2 * (c // 2) + (r + 1) // 2 * (c + 1) // 2\n    \n    # determine the number of complete zigzags completed\n    complete_zigzags = i // grey_per_zigzag\n    \n    # determine the starting row and column of the incomplete zigzag\n    i -= complete_zigzags * grey_per_zigzag\n    row_start = col_start = 0\n    \n    if r % 2 == 0:\n        if i >= (r // 2) * (c // 2):\n            i -= (r // 2) * (c // 2)\n            col_start = 1\n    else:\n        if i >= ((r + 1) // 2) * ((c + 1) // 2):\n            i -= (r + 1) // 2 * (c + 1) // 2\n            row_start = 1\n    \n    # iterate through the incomplete zigzag and count grey cells\n    grey_count = 0\n    row = row_start\n    col = col_start\n    while i > 0:\n        if row < (r // 2 + row_start):\n            grey_count += (col % 2 == 0)\n        else:\n            grey_count += (col % 2 == 1)\n        \n        i -= 1\n        col += 1\n        \n        if col == c:\n            row += 1\n            col = c - 1 - (c % 2 == 1)\n    \n    # add the grey cells in any remaining complete zigzags\n    grey_count += complete_zigzags * grey_per_zigzag\n    \n    # output the result\n    print(grey_count)"
 ],
 "3262": [
  "import heapq\n\ndef dijkstra(adj, s):\n    \"\"\"\n    Implementation of Dijkstra's algorithm to find shortest paths from a source node to all other nodes\n    in a weighted directed graph represented as an adjacency list.\n    \"\"\"\n    n = len(adj)\n    dist = [float('inf')] * n\n    dist[s] = 0\n    visited = [False] * n\n    pq = [(0, s)]\n    while pq:\n        d, u = heapq.heappop(pq)\n        if visited[u]:\n            continue\n        visited[u] = True\n        for v, w in adj[u]:\n            if dist[u] + w < dist[v]:\n                dist[v] = dist[u] + w\n                heapq.heappush(pq, (dist[v], v))\n    return dist\n\n# read input\nn, m, c = map(int, input().split())\nclients = list(map(int, input().split()))\nadj = [[] for _ in range(n)]\nfor _ in range(m):\n    u, v, w = map(int, input().split())\n    adj[u].append((v, w))\n\n# find the shortest driving time for each client\nclient_times = dijkstra(adj, 0)\nfor i in range(c):\n    client_times[clients[i]] = 0\nclient_times.sort(reverse=True)\n\n# find the minimum number of trucks needed\ntrucks = 0\nfor t in client_times:\n    if t == float('inf'):\n        break\n    if trucks == 0 or t > 0:\n        trucks += 1\n    trucks_needed = -(-t // trucks)\n    trucks = max(trucks_needed, trucks)\nprint(trucks)"
 ],
 "3263": [
  "import heapq\n\nn, m = map(int, input().split())\n\nptype = list(map(int, input().split()))\nput_times = list(map(int, input().split()))\n\nevents = []\nfor i in range(n):\n    c, t = map(int, input().split())\n    events.append((t, i, c-1))\n\nevents.sort()\n\nh = []\noccupied = -1\nans = 0\n\nfor ev in events:\n    t, _, ptype_idx = ev\n\n    if put_times[ptype_idx] > occupied:\n        occupied = heapq.heappushpop(h, -put_times[ptype_idx])\n    elif put_times[ptype_idx] < -occupied:\n        continue\n\n    occupied = -heapq.heappushpop(h, -ptype[ptype_idx])\n    ans += 1\n\nprint(ans)\n"
 ],
 "3264": [
  "def gcd(a,b):\n    if b==0:\n        return a\n    return gcd(b,a%b)\n\nn = int(input())\ndp = [0 for i in range(1<<n)]\ndp[0] = 1\nfor i in range(1, n+1):\n    for mask in range((1<<n)-1, -1, -1):\n        for j in range(n):\n            if mask & (1<<j) == 0 and gcd(i, j+1) == 1:\n                dp[mask|(1<<j)] = (dp[mask|(1<<j)] + dp[mask]) % 1000000000\nans = dp[(1<<n) - 1]\nprint(ans)"
 ],
 "3265": [
  "from math import exp\nfrom scipy.sparse import csc_matrix, identity\nfrom scipy.sparse.linalg import inv\n\nn, l = map(int, input().split())\nw = []\nfor _ in range(n):\n    x = list(map(int, input().split()))\n    w.append([x[i] > 0 for i in range(n)])\nw.append([False] * n)\nnode_l, node_r = 0, exp(-50)\nfor _ in range(200):\n    node_mid = (node_l + node_r) / 2\n    weight = [(csc_matrix(w) * inv(1 - node_mid * identity(n))).power(l + i).sum() for i in range(10)]\n    if 0.95 <= (weight[-1] - weight[0]) / (weight[-1] - weight[1]) <= 1:\n        print(l + weight.index(max(weight)))\n        break\n    elif (weight[-1] - weight[0]) / (weight[-1] - weight[1]) > 1:\n        node_r = node_mid\n    else:\n        node_l = node_mid\nelse:\n    print(-1)"
 ],
 "3266": [
  "from collections import deque\n\n# Ford-Fulkerson algorithm for finding maximum flow in a graph\ndef ford_fulkerson(n, s, t, adj_list, adj_matrix):\n    # Calculate a path from s to t using BFS\n    def bfs(n, s, t, adj_list, adj_matrix, parent):\n        visited = [False for _ in range(n)]\n        queue = deque()\n        queue.append(s)\n        visited[s] = True\n        while queue:\n            u = queue.popleft()\n            for v in adj_list[u]:\n                if not visited[v] and adj_matrix[u][v] > 0:\n                    parent[v] = u\n                    visited[v] = True\n                    queue.append(v)\n        return visited[t]\n\n    # Initialize flow as 0\n    max_flow = 0\n\n    # Copy the original graph to a residual graph\n    r_graph = [adj_list[i].copy() for i in range(n)]\n    residual = [[adj_matrix[i][j] for j in range(n)] for i in range(n)]\n\n    # Calculate paths from source to sink and update maximum flow until no more paths exist\n    parent = [-1 for _ in range(n)]\n    while bfs(n, s, t, r_graph, residual, parent):\n        # Find the minimum capacity edge on the path found by BFS\n        path_flow = float(\"Inf\")\n        v = t\n        while v != s:\n            u = parent[v]\n            path_flow = min(path_flow, residual[u][v])\n            v = u\n\n        # Update residual graph and maximum flow\n        v = t\n        while v != s:\n            u = parent[v]\n            residual[u][v] -= path_flow\n            residual[v][u] += path_flow\n            v = u\n        max_flow += path_flow\n\n    # Find the edges used in the maximum flow\n    edges = []\n    for u in range(n):\n        for v in adj_list[u]:\n            if adj_matrix[u][v] > 0 and residual[u][v] < adj_matrix[u][v]:\n                edges.append((u, v, adj_matrix[u][v]-residual[u][v]))\n\n    # Return number of nodes, maximum flow, number of edges used, and the edges\n    return n, max_flow, len(edges), edges\n\n# Read input\nn, m, s, t = map(int, input().split())\nadj_list = [[] for _ in range(n)]\nadj_matrix = [[0 for _ in range(n)] for _ in range(n)]\nfor _ in range(m):\n    u, v, c = map(int, input().split())\n    adj_list[u].append(v)\n    adj_list[v].append(u)\n    adj_matrix[u][v] += c\n    adj_matrix[v][u] += c\n\n# Find maximum flow and edges used\nn, max_flow, num_edges, edges_used = ford_fulkerson(n, s, t, adj_list, adj_matrix)\n\n# Print output\nprint(n, max_flow, num_edges)\nfor u, v, x in edges_used:\n    print(u, v, x)"
 ],
 "3267": [
  "from itertools import combinations\nR, C = map(int, input().split())\nboard = []\nm_kings, s_kings = [], []\n\nfor _ in range(R):\n    row = input().strip()\n    board.append(row)\n    for col_idx, char in enumerate(row):\n        if char == 'M':\n            m_kings.append((_, col_idx))\n        elif char == 'S':\n            s_kings.append((_, col_idx))\n\ndef get_total_dist(kings):\n    total_dist = 0\n    for king_1, king_2 in combinations(kings, 2):\n        dist = max(abs(king_1[0] - king_2[0]), abs(king_1[1] - king_2[1]))\n        total_dist += dist\n    return total_dist\n\nm_spread = get_total_dist(m_kings)\ns_spread = get_total_dist(s_kings)\nprint(m_spread, s_spread)"
 ],
 "3268": [
  "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    n = int(input())\n    tree = [[] for _ in range(n)]\n    DEPTH = [0] * n\n    BIGBRANCH = [-1] * n\n    CURRENT = [-1] * n\n    LEAF_LABEL = {}\n    LABEL_LEAF = []\n    for i in range(1, n):\n        pi,typ = input().split()\n        tree[int(pi)-1].append(i)\n        if typ[0] == 'B':\n            DEPTH[i] = DEPTH[int(pi)-1] + 1\n            BIGBRANCH[i] = i\n            CURRENT[i] = i\n        else:\n            DEPTH[i] = DEPTH[int(pi)-1]\n            BIGBRANCH[i] = BIGBRANCH[int(pi)-1]\n            CURRENT[i] = BIGBRANCH[i]\n            if typ[0] == 'G':\n                LABEL_LEAF.append((i, 'G', input().strip()))\n            elif typ[0] == 'T':\n                LABEL_LEAF.append((i, 'T', input().strip()))\n            else:\n                LABEL_LEAF.append((i, 'E', input().strip()))\n                LEAF_LABEL[i] = input().strip()\n\n    labelset = set([L for (i, typ, L) in LABEL_LEAF])\n    labelcount = {L: 0 for L in labelset}\n    for (i, typ, L) in LABEL_LEAF:\n        if typ == 'T':\n            labelcount[L] += 1\n\n    # Convert tiny birds to giants\n    needchange = []\n    fixed = {}\n    for (i, typ, L) in LABEL_LEAF:\n        if typ == 'T':\n            labelcount[L] -= 1\n            if labelcount[L] == 0:\n                for j in range(i, -1, BIGBRANCH[i]):\n                    if LABEL_LEAF[j][1] == 'G' and LABEL_LEAF[j][2] == L:\n                        break\n                    needchange.append((j, L))\n                    fixed[LABEL_LEAF[j][2]] = True\n                LABEL_LEAF[i] = (i, 'G', L)\n    for (i, _, L) in LABEL_LEAF:\n        if L in fixed:\n            continue\n        for (j, _, L2) in LABEL_LEAF[i:]:\n            if L2 != L:\n                break\n            if BIGBRANCH[i] == BIGBRANCH[j]:\n                needchange.append((j, L + 'X'))\n                fixed[L] = True\n                fixed[L + 'X'] = True\n                LABEL_LEAF[j] = (j, 'G', L + 'X')\n\n    # Now, check for conflicts\n    omap = {B: set() for B in range(n)}\n    conflict = set()\n    for (i, typ, L) in LABEL_LEAF[::-1]:\n        cur = CURRENT[i]\n        ok = False\n        while cur is not None:\n            if L in omap[cur]:\n                conflict.add((i, L))\n                ok = True\n                break\n            cur = BIGBRANCH[cur]\n        if not ok:\n            omap[CURRENT[i]].add(L)\n\n    # Rename conflicts\n    uf = UnionFind(n)\n    uf.add_group(-1, range(n))\n    rename = {}\n    conflicts = [cont for cont in conflict]\n    conflicts.sort()\n    for (i, L) in conflicts:\n        if uf.same(LEAF_PARENT[i], LEAF_PARENT[BIGB_PARENT[i]]):\n            oldname = L\n            newname = L\n            while newname in fixed:\n                newname += 'X'\n            fixed[newname] = True\n            for j in range(i, BIGBRANCH[i], -1):\n                needchange.append((j, newname))\n            rename[oldname] = newname\n        else:\n            uf.unite(LEAF_PARENT[i], LEAF_PARENT[BIGBRANCH[i]])\n\n    # Apply renames\n    ans = []\n    for (i, typ, L) in LABEL_LEAF:\n        if L in rename:\n            ans.append((i, rename[L]))\n        elif i in LEAF_LABEL:\n            ans.append((i, LEAF_LABEL[i]))\n    print(len(ans))\n    for pos, word in ans:\n        print(pos+1, word)\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n\n    def find(self, x):\n        if self.parent[x] == x:\n            return x\n        px = self.find(self.parent[x])\n        self.parent[x] = px\n        return px\n\n    def unite(self, x, y):\n        px = self.find(x)\n        py = self.find(y)\n        if px == py:\n            return\n        if self.rank[px] < self.rank[py]:\n            self.parent[px] = py\n        elif self.rank[py] < self.rank[px]:\n            self.parent[py] = px\n        else:\n            self.parent[py] = px\n            self.rank[px] += 1\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\nwhile True:\n    try: solve()\n    except: break"
 ],
 "3269": [
  "MOD = 10**9 + 7\n\ndef get_sum_of_distances(A, B):\n    len_a = len(A)\n    len_b = len(B)\n\n    if len_a < len_b:\n        A = \"0\" * (len_b - len_a) + A\n        len_a = len_b\n    elif len_b < len_a:\n        B = \"0\" * (len_a - len_b) + B\n        len_b = len_a\n\n    res = 0\n    for i in range(len_a):\n        res += (i + 1) * (len_b - i) * (int(B[i]) - int(A[i])) % MOD\n\n    return res % MOD\n\n\nA, B = input().split()\nprint(get_sum_of_distances(A, B))"
 ],
 "3270": [
  "from collections import defaultdict, deque\n\n# function to check if two words differ by only one character\ndef is_one_away(word1, word2):\n    diff_count = 0\n    for i in range(len(word1)):\n        if word1[i] != word2[i]:\n            diff_count += 1\n        if diff_count > 1:\n            return False\n    return True\n\n# inputs\nn = int(input())\nwords = [input().strip() for i in range(n)]\n\n# separate start and end words from dictionary\nstart_word = words.pop(0)\nend_word = words.pop(0)\n\n# add a node to the graph for each word in the dictionary\ngraph = defaultdict(list)\nfor word in words:\n    for other_word in words:\n        if is_one_away(word, other_word):\n            graph[word].append(other_word)\n\n# BFS to find shortest path from start to end word\nqueue = deque([(start_word, 1)])\nvisited = set([start_word])\nwhile queue:\n    current_word, distance = queue.popleft()\n    if current_word == end_word:\n        print(0)\n        print(distance)\n        break\n    for neighbor in graph[current_word]:\n        if neighbor not in visited:\n            visited.add(neighbor)\n            queue.append((neighbor, distance+1))\nelse:\n    # if no path found from start to end word, find a word to add to the dictionary\n    for i in range(len(start_word)):\n        for c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n            new_word = start_word[:i] + c + start_word[i+1:]\n            if new_word not in words and is_one_away(new_word, end_word):\n                words.append(new_word)\n                # recreate the graph with the new word added\n                graph = defaultdict(list)\n                for word in words:\n                    for other_word in words:\n                        if is_one_away(word, other_word):\n                            graph[word].append(other_word)\n                # BFS again to find shortest path with new word\n                queue = deque([(start_word, 1)])\n                visited = set([start_word])\n                while queue:\n                    current_word, distance = queue.popleft()\n                    if current_word == end_word:\n                        print(new_word)\n                        print(distance)\n                        break\n                    for neighbor in graph[current_word]:\n                        if neighbor not in visited:\n                            visited.add(neighbor)\n                            queue.append((neighbor, distance+1))\n                else:\n                    continue\n                break\n        else:\n            continue\n        break\nelse:\n    print(0)\n    print(-1)"
 ],
 "3271": [
  "n, c = map(int, input().split())\n\ndp = [[0]*(n+1) for _ in range(n+1)]\n\ndp[0][0] = 1\nfor i in range(1, n+1):\n    dp[i][0] = 1\n    for j in range(1, i+1):\n        dp[i][j] = (dp[i-1][j] * j + dp[i-1][j-1]) % 1000000007\n\nprint(dp[n][c])"
 ],
 "3272": [
  "import queue\n\n# Directions of the light beams\ndirections = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n# Check if the given position is within the bounds of the tomb\ndef in_bounds(pos, n, m):\n    row, col = pos\n    return 0 <= row < n and 0 <= col < m\n\n# Check if the given position contains a gargoyle\ndef is_gargoyle(tomb, pos):\n    row, col = pos\n    return tomb[row][col] in ['V', 'H']\n\n# Check if a given position is empty or contains a gargoyle\ndef is_empty_or_gargoyle(tomb, pos):\n    row, col = pos\n    return tomb[row][col] in ['.', 'V', 'H']\n\n# Reflect a beam of light on a backslash mirror\ndef reflect_on_backslash(pos, direction):\n    row, col = pos\n    if direction == (0, 1):  # Right\n        return (row - 1, col)\n    elif direction == (0, -1):  # Left\n        return (row + 1, col)\n    elif direction == (1, 0):  # Down\n        return (row, col - 1)\n    elif direction == (-1, 0):  # Up\n        return (row, col + 1)\n\n# Reflect a beam of light on a forwardslash mirror\ndef reflect_on_forwardslash(pos, direction):\n    row, col = pos\n    if direction == (0, 1):  # Right\n        return (row + 1, col)\n    elif direction == (0, -1):  # Left\n        return (row - 1, col)\n    elif direction == (1, 0):  # Down\n        return (row, col + 1)\n    elif direction == (-1, 0):  # Up\n        return (row, col - 1)\n\n# Reflect a beam of light on a mirror\ndef reflect_on_mirror(tomb, pos, direction):\n    row, col = pos\n    if tomb[row][col] == '/':\n        return reflect_on_forwardslash(pos, direction)\n    elif tomb[row][col] == '\\\\':\n        return reflect_on_backslash(pos, direction)\n\n# Check if a path exists between the two given positions\ndef path_exists(tomb, start, end):\n    n, m = len(tomb), len(tomb[0])\n    seen = set()\n    q = queue.Queue()\n    q.put(start)\n    seen.add(start)\n    while not q.empty():\n        curr_pos = q.get()\n        if curr_pos == end:\n            return True\n        row, col = curr_pos\n        for direction in directions:\n            new_pos = (row + direction[0], col + direction[1])\n            # If the new position is out of bounds or contains an obstacle, skip it\n            if not in_bounds(new_pos, n, m) or tomb[new_pos[0]][new_pos[1]] == '#':\n                continue\n            # If the new position is a mirror, reflect the direction of the beam\n            if tomb[new_pos[0]][new_pos[1]] in ['/', '\\\\']:\n                new_direction = reflect_on_mirror(tomb, new_pos, direction)\n            else:\n                new_direction = direction\n            # If the new position has not been seen, add it to the queue\n            if new_pos not in seen:\n                q.put(new_pos)\n                seen.add(new_pos)\n    return False\n\n# Rotate a gargoyle by 90 degrees clockwise\ndef rotate_gargoyle(tomb, pos):\n    row, col = pos\n    if tomb[row][col] == 'V':\n        tomb[row] = tomb[row][:col] + 'H' + tomb[row][col+1:]\n    elif tomb[row][col] == 'H':\n        tomb[row] = tomb[row][:col] + 'V' + tomb[row][col+1:]\n\n# Check if a solution exists for the puzzle\ndef has_solution(tomb):\n    n, m = len(tomb), len(tomb[0])\n    gargoyles = []\n    for i in range(n):\n        for j in range(m):\n            if tomb[i][j] in ['V', 'H']:\n                gargoyles.append((i, j))\n    for gargoyle in gargoyles:\n        for _ in range(4):\n            rotate_gargoyle(tomb, gargoyle)\n            for direction in directions:\n                pos = (gargoyle[0] + direction[0], gargoyle[1] + direction[1])\n                if not is_empty_or_gargoyle(tomb, pos):\n                    continue\n                if path_exists(tomb, gargoyle, pos):\n                    return True\n    return False\n\n# Count the number of gargoyles that need to be rotated to solve the puzzle\ndef count_rotations(tomb):\n    n, m = len(tomb), len(tomb[0])\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            if tomb[i][j] in ['V', 'H']:\n                rotated = False\n                if tomb[i][j] == 'V':\n                    if path_exists(tomb, (i, j), (i+1, j)) and path_exists(tomb, (i, j), (i-1, j)):\n                        continue\n                    else:\n                        rotate_gargoyle(tomb, (i, j))\n                        rotated = True\n                elif tomb[i][j] == 'H':\n                    if path_exists(tomb, (i, j), (i, j+1)) and path_exists(tomb, (i, j), (i, j-1)):\n                        continue\n                    else:\n                        rotate_gargoyle(tomb, (i, j))\n                        rotated = True\n                if not rotated:\n                    rotate_gargoyle(tomb, (i, j))\n                count += 1\n    return count if has_solution(tomb) else -1\n\n# Read input\nn, m = map(int, input().split())\ntomb = [input() for _ in range(n)]\n\n# Solve puzzle and print solution\nprint(count_rotations(tomb))"
 ],
 "3273": [
  "n = int(input())\n\n# Read in the text fragments\nfragments = []\nfor i in range(n):\n    fragments.append(input())\n\n# Construct a directed graph, where each fragment is a node and\n# there is a directed edge from fragment A to fragment B if A\n# has a suffix that matches a prefix of B with length at least 5\ngraph = [[] for _ in range(n)]\nfor i in range(n):\n    for j in range(n):\n        if i == j:\n            continue\n        for k in range(5, len(fragments[i])):\n            if fragments[j].startswith(fragments[i][-k:]):\n                graph[i].append(j)\n                break\n\n# Topologically sort the graph and keep track of the maximum length\n# sequence ending at each node\nsorted_nodes = []\nmax_lengths = [0] * n\nfor i in range(n):\n    stack = [i]\n    visited = [False] * n\n    while stack:\n        node = stack[-1]\n        if not visited[node]:\n            visited[node] = True\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    stack.append(neighbor)\n        else:\n            # All neighbors have been visited already\n            max_length = 0\n            next_node = None\n            for neighbor in graph[node]:\n                if max_lengths[neighbor] + 1 > max_length:\n                    max_length = max_lengths[neighbor] + 1\n                    next_node = neighbor\n            max_lengths[node] = max_length\n            if next_node is not None:\n                max_lengths[node] += len(fragments[node]) - (len(fragments[node])-len(fragments[next_node]))\n            sorted_nodes.append(node)\n            stack.pop()\n\n# Check if there is a unique maximal-length sequence of nodes\nmax_length = max(max_lengths)\nif max_lengths.count(max_length) > 1:\n    print(\"AMBIGUOUS\")\nelse:\n    # Construct the optimal reconstruction\n    optimal_fragments = [fragments[sorted_nodes[i]] for i in range(n) if max_lengths[sorted_nodes[i]] == max_length]\n    reconstructed_text = optimal_fragments[0]\n    for i in range(1, len(optimal_fragments)):\n        for k in range(5, len(optimal_fragments[i])):\n            if reconstructed_text.endswith(optimal_fragments[i][:k]):\n                reconstructed_text += optimal_fragments[i][k:]\n                break\n    print(reconstructed_text)"
 ],
 "3274": [
  "import sys\ninput = sys.stdin.readline\n\nn, m = map(int, input().split())\nships = [[] for _ in range(n)] # Stores ships at each y-coordinate\nfor _ in range(m):\n    x1, x2, y = map(int, input().split())\n    ships[y-1].append((x1, x2))\n\n# Helper function to check if torpedo will hit a ship given current position\ndef hit_ship(x, y):\n    for ship in ships[y]:\n        if x >= ship[0] and x <= ship[1]:\n            return True\n    return False\n\n# Start at (0, 0) and try all possible sideways moves\nmoves = ['-' for _ in range(n)]\ncur_x, cur_y = 0, 0\nfor i in range(n):\n    if cur_x > 0:\n        if not hit_ship(cur_x-1, cur_y+1):\n            cur_x -= 1\n            cur_y += 1\n            moves[i] = '-'\n            continue\n    if not hit_ship(cur_x, cur_y+1):\n        cur_y += 1\n        moves[i] = '0'\n        continue\n    if cur_x < 0:\n        if not hit_ship(cur_x+1, cur_y+1):\n            cur_x += 1\n            cur_y += 1\n            moves[i] = '+'\n            continue\n    print(\"impossible\")\n    exit()\n\nprint(''.join(moves))"
 ],
 "3275": [
  "MOD = 10007\n\nN, C = map(int, input().split())\ncolored = list(map(int, input().split()))\nblack_white = list(map(int, input().split()))\nans = 0\n\ndef solve(colored, black_white, C):\n    num_colored = 0\n    for i in range(N):\n        if colored[i] == 0:\n            continue\n        if colored[i] <= num_colored and (colored[i]+black_white[i] > num_colored):\n            num_colored += 1\n\n    if num_colored >= C:\n        return 1\n    else:\n        return 0\n\nfor i in range(N):\n    if colored[i] == 0:\n        continue\n    if colored[i] > 0 and colored[i] + black_white[i] <= C:\n        ans += 1\n\nchanges = int(input())\nfor i in range(changes):\n    P, Ai, Bi = map(int, input().split())\n    P -= 1\n\n    if colored[P] == 0:\n        continue\n\n    if Ai + Bi <= C or colored[P] > C:\n        ans -= solve(colored, black_white, C)\n        colored[P] = Ai\n        black_white[P] = Bi\n        ans += solve(colored, black_white, C)\n\n        print(ans % MOD"
 ],
 "3276": [
  "N, M = map(int, input().split())\ngrid = []\nfor i in range(N):\n    grid.append(input())\n\nfor i in range(1, N-1):\n    for j in range(1, M-1):\n        square = set([grid[x][y] for x in range(i-1, i+2) for y in range(j-1, j+2)])\n        if len(square) == 1 and 'W' not in square:\n            print(\"NO\")\n            exit()\n\nprint(\"YES\")"
 ],
 "3277": [
  "from collections import deque\nn, k, s = map(int, input().split())\narr = list(map(int, input().split()))\n\nif k*s > sum(arr):\n    s = (sum(arr) + k - 1) // k\ncounter = [0] * (s+1)\n\nfor i in range(k):\n    counter[arr[i]] += 1\n\nmodifications = float('inf')\nfor i in range(s+1):\n    if sum(counter[i:]) == k:\n        modifications = min(modifications, k - counter[i])\n    elif sum(counter[i:]) > k:\n        ones = sum(counter[i+1:])\n        zeros = k - ones\n        modifications = min(modifications, ones*(i+1) + zeros*i - sum(arr[i-k+1:i+1]))\n        \nfor j in range(k, n):\n    counter[arr[j-k]] -= 1\n    counter[arr[j]] += 1\n    i = arr[j-k]\n    if sum(counter[i:]) == k:\n        modifications = min(modifications, k - counter[i])\n    elif sum(counter[i:]) > k:\n        ones = sum(counter[i+1:])\n        zeros = k - ones\n        modifications = min(modifications, ones*(i+1) + zeros*i - sum(arr[j-k+1:j+1]))\n\nprint(modifications)"
 ],
 "3278": [
  "import math\nn = int(input())\nfrogs = []\nfor i in range(n):\n    x, d = map(int, input().split())\n    frogs.append((x, d))\n\nfrogs.sort()\n\npositions = [frogs[0][0]]\nfor i in range(1, n):\n    prev_pos = positions[-1]\n    distance = frogs[i][0] - frogs[i-1][0]\n    positions.append(prev_pos + distance)\n\nprime_distances = set([f[1] for f in frogs])\nmax_tower_size = 0\nmax_tower_pos = 0\n\nfor i in range(n):\n    for length in range(max_tower_size + 1, n-i+1):\n        if len(prime_distances.intersection(set([frogs[j][1] for j in range(i, i+length)]))) == length:\n            tower_height = sum([frogs[j][1] for j in range(i, i+length)])\n            if tower_height > max_tower_size:\n                max_tower_size = tower_height\n                max_tower_pos = positions[i]\n\nprint(max_tower_pos, max_tower_size)"
 ],
 "3279": [
  "def search(idx):\n    if idx == top and len(hstrips) == num_col:\n        for i in range(num_row):\n            print(hstrips[i])\n        for i in range(num_col+1):\n            ans = ''\n            for j in range(num_row):\n                ans += str(vstrips[i][j])\n            print(ans)\n        exit()\n    if idx == top:\n        return\n    if len(hstrips) == num_row:\n        search(idx+1)\n        return\n    if len(hstrips) == 0:\n        last_start = 0\n    else:\n        last_start = hstrips[-1].rfind('1')+2 # last_start: last 1's index + 2\n    remain_space = n+1-last_start\n    rem_count = len(rest_h[idx])\n    for num_blank in range(remain_space-rem_count+1):\n        bar_sum = sum(rest_h[idx])+len(rest_h[idx])-1\n        dish = [0]*(bar_sum+1)\n        for i, bar_length in enumerate(rest_h[idx]):\n            for j in range(last_start+num_blank, last_start+num_blank+bar_length):\n                hstrips[-1] += '1'\n                if j == last_start+num_blank:\n                    dish[i] = 1\n                elif j == last_start+num_blank+bar_length-1:\n                    dish[i] = 3\n                else:\n                    dish[i] = 2\n        for cmbs in combinations_with_replacement(dish[:-1], len(rest_h[idx])-1):\n            for per in permutations([1]*(bar_sum-len(rest_h[idx])+1)+[0]*num_blank):\n                cur, flag = [], True\n                for i in range(bar_sum):\n                    cur += [per[i]]\n                    if cmbs and i == cmbs[0]:\n                        cur += [0]\n                        cmbs.pop(0)\n                cur += [per[-1]]\n                for i in range(bar_sum+1):\n                    if cur[i] and (vstrips[i][len(hstrips)] if len(hstrips) else 0 \\\n                                   or i-1 >= 0 and vstrips[i-1][len(hstrips)] \\\n                                   or i+1 <= num_row and vstrips[i+1][len(hstrips)]):\n                        flag = False\n                        break\n                if flag:\n                    for i, ele in enumerate(cur[:-1]):\n                        vstrips[i][len(hstrips)] = ele\n                    search(idx+1)\n                    for i, ele in enumerate(cur[:-1]):\n                        vstrips[i][len(hstrips)] = 0\n        for i in range(last_start, last_start+num_blank+rem_count):\n            hstrips[-1] = hstrips[-1][:-1]\n    # unchecked\n    remain_space = n+1-last_start\n    for blank in range(num_row-last_start+1):\n        bar_sum = sum(rest_h[idx])+len(rest_h[idx])-1\n        dish = [0]*(bar_sum+1)\n        for i, bar_length in enumerate(rest_h[idx]):\n            for j in range(last_start, last_start+blank):\n                cur_idx = len(hstrips)-1 if i==0 else -1\n                hstrips[cur_idx] += '1'\n                if j == last_start:\n                    dish[i] = 1\n                elif j == last_start+blank-1:\n                    dish[i] = 3\n                else:\n                    dish[i] = 2\n                if i:\n                    vstrips[j][len(hstrips)-2] = 0\n        for cmbs in combinations_with_replacement(dish[:-1], len(rest_h[idx])-1):\n            for per in permutations([0]*blank+[1]*(bar_sum-len(rest_h[idx])+1)):\n                cur, flag = [], True\n                for i in range(bar_sum):\n                    cur += [per[i]]\n                    if cmbs and i == cmbs[0]:\n                        cur += [0]\n                        cmbs.pop(0)\n                cur += [per[-1]]\n                for i in range(bar_sum+1):\n                    if cur[i] and (vstrips[i][len(hstrips)-2] if len(hstrips)>=2 else 0 \\\n                                   or i-1 >= 0 and vstrips[i-1][len(hstrips)-2] \\\n                                   or i+1 <= num_row and vstrips[i+1][len(hstrips)-2] \\\n                                   or vstrips[i][len(hstrips)-1] if len(hstrips)>=1 else 0 \\\n                                   or i-1 >= 0 and vstrips[i-1][len(hstrips)-1] \\\n                                   or i+1 <= num_row and vstrips[i+1][len(hstrips)-1]):\n                        flag = False\n                        break\n                if flag:\n                    for i, ele in enumerate(cur[:-1]):\n                        vstrips[i][len(hstrips)-1] = ele\n                    search(idx+1)\n                    for i, ele in enumerate(cur[:-1]):\n                        vstrips[i][len(hstrips)-1] = 0\n        for i in range(last_start, last_start+blank):\n            hstrips[-1] = hstrips[-1][:-1]\n\nn = int(input())\nrest_h = []\nfor i in range(n):\n    arr = list(map(int, input().split()))\n    if arr[0] == 0:\n        rest_h += [[0]]\n    else:\n        rest_h += [arr]\nrest_v = []\nfor i in range(n):\n    arr = list(map(int, input().split()))\n    if arr[0] == 0:\n        rest_v += [[0]*(n+1)]\n    else:\n        rest_v += [[0]+[1]*bl+[0] for bl in arr]\nhstrips, vstrips = [], [[0]*n for i in range(n+1)]\nnum_row, num_col = n, n+1\ntop = num_row\nsearch(0)"
 ],
 "3280": [
  "n, k = map(int, input().split())\nshows = []\nfor i in range(n):\n    start, end = map(int, input().split())\n    shows.append((start, end))\nshows.sort(key=lambda x: x[1])\nend_times = []\ncount = 0\nfor start, end in shows:\n    while end_times and end_times[0] <= start:\n        heapq.heappop(end_times)\n    if len(end_times) < k:\n        heapq.heappush(end_times, end)\n        count += 1\nprint(count)"
 ],
 "3281": [
  "import math\n\n# Function to find the distance between two points\ndef distance(x1, y1, x2, y2):\n    return math.sqrt((x1-x2)**2 + (y1-y2)**2)\n\n# Function to calculate the turning angle at a junction\ndef turning_angle(x1, y1, x2, y2, x3, y3):\n    a = distance(x2, y2, x1, y1)\n    b = distance(x2, y2, x3, y3)\n    c = distance(x1, y1, x3, y3)\n    return math.degrees(math.acos((a**2 + b**2 - c**2)/(2*a*b)))\n\n# Function to perform DFS and find the minimum turning angle route\ndef dfs(curr, visited, graph, J, target, max_turning_angle, curr_turning_angle):\n    visited[curr] = True\n    if curr == target:\n        return curr_turning_angle\n    turning_angles = []\n    for neighbor in graph[curr]:\n        x1, y1 = junctions[curr]\n        x2, y2 = junctions[neighbor]\n        x3, y3 = junctions[target]\n        new_turning_angle = turning_angle(x1, y1, x2, y2, x3, y3)\n        if curr_turning_angle == float('inf'):\n            turning_angles.append(dfs(neighbor, visited, graph, J, target, max_turning_angle, new_turning_angle))\n        elif new_turning_angle <= max_turning_angle and curr_turning_angle+new_turning_angle <= max_turning_angle:\n            turning_angles.append(dfs(neighbor, visited, graph, J, target, max_turning_angle, curr_turning_angle+new_turning_angle))\n    if not turning_angles:\n        return float('inf')\n    return min(turning_angles)\n\n# Read input values\nJ, R, D = map(int, input().split())\n\njunctions = {}\n\n# Read all junction coordinates\nfor i in range(J):\n    x, y = map(int, input().split())\n    junctions[i+1] = (x, y)\n\n# Create adjacency list for the graph\ngraph = {i+1: [] for i in range(J)}\nfor i in range(R):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n\n# Perform DFS to find the minimum turning angle route that satisfies the maximum distance constraint\nvisited = {i+1: False for i in range(J)}\nmax_turning_angle = float('inf')\ncurr_turning_angle = float('inf')\ntarget = J\nresult = dfs(1, visited, graph, J, target, max_turning_angle, curr_turning_angle)\n\n# Check if a valid route was found\nif result == float('inf'):\n    print('Impossible')\nelse:\n    print('{:.8f}'.format(result))"
 ],
 "3282": [
  "from itertools import permutations\nP = int(input())\ncount = 0\npossible_bills = []\nfor bev, main in permutations(range(1, 10), 2):\n    bev_price = int(str(bev) + str(P))\n    main_price = int(str(main) + str(P))\n    total_price = bev_price + main_price\n    digits = set(str(bev) + str(main) + str(total_price))\n    if len(digits) == 6:\n        if not possible_bills or (bev_price, main_price) != possible_bills[-1]:\n            count += 1\n            possible_bills.append((bev_price, main_price))\n        if count == 5000:\n            break\nprint(count)\nfor bill in possible_bills:\n    print(bill[0], bill[1])"
 ],
 "3283": [
  "import numpy as np\n\nn, d, r = map(int, input().split())\n\n# Initializing a numpy array of size n with all elements as 1\na = np.ones(n)\n\nfor i in range(d):\n    # Choosing a random index to split\n    index = np.random.randint(0, n)\n    # Incrementing the value of that index by 1 (split into two gems)\n    a[index] += 1\n\n# Sorting the array in descending order\na = np.sort(a)[::-1]\n\n# Calculating the expected value of the sum of top r elements\nexpected_value = np.sum(a[:r]) + (r * (n-r) * (1/2)**d)\n\nprint(expected_value)"
 ],
 "3284": [
  "a, b, c, d = map(int, input().split())\n\ndef count_coprime_pairs(n):\n    phi = [i for i in range(n+1)]\n    for i in range(2, n+1):\n        if phi[i] == i:\n            for j in range(i, n+1, i):\n                phi[j] = (phi[j] // i) * (i - 1)\n    return phi\n\nphi = count_coprime_pairs(max(b, d))\nans = 0\nfor i in range(a, b+1):\n    ans += phi[d] - phi[c-1] if c > 1 else phi[d] - phi[c]\nprint(ans)"
 ],
 "3285": [
  "r, m = map(int, input().split())\n\nA = [r]\n\ndef smallest_diff(A):\n    diffs = []\n    for i in range(len(A)):\n        for j in range(i+1, len(A)):\n            diffs.append(abs(A[i]-A[j]))\n    smallest = 1\n    while smallest in diffs:\n        smallest += 1\n    return smallest\n\ni = 1\nwhile m not in A and m not in list(set([abs(A[j] - A[k]) for j in range(i) for k in range(j)])):\n    i += 1\n    A.append(A[i-2]+smallest_diff(A))\nprint(i)"
 ],
 "3286": [
  "def num_original_passwords(password):\n    vowels = set(['a', 'e', 'i', 'o', 'u'])\n    num_ways = 1\n    consecutive_consonants = 0\n    for letter in password:\n        if letter in vowels:\n            num_ways = (num_ways*1) % 1000009\n            consecutive_consonants = 0\n        else:\n            consecutive_consonants += 1\n            if consecutive_consonants == 1:\n                num_ways = (num_ways*2) % 1000009\n    return num_ways % 1000009\n\npassword = input().strip()\nprint(num_original_passwords(password))"
 ],
 "3287": [
  "MOD = 10**9 + 7\n\nk = int(input())\nx = list(map(int, input().split()))\n\ntotal = sum(x)\nhalf = total // 2\ndp = [0] * (half + 1)\ndp[0] = 1\n\nfor i in range(k):\n    for j in range(half, x[i]-1, -1):\n        dp[j] |= dp[j-x[i]]\n\nfor i in range(half, -1, -1):\n    if dp[i]:\n        print(total - 2*i)\n        break"
 ],
 "3288": [
  "from math import comb\n\ndef is_double_free(s):\n    return all(s[i] != s[i+1] for i in range(len(s)-1))\n\ndef count_strings(k, n, pos, freq):\n    if k == 0:\n        return \"\"\n    count = 0\n    for i in range(26):\n        if freq[i] == pos:\n            freq[i] -= 1\n            s = chr(i+97) + count_strings(k-1, n-count, pos-1, freq)\n            if is_double_free(s):\n                return s\n            count += comb(pos, k-1)\n            freq[i] += 1\n        elif freq[i] > pos:\n            count += comb(pos, k-1)\n    return -1\n\nk, n = map(int, input().split())\nif k*(k+1)//2 > n:\n    print(-1)\nelse:\n    print(count_strings(k, n, k, [min(i,k) for i in range(26)]))"
 ],
 "3289": [
  "n = int(input())\ndata = []\nfor i in range(n):\n    a, b, c = map(int, input().split())\n    data.append((a, b, c))\n\ndata.sort()\nnum_votes = sum(c for a, b, c in data)\nnum_true_votes = 0\nans = n\nfor i in range(n):\n    a, b, c = data[i]\n    # Count the number of true votes before and after this person\n    if c == 1:\n        num_true_votes += 1\n    if i < n-1 and a == data[i+1][0] and b == data[i+1][1]:\n        continue\n    if num_true_votes == num_votes or num_true_votes == 0:\n        ans = 0\n        break\n    # Calculate the cluster size for this a, b values\n    if num_true_votes > num_votes - num_true_votes:\n        cluster_size = num_true_votes\n    else:\n        cluster_size = num_votes - num_true_votes\n    ans = min(ans, cluster_size)\nprint(ans)"
 ],
 "3290": [
  "from collections import deque\n\nn, e, d = map(int, input().split())\nexp_locs = sorted(list(map(int, input().split())))\ndef_locs = sorted(list(map(int, input().split())))\n\n# create deck of cards\ndeck = deque()\ncurr_exp_loc = 0\nfor i in range(e):\n    deck.extend(list(range(curr_exp_loc+1, exp_locs[i]+1)))\n    curr_exp_loc = exp_locs[i]\ndeck.append(\"Exploding Kitten\")\ndeck += list(range(curr_exp_loc+1, len(deck)+d+1))\ncurr_def_loc = len(deck)-d-1\nfor i in range(d):\n    deck.insert(curr_def_loc, \"Defuse\")\n    curr_def_loc += def_locs[i]+1\n\n# simulate game and determine winner\nhands = [deque() for _ in range(n)]\nturn_idx = 0\nwhile len(hands) > 1:\n    curr_player = turn_idx % len(hands)\n    hands[curr_player].append(deck.popleft())\n    if hands[curr_player][-1] == \"Exploding Kitten\":\n        if \"Defuse\" in hands[curr_player]:\n            hands[curr_player].remove(\"Defuse\")\n        else:\n            hands.pop(curr_player)\n            turn_idx -= 1 # adjust turn index since player has been removed\n    elif len(hands[curr_player]) > 5:\n        hands[curr_player].popleft()\n    turn_idx += 1\n\nif len(hands) == 1:\n    print(turn_idx % n)\nelse:\n    print(-1)"
 ],
 "3291": [
  "from fractions import Fraction\n\n# function to construct the splitter network\ndef construct_network(a, b, c, d):\n    # reduce the split ratio\n    split_ratio = Fraction(c, c + d)\n    # calculate the required ratio for each splitter in the network\n    required_ratios = [split_ratio]\n    while len(required_ratios) < 200:\n        required_ratios.append(1 - required_ratios[-1])\n    \n    # calculate the total number of splitters needed\n    num_splitters = len(required_ratios) - 1\n    \n    # if the number of splitters needed exceeds the limit, return None\n    if num_splitters * (a + b) > 10**9:\n        return None\n    \n    # create the splitter network\n    network = []\n    prev_node = -1 # the initial input node\n    for i, ratio in enumerate(required_ratios[:-1]):\n        # determine the split ratio for the current splitter\n        split_ratio = Fraction(ratio * (a + b), b)\n        # determine the indices of the splitter's output nodes\n        left_node = i + 1\n        right_node = i + 2\n        \n        # add the splitter to the network\n        network.append((prev_node, left_node, split_ratio))\n        network.append((prev_node, right_node, 1 - split_ratio))\n        \n        # update the previous node\n        prev_node = left_node\n        \n    # add the final output nodes to the network\n    network.append((prev_node, -1, Fraction(c, c + d)))\n    network.append((prev_node, -2, Fraction(d, c + d)))\n    \n    # return the splitter network\n    return (num_splitters, network)\n\n# read the input values\na, b = map(int, input().split())\nc, d = map(int, input().split())\n\n# construct the splitter network\nresult = construct_network(a, b, c, d)\n\n# if the result is None, output -1\nif result is None:\n    print(\"-1\")\nelse:\n    num_splitters, network = result\n    # output the number of splitters\n    print(num_splitters)\n    # output the splitter network\n    for left_node, right_node, ratio in network:\n        print(left_node, right_node)"
 ],
 "3292": [
  "from collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef dfs(graph, name, visited, memo):\n    if memo[name]:\n        return memo[name]\n    visited[name] = True\n    result = 1\n    for neighbor in graph[name]:\n        if not visited[neighbor]:\n            result *= dfs(graph, neighbor, visited, memo)\n            result %= MOD\n    memo[name] = (result + 1) % MOD\n    return memo[name]\n\nn = int(input())\nnames = [input() for _ in range(n)]\ngraph = defaultdict(list)\nfor i in range(n):\n    for j in range(i+1, n):\n        if names[i][0] == names[j][0]:\n            graph[names[i]].append(names[j])\n            graph[names[j]].append(names[i])\nvisited = defaultdict(bool)\nmemo = defaultdict(int)\nans = 1\nfor name in names:\n    if not visited[name]:\n        size = dfs(graph, name, visited, memo)\n        ans *= size\n        ans %= MOD\nprint(ans)"
 ],
 "3293": [
  "n = int(input())\nsnacks = []\nfor i in range(n):\n    f, p, m, s = map(int, input().split())\n    snacks.append([f, p, m, s])\n\ntotal_profit = 0\nfor i in range(n):\n    visited = [False]*n\n    j = i\n    curr_profit = 0\n    while not visited[j]:\n        visited[j] = True\n        f, p, m, s = snacks[j]\n        curr_profit += m # selling price - vending price\n        j = f-1 # adjust for 0-indexing\n        if s == 1: # if last snack from this position, skip to next\n            j += 1\n        s -= 1\n        snacks[j][3] = s # update remaining snacks\n    total_profit = max(total_profit, curr_profit)\n\nprint(total_profit)"
 ],
 "3294": [
  "import math\n\ndef distance(x1, y1, x2, y2):\n    return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n\nN = int(input())\n\ncontours = []\n\nfor i in range(N):\n    H0, H1, M = map(int, input().split())\n    vertices = []\n    for j in range(M):\n        x, y = map(int, input().split())\n        vertices.append((x, y))\n    contours.append((H0, H1, vertices))\n\nmin_distance = float('inf')\n\nfor H0, _, vertices in contours:\n    for i in range(len(vertices)):\n        j = (i + 1) % len(vertices)\n        x1, y1 = vertices[i]\n        x2, y2 = vertices[j]\n        if y1 == y2: # line is vertical, distance is horizontal\n            if x1 < 0 and x2 < 0: # both points are to the left of the y-axis\n                continue\n            if x1 > 0 and x2 > 0: # both points are to the right of the y-axis\n                continue\n            if min(x1, x2) > 0: # line is to the right of the y-axis\n                continue\n            distance_from_y_axis = abs(x1)\n        else:\n            m = (y2 - y1) / (x2 - x1) # slope of the line\n            c = y1 - m * x1 # y-intercept of the line\n            # find x-coordinate of the point where the line intersects the y-axis\n            distance_from_y_axis = abs(c / m)\n        min_distance = min(min_distance, distance_from_y_axis + H0)\n\nprint(\"{:.7f}\".format(min_distance))"
 ],
 "3295": [
  "from sympy import primepi\n\ndef happy_number(x):\n    if x <= M and (x <= 1 or is_prime[x]):\n        return True\n    return False\n\ndef possible_nums():\n    possible = []\n    start_num = 1\n    while len(possible) < L:\n        if happy_number(start_num):\n            possible.append(start_num)\n        start_num += 1\n    if len(possible) == L:\n        return possible\n    else:\n        return None\n\nfor _ in range(int(input())):\n    K, L, M = map(int, input().split())\n    is_prime = [False, False] + [True]*(M-1)\n    for i in range(2, int(M**0.5)+1):\n        if is_prime[i]:\n            for j in range(i*i, M+1, i):\n                is_prime[j] = False\n    happy_count = primepi(M+1) - 2 # exclude 0 and 1\n    i = 0\n    while i+K <= happy_count:\n        possibles = possible_nums()\n        if possibles:\n            break\n        i += 1\n    if possibles:\n        print(possibles[0])\n    else:\n        print(-1)"
 ],
 "3296": [
  "from math import gcd\nP = 2**31 - 1\n\ndef fact(n):\n    ans = 1\n    for i in range(2, n+1):\n        ans = ans * i % P\n    return ans\n\ndef powmod(x,n):\n    ans = 1\n    while n:\n        if n % 2:\n            ans = ans * x % P\n        x = x * x % P\n        n //= 2\n    return ans\n\ndef inv(x):\n    return powmod(x, P-2)\n\nn, k = map(int, input().split())\n\ndivisor = []\nfor i in range(1, n+1):\n    if k % i == 0:\n        divisor.append(i)\n\nans = 0\nfor d in divisor:\n    sgn = 1 if len(divisor) % 2 == 0 else -1\n    ans += sgn * fact(n-d) * powmod(d, n) * inv(powmod(k//d, n))\n    ans %= P\n\nans = ans * inv(fact(n)) % P\nprint(ans)"
 ],
 "3297": [
  "from itertools import permutations\n\nexp = input()\nwords = exp.split(\"+\") + exp.split(\"=\")\nunique_chars = set(\"\".join(words))\nif len(unique_chars) > 10:\n    print(\"impossible\")\nelse:\n    for p in permutations(\"0123456789\", len(unique_chars)):\n        mapping = dict(zip(unique_chars, p))\n        if all(mapping[word[0]] != '0' for word in words) and \\\n                int(\"\".join(mapping[c] for c in words[0])) + \\\n                int(\"\".join(mapping[c] for c in words[1])) == \\\n                int(\"\".join(mapping[c] for c in words[2])):\n            print(exp.translate(str.maketrans(mapping)))\n            break\n    else:\n        print(\"impossible\")"
 ],
 "3298": [
  "n = int(input())\na = list(map(int, input().split()))\n\nMOD = 10**9 + 9\n\nfact = [1] * (n+1)\nfor i in range(1, n+1):\n    fact[i] = (fact[i-1] * i) % MOD\n\ndp = [0] * (n+1)\ndp[1] = 1\n\nfor i in range(2, n+1):\n    dp[i] = fact[i]\n    for j in range(1, i):\n        if a[j-1] > a[i-1]: # unsorted\n            dp[i] = (dp[i] - dp[j] * fact[i-j] % MOD + MOD) % MOD\n\nprint(dp[n])"
 ],
 "3299": [
  "n, m = map(int, input().split())\nmatrix = []\nfor i in range(n):\n    matrix.append([int(x) if x != 0 else None for x in input().split()])\n\n# helper functions\ndef is_valid(row, col, num):\n    # check row and column constraints\n    for i in range(n):\n        if matrix[i][col] == num:\n            return False\n    for j in range(m):\n        if matrix[row][j] == num:\n            return False\n    \n    # check corner constraints\n    if row > 0 and col > 0:\n        if ((matrix[row-1][col-1] is not None) and\n            (num % 2 == matrix[row-1][col-1] % 2)):\n            return False\n    if row > 0 and col < m-1:\n        if ((matrix[row-1][col+1] is not None) and\n            (num % 2 == matrix[row-1][col+1] % 2)):\n            return False\n    if row < n-1 and col > 0:\n        if ((matrix[row+1][col-1] is not None) and\n            (num % 2 == matrix[row+1][col-1] % 2)):\n            return False\n    if row < n-1 and col < m-1:\n        if ((matrix[row+1][col+1] is not None) and\n            (num % 2 == matrix[row+1][col+1] % 2)):\n            return False\n    \n    return True\n\ndef backtrack():\n    # find the next empty cell\n    for i in range(n):\n        for j in range(m):\n            if matrix[i][j] is None:\n                # try all valid numbers in this cell\n                for num in range(1, n*m+1):\n                    if is_valid(i, j, num):\n                        matrix[i][j] = num\n                        backtrack()  # move to next empty cell\n                        matrix[i][j] = None  # backtrack\n                        \n                return  # no valid number found, backtrack\n    \n    # all cells filled with valid numbers\n    min_sum = sum([sum(row) for row in matrix])\n    global ans\n    ans = min(ans, min_sum)\n\n# main backtracking search\nans = float('inf')\nbacktrack()\n\n# output answer\nif ans == float('inf'):\n    print(-1)\nelse:\n    print(ans)"
 ],
 "3300": [
  "n = int(input())\ncheetahs = []\nfor i in range(n):\n    start_time, velocity = map(int, input().split())\n    cheetahs.append((start_time, velocity))\n\ncheetahs = sorted(cheetahs, key=lambda x: x[0])\n\nmin_length = 0\nt_max = 0\nfor start_time, velocity in cheetahs:\n    t = (min_length + start_time) / (velocity - 0.5)\n    if t > t_max:\n        t_max = t\n        min_length += velocity * (t_max - start_time)\n\nprint(\"{:.3f}\".format(min_length))"
 ],
 "3301": [
  "import heapq\n\ndef dijkstra(graph, start, end):\n    dist = {node: float('inf') for node in graph}\n    dist[start] = 0\n    heap = []\n    heapq.heappush(heap, [dist[start], start])\n\n    while heap:\n        current_dist, current_node = heapq.heappop(heap)\n\n        if current_dist > dist[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node].items():\n            distance = current_dist + weight\n\n            if distance < dist[neighbor]:\n                dist[neighbor] = distance\n                heapq.heappush(heap, [distance, neighbor])\n\n    return dist[end]\n\nn, p, x, y = map(int, input().split())\npartnerships = {i: {} for i in range(1, n+1)}\nfor _ in range(p):\n    a, b, c = map(int, input().split())\n    partnerships[a][b] = c\n    partnerships[b][a] = c\n\nm = int(input())\nswerc_banks = set(map(int, input().split()))\n\nmin_cost = float('inf')\nfor mid_bank in range(1, n+1):\n    if mid_bank not in swerc_banks:\n        continue\n    cost = dijkstra(partnerships, x, mid_bank) + dijkstra(partnerships, mid_bank, y)\n    min_cost = min(min_cost, cost)\n\nif min_cost == float('inf'):\n    print(\"Impossible\")\nelif min_cost == 0:\n    print(\"Infinity\")\nelse:\n    print(min_cost)"
 ],
 "3302": [
  "from itertools import product\n\ndef gray_code(n: int) -> list:\n    if n == 1:\n        return ['0', '1']\n    \n    prev_code = gray_code(n-1)\n    new_code = []\n    for i in range(len(prev_code)):\n        new_code.append(f'0{prev_code[i]}')\n    for i in range(len(prev_code)-1, -1, -1):\n        new_code.append(f'1{prev_code[i]}')\n    return new_code\n\nn, p = map(int, input().split())\nall_bits = set(range(1, n+1))\npalette = set(map(int, input().split()))\n\nif not (all_bits >= palette):\n    print(\"impossible\")\nelse:\n    colors = [''] * (2 ** n)\n    gray_order = gray_code(n)\n    valid = True\n    for i in range(1, len(gray_order)):\n        diff = sum(1 for j in range(n) if gray_order[i-1][j] != gray_order[i][j])\n        if diff not in palette:\n            valid = False\n            break\n        else:\n            colors[i-1] = gray_order[i-1]\n    colors[-1] = gray_order[-1]\n    if valid:\n        print('\\n'.join(colors))\n    else:\n        print(\"impossible\")"
 ],
 "3303": [
  "num1 = input()\nnum2 = input()\n\ncarry = 0\nsteps = 0\nfor i in range(max(len(num1), len(num2))):\n    d1 = int(num1[-(i+1)]) if i < len(num1) else 0\n    d2 = int(num2[-(i+1)]) if i < len(num2) else 0\n\n    s = d1 + d2 + carry\n    carry = s // 10\n    if carry == 0:\n        continue\n    steps_needed = 10 - s\n    steps += steps_needed\n    carry = 1\n\nprint(steps)"
 ],
 "3304": [
  "n = int(input())\na = list(map(int, input().split()))\np = list(map(int, input().split()))\nv = list(map(int, input().split()))\n\nd = {}\nfor i in range(n):\n    if a[i] in d:\n        d[a[i]].append(i)\n    else:\n        d[a[i]] = [i]\n\nd_pos = sorted(d.keys(), key=lambda k: p[k-1], reverse=True)\n\ne = [(v[i], i) for i in range(n)]\ne.sort(reverse=True)\n\ncandidates = []\nans = 0\n\nfor pos in d_pos:\n    curr = []\n    for elf in d[pos]:\n        while candidates and candidates[0][1] < elf:\n            curr.append(candidates.pop(0))\n        if candidates and candidates[0][0] > e[elf][0]:\n            pass\n        else:\n            ans += 1\n            candidates.append(e[elf])\n    curr += candidates\n    candidates = curr[:]\n\nprint(ans)"
 ],
 "3305": [
  "n, q = map(int, input().split())\ns = input()\n\n# build an array to count palindrome substrings\ndp = [0] * n\nfor i in range(n):\n    # for odd length palindromes\n    l, r = i, i\n    while l >= 0 and r < n and s[l] == s[r]:\n        dp[i] += 1\n        l -= 1\n        r += 1\n    # for even length palindromes\n    l, r = i, i+1\n    while l >= 0 and r < n and s[l] == s[r]:\n        dp[i] += 1\n        l -= 1\n        r += 1\n\n# accumulate the counts to get counts of all substrings\nacc = [0] * (n+1)\nfor i in range(1, n+1):\n    acc[i] = acc[i-1] + dp[i-1]\n\n# loop through the demonstrations and output counts\nfor i in range(q):\n    l, r = map(int, input().split())\n    print(acc[r] - acc[l-1])"
 ],
 "3306": [
  "from functools import cmp_to_key\n\nn, m = map(int, input().split())\ndetectors = []\nfor i in range(n):\n    p, c = map(int, input().split())\n    detectors.append((p, c))\n\ndetectors.sort(key=cmp_to_key(lambda a, b: a[0] - b[0]))\ntotal_calls = 0\nfor i in range(n):\n    # check calls made to the left of detector\n    left_calls = 0\n    if i > 0:\n        left_calls = sum(c for p, c in detectors[:i] if p < detectors[i][0])\n    # check calls made to the right of detector\n    right_calls = 0\n    if i < n - 1:\n        right_calls = sum(c for p, c in detectors[i+1:] if p > detectors[i][0])\n    # total calls is maximum of left and right calls\n    total_calls += max(left_calls, right_calls)\n\nprint(total_calls)"
 ],
 "3307": [
  "from math import atan2, pi, sin, cos\n\ndef direction(ax, ay, bx, by, cx, cy):\n    return (bx - ax) * (cy - ay) - (by - ay) * (cx - ax)\n\ndef intersect(ax, ay, bx, by, cx, cy, dx, dy):\n    d = direction(ax, ay, bx, by, cx, cy)\n    e = direction(ax, ay, bx, by, dx, dy)\n    f = direction(cx, cy, dx, dy, ax, ay)\n    g = direction(cx, cy, dx, dy, bx, by)\n    if (d > 0 and e < 0 or d < 0 and e > 0) and (f > 0 and g < 0 or f < 0 and g > 0):\n        x = (c - a) * (dy - cy) - (d - b) * (dx - cx)\n        y = (a - c) * (g - e) - (b - d) * (f - h)\n        denom = (b - d) * (g - e) - (a - c) * (f - h)\n        x /= denom\n        y /= -denom\n        return True, x, y\n    return False, 0, 0\n\ndef dist(a, b, c, d):\n    return ((a - c) ** 2 + (b - d) ** 2) ** 0.5\n\ndef projection(ax, ay, bx, by, cx, cy):\n    k = ((cx - ax) * (bx - ax) + (cy - ay) * (by - ay)) / ((bx - ax) ** 2 + (by - ay) ** 2)\n    return ax + k * (bx - ax), ay + k * (by - ay)\n\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\nax, ay, bx, by = map(int, input().split())\n\nisect = []\nfor i in range(n):\n    d1 = direction(ax, ay, bx, by, *points[i])\n    d2 = direction(ax, ay, bx, by, *points[(i + 1) % n])\n    if d1 > 0 and d2 > 0:\n        continue\n    if d1 < 0 and d2 < 0:\n        continue\n    isect.append(projection(ax, ay, bx, by, *points[i]))\n\narea = 0\nfor i in range(n):\n    a, b = points[i]\n    c, d = points[(i + 1) % n]\n    area += a * d - b * c\narea /= 2\n\nans = 0\na, b = isect[0]\naprev, bprev = points[0]\nfor i in range(n):\n    c, d = points[i]\n    products = []\n    for j in range(len(isect)):\n        x, y = isect[j]\n        if dist(x, y, aprev, bprev) > dist(x, y, c, d):\n            products.append(-1)\n            continue\n        if dist(x, y, a, b) <= 1e-9:\n            products.append(0)\n            continue\n        products.append(dist(x, y, a, b) / dist(x, y, aprev, bprev))\n    if len(products) == 0:\n        aprev, bprev = c, d\n        continue\n\n    _, minj = min((abs(prod - 1), j) for j, prod in enumerate(products))\n    if products[minj] >= 1:\n        ans += area / 2 * (products[minj] + 1)**2 / 4 * (cos(atan2(b - d, a - c)) - cos(atan2(bprev - d, aprev - c)))\n        a, b = isect[minj]\n    else:\n        ax, ay, bx, by = a, b, isect[minj][0], isect[minj][1]\n        a, b = points[i - 1]\n        aprev, bprev = points[(i - 1 - n) % n]\n        for j in range(len(isect)):\n            t, _, _ = intersect(ax, ay, bx, by, *isect[j - 1], *isect[j])\n            if t:\n                a, b = isect[j - 1]\n                aprev, bprev = points[i - 1]\n                break\n\nif len(isect):\n    _, minj = min((dist(a, b, at, bt), j) for j, (at, bt) in enumerate(isect))\n    ans += area / 2 * (dist(a, b, *isect[minj])**2 + 1e-18) / 4 * (2 * pi - 2 * atan2(b - isect[minj][1], a - isect[minj][0]))\nprint(f\"{ans:.10f}\")"
 ],
 "3308": [
  "import math\nn = int(input())\nvertices = [list(map(float, input().split())) for _ in range(n)]\n\n# Function to calculate the area of a polygon given its vertices\ndef area_of_polygon(vertices):\n    area = 0.0\n    n = len(vertices)\n    j = n - 1\n    for i in range(n):\n        area += (vertices[j][0] + vertices[i][0]) * (vertices[j][1] - vertices[i][1])\n        j = i\n    return abs(area / 2.0)\n\n# Function to calculate the distance between two points\ndef distance(point1, point2):\n    return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)\n\n# Function to check if a wall intersects a line segment\ndef intersects(vertex1, vertex2, point1, point2):\n    dx1 = vertex1[0] - point1[0]\n    dy1 = vertex1[1] - point1[1]\n    dx2 = vertex2[0] - point1[0]\n    dy2 = vertex2[1] - point1[1]\n    dx3 = point2[0] - point1[0]\n    dy3 = point2[1] - point1[1]\n    if dy3 * dx2 > dx3 * dy2:\n        return dy1 * dx2 > dx1 * dy2 and dy2 * dx3 > dx2 * dy3\n    else:\n        return dy1 * dx3 > dx1 * dy3 and dy3 * dx2 > dx3 * dy2\n\n# Function to check if a point is visible from a given vertex\ndef is_visible(vertex, point, vertices):\n    for i in range(len(vertices)):\n        if intersects(vertices[i], vertices[(i+1)%len(vertices)], vertex, point):\n            return False\n    return True\n\n# Function to calculate the area of the set of visible points around a vertex\ndef visible_area(vertex, vertices):\n    min_distance = float('inf')\n    max_distance = 0\n    for i in range(len(vertices)):\n        if i != vertices.index(vertex):\n            dist = distance(vertex, vertices[i])\n            if is_visible(vertex, vertices[i], vertices):\n                min_distance = min(min_distance, dist)\n            max_distance = max(max_distance, dist)\n    radius = (min_distance + max_distance) / 2\n    return math.pi * radius**2\n\n# Calculate the sum of visible areas around all vertices\ntotal_area = sum([visible_area(vertices[i], vertices) for i in range(n)])\nprint(\"{:.10f}\".format(total_area))"
 ],
 "3309": [
  "n, k, c = map(int, input().split())\na = list(map(int, input().split()))\n\nleft = [0]*n   # left[i] stores the maximum possible number of media companies broadcasting if sequence starting from 0 to i is selected\nright = [0]*n  # right[i] stores the maximum possible number of media companies broadcasting if sequence ending at i is selected\n\nfans = {}      # fans[color] stores the rightmost index of given color seen so far\ncolors = 0     # denotes the number of distinct colors seen so far\n\nfor i in range(n):\n  x = a[i]\n  \n  # update fans\n  if x not in fans:\n    fans[x] = i\n    colors += 1\n  else:\n    fans[x] = i   # update rightmost index of a color\n\n  # update left[i]\n  if i >= k-1:\n    if i == k-1:\n      left[i] = colors\n    else:\n      left[i] = max(left[i-1], colors)\n\n  # update right[i]\n  j = n - 1 - i\n  y = a[j]\n  if y not in fans:\n    fans[y] = j\n    colors += 1\n  else:\n    fans[y] = j\n\n  if j <= n - k:\n    if j == n - k:\n      right[j] = colors\n    else:\n      right[j] = max(right[j+1], colors)\n\n# calculate the maximum number of media companies broadcasting\nans = 0\nfor i in range(n):\n  if i == 0:\n    if right[i+k] >= c:\n      ans += 1\n  elif i == n - k:\n    if left[i-1] >= c:\n      ans += 1\n  else:\n    if left[i-1] >= c and right[i+k] >= c:\n      ans += 1\n\nprint(ans)"
 ],
 "3310": [
  "n, g, t = map(int, input().split())\nc = list(map(int, input().split()))\n\ns = sum(c)\n\ndp = [[0]*(s+1) for i in range(n+1)]\nr = 0\nfor i in range(n+1):\n    dp[i][0] = 1\nfor i in range(1, n+1):\n    for j in range(1, s+1):\n        if j < c[i-1]:\n            dp[i][j] = dp[i-1][j]\n        else:\n            dp[i][j] = (dp[i-1][j] + dp[i-1][j-c[i-1]])/2\n\nfor i in range(1, s+1):\n    ways = 0\n    for j in range(1, min(g+1, i+1)):\n        ways += dp[n][i-j]*dp[n][j-1]\n    r += min(i, ways*t)\n\nprint(\"{:.12f}\".format(r))"
 ],
 "3311": [
  "n, m = map(int, input().split())\n\ndef exponial(n, m):\n    if n == 1:\n        return 1\n    else:\n        return pow(n, exponial(n-1, phi(m)), m)\n\ndef phi(m):\n    result = m\n    for i in range(2, int(m**0.5)+1):\n        if m % i == 0:\n            while m % i == 0:\n                m //= i\n            result -= result // i\n    if m > 1:\n        result -= result // m\n    return result\n\nprint(exponial(n, m))"
 ],
 "3312": [
  "import heapq\n\ndef bfs(s, t, g, n):      # Breadth first search function to find the shortest path from (S_X, S_Y) to each node\n    d = [float(\"inf\")]*n      # list to store minimum cost to reach each node from (S_X, S_Y)\n    pq = [(0, s)]        # priority queue to get node with minimum cost first\n    while pq:\n        cnt, u = heapq.heappop(pq)\n        if d[u] < cnt:\n            continue\n        d[u] = cnt\n        for v, cost in g[u]:\n            if d[v] > cnt+cost:   \n                heapq.heappush(pq, (cnt+cost, v))\n    return d[t]         # returns minimum distance between source and target\n\nN, E, S_X, S_Y, C = map(int, input().split())    # taking input of N, E, S_X, S_Y, and C\ns = S_X*N+S_Y       # calculating the starting node from S_X and S_Y\nt = N*N          # calculating target node\ng = [[] for _ in range(N*N)]      # creating an empty graph of size N*N\nfor i in range(N):          # iterating through the grid and adding edges to graph\n    for j in range(N):\n        u = i*N+j\n        if i>0:  # check if can move up\n            g[u].append((u-N, 1))\n        if i<N-1: # check if can move down\n            g[u].append((u+N, 1))\n        if j>0:  # check if can move left\n            g[u].append((u-1, 1))\n        if j<N-1: # check if can move right\n            g[u].append((u+1, 1))\nans = 0         # initializing the maximum number of points to zero\noil_cans = []       # creating an empty list of oil cans\nfor i in range(C):      # iterating through the input of oil cans\n    X, Y, CT = map(int, input().split())\n    oil_cans.append((CT, X, Y))     # adding time, x, y to the list of oil cans\noil_cans.sort()     # sorting the list of oil cans based on time\nfor i in range(len(oil_cans)):      # iterating through each of the oil cans\n    can_time, X, Y = oil_cans[i]\n    t = S_X*N + S_Y\n    if i>0 and oil_cans[i-1][0] == can_time:    # if there are multiple oil cans at the same second\n        E += 1          # increment E by 1\n    else:\n        E -= can_time - (i==0)     # decrement E by the time needed to reach the oil can from the previous oil can\n    if E<0:         # if E is negative, it is not possible to collect the oil can\n        break\n    if bfs(t, X*N+Y, g, N*N) > can_time:    # if the shortest distance from S_X, S_Y to this can is less than or equal to can_time\n        ans += 1        # increment the number of points by 1\n        S_X, S_Y = X, Y     # move the robot to the location of the can\n        t = S_X*N + S_Y\n        for j in range(len(g[t])):      # check if there are any adjacent oil cans\n            v, _ = g[t][j]\n            if abs(v-t) == 1 or abs(v-t) == N:\n                E += 1      # if there is, increment E by 1\n    else:\n        E += can_time - (i==0) + 1       # if the shortest distance from S_X, S_Y to this can is greater than can_time, increment E by the time needed to reach this oil can and 1 unit (stand still)\n    E = min(E, 100)     # E cannot exceed 100\nprint(ans)      # output maximum number of points obtained"
 ],
 "3313": [
  "n, r, w, h = map(int, input().split())\ngems = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    if y <= r*x:\n        gems.append(x)\ngems.sort()\ndp = [0]*(len(gems)+1)\nfor i in range(1, len(dp)):\n    dp[i] = dp[i-1]\n    for j in range(i-1, -1, -1):\n        if gems[i-1] - gems[j] <= v/r*(i-j):\n            dp[i] = max(dp[i], dp[j]+i-j)\n        else:\n            break\nprint(dp[-1])"
 ],
 "3314": [
  "from itertools import permutations\n\nwheels = [input() for _ in range(3)]\nn = len(wheels[0])\nvalid = False\nmin_rotations = float('inf')\n\nfor combo in permutations(wheels):\n    for i in range(n):\n        if len(set(combo[j][i] for j in range(3))) != 3:\n            break\n    else:\n        valid = True\n        rotations = sum(abs(j - i) for wheel in combo for i, j in ((wheel.index('A'), 0), (wheel.index('B'), 1), (wheel.index('C'), 2)))\n        min_rotations = min(min_rotations, rotations)\n\nprint(min_rotations if valid else -1)"
 ],
 "3315": [
  "n = int(input())\nstrings = [input() for _ in range(n)]\nconnections = {}\nfor i in range(n):\n    start = strings[i]\n    end = start[-1]\n    if end not in connections:\n        connections[end] = []\n    connections[end].append(i)\n\n\ndef dfs(node, visited):\n    if visited[node]:\n        return 0\n    visited[node] = True\n    teleport_count = 1\n    for neigh in connections.get(strings[node][-1], []):\n        teleport_count = max(teleport_count, 1 + dfs(neigh, visited))\n    visited[node] = False\n    return teleport_count\n\n\nmax_teleports = 0\nvisited = [False] * n\nfor i in range(n):\n    max_teleports = max(max_teleports, dfs(i, visited))\nprint(max_teleports)"
 ],
 "3316": [
  "m, n, t, p = map(int, input().split())\nprob = 0\n\n# Probability of at least one member getting a ticket\nfor i in range(p, n+1):\n    prob += ((math.comb(n, i) * math.comb(m-n, t*i-n+i)) / math.comb(m, t*n))\n\nprint(\"%.10f\" % prob)"
 ],
 "3317": [
  "s = input().strip()\nq = int(input())\n\n# Create a mapping of each stock to its latest occurrence\nlatest_occurrence = {}\nfor i, stock in enumerate(s):\n    latest_occurrence[stock] = i\n\n# Create an array of the latest occurrence of each stock\nlatest_occurrences = [latest_occurrence[chr(i)] for i in range(ord('A'), ord('Z')+1)]\n\n# Precalculate the suffix array\nsuffixes = []\nfor i in range(len(s)):\n    suffixes.append(s[i:])\nsuffixes.sort()\n\n# Process each query\nfor _ in range(q):\n    i, j = map(int, input().split())\n    longest_match = 0\n    for k in range(26):\n        if latest_occurrences[k] < i or latest_occurrences[k] < j:\n            continue\n        suffix_index_i = suffixes.index(s[i:latest_occurrences[k]+1])\n        suffix_index_j = suffixes.index(s[j:latest_occurrences[k]+1])\n        longest_match = max(longest_match, latest_occurrences[k]-i+1)\n        longest_match = max(longest_match, latest_occurrences[k]-j+1)\n        longest_match = max(longest_match, len(s)-suffix_index_i-suffix_index_j)\n    print(longest_match)"
 ],
 "3318": [
  "import sys\n\nsys.setrecursionlimit(200005)\n\ndef calculate_max_nodes(root, parent, graph, d, dp):\n    marked = 1\n    for child in graph[root]:\n        if child != parent:\n            marked_child = calculate_max_nodes(child, root, graph, d, dp)\n            if abs(child - root) <= d:\n                dp[root][0] += marked_child\n            else:\n                dp[root][1] += marked_child\n            marked += marked_child\n    if dp[root][0] == 0:\n        dp[root][0] = float('-inf')\n    return marked - max(dp[root][0], dp[root][1])\n\nn, d = map(int, input().split())\ngraph = [[] for _ in range(n)]\nfor i in range(1, n):\n    x = int(input())\n    graph[x].append(i)\n    graph[i].append(x)\ndp = [[0, 0] for _ in range(n)]\nprint(calculate_max_nodes(0, -1, graph, d, dp))"
 ],
 "3319": [
  "import sys\ninput = sys.stdin.readline\n\nclass Planet:\n    def __init__(self, i, mass, x, y, z, vx, vy, vz):\n        self.i = i\n        self.mass = mass\n        self.x = x\n        self.y = y\n        self.z = z\n        self.vx = vx\n        self.vy = vy\n        self.vz = vz\n\n    def __lt__(self, other):\n        if self.mass == other.mass:\n            if self.x == other.x:\n                if self.y == other.y:\n                    return self.z < other.z\n                return self.y < other.y\n            return self.x < other.x\n        return self.mass > other.mass\n\n    def __repr__(self):\n        return f'P{self.i}: {self.mass} {self.x} {self.y} {self.z} {self.vx} {self.vy} {self.vz}'\n\nn, n_x, n_y, n_z = map(int, input().split())\nplanets = []\nfor i in range(n):\n    m, x, y, z, vx, vy, vz = map(int, input().split())\n    planets.append(Planet(i, m, x, y, z, vx, vy, vz))\n\ntime = 0\nwhile True:\n    grid = {}\n    for planet in planets:\n        planet.x += planet.vx\n        planet.y += planet.vy\n        planet.z += planet.vz\n        planet.x %= n_x\n        planet.y %= n_y\n        planet.z %= n_z\n        if (planet.x, planet.y, planet.z) in grid:\n            grid[(planet.x, planet.y, planet.z)].append(planet)\n        else:\n            grid[(planet.x, planet.y, planet.z)] = [planet]\n\n    new_planets = []\n    for location, planet_list in grid.items():\n        if len(planet_list) >= 2:\n            total_mass = sum(planet.mass for planet in planet_list)\n            new_x = sum(planet.x * planet.mass for planet in planet_list) // total_mass\n            new_y = sum(planet.y * planet.mass for planet in planet_list) // total_mass\n            new_z = sum(planet.z * planet.mass for planet in planet_list) // total_mass\n            new_vx = sum(planet.vx for planet in planet_list) // len(planet_list)\n            new_vy = sum(planet.vy for planet in planet_list) // len(planet_list)\n            new_vz = sum(planet.vz for planet in planet_list) // len(planet_list)\n            new_planets.append(Planet(0, total_mass, new_x, new_y, new_z, new_vx, new_vy, new_vz))\n        else:\n            new_planets.append(planet_list[0])\n    planets = new_planets\n    if len(planets) == n or not grid:\n        break\n    time += 1\n\nprint(len(planets))\nfor planet in sorted(planets):\n    print(planet)"
 ],
 "3320": [
  "import heapq\nfrom math import log2\n\ndef bitOr(a, b):\n    return a | b\n\ndef shortestPath(adj, n, s, t):\n    dist = [float('inf')] * (n + 1)\n    dist[s] = 0\n    heap = [(0, s)]\n    \n    while heap:\n        currDist, currNode = heapq.heappop(heap)\n        \n        if currDist > dist[currNode]:\n            continue\n            \n        for neighbour, weight in adj[currNode]:\n            newDist = bitOr(weight, currDist)\n            if newDist < dist[neighbour]:\n                dist[neighbour] = newDist\n                heapq.heappush(heap, (newDist, neighbour))\n                \n    return dist[t]\n\nn, m = map(int, input().split())\nadj = [[] for _ in range(n + 1)]\nfor _ in range(m):\n    a, b, w = map(int, input().split())\n    adj[a].append((b, w))\n    adj[b].append((a, w))\n\nq = int(input())\nfor _ in range(q):\n    s, t = map(int, input().split())\n    print(shortestPath(adj, n, s, t))"
 ],
 "3321": [
  "n = int(input())\nstart = list(map(int, input().split()))\nend = list(map(int, input().split()))\n\ndef get_index(lst, i):\n    return lst.index(i) + 1\n\nfor i in range(1, n+1):\n    start_index = get_index(start, i)\n    end_index = get_index(end, i)\n    num_leaps = end_index - start_index\n    if num_leaps <= 0:\n        num_leaps += n\n    print(num_leaps)"
 ],
 "3322": [
  "n,m,k=map(int,input().split())\na=[]\nfor i in range(n):\n    s=input().split()\n    a.append((int(s[0]),int(s[1]),int(s[2]),int(s[3])))\nans=99999999\nfor i in range(m):\n    for j in range(m):\n        if i==j :\n            continue\n        cost=0\n        b=[-1]*n\n        for x in range(n):\n            if(a[x][0]-1==i or a[x][2]-1==i):\n                if(b[x]==-1):\n                    if(a[x][1]<=a[x][3]):\n                        b[x]=i\n                        cost+=a[x][1]\n                    else:\n                        b[x]=a[x][2]-1\n                        cost+=a[x][3]\n        for x in range(n):\n            if(a[x][0]-1==j or a[x][2]-1==j):\n                if(b[x]==-1):\n                    if(a[x][1]<=a[x][3]):\n                        b[x]=j\n                        cost+=a[x][1]\n                    else:\n                        b[x]=a[x][0]-1\n                        cost+=a[x][3]\n        c=0\n        for x in range(n):\n            if(b[x]==-1):\n                c=1\n        if(c==1):\n            continue\n        ans=min(ans,cost)\nif(ans==99999999):\n    print(-1)\nelse:\n    print(ans)"
 ],
 "3323": [
  "from fractions import Fraction\n\nT = int(input())\n\nfor i in range(1, T+1):\n    n = int(input())\n\n    # list to hold the minimum fractions of juices required by each person\n    min_fractions = []\n    for j in range(n):\n        a, b, c = map(int, input().split())\n        min_fractions.append((Fraction(a, 10000), Fraction(b, 10000), Fraction(c, 10000)))\n\n    # binary search for maximum number of people who will like the drink\n    left = 0\n    right = n\n    while left <= right:\n        mid = (left + right) // 2\n        possible_combinations = set()\n        for j in range(n):\n            if sum(1 for A, B, C in min_fractions[j:] if A <= min_A and B <= min_B and C <= min_C) >= mid:\n                possible_combinations.add(tuple(sorted((min_A, min_B, min_C))) for min_A, min_B, min_C in min_fractions[j:])\n        if possible_combinations:\n            left = mid + 1\n            best_combination = max(possible_combinations, key=lambda c: sum(c))\n        else:\n            right = mid - 1\n\n    print(\"Case #{}: {}\".format(i, sum(1 for A, B, C in min_fractions if A <= best_combination[0] and B <= best_combination[1] and C <= best_combination[2])))"
 ],
 "3324": [
  "from fractions import gcd\ndef lcm(a,b):\n    return (a*b)/gcd(a,b)\ndef balance_eq(equations):\n    #make a list of unique elements\n    u = []\n    for eq in equations:\n        for pair in eq[1:]:\n            if pair[0] not in u:\n                u.append(pair[0])\n    #initialize coefficient dictionary\n    coeff = dict()\n    for element in u:\n        coeff[element] = 1\n    #find coefficient for each equation\n    for eq in equations:\n        left,right = [],[]\n        for pair in eq[1:]:\n            sign = -1 if eq[0] == '-' else 1\n            if sign == 1:\n                left.append((pair[0],pair[1]))\n            else:\n                right.append((pair[0],pair[1]))\n        lcm_lr,lcm_e = 1,1\n        for element in u:\n            c_l,c_r = 0,0\n            for pair in left:\n                if pair[0] == element:\n                    c_l = pair[1]\n            for pair in right:\n                if pair[0] == element:\n                    c_r = pair[1]\n            if c_l > 0 and c_r > 0:\n                lcm_lr = lcm(lcm_lr,lcm(c_l,c_r))\n            elif c_l > 0:\n                lcm_e = lcm(lcm_e,c_l)\n            elif c_r > 0:\n                lcm_e = lcm(lcm_e,c_r)\n        for element in u:\n            c_l,c_r = 0,0\n            for pair in left:\n                if pair[0] == element:\n                    c_l = pair[1]\n            for pair in right:\n                if pair[0] == element:\n                    c_r = pair[1]\n            if c_l > 0 and c_r > 0:\n                f_l,f_r = lcm_lr/c_l,lcm_lr/c_r\n                coeff[element] = lcm_lr\n            elif c_l > 0:\n                coeff[element] = lcm_e*c_l\n            elif c_r > 0:\n                coeff[element] = lcm_e*c_r\n    #normalize by gcd\n    l = [coeff[element] for element in u]\n    GCD = reduce(lambda x,y: gcd(x,y),l)\n    for element in u:\n        coeff[element] /= GCD\n    #output\n    return [coeff[eq[1:][i][0]]*int(eq[0]+'1') for i in range(len(eq[1:]))]\nequations = []\nwhile True:\n    equation = input().split()\n    if equation == ['0','0']:\n        break\n    equation[1:] = [(equation[i], equation[i+1]) for i in range(1, len(equation[1:]), 2)]\n    equations.append(equation)\noutput = balance_eq(equations)\nfor i in output:\n    print(i,end=' ')"
 ],
 "3325": [
  "import math\n\nn = int(input())\ndepth, liters = map(int, input().split())\nvertices = [tuple(map(int, input().split())) for _ in range(n)]\n\nmax_y = sorted(vertices, key=lambda vertex: -vertex[1])[:2]\ny_diff = max_y[0][1] - max_y[1][1]\nfilled_volume = (liters / 1000) * 100**2\ntotal_area = 0\n\nfor i in range(n):\n    j = (i + 1) % n\n    total_area += vertices[i][0] * vertices[j][1] - vertices[i][1] * vertices[j][0]\n\nfilled_area = filled_volume / depth\nwater_height = (filled_area + total_area) / ((max_y[1][0] - max_y[0][0]) * y_diff)\nprint(\"{:.2f}\".format(water_height))"
 ],
 "3326": [
  "from itertools import combinations\n\nr, c = map(int, input().split())\ngrid = [list(map(int, input().split())) for _ in range(r)]\n\n# function to check if a list of numbers is monotonic\ndef is_monotonic(lst):\n    return lst == sorted(lst) or lst == sorted(lst, reverse=True)\n\ncount = 0\n\n# loop through all possible combinations of rows and columns\nfor r_set in combinations(range(r), 1):\n    for c_set in combinations(range(c), 1):\n        # get the elements in the subgrid defined by this combination\n        subgrid = [grid[i][j] for i in r_set for j in c_set]\n        # check if the subgrid is monotonic\n        if is_monotonic(subgrid):\n            count += 1\n\n# output the count\nprint(count)"
 ],
 "3327": [
  "R, C = map(int, input().split())\ngrid = [input() for _ in range(R)]\nn = int(input())\nwords = [input() for _ in range(n)]\n\nfor word in words:\n    for r in range(R):\n        for c in range(C):\n            if grid[r][c] == \".\" or grid[r][c] == word[0]:\n                if c + len(word) <= C and all(grid[r][c+i] == \".\" or grid[r][c+i] == word[i] for i in range(len(word))):\n                    for i in range(len(word)):\n                        grid[r] = grid[r][:c+i] + word[i] + grid[r][c+i+1:]\n                    break\n\n                if r + len(word) <= R and all(grid[r+i][c] == \".\" or grid[r+i][c] == word[i] for i in range(len(word))):\n                    for i in range(len(word)):\n                        grid[r+i] = grid[r+i][:c] + word[i] + grid[r+i][c+1:]\n                    break\n\nfor r in range(R):\n    print(grid[r])"
 ],
 "3328": [
  "n, k = map(int, input().split())\ntable = [list(map(int, input().split())) for _ in range(n)]\ndominoes_needed = 2 * k\n\n# helper function to find the minimum sum of visible fields\ndef get_min_sum(table, n, dominoes_needed):\n    # initialize variables\n    min_sum = float('inf')\n    for i in range(n):\n        for j in range(n):\n            # determine if it's possible to place a horizontal domino\n            if j + 1 < n:\n                sum_ = table[i][j] + table[i][j+1]\n                # temporarily cover the fields with the dominoes\n                table[i][j] = table[i][j+1] = -1\n                # recursively call the function to place the remaining dominoes\n                if dominoes_needed - 1 == 0:\n                    min_sum = min(min_sum, sum([num for row in table for num in row if num >= 0]))\n                else:\n                    min_sum = min(min_sum, get_min_sum(table, n, dominoes_needed - 1))\n                # uncover the fields with the dominoes\n                table[i][j] = table[i][j+1] = sum_\n                \n            # determine if it's possible to place a vertical domino\n            if i + 1 < n:\n                sum_ = table[i][j] + table[i+1][j]\n                # temporarily cover the fields with the dominoes\n                table[i][j] = table[i+1][j] = -1\n                # recursively call the function to place the remaining dominoes\n                if dominoes_needed - 1 == 0:\n                    min_sum = min(min_sum, sum([num for row in table for num in row if num >= 0]))\n                else:\n                    min_sum = min(min_sum, get_min_sum(table, n, dominoes_needed - 1))\n                # uncover the fields with the dominoes\n                table[i][j] = table[i+1][j] = sum_\n    return min_sum\n\n# call the function and print the result\nprint(get_min_sum(table, n, dominoes_needed))"
 ],
 "3329": [
  "from itertools import cycle\n\nn, k = map(int, input().split())\ns = input()\n\ndef rotate(s):\n    return s[-1] + s[:-1]\n\ndef apply_transform(s):\n    t = ''\n    for i, c in enumerate(s):\n        if c == s[(i+1)%n]:\n            t += 'B'\n        else:\n            t += 'W'\n    return t\n\ns_set = set()\nfor _ in range(n):\n    s_set.add(s)\n    s = rotate(s)\n\nfor _ in range(k):\n    new_set = set()\n    for s in s_set:\n        new_set.add(apply_transform(s))\n        for _ in range(n-1):\n            s = rotate(s)\n            new_set.add(apply_transform(s))\n    s_set = new_set\n\nans = 0\nfor s in s_set:\n    for r in range(n):\n        if tuple(s) == tuple(islice(cycle(rotate(s)), r, r+n)):\n            ans += 1\n            break\n\nprint(ans)"
 ],
 "3330": [
  "import itertools \n\nn, L = map(int, input().split()) \na = list(map(int, input().split())) \nc = list(map(int, input().split())) \n\nans = 10**9 \n\nfor l in range(n-L+1): \n    for comb in itertools.combinations(range(n), l): \n        \n        total_price = sum([c[i] for i in comb]+[c[i] for i in range(n) if i not in comb]) \n        total_potatoes = sum([a[i] for i in comb]+[a[i] for i in range(n) if i not in comb]) \n        p1 = total_price/(total_potatoes-L) \n        p2 = total_price/(L) \n        ans = min(ans, p1*p2) \n\nprint(f'{ans:.3f}')"
 ],
 "3331": [
  "L, A, B, P = map(int,input().split())\n\ndist = abs(B-A) # distance b/w cows\nif A > B:\n    A, B = B, A\n\ncow1_pos = A-1   # cows reveal themselves from hiding \ncow2_pos = B+1   # within 1 meter distance\n\ntime = 0 # initial time taken by the horse to be captured\nwhile True:\n    # check if horse is caught\n    if P in (cow1_pos, cow2_pos):\n        break\n    \n    # update the position of cows\n    if abs(P-cow1_pos) < abs(P-cow2_pos):\n        cow_dist = abs(cow2_pos-cow1_pos)\n        cow1_pos -= min(cow_dist//2, abs(cow1_pos-1))\n        cow2_pos += min(cow_dist//2, abs(L-cow2_pos))\n    else:\n        cow_dist = abs(cow2_pos-cow1_pos)\n        cow2_pos += min(cow_dist//2, abs(L-cow2_pos))\n        cow1_pos -= min(cow_dist//2, abs(cow1_pos-1))\n    \n    # update the position of horse\n    if P > cow2_pos:\n        P -= 1\n    elif P < cow1_pos:\n        P += 1\n    else:    \n        if P-A > B-P:\n            P -= min(2, P-cow2_pos)\n        else:\n            P += min(2, cow1_pos-P)\n            \n    time += 1 # increase time taken by 1 minute\n            \nprint(time)"
 ],
 "3332": [
  "import heapq\n\nn = int(input())\ndata = [list(map(int, input().split())) for i in range(n)]\ndata.sort() #sort by start time\n\npq = [] #priority queue to keep track of active streams\ntotal = 0 #total priority of chosen subset\n\nfor i in range(n):\n    start, duration, priority = data[i]\n    end = start + duration #calculate end time\n    while pq and pq[0][0] <= start: #pop streams that have ended before current stream starts\n        heapq.heappop(pq)\n    heapq.heappush(pq, (end, priority)) #push current stream\n    total = max(total, sum([p for t,p in pq])) #update total priority\n\nprint(total)"
 ],
 "3333": [
  "import itertools\nimport math\n\nroost = input().split()\nroost = (float(roost[0]), float(roost[1]))\n\nn = int(input())\n\nspots = []\nfor i in range(n):\n    spot = input().split()\n    spot = (float(spot[0]), float(spot[1]))\n    spots.append(spot)\n\ndistances = []\nfor pair in itertools.permutations(spots, n):\n    total_dist = 0\n    pos = roost\n    for spot in pair:\n        dist = math.sqrt((spot[0]-pos[0])**2 + (spot[1]-pos[1])**2) # euclidean distance\n        total_dist += dist\n        pos = spot\n    distances.append(total_dist)\n\nprint(\"%.6f\" % min(distances))"
 ],
 "3334": [
  "import sys\n\nn = int(sys.stdin.readline().strip())\n\n# Read in the distance table\ndist = []\nfor i in range(n-1):\n    row = list(map(int, sys.stdin.readline().split()))\n    dist.append(row + [0])\ndist.append([0]*n)\n\n# Check if it is possible to determine the answer\nfor i in range(n):\n    for j in range(n):\n        for k in range(n):\n            if dist[i][j] > dist[i][k] + dist[k][j]:\n                print(\"impossible\")\n                sys.exit()\n\n# Calculate the average\nnum_pairs = n*(n-1)//2\ntotal_dist = 0\nfor i in range(n):\n    for j in range(i+1, n):\n        total_dist += dist[i][j]\n\navg_dist = total_dist / num_pairs\n\nprint(round(avg_dist, 10))"
 ],
 "3335": [
  "n = int(input())\nans = 0\nfor a in range(1, n):\n    for b in range(a, n):\n        c_sq = (a*a + b*b) % n\n        \n        if c_sq >= n:\n            break\n            \n        if b < c_sq:\n            ans += 2 \n            \n        if b == c_sq:\n            ans += 1\n            \nprint(ans)"
 ],
 "3336": [
  "n = int(input())\nstudents = []\nfor i in range(n):\n    h, sex, music, sport = input().split()\n    students.append((int(h), sex, music, sport))\n\ncount = 0\nfor i in range(n):\n    for j in range(i+1, n):\n        h_diff = abs(students[i][0] - students[j][0])\n        sex_diff = students[i][1] != students[j][1]\n        music_diff = students[i][2] != students[j][2]\n        sport_diff = students[i][3] != students[j][3]\n        if h_diff > 40 or sex_diff or music_diff or sport_diff:\n            count += 1\n\nprint(count)"
 ],
 "3337": [
  "import sys\n\nn = int(input().strip())\n\n# Key: stack number, value: set of elements in stack\nstacks = {0: set()}\n\n# Function to copy a stack\ndef copy_stack(v):\n    new_stack = set(stacks[v])\n    stacks[len(stacks)] = new_stack\n    return len(stacks) - 1\n\n# Process each step of the game\nfor i in range(1, n+1):\n    line = input().strip().split()\n\n    op = line[0]\n\n    if op == 'a':\n        stacks[i] = set()\n    elif op == 'b':\n        v = int(line[1])\n        elem = stacks[v].pop()\n        print(elem)\n    else: # op == 'c'\n        v, w = int(line[1]), int(line[2])\n        common_elems = stacks[v].intersection(stacks[w])\n        print(len(common_elems))\n\n    # Copy a stack and perform an action\n    if op != 'a':\n        v = int(line[1])\n        copied_stack = copy_stack(v)\n        if op == '1':\n            stacks[copied_stack].add(i)\n        else: # op == '3'\n            w = int(line[2])\n            common_elems = stacks[copied_stack].intersection(stacks[w])\n            print(len(common_elems))"
 ],
 "3338": [
  "from bisect import bisect_left\n\nn, k = map(int, input().split())\n\npartners = []\nfor _ in range(n):\n    g, p, ga, pa = map(int, input().split())\n    if ga:  # partner can be awakened\n        partners.append((ga, pa, g, p))\n    else:\n        partners.append((g, p, 0, 0))\n\npartners.sort()\n\nINF = 10**9+1  # some large number\ndp = [[-INF]*(k+1) for _ in range(n+1)]\ndp[0][0] = 0\n\nfor i in range(1, n+1):\n    dp[i][0] = 1\n    for j in range(1, min(i, k)+1):\n        p, s, _, _ = partners[i-1]\n        dp[i][j] = max(dp[i-1][j], dp[bisect_left(partners, (p, s, 0, 0))][j-1])\n\nans = 0\nfor i in range(n+1):\n    for j in range(k+1):\n        ans = max(ans, min(i, dp[i][j]+j))\n\nprint(ans)"
 ],
 "3339": [
  "from collections import defaultdict\n\nn, m = map(int, input().split())\nroads = defaultdict(int) \n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    roads[a] += 1\n    roads[b] += 1\n\ncount = 1\nfor i in roads.values():\n    count = (count * (i+1)) % 1000000009\n\nprint((count - 1) % 1000000009)"
 ],
 "3340": [
  "import sys\n \ndef main():\n    n = int(input())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    ans = sys.maxsize\n    ansu = ans\n    ansv = ans\n    max_depth = [-1] * (n + 1)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n \n    def dfs(u, fa, d):\n        nonlocal graph, dp, max_depth\n        max_depth[u] = d\n        for v in graph[u]:\n            if v == fa:\n                continue\n            dfs(v, u, d + 1)\n            if dp[u][v] == -1:\n                dp[u][v] = dp[v][u] = max_depth[v] - d\n            ans, ansu, ansv = (dp[u][v] + d - max_depth[v]), u, v\n            if ans < dp[ansu][ansv]:\n                dp[ansu][ansv] = dp[ansv][ansu] = ans\n                \n    dfs(1, 0, 0)\n    maX = -1\n    u = v = 1\n    for i in range(1,n+1):\n        for j in range(len(graph[i])):\n            e = graph[i][j]\n            if dp[i][e] > maX:\n                maX = dp[i][e]\n                u, v = i, e\n \n    result = [max(dp[i]) for i in range(n + 1)]\n    ans, ansu, ansv = n * n, -1, -1\n \n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if i == u and j == v or i == v and j == u or dp[i][j] != maX or dp[j][i] != maX:\n                continue\n            da = max(dp[i])\n            db = max(dp[j])\n            dc = (maX + 1) // 2 + (da + 1) // 2 + (db + 1) // 2 + 1\n            if ans > dc:\n                ans = dc\n                ansu = i\n                ansv = j\n\n    print(ans)\n    print(f\"{ansu} {ansv}\")\n    xu, xv = -1, -1\n    for i in range(1, n + 1):\n        if dp[i][u] == maX and dp[i][v] == max_depth[v]:\n            xu = i\n            break\n    for i in range(1, n + 1):\n        if dp[i][v] == maX and dp[i][u] == max_depth[u]:\n            xv = i\n            break\n    print(f\"{xu} {xv}\")\n    \nif __name__ == '__main__':\n    main()"
 ],
 "3341": [
  "m, n = map(int, input().split())\nproducers = []\nfor i in range(m):\n    p_i, d_i = map(int, input().split())\n    producers.append((d_i, p_i))\nconsumers = []\nfor i in range(n):\n    q_j, e_j = map(int, input().split())\n    consumers.append((e_j, q_j))\n\nproducers.sort()\nconsumers.sort()\n\nmax_profit = 0\nj = 0\nheap = []\nimport heapq\nfor i in range(m):\n    while j < n and consumers[j][0] <= producers[i][0]:\n        heapq.heappush(heap, -consumers[j][1])\n        j += 1\n    if heap:\n        max_profit += producers[i][1] + heapq.heappop(heap)\nprint(max_profit)"
 ],
 "3342": [
  "from itertools import combinations\nfrom math import comb\n\nN, M, K = map(int, input().split())\nonions = [tuple(map(int, input().split())) for _ in range(N)]\nfence_posts = [tuple(map(int, input().split())) for _ in range(M)]\n\ndef is_onion_inside_fence(vertices, onion):\n  \"\"\"Returns True if onion is inside the convex polygon formed by `vertices`\"\"\"\n  x, y = onion\n  for i in range(len(vertices)):\n    x1, y1 = vertices[i]\n    x2, y2 = vertices[(i+1) % len(vertices)]\n    if (x-x1)*(y-y2) - (y-y1)*(x-x2) >= 0:\n      return False\n  return True\n\nmax_onions = 0\nfor c in combinations(range(M), K):\n  vertices = [fence_posts[i] for i in c]\n  onions_inside = sum(1 for onion in onions if is_onion_inside_fence(vertices, onion))\n  max_onions = max(max_onions, onions_inside)\n\nprint(max_onions)"
 ],
 "3343": [
  "L, n = map(int, input().split())\npoints = [(0, 0)]\nfor i in range(n):\n    p, dire = input().split()\n    p = int(p)\n    prev_p, prev_dire = points[-1]\n    # Calculate the angle between the current point and the previous point\n    angle = (p - prev_p) * 90 * (-1 if dire == \"C\" else 1)\n    # If the angle is negative, add 360 degrees to get the positive equivalent\n    angle = angle + 360 if angle < 0 else angle\n    # Calculate the angle between the starting point and the current point\n    total_angle = (angle + prev_dire) % 360\n    points.append((p, total_angle))\n    # Check if the wire intersects itself\n    if len(set([x[0] for x in points])) < len(points):\n        print(\"GHOST\")\n        break\nelse:\n    print(\"SAFE\")"
 ],
 "3344": [
  "n, L = map(int, input().split())\npos = list(map(float, input().split()))\n\npos.sort()\nmax_dist = 0\n\nfor i in range(1, n):\n    max_dist = max(max_dist, pos[i]-pos[i-1])\n\nmax_speed = max_dist - 1\nif max_speed < 0.1:\n    print(\"no fika\")\nelse:\n    print(\"{:.9f}\".format(min(10, max_speed)))"
 ],
 "3345": [
  "n = int(input())\nshadow_walk = [tuple(map(int, input().split())) for _ in range(n)]\nm = int(input())\nlydia_walk = [tuple(map(int, input().split())) for _ in range(m)]\n\nmin_distance = float('inf')\nj = 0\nfor i in range(n):\n    while j < m - 1 and abs(lydia_walk[j+1][0] - shadow_walk[i][0]) < abs(lydia_walk[j][0] - shadow_walk[i][0]):\n        j += 1\n    min_distance = min(min_distance, ((lydia_walk[j][1] - shadow_walk[i][1])**2 + \n                                       (lydia_walk[j][0] - shadow_walk[i][0])**2)**0.5)\n\nprint('{:.4f}'.format(min_distance))"
 ],
 "3346": [
  "from heapq import heappush, heappop\n  \nt, n = map(int, input().split())\ncars = {'W': [], 'E': []}\nfor _ in range(n):\n    d, a, r = input().split()\n    a, r = int(a), int(r)\n    cars[d].append((a, r))\nfor _, lst in cars.items():\n    lst.sort()\npq, ans = [], 0\nfor d, lst in cars.items():\n    for a, r in lst:\n        while pq and pq[0] <= a:\n            heappop(pq)\n        if len(pq) >= 3:\n            ans += 1\n        else:\n            heappush(pq, a + t)\nprint(ans)"
 ],
 "3347": [
  "n = int(input())\nstores = []\nfor i in range(n):\n    t, h = map(int, input().split())\n    stores.append((t, h))\nstores.sort(key=lambda x: x[1]) # sort by altitude\n\ncount = 0 # count of stores Demetrios can visit\nmax_time = 0 # maximum time Demetrios has before the store is submerged\nfor t, h in stores:\n    if h - max_time > 0: # store is still above water during the entire trip\n        count += 1\n        max_time += t\nprint(count)"
 ],
 "3348": [
  "# Reading inputs\nR, C = map(int, input().split())\na, b, c = map(int, input().split())\n\n# Initializing the board\nboard = [[None for _ in range(C)] for _ in range(R)]\n\n# Putting the bonbons on the board\nfor i in range(R):\n    for j in range(C):\n        if a > 0:\n            board[i][j] = 'A'\n            a -= 1\n        elif b > 0:\n            board[i][j] = 'B'\n            b -= 1\n        elif c > 0:\n            board[i][j] = 'C'\n            c -= 1\n\n# Checking if the board has adjacent bonbons of the same color\nfor i in range(R):\n    for j in range(C):\n        if i < R-1 and board[i][j] == board[i+1][j]:\n            print(\"impossible\")\n            exit()\n        if j < C-1 and board[i][j] == board[i][j+1]:\n            print(\"impossible\")\n            exit()\n\n# Printing the board\nfor row in board:\n    print(\"\".join(row))"
 ],
 "3349": [
  "from collections import Counter\nfrom typing import List\n\nn = int(input())\ndictionary = set(input().strip() for _ in range(n))\nencoded = input().strip()\n\n# Utility function to count the number of vowels in a word\ndef count_vowels(word: str) -> int:\n    return sum(1 for letter in word if letter in 'AEIOU')\n\n# Create a frequency table of letters in the encoded message\nencoded_freq = Counter(encoded)\n\n# Create a lookup table from a set of words to a tuple containing\n# the word's letter frequency and the number of vowels it contains\nword_lookup = {}\nfor word in dictionary:\n    word_freq = Counter(word)\n    num_vowels = count_vowels(word)\n    word_lookup[word] = (word_freq, num_vowels)\n\n# Create a list of candidate sentences, where each candidate is a tuple\n# containing the sentence, the total number of vowels in the sentence, and\n# the letter frequency of the remaining unused letters in the encoded message\ncandidates = [('', 0, encoded_freq)]\nfor _ in range(len(encoded)):\n    new_candidates = []\n    for candidate in candidates:\n        sentence, num_vowels, unused_freq = candidate\n        for word in dictionary:\n            word_freq, word_vowels = word_lookup[word]\n            if all(unused_freq[letter] >= word_freq[letter] for letter in word_freq):\n                new_sentence = sentence + ' ' + word if sentence else word\n                new_num_vowels = num_vowels + word_vowels\n                new_unused_freq = unused_freq - word_freq\n                new_candidates.append((new_sentence, new_num_vowels, new_unused_freq))\n    candidates = new_candidates\n\n# Choose the candidate with the maximum number of vowels\nbest_candidate = max(candidates, key=lambda candidate: candidate[1])[0]\n\nprint(best_candidate)"
 ],
 "3350": [
  "s = input()\nn = len(s)\np = [0 for i in range(n)]\nc = 0\nr = 0\nfor i in range(n):\n    if i < r:\n        p[i] = min(r - i, p[2 * c - i])\n    else:\n        p[i] = 0\n    while i - p[i] - 1 >= 0 and i + p[i] + 1 < n and s[i - p[i] - 1] == s[i + p[i] + 1]:\n        p[i] += 1\n    if i + p[i] > r:\n        c = i\n        r = i + p[i]\nans = 0\nfor i in range(2, n, 2):\n    if i - p[i] == 2:\n        ans = max(ans, i)\nprint(ans)"
 ],
 "3351": [
  "n = int(input())\n\nrolls = list(map(int, input().split()))\n\n# Initializing scores\nscores = [0] * 13\n\nfor i in range(n):\n    for j in range(12, -1, -1):\n        # If score is already assigned, skip to the next\n        if scores[j] != -1:\n            # Calculate the score for the current dice roll\n            current_score = 0\n            if j in [0, 2, 3, 4, 6, 7, 8, 9, 10]:\n                current_score = rolls[i] * (j+1)\n            elif j == 1:\n                current_score = rolls[i] * 2\n            elif j == 5:\n                current_score = rolls[i] * 5\n            elif j == 11:\n                # Check for a full house\n                unique_rolls = list(set(rolls[i-2:i+3]))\n                if len(unique_rolls) == 2 and unique_rolls[0] != unique_rolls[1]:\n                    current_score = 25\n            elif j == 12:\n                # Check for a yahtzee\n                if rolls[i-4:i+1] == [rolls[i]] * 5:\n                    current_score = 50\n            else:\n                # Check for a straight or a kind\n                if j == 0:\n                    straight_vals = [1, 2, 3, 4, 5]\n                elif j == 5:\n                    straight_vals = [2, 3, 4, 5, 6]\n                if rolls[i-3:i+2] == straight_vals:\n                    current_score = 30 if j == 8 else 40\n                elif rolls[i-2:i+3].count(rolls[i]) >= 4:\n                    current_score = sum(rolls[i-2:i+3])\n                elif rolls[i-1:i+4].count(rolls[i-1]) >= 3:\n                    current_score = sum(rolls[i-1:i+4])\n            # If score for this category is higher than the one previously assigned, update it\n            if current_score > scores[j]:\n                scores[j] = current_score\n            else:\n                # If no score assigned for this roll and category, stop looping over categories and move on to the next roll\n                if i > j:\n                    break\n    # If all categories are assigned scores, break out of loop\n    if all(x != 0 for x in scores):\n        break\n# If there are any categories without scores, assign 0 to those\nscores = [x if x != -1 else 0 for x in scores]\nprint(sum(scores))"
 ],
 "3352": [
  "import sys\n\n\ndef get_input():\n    input = [int(x) for x in sys.stdin.readline().split()]\n    return input\n\n\nn, q = get_input()\n\ncolor = [0 for _ in range(n + 5)]\nlight_count = [0 for _ in range(n + 5)]\nroot = 1\n\nlight_by_color = [[] for _ in range(105)]\nparent = [[] for _ in range(n + 5)]\ncolor_count = [[0 for _ in range(105)] for _ in range(n + 5)]\n\nfor i in range(1, n + 1):\n    color[i] = get_input()[0]\n    light_by_color[color[i]].append(i)\n    color_count[i][color[i]] = 1\n    light_count[i] = 1\n\nfor i in range(2, n + 1):\n    parent[i] = get_input()[0]\n    light_count[parent[i]] += light_count[i]\n\nlight_magic = [False for _ in range(n + 5)]\nmagic_count = [0 for _ in range(n + 5)]\n\n\ndef pre_process(u):\n    for color in range(1, 101):\n        magic_count[color] = 0\n    for child in parent[u]:\n        pre_process(child)\n    for child in parent[u]:\n        color_count[u] = [color_count[u][color] + color_count[child][color] for color in range(1, 101)]\n    color_count[u][color[u]] += 1\n    total_magics = 0\n    for color in range(1, 101):\n        to_add = 0\n        for light in light_by_color[color]:\n            if light == u:\n                continue\n            sub_lights = light_count[light]\n            odd_lights = 0\n            for sub_color in range(1, 101):\n                odd_sub = color_count[light][sub_color] - color_count[parent[light]][sub_color]\n                if odd_sub % 2 == 1:\n                    odd_lights += 1\n            if odd_lights % 2 == 1:\n                to_add += sub_lights\n        if to_add > 0:\n            light_magic[u] = True\n            total_magics += 1\n        magic_count[color] = total_magics\n\n\npre_process(1)\n\nfor i in range(q):\n    k, x = get_input()\n    if k == 0:\n        if light_magic[x]:\n            print(magic_count[color[x]])\n        else:\n            print(0)\n    else:\n        color_count[x][color[x]] -= 1\n        color[x] = k\n        color_count[x][color[x]] += 1\n        pre_process(root)"
 ],
 "3353": [
  "from collections import deque\nimport heapq\n\nn, m, l = map(int, input().strip().split())\nvertices = [[] for _ in range(m+2)]\nfor i in range(l):\n    u, v = map(int, input().strip().split())\n    vertices[u+2].append((v+2, i))\n    vertices[v+2].append((u+2, i))\n\ndist = None\nheap = [(0, 0)]\nvisited = [False] * (m+2)\nwhile heap:\n    w, u = heapq.heappop(heap)\n    if visited[u]:\n        continue\n    visited[u] = True\n    if u == 1:\n        print(w)\n        break\n    for v, i in vertices[u]:\n        if not visited[v]:\n            if dist is None:\n                dist = [None] * (2**(n+1))\n                dist[(1 << n)-1] = 0\n            key = 0\n            for j in range(n):\n                if i & (1 << j):\n                    key |= 1 << (n-1-j)\n            new_dist = dist[w]+1\n            if dist[key] is None or dist[key] > new_dist:\n                dist[key] = new_dist\n                heapq.heappush(heap, (new_dist, v))\nelse:\n    num_uncrossable = 0\n    for i in range(n, -1, -1):\n        visited = [False] * (m+2)\n        current = deque([0])\n        while current:\n            u = current.popleft()\n            if visited[u]:\n                continue\n            visited[u] = True\n            if u == 1:\n                break\n            for v, j in vertices[u]:\n                if j & (1 << i) and not visited[v]:\n                    current.append(v)\n        else:\n            num_uncrossable += 2**i\n    print(num_uncrossable)"
 ],
 "3354": [
  "from math import pi,floor\ns,r = map(float,input().split())\nn,z = map(int,input().split())\narea_sandwich = pi * s**2\narea_pickles = n * pi * r**2\nmax_area = z/100 * area_sandwich\nmax_pickles = floor(max_area / area_pickles)\nprint(max_pickles)"
 ],
 "3355": [
  "import itertools\n\nn,t=map(int,input().split())\npoints,duration,deadline=[0],[],[]\nfor i in range(n):\n    p,d,t_i=map(int,input().split())\n    points.append(p)\n    duration.append(t_i)\n    deadline.append(d)\n\ntime=[list(map(int,input().split())) for _ in range(n+2)]\n\ndp=[[0 for _ in range(t+1)] for __ in range(1<<n+1)]\nroute=[[] for _ in range(1<<n+1)]\n\nfor i in range(1,n+1):\n    for j in range(t-duration[i],-1,-1):\n        mask=(1<<i)\n        if deadline[i]<0 or j+time[n+1][i]<=deadline[i]:\n            for k in range(1,n+1):\n                if(j+time[k][i]<=t):\n                    if(dp[mask][j+duration[i]]<dp[mask^mask%k][j]+points[i]):\n                        dp[mask][j+duration[i]]=dp[mask^mask%k][j]+points[i]\n                        route[mask][j+duration[i]-duration[i]]=[i]+route[mask^mask%k][j]\nans=0\nfor mask in range(1,1<<n+1):\n    for time_ in range(t+1):\n        if(dp[mask][time_]>ans and dp[mask][time_]!=-1):\n            ans=dp[mask][time_]\n            res=route[mask][time_]\ntask_output = ''\nfor ob in sorted(res):\n    task_output += str(ob) + ' '\nprint(ans)\nprint(task_output[:-1])"
 ],
 "3356": [
  "import sys\nfrom collections import deque\n\ninput = sys.stdin.readline\n\nn = int(input().strip())\n\ngraph = [[] for _ in range(n+1)]\n\nfor _ in range(n-1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n    graph[v].append(u)\n\ndef bfs(start):\n    distance = [-1] * (n+1)\n    distance[start] = 0\n    queue = deque([start])\n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if distance[neighbor] == -1:\n                distance[neighbor] = distance[node] + 1\n                queue.append(neighbor)\n    return distance\n\n# First bfs to get the distance from any node\ndistance_from_1 = bfs(1)\n\n# Find the farthest node from 1\nfarthest_node = distance_from_1.index(max(distance_from_1))\n\n# Second bfs to get the distance from the previous farthest node\ndistance_from_farthest = bfs(farthest_node)\n\n# Find the new farthest node from the previous farthest node\nnew_farthest_node = distance_from_farthest.index(max(distance_from_farthest))\n\n# The original farthest distance is the distance from farthest_node to new_farthest_node\noriginal_farthest_distance = distance_from_farthest[new_farthest_node]\n\n# Initialize variables to store the new farthest distance and edges to remove and add\nnew_farthest_distance = float('inf')\nremove_edge = (-1, -1)\nadd_edge = (-1, -1)\n\n# Check every edge in the graph to find the optimal edges to remove and add\nfor node in range(1, n+1):\n    for neighbor in graph[node]:\n        # If the current edge is the one connecting the farthest two nodes, continue\n        if (node == farthest_node and neighbor == new_farthest_node) or (node == new_farthest_node and neighbor == farthest_node):\n            continue\n        # Calculate the new farthest distance if this edge is removed\n        temp_distance = max(distance_from_1[node] + distance_from_farthest[neighbor] + 1, distance_from_1[neighbor] + distance_from_farthest[node] + 1)\n        # If the new farthest distance is smaller, update the variables accordingly\n        if temp_distance < new_farthest_distance:\n            new_farthest_distance = temp_distance\n            remove_edge = (node, neighbor)\n            add_edge = (farthest_node, new_farthest_node)\n\nprint(new_farthest_distance)\nprint(remove_edge[0], remove_edge[1])\nprint(add_edge[0], add_edge[1])"
 ],
 "3357": [
  "import sys\ninput = sys.stdin.readline\n\nN = int(input())\nbuildings = [list(map(int, input().split())) for _ in range(N)]\n\nsun_hours = [0] * N\nseen_angles = []\nfor i in range(N):\n    x, h = buildings[i]\n    angle = 2 * h / x\n    while seen_angles and seen_angles[-1][0] < angle:\n        prev_angle, prev_idx = seen_angles.pop()\n        sun_hours[prev_idx] += angle - prev_angle\n        angle = prev_angle\n    if seen_angles:\n        prev_angle, _ = seen_angles[-1]\n        sun_hours[i] += angle - prev_angle\n    seen_angles.append((angle, i))\n\nfor hours in sun_hours:\n    print(\"{:.4f}\".format(hours * 12 / N))"
 ],
 "3358": [
  "n = int(input())\nprint(\"ST A\")\nprint(\"ST X\")\nprint(\"PH A\")\nprint(\"PH X\")\nwhile n > 0:\n    print(\"AD\")\n    n -= 1\nprint(\"PL Y\")\nprint(\"DI Y\")"
 ],
 "3359": [
  "N, R, C = map(int, input().split())\nimage = [input().split() for i in range(R)]\n\ncount = 0\nfor i in range(N//2, R-N//2):\n    for j in range(N//2, C-N//2):\n        is_stellar = True\n        for r in range(i-N//2, i+N//2+1):\n            for c in range(j-N//2, j+N//2+1):\n                if image[r][c] != 'FFFF':\n                    is_stellar = False\n                    break\n            if not is_stellar:\n                break\n        if is_stellar:\n            count += 1\n\nprint(count)"
 ],
 "3360": [
  "from collections import defaultdict\n\ndef derive(grammar, variable, memo):\n    if variable in memo:  # already derived\n        return memo[variable]\n    results = set()\n    for production in grammar[variable]:\n        if production.islower():\n            results.add(production)\n        else:\n            # non-terminal symbol, derive recursively\n            substrings = [[] for _ in range(len(production) + 1)]\n            substrings[0].append(\"\")\n            for symbol in production:\n                new_substrings = []\n                for i, substring in enumerate(substrings):\n                    if substring:  # the previous substring is non-empty\n                        if symbol in grammar:\n                            for derivation in derive(grammar, symbol, memo):\n                                new_substring = substring[-1] + derivation\n                                new_substrings.append(new_substring)\n                        else:\n                            # terminal symbol, append to the previous substring\n                            new_substrings.append(substring[-1] + symbol)\n                    new_substrings.append(\"\")  # start a new substring\n                substrings = new_substrings\n            results.update(substrings[-1][:-1])  # remove the last empty substring\n    memo[variable] = results\n    return results\n\ndef main():\n    # read CFG\n    grammar = defaultdict(list)\n    num_rules = int(input())\n    for _ in range(num_rules):\n        lhs, rhs = input().split(\" -> \")\n        grammar[lhs].append(rhs)\n\n    # derive substrings from CFG for each line\n    for line in map(str.strip, input().splitlines()):\n        longest_substring = \"\"\n        for i in range(len(line)):\n            for j in range(i + 1, len(line) + 1):\n                substring = line[i:j]\n                if not longest_substring or len(substring) > len(longest_substring):\n                    # derive substring and check if it can be generated by CFG\n                    memo = {}\n                    if substring in derive(grammar, grammar[\"S\"][0], memo):\n                        longest_substring = substring\n        if longest_substring:\n            print(longest_substring)\n        else:\n            print(\"NONE\")\n\nif __name__ == \"__main__\":\n    main()"
 ],
 "3361": [
  "import sys\n\nn = int(input())\ndistances = [list(map(int, input().split())) for i in range(n-1)]\n\ndp = [[-1 for j in range(n)] for i in range(n)]  # initialize dp array\ndp[0][0] = 0  # base case\n\n# calculate prefix sum of distances\npref_sum = [[0 for j in range(n)] for i in range(n)]\nfor i in range(n):\n    for j in range(n):\n        if j > i:\n            pref_sum[i][j] = pref_sum[i][j-1] + distances[i][j-i-1]\n        elif i > j:\n            pref_sum[i][j] = pref_sum[i-1][j] + distances[j][i-j-1]\n\ndef solve(idx, cnt):\n    if idx == n:  # reached end of shipments\n        if cnt == n//2:  # partitioning complete\n            return 0\n        else:\n            return sys.maxsize  # invalid partitioning\n    \n    if dp[idx][cnt] != -1:  # already computed this state\n        return dp[idx][cnt]\n    \n    ans = sys.maxsize\n    \n    for i in range(cnt+1):\n        j = idx - cnt + i - 1\n        if j < i:\n            continue\n        total_dist = pref_sum[idx-1][j] - pref_sum[idx-1][i-1] if i > 0 else pref_sum[idx-1][j]\n        ans = min(ans, total_dist + solve(idx+1, cnt-i))\n    \n    dp[idx][cnt] = ans\n    return ans\n\nprint(solve(1, n//2))"
 ],
 "3362": [
  "from queue import Queue\n\ndef bfs(start, end, adj, step_len):\n    q = Queue()\n    visited = set()\n    q.put((start, end, 0))\n    visited.add((start, end))\n    while not q.empty():\n        curr = q.get()\n        if curr[0] == curr[1]:\n            return True\n        for dx in range(-step_len, step_len+1):\n            for dy in range(-step_len, step_len+1):\n                child1 = (curr[0][0]+dx, curr[0][1]+dy)\n                child2 = (curr[1][0]+dx, curr[1][1]+dy)\n                if (child1, child2) in visited:\n                    continue\n                if child1[0] < 0 or child2[0] < 0 or child1[0] >= L or child2[0] >= L or child1[1] < 0 or child2[1] < 0 or child1[1] >= W or child2[1] >= W:\n                    continue\n                if tiles[child1[0]][child1[1]] == 'B' or tiles[child2[0]][child2[1]] == 'B':\n                    continue\n                if abs(dx) ** 2 + abs(dy) ** 2 > step_len ** 2:\n                    continue\n                q.put((child1, child2, curr[2]+1))\n                visited.add((child1, child2))\n    return False\n\nA, F = map(int, input().split())\nstep_len_elsa = A\nstep_len_father = F\nL, W = map(int, input().split())\n\ntiles = []\nfor i in range(L):\n    row = input()\n    start_index = row.find('S')\n    if start_index != -1:\n        start = (i, start_index)\n    if row.find('G') != -1:\n        end = (i, row.find('G'))\n    tiles.append(row)\n    \nif bfs(start, end, [], step_len_elsa):\n    if bfs(start, end, [], step_len_father):\n        print(\"SUCCESS\")\n    else:\n        print(\"GO FOR IT\")\nelse:\n    if bfs(start, end, [], step_len_father):\n        print(\"NO CHANCE\")\n    else:\n        print(\"NO WAY\")"
 ],
 "3363": [
  "n, m = map(int, input().split())\nc = list(map(int, input().split()))\n\ncalories = 0\nhour = 0\nfor i in range(n):\n    if c[i] > m:\n        break\n    if c[i] >= m * (2 / 3) ** hour:\n        calories += c[i]\n        hour += 1\n    else:\n        if i == n - 1 or c[i + 1] < c[i]:\n            calories += m\n            hour += 2\n        else:\n            hour += 1\nprint(calories)"
 ],
 "3364": [
  "parent = [i for i in range(N)]\n\ndef find(a):\n    while parent[a] != a:\n        a = parent[a]\n    return a\n\nfor _ in range(Q):\n    op, a, b = input().split()\n    a, b = int(a), int(b)\n    if op == \"=\":\n        parent[find(a)] = find(b)\n    else:\n        if find(a) == find(b):\n            print(\"yes\")\n        else:\n            print(\"no\")"
 ],
 "3365": [
  "import math\n\nn, k = map(int, input().split())\nv = list(map(int, input().split()))\n\ndef largest_prime_divisor(num):\n    for i in range(2, int(math.sqrt(num))+1):\n        if num % i == 0:\n            while num % i == 0:\n                num //= i\n            if num == 1:\n                return i\n    return num\n\ndef max_score_partition(n, k, v):\n    score = [0]*n\n    for i in range(n):\n        prime = largest_prime_divisor(v[i])\n        j = i\n        while j < i+k and j < n:\n            new_prime = largest_prime_divisor(v[j])\n            if new_prime != prime:\n                break\n            j += 1\n        for l in range(i, j):\n            score[l] = prime\n    min_score = float('inf')\n    for i in range(k-1, n):\n        min_score = min(min_score, min(score[i-k+1:i+1]))\n    return min_score\n\nprint(max_score_partition(n, k, v))"
 ],
 "3366": [
  "MOD = 10**9 + 7\n\ndef f(x):\n    iterations = 0\n    while x != 1:\n        if x % 2 == 0:\n            x //= 2\n        else:\n            x += 1\n        iterations += 1\n    return iterations\n\nL, R = map(int, input().split())\n\nans = 0\nfor i in range(L, R+1):\n    ans += f(i)\n    ans %= MOD\n\nprint(ans)"
 ],
 "3367": [
  "import bisect\n\ndef binarySearch(arr, x):\n    indx=bisect.bisect_left(arr, x)\n    if indx==len(arr): #if the x is larger than the last element\n        indx-=1\n    return indx\n\nt, n = map(int, input().split())\nq_list = []\nfor i in range(n):\n    q, a = input().split(\"? \")\n    words = q.split()\n    q_list.append((len(words), q, a))\nq_list.sort()\n\nans = 0\ntime_left = t\nscore = [0 for _ in range(n+1)]\nfor i in range(n):\n    l, q, a = q_list[i]\n    time_left -= (l+1) # finishing reading the question + waiting 1 second\n    words = q.split()\n    while 2 <= len(words):\n        mid = (len(words)+1)//2\n        subq = ' '.join(words[:mid])+' '\n        indx = binarySearch(q_list, (mid, subq))\n        score[i+1] += (score[indx] + 1/2) / (n-i)\n        score[indx] = (score[indx] + 1/2) / (n-i)\n        words = words[mid:]\n    score[i+1] += score[i] / (n-i)\n    \nprint(f'{score[-1]*t:.10f}')"
 ],
 "3368": [
  "n, m = map(int, input().split())\nenclosures = {}\nfor i in range(n):\n    data = input().split()\n    enclosure_type = data[0]\n    num_animals = int(data[1])\n    animals = set(data[2:])\n    enclosures[enclosure_type] = (animals, set())\n\nfor i in range(m):\n    animal, destination = input().split()\n    for enclosure_type, (animals, dest_animals) in enclosures.items():\n        if animal in animals:\n            animals.remove(animal)\n            dest_animals.add(animal)\n        elif animal in dest_animals:\n            dest_animals.remove(animal)\n            if enclosure_type == destination:\n                animals.add(animal)\n            else:\n                enclosures[destination][1].add(animal)\n\nfor animals, dest_animals in enclosures.values():\n    if animals:\n        print(\"IMPOSSIBLE\")\n        break\nelse:\n    print(\"FALSE ALARM\" if all(not dest_animals for _, dest_animals in enclosures.values()) else \"POSSIBLE\")"
 ],
 "3369": [
  "p = int(input())\nseq = list(map(int, input().split()))\n\nfor n in range(1,11):\n    for m in range(1,11):\n        for a in range(10):\n            for b in range(10):\n                for c in range(10):\n                    count = 0\n                    for i in range(p-n-m):\n                        if seq[i] == a and seq[i+n] == b and seq[i+n+m] == c:\n                            if i >= m and seq[i-n] != b:\n                                continue\n                            if i <= p-n-m-1 and seq[i+n+m] != b:\n                                continue\n                            count += 1\n\n                    if count >= ((p+39)//40):\n                        print(f\"triple correlation {a}({n}){b}({m}){c} found\")\n                        exit()\nelse:\n    print(\"random sequence\")"
 ],
 "3370": [
  "n, k = map(float, input().split())\nheights = [float(input()) for _ in range(int(n))]\n\nwhile True:\n    max_diff = 0\n    for i in range(1, int(n)-1):\n        avg_height = (heights[i-1] + heights[i+1]) / 2\n        if avg_height + k > heights[i]:\n            diff = avg_height + k - heights[i]\n            max_diff = max(max_diff, diff)\n            heights[i] += diff\n    if max_diff == 0:\n        break\n\nprint(max(heights))"
 ],
 "3371": [
  "from collections import defaultdict\n\ndef dfs(i, c, g, color):\n  stk = [i]\n  color[i] = c\n  while stk:\n    cur = stk.pop()\n    for ne, yr in g[cur]:\n      if color[ne] == -c:\n        continue\n      if color[ne] == c:\n        if color[cur] == c and yr == Y:\n          return False\n        if color[cur] == -c and yr < Y:\n          return False\n      if color[ne] == 0:\n        color[ne] = -c\n        stk.append(ne)\n\n  return True\n\ndef check(Y, n, g):\n  color = [0] * (n+1)\n  for i in range(1, n+1):\n    if color[i] == 0:\n      if not dfs(i, 1, g, color):\n        return False\n\n  return True\n\ndef solve():\n  n, c = map(int, input().split())\n  g = defaultdict(list)\n  mn_yr = float('inf')\n  mx_yr = float('-inf')\n  for _ in range(c):\n    a, b, yr = map(int, input().split())\n    mn_yr = min(mn_yr, yr)\n    mx_yr = max(mx_yr, yr)\n    g[a].append((b, yr))\n    g[b].append((a, yr))\n\n  l, r = mn_yr, mx_yr\n  ans = float('inf')\n  while l <= r:\n    mid = (l+r) >> 1\n    if check(mid, n, g):\n      ans = mid\n      r = mid - 1\n    else:\n      l = mid + 1\n\n  if ans == float('inf'):\n    print(\"Impossible\")\n  else:\n    print(ans)\n\nsolve()"
 ],
 "3372": [
  "import sys\nimport queue\n\n\ndef get_input():\n    num_airports, start, end = map(int, input().strip().split())\n    airports = {}\n    for i in range(num_airports):\n        line = input().strip().split()\n        if 'N' in line:\n            destinations = set(map(int, line[1:]))\n            airports[i] = destinations\n        elif 'C' in line:\n            non_destinations = set(range(num_airports)) - set(map(int, line[1:]))\n            airports[i] = non_destinations\n    return start, end, airports\n\n\ndef bfs(start, end, airports):\n    # Initialize queue and visited set\n    q = queue.Queue()\n    visited = set()\n    q.put((start, 0))\n\n    while not q.empty():\n        airport, num_flights = q.get()\n        visited.add(airport)\n        # If we reach the destination, return the number of flights\n        if airport == end:\n            return num_flights\n\n        # Add all unvisited neighboring airports to the queue\n        for neighbor in airports[airport]:\n            if neighbor not in visited:\n                q.put((neighbor, num_flights+1))\n\n    # If we exhaust all possible paths without reaching the destination, return 'impossible'\n    return 'impossible'\n\n\nif __name__ == '__main__':\n    start, end, airports = get_input()\n    result = bfs(start, end, airports)\n    print(result)\n    sys.stdout.flush()"
 ],
 "3373": [
  "def is_balanced(string):\n    stack = []\n    for char in string:\n        if char == \"(\":\n            stack.append(char)\n        else:\n            if not stack:\n                return False\n            stack.pop()\n    return not stack\n \nn = int(input())\npieces = []\nfor _ in range(n):\n    pieces.append(input())\n \nmemo = {}\n \ndef helper(pieces, cur_str, idx):\n    if idx == n:\n        if is_balanced(cur_str):\n            return len(cur_str)\n        else:\n            return 0\n    if (cur_str, idx) in memo:\n        return memo[(cur_str, idx)]\n    ans = 0\n    ans = max(ans, helper(pieces, cur_str + pieces[idx], idx+1))\n    ans = max(ans, helper(pieces, pieces[idx] + cur_str, idx+1))\n    ans = max(ans, helper(pieces, cur_str, idx+1))\n    memo[(cur_str, idx)] = ans\n    return ans\n \nprint(helper(pieces, \"\", 0))"
 ],
 "3374": [
  "from heapq import heappop, heappush\na = float('inf')\nn = int(input())\np = [input().split() for _ in range(n)]\nd = {p[i][1]: i for i in range(n)}\nfor i in range(n): p[i][0] = int(p[i][0])\nm = int(input())\nadj = [set() for _ in range(n)]\nwhile m:\n    m -= 1\n    u, v = map(int, input().split())\n    u -= 1\n    v -= 1\n    adj[u].add(v)\n    adj[v].add(u)\n\nalien, man = None, None\nfor i in range(n):\n    if p[i][1] == 'a':\n        alien = i\n    elif p[i][1] == 'h':\n        man = i\n\ndef calc_gud(p, d, v):\n    n = len(p)\n    visited = [False] * n\n    preorder = [-1] * n\n    low = [-1] * n\n    stack = []\n    level = [-1] * n\n    parent = [-1] * n\n    k = -1\n    st = []\n    pos = [-1] * n\n    pos[v] = k\n    stk = [v]\n    sum_cap = [0] * n\n    sum_pot = [0] * n\n    sum_ind = [0] * n\n\n    while stk:\n        v = stk.pop()\n        if visited[v]:\n            k += 1\n            st.pop()\n            adj_star = set()\n            cap_head = sum_cap[v]\n            cap_tail = sum_cap[v]\n            while stack[-1] != v:\n                adj_star.add(stack[-1])\n                w = st.pop()\n                visited[w] = False\n                if preorder[w] <= low[v]:\n                    pos[w] = k\n                    cap_head += sum_cap[w]\n                    cap_tail += sum_pot[w]\n                else:\n                    stk.append(w)\n            stack.pop()\n            sum_cap[v] = cap_head\n            sum_pot[v] = cap_head + cap_tail\n            sum_ind[v] = p[v][0] * sum_cap[v]\n            for w in adj_star:\n                sum_cap[w] += sum_cap[v] - sum_cap[w] - p[w][0]\n                sum_pot[w] += sum_pot[v] - cap_head + sum_pot[w] - cap_tail\n                sum_ind[w] += sum_ind[v] - p[w][0] * cap_head - p[w][0] * cap_tail - p[v][0] * sum_cap[w] + p[v][0] * sum_cap[v]\n        else:\n            visited[v] = True\n            k += 1\n            st.append(v)\n            stack.append(v)\n            preorder[v] = low[v] = k\n            for w in adj[v]:\n                if not visited[w]:\n                    level[w] = level[v] + 1\n                    parent[w] = v\n                    stk.append(w)\n                else:\n                    low[v] = min(low[v], preorder[w])\n    return (pos, level, parent), (sum_cap, sum_pot, sum_ind)\n\ndef gud(v):\n    pos, lvl, par, spr = pos1, lvl1, par1, spr1\n    sum_cap, sum_pot, sum_ind = sum_cap1, sum_pot1, sum_ind1\n    if pos[v] == -1:\n        return None\n    med = pos[v]\n    c = a\n    for w in range(n):\n        if pos[w] != med:\n            continue\n        lca = w\n        while lca is not None and spr[lca] != -1:\n            if lvl[lca] < lvl[pos[man]]:\n                lca = None\n            else:\n                lca = spr[lca]\n        if lca is not None:\n            cc = (sum_pot[lca] * sum_pot[lca] - sum_ind[lca]) * sum_cap[lca]\n            cc += (sum_pot[lca] + sum_cap[lca]) * sum_cap[lca] * (p[v][0] - p[lca][0]) * 2\n            cc += sum_cap[v] * (sum_pot[lca] + sum_cap[lca]) * 2 * p[lca][0]\n            cc -= 2 * p[lca][0] * sum_pot[lca] * sum_cap[v] + p[lca][0] * p[lca][0] * sum_cap[v]\n            c = min(c, abs(cc))\n\n    for i in range(n):\n        if lvl[i] > lvl[v] or lvl[i] < lvl[pos[man]] or i == v or i == pos[man]:\n            continue\n        lca = i\n        while lca is not None and spr[lca] != -1:\n            if lvl[lca] < lvl[pos[man]]:\n                lca = None\n            else:\n                lca = spr[lca]\n        if lca is None:\n            continue\n        w = (sum_pot[lca] * sum_pot[lca] - sum_ind[lca]) * sum_cap[lca]\n        w += (sum_pot[lca] + sum_cap[lca]) * sum_cap[lca] * (p[v][0] - p[lca][0]) * 2\n        w += sum_cap[v] * (sum_pot[lca] + sum_cap[lca]) * 2 * p[lca][0]\n        w -= 2 * p[lca][0] * sum_pot[lca] * sum_cap[v] + p[lca][0] * p[lca][0] * sum_cap[v]\n        w = abs(w)\n        p1 = pos[v]\n        p2 = pos[i]\n        lca_l = lca\n        while p1 != p2:\n            if lvl[p1] < lvl[p2]:\n                p2 = spr[p2]\n            else:\n                lca_l = max(lca_l, par1[p1])\n                p1 = spr[p1]\n        lca_l = max(lca_l, lca)\n        w += (lca_l != i) * 2 * p[i][0] * sum_cap[i] + 2 * p[lca_l][0] * sum_cap[v]\n        c = min(c, w)\n    return c\n\npos1, sum1 = calc_gud(p, d, man)\nsum_cap1, sum_pot1, sum_ind1 = sum1\n_, _, spr1 = calc_gud(p, d, alien)\n\nans = gud(alien)\nfor i in range(n):\n    g = p[i][0]\n    if i != alien:\n        p[i][0] = g - 1\n        for j in adj[i]:\n            gt = p[j][0]\n            p[j][0] = gt + 1\n            pos1, sum1 = calc_gud(p, d, man)\n            sum_cap1, sum_pot1, sum_ind1 = sum1\n            f = gud(alien)\n            ans = min(ans, f)\n            p[j][0] = gt\n        p[i][0] = g\nprint(ans)"
 ],
 "3375": [
  "MOD = 1000000007\n\nV, E = map(int, input().split())\n\n# Constructing adjacency matrix\nadjMat = [[0 for j in range(V)] for i in range(V)]\n\nfor i in range(E):\n    u, v = map(int, input().split())\n    u = u - 1\n    v = v - 1\n    adjMat[u][v] = 1\n    adjMat[v][u] = 1\n    \n# Count number of spanning unicyclic subgraphs\ndp = [[0 for i in range(2**V)] for j in range(V)]\n\nfor i in range(V):\n    dp[i][1<<i] = 1\n\nfor state in range(1, 2**V):\n    for i in range(V):\n        if (2**i) & state:\n            for j in range(V):\n                if adjMat[i][j] == 1 and (2**j) & state:\n                    dp[i][state] += dp[j][state - (2**i)]\n                    dp[i][state] %= MOD\n\nans = 0\n\nfor state in range(1, 2**V):\n    vertices = 0\n    for i in range(V):\n        if (2**i) & state:\n            vertices += 1\n    if vertices == 1:\n        continue\n    for i in range(V):\n        if (2**i) & state:\n            for j in range(V):\n                if (2**j) & state and adjMat[i][j] and (state - (2**i) - (2**j)) > 0:\n                    ans += dp[i][state - (2**i)]*dp[j][state - (2**j)]\n                    ans %= MOD\n\nprint(ans)"
 ],
 "3376": [
  "from collections import defaultdict\n\nf = int(input().strip())\nfamilies = []\nfor i in range(f):\n    row = input().strip().split()\n    num_members = int(row[0])\n    family_candies = []\n    for j in range(1, num_members*2, 2):\n        family_candies.append(int(row[j+1]))\n    families.append(family_candies)\n\nn = int(input().strip())\ncatches = defaultdict(list)\nfor i in range(n):\n    row = input().strip().split()\n    time = int(row[0])\n    pokemon = row[1]\n    catches[pokemon].append(time)\n\nfor family in families:\n    xp = 0\n    candies = 0\n    prev_time = -1\n    for i in range(len(family)-1):\n        candies += 3  # earned candies from catching a pokemon\n        while len(catches[pokemon_names[i]]) > 0 and catches[pokemon_names[i]][0] <= egg_end:\n            candies += 1  # earned candies from transferring a pokemon\n            catches[pokemon_names[i]].pop(0)\n        \n        # evolve pokemon if possible\n        while candies >= family[i+1]:\n            candies -= family[i+1]\n            xp += 500\n        xp += 100  # earned xp from catching a pokemon\n        if i == len(family)-2:\n            # last pokemon in family\n            while len(catches[pokemon_names[i+1]]) > 0 and catches[pokemon_names[i+1]][0] <= egg_end:\n                candies += 1  # earned candies from transferring a pokemon\n                catches[pokemon_names[i+1]].pop(0)\n\n        # use egg if it is the optimal time\n        if i == len(family)-2:\n            # last pokemon in family\n            if prev_time != -1 and egg_end >= prev_time + 30*60:\n                # if the previous pokemon was caught during the egg's duration, activate the egg\n                xp *= 2\n            else:\n                # otherwise, calculate the optimal duration for the egg and activate it at that time\n                optimal_time = -1\n                candies_needed = family[0] + family[-2] + sum(family[:-1])\n                for catch_time in catches[pokemon_names[0]]:\n                    if catch_time > prev_time + 30*60:\n                        # calculate the candies obtained by transferring all the caught pokemon, starting from the first i.e., family[0]\n                        candies_obtained = 0\n                        j = 0\n                        while candies_obtained < candies_needed and j < len(pokemon_names)-1:\n                            while len(catches[pokemon_names[j]]) > 0 and catches[pokemon_names[j]][0] <= catch_time:\n                                candies_obtained += 1\n                                catches[pokemon_names[j]].pop(0)\n                            j += 1\n                        if candies_obtained >= candies_needed:\n                            optimal_time = catch_time\n                        else:\n                            break\n                if optimal_time != -1:\n                    egg_end = optimal_time + 30*60\n                    prev_time = optimal_time\n                    \n    max_xp += xp\n                    \nprint(max_xp)"
 ],
 "3377": [
  "from collections import deque\n\nn = int(input())\nadj_list = [[] for _ in range(n)]\nfor i in range(n):\n    lst = list(map(int, input().split()))\n    for x in lst[1:]:\n        adj_list[i].append(x-1)\n\nm = int(input())\nops = []\nfor i in range(m):\n    ops.append(int(input())-1)\n\ndistinct_moves = deque()\nfor i in range(m):\n    for j in range(i+1, m):\n        temp = ops.copy()\n        temp[i], temp[j] = temp[j], temp[i]\n        if temp not in distinct_moves:\n            distinct_moves.append(temp)\n\nplanned_moves = [[] for _ in range(len(distinct_moves))]\nfor i in range(len(distinct_moves)):\n    cur_state = set()\n    for j in range(m):\n        if distinct_moves[i][j] in cur_state:\n            break\n        planned_moves[i].append(distinct_moves[i][j])\n        cur_state.add(distinct_moves[i][j])\n        for adj in adj_list[distinct_moves[i][j]]:\n            if adj not in cur_state:\n                break\n        else:\n            cur_state.discard(distinct_moves[i][j])\n\nmin_moves = float('inf')\nans = []\nfor moves in planned_moves:\n    moves_set = set(moves)\n    num_moves = len(moves)\n    moves_set_by_move = [[] for _ in range(num_moves)]\n    for i in range(num_moves):\n        moves_set_by_move[i] = moves_set_by_move[i-1] + [moves[i-1]]\n\n    visited = [False] * n\n    for i in range(num_moves):\n        if ops[i] == moves[i] and all(visited[m] for m in moves_set_by_move[i]):\n            visited[ops[i]] = True\n        elif moves[i] not in visited:\n            break\n        elif ops[i] in moves_set_by_move[i]:\n            visited[ops[i]] = False\n        else:\n            break\n    else:\n        if num_moves < min_moves:\n            min_moves = num_moves\n            ans = moves\n\nif min_moves > 10 * m:\n    print(-1)\nelse:\n    print(min_moves)\n    for move in ans:\n        if move in ops:\n            print(move+1)\n        else:\n            print(-move-1)"
 ],
 "3378": [
  "import heapq\n\nn, d = map(int, input().split())\nschedule = list(map(int, input().split()))\nm = int(input())\nfares = {i: [] for i in range(1, n+1)}  # create dictionary to store possible fares for each city\n\nfor i in range(m):\n    s, d, t, p = input().split()\n    s, d, p = int(s), int(d), int(p)\n    fares[s].append((d, t, p))\n\n# Dijkstra's shortest path algorithm using heapq\ndist = [-1] * (n+1)\ndist[schedule[0]] = 0\nheap = [(0, schedule[0])]\n\nwhile heap:\n    cost, cur_city = heapq.heappop(heap)\n    \n    if cost > dist[cur_city]:\n        continue\n        \n    for next_city, fare_type, fare_price in fares[cur_city]:\n        if fare_type == 'O':  # one-way fare\n            if dist[next_city] == -1 or cost + fare_price < dist[next_city]:\n                dist[next_city] = cost + fare_price\n                heapq.heappush(heap, (dist[next_city], next_city))\n        else:  # round-trip fare\n            for round_city, round_type, round_price in fares[next_city]:\n                if round_type == 'R' and round_city == cur_city:\n                    if dist[next_city] == -1 or cost + fare_price + round_price < dist[next_city]:\n                        dist[next_city] = cost + fare_price + round_price\n                        heapq.heappush(heap, (dist[next_city], next_city))\n\nprint(dist[schedule[-1]])  # answer is the shortest path from start to end city"
 ],
 "3379": [
  "import heapq\n\nn, m = map(int, input().split())\n\nin_degrees = [0] * n  # list to store in-degree of each node\ngraph = [[] for _ in range(n)]  # adjacency list to represent the graph\n\n# read input and populate the in_degrees and graph\nfor _ in range(m):\n    x, y = map(int, input().split())\n    graph[x].append(y)\n    in_degrees[y] += 1\n\nq = []  # priority queue to store nodes with 0 in-degree\nfor u in range(n):\n    if in_degrees[u] == 0:\n        heapq.heappush(q, u)\n\nmax_source_nodes = 0  # variable to store maximum number of source nodes seen so far\n\n# perform Kahn's Algorithm\nwhile q:\n    s = set()  # set to store all source nodes in current iteration\n    while q:\n        u = heapq.heappop(q)\n        s.add(u)\n        for v in graph[u]:\n            in_degrees[v] -= 1\n            if in_degrees[v] == 0:\n                heapq.heappush(q, v)\n    max_source_nodes = max(max_source_nodes, len(s))\n\nprint(max_source_nodes)"
 ],
 "3380": [
  "import math\n\nn = int(input())\nans = 1\nfor i in range(2, n+1):\n    ans *= i\n\np = 0\nfor i in range(n):\n    p += ((-1)**i) * (math.comb(n, i)) * ((n-i)**n)\n\nprob = p/ans\n\nprint(\"{:.10f}\".format(prob))"
 ],
 "3381": [
  "n=int(input())\nprint(0,0)\nprint(4*(10**7),0)\nprint(0,(n-2)*(10**7))\nfor i in range(n-3):\n    print((i+1)*10**7,(n-3-i)*10**7)"
 ],
 "3382": [
  "from itertools import permutations\n\ndef apply_operator(a, b, op):\n    if op == '+':\n        return a + b\n    elif op == '-':\n        return a - b\n    elif op == '*':\n        return a * b\n    elif op == '/' and b != 0 and a % b == 0:\n        return a // b\n    else:\n        return None\n\ndef evaluate(nums, ops):\n    stack = []\n    for x in nums:\n        stack.append(x)\n        while len(stack) >= 3:\n            a, b, c = stack[-3:]\n            for op in ops:\n                val = apply_operator(a, b, op)\n                if val is not None:\n                    stack[-3:] = [val, c]\n                    break\n            else:\n                break\n    return stack[0]\n\ndef count_parentheses(expr):\n    return sum(1 for x in expr if x in '()')\n\ndef count_inversions(nums, expr):\n    target = list(nums)\n    cur = [int(x) for x in expr if x not in '()']\n    inversions = 0\n    for i in range(4):\n        j = cur.index(nums[i])\n        while i < j:\n            cur[j], cur[j-1] = cur[j-1], cur[j]\n            j -= 1\n            inversions += 2\n    return inversions\n\ndef generate_expr(nums, ops):\n    n = len(nums)\n    if n == 1:\n        return [str(nums[0])]\n    res = []\n    for i in range(1, n):\n        left_exprs = generate_expr(nums[:i], ops)\n        right_exprs = generate_expr(nums[i:], ops)\n        for left in left_exprs:\n            for right in right_exprs:\n                for op in ops:\n                    if op == '/' and (not right.startswith('-')\n                            and not int(right) == 0 and int(left) % int(right) != 0):\n                        continue\n                    res.append('({}{}{})'.format(left, op, right))\n    for left in generate_expr(nums[1:], ops):\n        for op in ops:\n            if op == '/' and (not nums[1:].startswith('-')\n                              and not int(nums[1:]) == 0 and int(left) % int(nums[1:]) != 0):\n                continue\n            res.append('{}{}{}'.format(nums[0], op, left))\n    return res\n\ndef find_lowest_grade(nums):\n    ops = ['+', '-', '*', '/']\n    exprs = generate_expr(nums, ops)\n    min_grade = float('inf')\n    for expr in exprs:\n        if evaluate(nums, ops) == 24:\n            grade = count_parentheses(expr) + count_inversions(nums, expr)\n            if grade < min_grade:\n                min_grade = grade\n    return min_grade if min_grade != float('inf') else 'impossible'\n\nnums = list(map(int, input().split()))\nprint(find_lowest_grade(nums))"
 ],
 "3383": [
  "n, k, a, b = map(int, input().split())\nt = list(map(int, input().split()))\nu = [list(map(int, input().split())) for _ in range(k)]\n\ndef check(s):\n    # dp[i][j] is the maximum tastiness if we have used i scoops and the last scoop is j.\n    dp = [[-float('inf')] * k for _ in range(s)]\n    for i in range(k):\n        dp[0][i] = t[i]\n    for i in range(1, s):\n        for j in range(k):\n            for l in range(k):\n                dp[i][j] = max(dp[i][j], dp[i-1][l] + t[j] + u[l][j]*i)\n    return max([dp[i][j] - i*a for i in range(1, s+1) for j in range(k)]) - s*b >= 0\n\n# Binary search over the number of scoops\nl, r = 0, n\nwhile l < r:\n    mid = (l + r + 1) // 2\n    if check(mid):\n        l = mid\n    else:\n        r = mid - 1\n\nif l == 0:\n    print(0)\nelse:\n    ans = max([dp[i][j] - i*a for i in range(1, l+1) for j in range(k)]) / (l*a + b)\n    print('{:.8f}'.format(ans))"
 ],
 "3384": [
  "n = input()\nfor i, digit in enumerate(n):\n    if i == 0:\n        continue\n    prev_digit = n[i-1]\n    if digit == prev_digit:\n        for new_digit in ['0','1','2','3','4','5','6','7','8','9']:\n            if new_digit != digit and new_digit%2 != prev_digit%2:\n                new_num = n[:i] + new_digit + n[i+1:]\n                if int(new_num) > int(n):\n                    print(new_num)\n                    exit(0)\n                else:\n                    print(new_num)\n                    exit(0)\n    else:\n        continue"
 ],
 "3385": [
  "MOD = 1000000007\n\nn = int(input())\ndata = [list(map(int, input().split())) for _ in range(n)]\n\n# check if the constraints are solvable\nfor i in range(n):\n    if (data[i][0] + data[i][1] + 1) % 2 != data[i][2]:\n        print(0)\n        exit()\n\n# count number of pumpkin and bat costumes\npumpkin_count = [0] * n\nfor i in range(n):\n    for j in range(-data[i][0], data[i][1] + 1):\n        idx = (i + j + n) % n\n        if j < 0:\n            pumpkin_count[idx] += 1\n        else:\n            pumpkin_count[idx] -= 1\n\n# compute the number of solutions\nans = 1\nfor i in range(n):\n    if pumpkin_count[i] == 0:\n        ans = (ans * 2) % MOD\n\nprint(ans)"
 ],
 "3386": [
  "n, m = map(int, input().split())\n\nif n == 1 and m == 1:\n    print(\"1 1\")\nelif n == 1:\n    for j in range(2, m+1, 2):\n        print(\"1\", j//2)\n    for j in range(1, m+1, 2):\n        print(\"1\", m-(j//2))\nelif m == 1:\n    for i in range(2, n+1, 2):\n        print(i//2, \"1\")\n    for i in range(1, n+1, 2):\n        print(n-(i//2), \"1\")\nelif n == 2 and m in [2, 3]:\n    print(\"-1\")\nelif m == 2:\n    for i in range(2, n+1, 2):\n        print(i//2, \"1\")\n    for i in range(1, n+1, 2):\n        print(n-(i//2), \"2\")\nelse:\n    a = []\n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            if (i+j)%2 == 0:\n                a.append((i, j))\n    for j in range(2, m+1, 2):\n        a.append((n, j))\n    for j in range(m-1, 0, -2):\n        a.append((n-1, j))\n    for i in range(n-2, 0, -2):\n        a.append((i, 1))\n    for i in range(2, n+1, 2):\n        for j in range(1, m+1):\n            if (i+j)%2 == 1:\n                a.append((i, j))\n    for i in range(len(a)):\n        print(a[i][0], a[i][1])"
 ],
 "3387": [
  "import sys\ninput = sys.stdin.readline\n\nn, t = map(int, input().split())\ncd = [(0,0,0)]*n\ntotal_demand = 0\nfor i in range(n):\n    ai, bi, di = map(int, input().split())\n    cd[i] = (ai, bi, di)\n    total_demand += di\n\ndef calculate(y):\n    allocated_bandwidth = [0]*n\n    for i in range(n):\n        y_i = y*cd[i][2]/total_demand\n        allocated_bandwidth[i] = max(cd[i][0], min(cd[i][1], y_i))\n    return allocated_bandwidth\n\nl, r = 0, t\nft_y = 0\nfor _ in range(60):\n    y1 = (2*l + r) / 3\n    y2 = (l + 2*r) / 3\n    x1 = calculate(y1)\n    x2 = calculate(y2)\n    f1 = sum([(x1[i] - t*cd[i][2]/total_demand)**2 / (t*cd[i][2]/total_demand) for i in range(n)])\n    f2 = sum([(x2[i] - t*cd[i][2]/total_demand)**2 / (t*cd[i][2]/total_demand) for i in range(n)])\n    if f1 > f2:\n        l = y1\n        ft_y = y2\n    else:\n        r = y2\n        ft_y = y1\n\nans = calculate(ft_y)\nfor i in range(n):\n    print(\"{:.8f}\".format(ans[i]))"
 ],
 "3388": [
  "n = int(input())\nscores = list(map(int, input().split()))\nmax_score = max(scores)\n\nif scores.count(max_score) == 1:\n    # Julia is the only one with the maximum score, so she will remain in the lead.\n    print(\"0\")\nelse:\n    # Find the teams with the maximum scores (excluding Julia).\n    max_teams = []\n    for i in range(1, n):\n        if scores[i] == max_score:\n            max_teams.append(i)\n\n    # Count the number of matches where Julia can choose the winning team.\n    guaranteed_wins = 0\n    for i in max_teams:\n        if scores[i] + 1 <= scores[0]:\n            # Julia can choose the team that this player did not choose to remain in the lead.\n            guaranteed_wins += 1\n    print(guaranteed_wins)"
 ],
 "3389": [
  "n, k = map(int, input().split())\nvideos = input()\nclicks = 0\ntypes = {}\nfor i in range(n):\n    curr_type = videos[i]\n    # check if current type needs to be watched\n    if curr_type not in types: \n        types[curr_type] = True\n        clicks += 1\n    # remove current type from list\n    videos = videos[:i] + videos[i+1:]\n    n -= 1\n    i -= 1\n    # check if there are more videos of current type\n    while n > 0 and videos[i] == curr_type:\n        videos = videos[:i] + videos[i+1:]\n        n -= 1\n        i -= 1\nprint(clicks)"
 ],
 "3390": [
  "from collections import defaultdict, deque\n\nn, m = map(int, input().split())\ngraph = defaultdict(list)\nin_degree = {i: 0 for i in range(1, n+1)}\n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    in_degree[b] += 1\n    \nq = deque()\nfor i in range(1, n+1):\n    if in_degree[i] == 0:\n        q.append(i)\n\ntop_sort = []\nwhile q:\n    node = q.popleft()\n    top_sort.append(node)\n    for neighbor in graph[node]:\n        in_degree[neighbor] -= 1\n        if in_degree[neighbor] == 0:\n            q.append(neighbor)\n\ndp = [0] * (n+1)\nans = 0\nfor node in top_sort:\n    for neighbor in graph[node]:\n        dp[neighbor] = max(dp[neighbor], dp[node]+1)\n    ans = max(ans, dp[node]+1)\nprint(ans)"
 ],
 "3391": [
  "import sys\n\ninput = sys.stdin.readline\n\nn, q = map(int, input().split())\n\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\nsorted_x = sorted(points, key=lambda x: x[0])\nsorted_y = sorted(points, key=lambda x: x[1])\n\ndef get_width_and_height(left, right, bottom, top):\n    return max(right - left, top - bottom)\n\ndef check(width):\n    left_idx = right_idx = top_idx = bottom_idx = 0\n    count = 1\n    while right_idx < n:\n        while sorted_x[right_idx][0] - sorted_x[left_idx][0] > width:\n            left_idx += 1\n        while sorted_y[top_idx][1] - sorted_y[bottom_idx][1] > width:\n            bottom_idx += 1\n        while right_idx < n and sorted_x[right_idx][0] - sorted_x[left_idx][0] <= width and \\\n                sorted_y[top_idx][1] - sorted_y[bottom_idx][1] <= width:\n            if sorted_x[right_idx][1] > sorted_y[top_idx][1]:\n                top_idx += 1\n            elif sorted_x[right_idx][1] < sorted_y[top_idx][1]:\n                right_idx += 1\n            else:\n                if sorted_x[right_idx][1] < sorted_y[bottom_idx][1]:\n                    right_idx += 1\n                elif sorted_x[right_idx][1] > sorted_y[top_idx][1]:\n                    top_idx += 1\n                else:\n                    break\n            count += 1\n            if count >= len(sorted_x):\n                return True\n        if right_idx < n:\n            left_idx += 1\n            bottom_idx += 1\n            count -= 1\n        else:\n            break\n    return count >= len(sorted_x)\n\nfor _ in range(q):\n    a, b = map(int, input().split())\n    left, right = min(p[0] for p in points[a - 1:b]), max(p[0] for p in points[a - 1:b])\n    bottom, top = min(p[1] for p in points[a - 1:b]), max(p[1] for p in points[a - 1:b])\n    ans = get_width_and_height(left, right, bottom, top)\n    lo, hi = 0, ans\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if check(mid):\n            hi = mid\n        else:\n            lo = mid + 1\n    print(lo)"
 ],
 "3392": [
  "import sys\ninput = sys.stdin.readline\n\nfrom collections import deque\n\nn = int(input())\nh = [list(map(int, input().split())) for _ in range(n)]\nv = [list(map(int, input().split())) for _ in range(n)]\n\nheight = [[0]*n for _ in range(n)]\nfor i in range(n):\n    for j in range(n):\n        height[i][j] = h[i][j]+v[i][j]*2500  # calculate the maximum height for each tree\n\ndx = [0, 0, 1, -1]\ndy = [1, -1, 0, 0]\n\ndef bfs(x, y, size):\n    q = deque()\n    \n    q.append((x, y))\n    visited[x][y] = True\n    \n    while q:\n        x, y = q.popleft()\n        for i in range(4):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if nx>=n or ny>=n or nx<0 or ny<0:\n                continue\n            if not visited[nx][ny] and height[x][y]==height[nx][ny]:\n                q.append((nx, ny))\n                visited[nx][ny] = True\n                size += 1\n    return size\n\nvisited = [[False]*n for _ in range(n)]\nans = 0\nfor i in range(n):\n    for j in range(n):\n        if not visited[i][j]:\n            size = bfs(i, j, 1)\n            ans = max(ans, size)\n\nprint(ans)"
 ],
 "3393": [
  "from heapq import heapify, heappush, heappop\n\nI = lambda: tuple(input().split())\nn, k = map(int, input().split())\n\nc1 = []\nc2 = []\n\nfor i in range(n):\n    s, d = I()\n    if s[-1] == \"1\":\n        c1.append(int(d))\n    elif s[-1] == \"2\":\n        c2.append(int(d))\n    \nheapify(c1), heapify(c2)\nS = []\nans = 0\nfor i in range(min(len(c1), len(c2))):\n    x = heappop(c1)\n    y = heappop(c2)\n    ans += (x + y)\n    \nfor i in range(k - len(S)):\n    if c2:\n        ans += heappop(c2)\n    else:\n        ans += heappop(c1)\nprint(ans)"
 ],
 "3394": [
  "import heapq\ninf = float('inf')\n\nn, m = map(int, input().split())\n\ngraph = [[] for _ in range(n+1)]\n\nfor i in range(m):\n    u, v, d = map(int, input().split())\n    graph[u].append((v,d))\n    graph[v].append((u,d))\n\nk = int(input())\norders = []\nfor i in range(k):\n    s, u, t = map(int, input().split())\n    orders.append((s,u,t))\n\npq = []\nans = 0\ncurTime = 0\n\n# Dijkstra\nfor i in range(k):\n    s, u, t = orders[i]\n    curTime = s\n    pq = [(0,1)] # dist, curNode\n    dist = [inf]*(n+1)\n    visited = [False]*(n+1)\n    dist[1] = 0\n    \n    while pq:\n        time, node = heapq.heappop(pq)\n        \n        if visited[node]:\n            continue\n        \n        visited[node] = True\n        \n        if node == u:\n            curTime += max(0, time - curTime)\n            curTime += (abs(t-curTime) + 1)//2\n            ans = max(ans, curTime - s)\n        \n        for v, d in graph[node]:\n            cost = time + d\n            if cost < dist[v]:\n                dist[v] = cost\n                heapq.heappush(pq, (cost, v))\n\nprint(ans)"
 ],
 "3395": [
  "n, m, k = map(int, input().split())\no = list(map(int, input().split()))\nc = list(map(int, input().split()))\n\nconnections = [[] for _ in range(n)]\nfor i in range(n):\n    adj = list(map(int, input().split()))[1:]\n    for a in adj:\n        connections[i].append(a-1)\n\nINF = int(1e9)\n\ndef bfs(start):\n    dist = [INF] * n\n    dist[start] = 0\n    q = [start]\n    while q:\n        u = q.pop(0)\n        for v in connections[u]:\n            if dist[v] == INF:\n                dist[v] = dist[u] + 1\n                q.append(v)\n    return dist\n\ndist1 = bfs(0)\ndist2 = bfs(n-1)\no.sort()\nc.sort()\n\nans = INF\nfor i in o:\n    if(dist1[i-1] == INF):\n        continue\n    for j in c:\n        if(dist2[j-1] == INF):\n            continue\n        d = dist1[i-1] + dist2[j-1]\n        ans = min(ans, d)\n\nif(ans == INF):\n    print(\"impossible\")\nelse:\n    print(ans)"
 ],
 "3396": [
  "import math\n\nn = int(input())\nposts = []\nfor _ in range(n):\n    x, y = map(int, input().split())\n    posts.append((x, y))\n    \nmax_rope = 0\nfor i in range(n-1):\n    for j in range(i+1, n):\n        distance = math.sqrt((posts[i][0]-posts[j][0])**2 + (posts[i][1]-posts[j][1])**2)\n        max_rope = max(max_rope, distance)\n        \nprint(f\"{max_rope:.2f}\")"
 ],
 "3397": [
  "N,M = map(int, input().split())\ntimes = [list(map(int, input().split())) for _ in range(N)]\nmax_dog_time = max([max(times[i]) for i in range(N)])\ntotal_waiting_time = sum([max_dog_time - max(times[i]) for i in range(N)])\nprint(total_waiting_time)"
 ],
 "3398": [
  "n_r, n_c, n, m = map(int, input().split())\nfiles = [tuple(map(int, input().split())) for _ in range(n+m)]\n\n# Calculating the boundary of the cluster\nmax_r = max(files[i][0] for i in range(n))\nmin_r = min(files[i][0] for i in range(n))\nmax_c = max(files[i][1] for i in range(n))\nmin_c = min(files[i][1] for i in range(n))\n\n# Counting the number of files to be moved out of boundary\nnum_outside = sum(1 for i in range(n+m) if (files[i][0] < min_r or files[i][0] > max_r or files[i][1] < min_c or files[i][1] > max_c) and i < n)\n\n# Calculating minimum number of files to be moved inside boundary\nnum_inside = n - (max_r - min_r + 1) * (max_c - min_c + 1)\n\n# Outputting the result\nprint(num_outside + num_inside)"
 ],
 "3399": [
  "n, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\n\nvisited = set()\nregions = [[] for _ in range(3)]\n\nfor i in range(n):\n    for j in range(m):\n        if (i, j) not in visited:\n            region = set()\n            queue = [(i, j)]\n            visited.add((i, j))\n            while queue:\n                x, y = queue.pop(0)\n                region.add((x, y))\n                if x > 0 and grid[x-1][y] == grid[x][y] and (x-1, y) not in visited:\n                    queue.append((x-1, y))\n                    visited.add((x-1, y))\n                if x < n-1 and grid[x+1][y] == grid[x][y] and (x+1, y) not in visited:\n                    queue.append((x+1, y))\n                    visited.add((x+1, y))\n                if y > 0 and grid[x][y-1] == grid[x][y] and (x, y-1) not in visited:\n                    queue.append((x, y-1))\n                    visited.add((x, y-1))\n                if y < m-1 and grid[x][y+1] == grid[x][y] and (x, y+1) not in visited:\n                    queue.append((x, y+1))\n                    visited.add((x, y+1))\n            if len(region) == 1:\n                continue\n            languages = set()\n            for x, y in region:\n                languages.add(grid[x][y])\n            if len(languages) == 1:\n                idx = int(languages.pop()) - 1\n                for x, y in region:\n                    regions[idx].append((x, y))\n            else:\n                print(\"impossible\")\n                exit()\n\nif not regions[0] or not regions[1] or not regions[2]:\n    print(\"impossible\")\nelse:\n    ans = [[\".\"] * m for _ in range(n)]\n    for x, y in regions[0]:\n        ans[x][y] = \"A\"\n    for row in ans:\n        print(\"\".join(row))\n    print()\n    ans = [[\".\"] * m for _ in range(n)]\n    for x, y in regions[1]:\n        ans[x][y] = \"B\"\n    for row in ans:\n        print(\"\".join(row))\n    print()\n    ans = [[\".\"] * m for _ in range(n)]\n    for x, y in regions[2]:\n        ans[x][y] = \"C\"\n    for row in ans:\n        print(\"\".join(row))"
 ],
 "3400": [
  "from collections import defaultdict\nINF = float('inf')\nN, A, R, T = map(int, input().split())\n\n# make adjacency matrix\nadj_mat = [[INF for _ in range(N)] for _ in range(N)]\nfor i in range(N):\n    adj_mat[i][i] = 0\nfor _ in range(T):\n    d, p, *a = map(int, input().split())\n    for i in range(p-1):\n        for j in range(i+1, p):\n            adj_mat[a[i]-1][a[j]-1] = adj_mat[a[j]-1][a[i]-1] = d\n\n# find shortest path using Floyd-Warshall algorithm\nfor k in range(N):\n    for i in range(N):\n        for j in range(N):\n            adj_mat[i][j] = min(adj_mat[i][j], adj_mat[i][k] + adj_mat[k][j])\n\nprint(adj_mat[A-1][R-1])"
 ],
 "3401": [
  "from math import sqrt\nfrom heapq import heappush, heappop\n\nn, s, t, q = map(int, input().split())\nhills = []\n\nfor i in range(1, n + 1):\n    x, y, h = map(int, input().split())\n    hills.append((h, x, y, i))\n\nsprings = set(map(int, input().split()))\ntowns = set(map(int, input().split()))\n\ngraph = [[] for _ in range(n + 1)]\nfor i, (hi, xi, yi, _) in enumerate(hills):\n    for j, (hj, xj, yj, _) in enumerate(hills[:i]):\n        dx, dy, dh = xi - xj, yi - yj, hi - hj\n        if dx * dy == 0:\n            dist = max(abs(dx), abs(dy))\n        else:\n            dist = sqrt(dx * dx + dy * dy)\n        if dist <= q and dh >= dist:\n            graph[i].append((dist, j))\n            graph[j].append((dist, i))\n\nINF = float('inf')\ndist = [INF] * (n + 1)\npq = [(0, i) for i in range(1, n + 1)]\nvisited = [False] * (n + 1)\nwhile pq:\n    d, u = heappop(pq)\n    if visited[u]:\n        continue\n    visited[u] = True\n    dist[u] = d\n    for w, v in graph[u]:\n        if not visited[v]:\n            heappush(pq, (d + w, v))\n\nsprings_dist = [dist[u] for u in range(1, n + 1) if u in springs]\ntowns_dist = [dist[u] for u in range(1, n + 1) if u in towns]\nif any(d == INF for d in springs_dist + towns_dist):\n    print(\"IMPOSSIBLE\")\nelse:\n    total_dist = sum(sorted(towns_dist)) + sum(sorted(springs_dist)[:t])\n    print(\"{:.6f}\".format(total_dist))"
 ],
 "3402": [
  "from collections import deque\n\n# input\nS = input().strip()\nT = input().strip().split()\nU = input().strip().split()\nK = int(input().strip())\nM = int(input().strip())\nm = list(map(int, input().strip().split()))\n\n# convert T to dictionary for fast lookup\nd = {}\nfor i in range(26):\n    d[chr(97+i)] = T[i]\n    d[chr(65+i)] = T[i].upper()\n\n# function to apply f on a string\ndef f(s):\n    res = deque()\n    for c in s:\n        res.extend(d[c])\n    return ''.join(res)\n\n# create a list of lengths after each application of f\nlens = [len(S)]\nfor i in range(K):\n    lens.append(len(f(S)))\n    S = f(S)\n\n# loop over the positions of forgotten letters\nfor pos in m:\n    # determine which iteration of f results in the forgotten letter\n    i = 0\n    while pos > lens[i]:\n        i += 1\n    # find the position of the forgotten letter in the string resulting from the i-th application of f\n    for c in S:\n        if pos <= len(d[c]):\n            break\n        pos -= len(d[c])\n    # output the forgotten letter\n    print(d[c][pos-1])"
 ],
 "3403": [
  "from sys import stdin, stdout\n\n# Function to find the longest common prefix\ndef lcp(s1, s2):\n    i = 0\n    j = 0\n    while i < len(s1) and j < len(s2) and s1[i] == s2[j]:\n        i += 1\n        j += 1\n    return i\n\n# Reading input\nn = int(stdin.readline())\nwords = [stdin.readline().strip() for i in range(n)]\nq = int(stdin.readline())\nqueries = [stdin.readline().strip() for i in range(q)]\n\n# Searching for query words\nfor query in queries:\n    steps = 0\n    for word in words:\n        prefix_len = lcp(query, word)\n        steps += 1 + prefix_len\n        if prefix_len < len(query) and prefix_len == len(word) or query[prefix_len] != word[prefix_len]:\n            # Query word is not found in database\n            break\n    stdout.write(str(steps) + '\\n')"
 ],
 "3404": [
  "N, X = map(int, input().split())\nencrypted_text = input().rstrip('\\n')\n\ndef f(x):\n    return (33 * x + 1) % (2 ** 20)\n\ndef column_sum(X, f):\n    column_sums = [0] * X\n    for j in range(X):\n        val = f(j)\n        for i in range(X):\n            column_sums[i] = (column_sums[i] + val) % (2 ** 20)\n            val = f(val)\n    return column_sums\n\ndef base10_to_base27(num):\n    result = \"\"\n    while num > 0:\n        result += chr(ord('A') + num % 27)\n        num //= 27\n    return result[::-1]\n\npad = base10_to_base27(int(''.join(str(i) for i in column_sum(X, f))))\n\ndecrypted_text = \"\"\nfor i in range(N):\n    encrypted_val = ord(encrypted_text[i]) - ord('A')\n    pad_val = ord(pad[i]) - ord('A')\n    decrypted_val = (encrypted_val + pad_val) % 27\n    decrypted_text += chr(decrypted_val + ord('A') if decrypted_val < 26 else ord(' '))\n\nprint(decrypted_text)"
 ],
 "3405": [
  "from decimal import Decimal\n\nx = Decimal(input())\n\nfound = False\nfor i in range(1, 10000000):\n    prod = i * x\n    if prod == int(str(prod)[1:] + str(prod)[0]): # check if first digit moved to end equals x times i\n        print(i)\n        found = True\n\nif not found:\n    print(\"No solution\")"
 ],
 "3406": [
  "n = int(input())\nnazis = []\nfor i in range(n):\n    nazis.append(tuple(map(int, input().split())))\ns = int(input())\ncastles = []\nfor i in range(s):\n    castles.append(tuple(map(int, input().split())))\n\nans = 0\nfor i in range(s):\n    for j in range(i+1, s):\n        for k in range(j+1, s):\n            for l in range(k+1, s):\n                form_quadrilateral = True\n                for n in nazis:\n                    if ((n[0]-castles[i][0])*(castles[j][1]-castles[i][1])+(castles[j][0]-castles[i][0])*(castles[i][1]-n[1]))*((n[0]-castles[k][0])*(castles[l][1]-castles[k][1])+(castles[l][0]-castles[k][0])*(castles[k][1]-n[1])) < 0 or ((n[0]-castles[j][0])*(castles[k][1]-castles[j][1])+(castles[k][0]-castles[j][0])*(castles[j][1]-n[1]))*((n[0]-castles[l][0])*(castles[i][1]-castles[l][1])+(castles[i][0]-castles[l][0])*(castles[l][1]-n[1])) < 0:\n                        form_quadrilateral = False\n                        break\n                if form_quadrilateral:\n                    ans += 1\n\nprint(ans)"
 ],
 "3407": [
  "import math\n\ndef dfs(u,p):\n    global x,y,node\n    x[u] = math.cos(2 * math.pi * node / n)\n    y[u] = math.sin(2 * math.pi * node / n)\n    node += 1\n    for v in adj[u]:\n        if v != p:\n            dfs(v, u)\n            x[u] += x[v]\n            y[u] += y[v]\n    s = math.sqrt(x[u]**2 + y[u]**2)\n    x[u] /= s\n    y[u] /= s\n\nn = int(input())\nadj = [[] for _ in range(n)]\nfor _ in range(n-1):\n    a, b = map(int, input().split())\n    adj[a-1].append(b-1)\n    adj[b-1].append(a-1)\n\nx = [0] * n\ny = [0] * n\nnode = 1\ndfs(0,-1)\nfor i in range(n):\n    print(x[i]*1000, y[i]*1000)"
 ],
 "3408": [
  "class Node:\n    __slots__ = ['_data', '_is_end_word', '_left', '_equal', '_right']   \n \n    def __init__(self):\n        self._data = None\n        self._is_end_word = False\n        self._left = None\n        self._equal = None\n        self._right = None\n \nclass TernarySearchTree:\n    def __init__(self):\n        self._root = None\n   \n    def put(self, key, value):\n        self._root = self._put(key, value, self._root, 0)\n\n    def _put(self, key, value, node, idx):\n        c = key[idx]\n        \n        if node is None:\n            node = Node()\n            node._data = c\n        \n        if c < node._data:\n            node._left = self._put(key, value, node._left, idx)\n        elif c > node._data:\n            node._right = self._put(key, value, node._right, idx)\n        elif idx < len(key) - 1:\n            node._equal = self._put(key, value, node._equal, idx+1)\n        else:\n            node._is_end_word = True\n        \n        return node\n    \n    def get(self,key):\n        node = self._get(key, self._root, 0)\n        if node is None:\n            return None\n        \n        if node._is_end_word:\n            return node._data\n        else:\n            return None\n    \n    def _get(self, key, node, idx):\n        if node is None:\n            return None\n            \n        c = key[idx]\n        \n        if c < node._data:\n            return self._get(key, node._left, idx)\n        elif c > node._data:\n            return self._get(key, node._right, idx)\n        elif idx < len(key) - 1:\n            return self._get(key, node._equal, idx+1)\n        else:\n            return node\n \nclass WordPatterns:\n    def __init__(self, n, q):\n        self._n = n\n        self._q = q\n        self._words = []\n        self._ternary_search = TernarySearchTree() \n\n    def process(self):\n        for i in range(self._n):\n            self._ternary_search.put(self._readline().strip(), None)\n        for i in range(self._q):\n            wc = 0\n            wd = self._readline().strip()\n            wc = self._count_matches(\"\",wd,self._ternary_search._root)\n            self._writeln(str(wc))\n\n    def _count_matches(self,prefix,pattern, current_node):\n        if current_node is None:\n            return 0\n        c = pattern[0]\n        if c == '*':\n            if len(pattern) == 1:\n                wc = self._all_words_starting_with_prefix(prefix,current_node)\n            else:\n                wc = 0\n                wc = wc + self._count_matches(prefix, pattern[1:],current_node._left)\n                wc = wc + self._all_words_starting_with_prefix(prefix,current_node._equal)\n                wc = wc + self._count_matches(prefix,pattern[1:],current_node._right)\n                wc = wc + self._count_matches(prefix, pattern,current_node._equal)\n        else:\n            if current_node._data == c:\n                if len(pattern) == 1:\n                    if current_node._is_end_word:\n                        wc = 1\n                    else:\n                        wc = 0\n                else:\n                    wc = self._count_matches(prefix+c, pattern[1:],current_node._equal)\n            elif c < current_node._data:\n                wc = self._count_matches(prefix,pattern,current_node._left)\n            else:\n                wc = self._count_matches(prefix,pattern,current_node._right)\n\n        return wc\n    \n    def _all_words_starting_with_prefix(self, prefix, current_node):\n        if current_node is None:\n            return 0\n        count = 0\n        if current_node._is_end_word:\n            count = 1\n        count = count + self._all_words_starting_with_prefix(prefix,current_node._left)\n        count = count + self._all_words_starting_with_prefix(prefix,current_node._equal)\n        count = count + self._all_words_starting_with_prefix(prefix+current_node._data,current_node._equal)\n        count = count + self._all_words_starting_with_prefix(prefix,current_node._right)\n\n        return count\n\n    def _readline(self):\n        return input().strip()\n\n    def _writeln(self,text):\n        print(text)\n\nn, q = input().strip().split()\nwp = WordPatterns(int(n),int(q))\nwp.process()"
 ],
 "3409": [
  "r, c = map(int, input().split())\n\nstart = []\nfor _ in range(r):\n  start.append([1 if x == 'O' else -1 for x in input().strip()])\n\ntarget = []\nfor _ in range(r):\n  target.append([1 if x == 'O' else -1 for x in input().strip()])\n\ndef check_possible(start, target):\n  for i in range(r):\n    for j in range(c):\n      if target[i][j] != (1 if sum([start[x][j] for x in range(r)]) * sum([start[i][x] for x in range(c)]) == 1):\n        return 0\n  return 1\n\nprint(check_possible(start, target))"
 ],
 "3410": [
  "from itertools import combinations\nfrom math import fabs\nmod = 1000003\n\nn = int(input())\npoints = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    points.append((x, y))\n\nquads = []\nfor comb in combinations(points, 4):\n    a, b, c, d = comb\n    # check if points are not collinear (by checking slope of AB and BC)\n    if (b[1]-a[1])*(c[0]-b[0]) != (c[1]-b[1])*(b[0]-a[0]):\n        area = fabs((b[0]-a[0]) * (c[1]-b[1]) - (b[1]-a[1]) * (c[0]-b[0])) + fabs((c[0]-b[0]) * (d[1]-c[1]) - (c[1]-b[1]) * (d[0]-c[0]))\n        quad_score = int(area) % mod\n        quads.append((comb, quad_score))\n\n# sort list of quads by score in descending order\nquads.sort(key=lambda x: x[1], reverse=True)\n\n# play game\nplayer1_score = 0\nplayer2_score = 0\nused_quads = set()\n\nfor i in range(len(quads)):\n    if i % 2 == 0:\n        # player 1's turn\n        for j in range(len(quads)):\n            if quads[j][0] not in used_quads:\n                player1_score += quads[j][1]\n                used_quads.add(quads[j][0])\n                break\n    else:\n        # player 2's turn\n        for j in range(len(quads)):\n            if quads[j][0] not in used_quads:\n                player2_score += quads[j][1]\n                used_quads.add(quads[j][0])\n                break\n\nprint((player1_score + player2_score) % mod)"
 ],
 "3411": [
  "n, c, r = map(int, input().split())\narr = list(map(int, input().split()))\npos = [0]*n\nneg = [0]*n\nfor i in range(n):\n    if i%2 == 0:\n        if i>0:\n            pos[i] += pos[i-2]\n            neg[i] += neg[i-2]\n        if arr[i] > 0:\n            pos[i] += arr[i]\n        else:\n            neg[i] -= arr[i]\n    else:\n        pos[i] += pos[i-1]\n        neg[i] += neg[i-1]\n        if arr[i] > 0:\n            pos[i] += arr[i]\n        else:\n            neg[i] -= arr[i]\n\ntot_moves = min(n-pos[-1], n-neg[-1])\ntot_time = tot_moves*r\npos_moves = []\nneg_moves = []\nfor i in range(n):\n    needed_moves = abs(pos[i]-neg[i])+1\n    pos_moves.append((i+1, needed_moves-pos[i]%2))\n    neg_moves.append((i+1, needed_moves-neg[i]%2))\n    \npos_moves.sort(key=lambda x:x[1])\nneg_moves.sort(key=lambda x:x[1])\nrem_pos = pos_moves[0][1]\nrem_neg = neg_moves[0][1]\n\ntot_time += min(c*(rem_pos+rem_neg), min(c*rem_pos+r*(rem_neg%2)), min(c*rem_neg+r*(rem_pos%2)))\nprint(tot_time)"
 ],
 "3412": [
  "import math\n\nv_walk, v_bike = map(int, input().split())\nx1, y1, x2, y2 = map(int, input().split())\nx_g, y_g = map(int, input().split())\nx_d, y_d = map(int, input().split())\nn = int(input())\n\ndist_walk = math.sqrt((x_d - x_g) ** 2 + (y_d - y_g) ** 2) / v_walk\n\ndist_bike = math.inf\nfor i in range(n):\n    x_station, y_station = map(int, input().split())\n    if x_station < x1 or x_station > x2 or y_station < y1 or y_station > y2:\n        continue\n    dist_to_station = math.sqrt((x_station - x_g) ** 2 + (y_station - y_g) ** 2)\n    dist_from_station = math.sqrt((x_d - x_station) ** 2 + (y_d - y_station) ** 2)\n    total_dist = dist_to_station + dist_from_station\n    time = total_dist / v_bike\n    if time < dist_bike:\n        dist_bike = time\n\nprint(min(dist_walk, dist_bike))"
 ],
 "3413": [
  "from collections import deque\n\n# BFS function to find the minimum number of months required\ndef bfs(start):\n    q = deque()\n    q.append(start)\n    level = {start: 0}\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if v not in level:\n                level[v] = level[u] + 1\n                q.append(v)\n    return level\n\n# main function\nn, m = map(int, input().split())\nparties = list(map(int, input().split()))\ngraph = {i+1: [] for i in range(n)} # initialize empty adjacency list\nfor i in range(m):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\n# check if all are already part of the same party\nif parties.count(0) == n or parties.count(1) == n:\n    print(0)\nelse:\n    orange_start = parties.count(0) >= parties.count(1) # start with the majority party\n    orange_level = bfs([i+1 for i in range(n) if parties[i] == 0])\n    purple_level = bfs([i+1 for i in range(n) if parties[i] == 1])\n    max_level = 0 # find the maximum level reached by both BFS\n    for i in range(1, n+1):\n        if orange_start:\n            max_level = max(max_level, orange_level[i] + purple_level.get(i, -1))\n        else:\n            max_level = max(max_level, purple_level[i] + orange_level.get(i, -1))\n    print(max_level+1) # add 1 to get the number of months required"
 ],
 "3414": [
  "import math\n\n\ndef dfs(v):\n    vis[v] = True\n    for u in g[v]:\n        if not vis[u]:\n            dfs(u)\n    st.append(v)\n\n\ndef check(u, v):\n    dx1, dy1 = coords[u]\n    dx2, dy2 = coords[v]\n    theta1 = math.atan2(dy1 - bn[1], dx1 - bn[0])\n    theta2 = math.atan2(dy2 - bn[1], dx2 - bn[0])\n    angle = theta2 - theta1\n    if angle <= -math.pi:\n        angle += 2*math.pi\n    elif angle > math.pi:\n        angle -= 2*math.pi\n    return angle\n\n\nn, m = map(int, input().split())\ncoords = [tuple(map(int, input().split())) for _ in range(n)]\ng = [[] for _ in range(n)]\nindeg = [0]*n\nfor _ in range(m):\n    u, v = map(int, input().split())\n    g[u].append(v)\n    g[v].append(u)\n    indeg[u] += 1\n    indeg[v] += 1\n\nbn = min(coords)\nvis = [False]*n\nst = []\nfor i in range(n):\n    if not vis[i]:\n        dfs(i)\nst.reverse()\n\ncurrent = st[0]\nans = 0\nfor nxt in st[1:]:\n    angle = check(current, nxt)\n    ans += abs(angle)\n    current = nxt\n\nprint(ans)"
 ],
 "3415": [
  "n = int(input())\nnums = [i for i in range(1, 2 ** n)]\n\ndef fill_tree(tree, level, left, right):\n    if level == n - 1:\n        tree[left], tree[right] = nums.pop(0), nums.pop(0)\n    else:\n        mid = (left + right) // 2\n        fill_tree(tree, level + 1, left, mid)\n        fill_tree(tree, level + 1, mid, right)\n        tree[left] = sum(tree[left+1:right])\n        tree[right] = nums.pop(0)\n\ntree = [0] * (2 ** n - 1)\nfill_tree(tree, 0, 0, len(tree))\n\nprint(' '.join(map(str, tree)))"
 ],
 "3416": [
  "from queue import Queue, PriorityQueue\n\nn, m = map(int, input().split())\n\ngraph = [[] for _ in range(n+1)]\n\nfor _ in range(m):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n\ninq = [False] * (n+1)\ninDegree = [0] * (n+1)\n\nfor i in range(1, n+1):\n    for j in graph[i]:\n        inDegree[j] += 1\n\nqueue = Queue()\nstart = 0\nend = 0\nfor i in range(1, n+1):\n    if inDegree[i] == 0:\n        queue.put(i)\n        inq[i] = True\n        start += 1\n\nleafAirport = set()\n\nwhile not queue.empty():\n    u = queue.get()\n    if len(graph[u]) == 0:\n        leafAirport.add(u)\n    for v in graph[u]:\n        if inq[v]:\n            continue\n        inDegree[v] -= 1\n        if inDegree[v] == 0:\n            inq[v] = True\n            queue.put(v)\n\nprint(len(leafAirport))\nif len(leafAirport) > 0:\n    for u in range(1, n+1):\n        if u in leafAirport:\n            print(u, end=' ')\n    print()\nelse:\n    print()"
 ],
 "3417": [
  "n, m = map(int, input().split())\ngraph = [[] for _ in range(n + 1)]\nfor _ in range(m):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\ndp = [[0] * 1024 for _ in range(n + 1)]\n\ndef dfs(node, parent):\n    mask = 1 << node\n    for child in graph[node]:\n        if child == parent:\n            continue\n        dfs(child, node)\n        for i in range(1024):\n            if i & mask == 0:\n                dp[node][i | mask] += dp[child][i]\n        dp[node][mask] += 1\ndfs(1, 0)\nfor i in range(1023, -1, -1):\n    for j in range(n + 1):\n        if i & (1 << j):\n            continue\n        dp[j][i] += max(dp[j][i | (1 << j)], dp[j][i])\n        \nprint(dp[0][0])"
 ],
 "3418": [
  "from math import gcd\n\ndef f(num, digits):\n    for i in range(digits, 0, -1):\n        if num // 10**(i-1) % i:\n            return False\n    return True\n\ndef count_lucky_numbers(digits):\n    count = 0\n    for num in range(10**(digits-1), 10**digits):\n        if f(num, digits):\n            count += 1\n    return count\n\nn = int(input())\nsupply = count_lucky_numbers(n)\nprint(supply)"
 ],
 "3419": [
  "n, s1, s2 = map(int, input().split())\nt = list(map(int, input().split()))\nt.sort(reverse=True)\ncnt1 = 0\ncnt2 = 0\nfor i in range(n):\n    if cnt1 + t[i] <= s1:\n        cnt1 += t[i]\n    elif cnt2 + t[i] <= s2:\n        cnt2 += t[i]\n    else:\n        print(i)\n        break\nelse:\n    print(n)"
 ],
 "3420": [
  "from collections import defaultdict\n\n# reading input\nb, g = map(int, input().split())\nboys_books = defaultdict(set)\ngirls_books = defaultdict(set)\nfor i in range(b):\n    name, n = input().split()\n    n = int(n)\n    for j in input().split():\n        boys_books[name].add(j)\nfor i in range(g):\n    name, n = input().split()\n    n = int(n)\n    for j in input().split():\n        girls_books[name].add(j)\n\n# creating a set of all book titles read by the students\nall_books = set()\nfor books in boys_books.values():\n    all_books |= books\nfor books in girls_books.values():\n    all_books |= books\n    \n# calculating the number of presentations needed\npresentations = 0\nfor book in all_books:\n    boy_found = False\n    girl_found = False\n    for boy, books in boys_books.items():\n        if book in books:\n            boy_found = True\n            break\n    for girl, books in girls_books.items():\n        if book in books:\n            girl_found = True\n            break\n    if boy_found and girl_found:\n        presentations += 1\n        \n# printing the output\nprint(presentations)"
 ],
 "3421": [
  "k = int(input())\nresults = input().strip()\n\nmax_rate = 0\nstart = 0\n\nfor i in range(k-1, len(results)):\n    successes = results[i-k+1:i+1].count('1')\n    sequence_length = k\n    while successes/sequence_length > max_rate:\n        max_rate = successes/sequence_length\n        start = i - sequence_length + 2\n        sequence_length += 1\n\nprint(start, sequence_length-1)"
 ],
 "3422": [
  "n = int(input())\nmaps = []\nfor i in range(n):\n    w, h = map(int, input().split())\n    m = [list(input().strip()) for _ in range(h)]\n    maps.append((w, h, m))\n    \ndef rotate(m):\n    h, w = len(m), len(m[0])\n    r = [['' for _ in range(h)] for _ in range(w)]\n    for i in range(h):\n        for j in range(w):\n            r[w-j-1][i] = m[i][j]\n    return r\n\ngrid = {}\nfor w, h, m in maps:\n    for i in range(10-w+1):\n        for j in range(10-h+1):\n            valid = True\n            squares = []\n            for x in range(w):\n                for y in range(h):\n                    val = m[y][x]\n                    if (i+x, j+y) in grid and grid[(i+x, j+y)] != val:\n                        valid = False\n                        break\n                    squares.append((i+x, j+y))\n                if not valid:\n                    break\n            if valid:\n                for x, y in squares:\n                    grid[(x, y)] = m[y-j][x-i]\n                break\n        if valid:\n            break\n                \nres = [['' for _ in range(10)] for _ in range(10)]\nfor (x, y), val in grid.items():\n    res[9-y][x] = val\n\n# find the size of the grid\nw = max(len(row) - row.count('') for row in res)\nh = res.count([c for c in res[0] if c != ''])\n\n# output the full map\nprint(w, h)\nfor i in range(h):\n    print(''.join(res[i][:w]))\n    \n# output the index of each square\nprint('-' * w)\nfor i in range(h):\n    for j in range(w):\n        for idx, (pw, ph, pm) in enumerate(maps):\n            if res[h-i-1][j] == pm[i][j]:\n                print(idx+1, end='')\nprint()        "
 ],
 "3423": [
  "import sys\n\ndef topological_sort(graph):\n    result = []\n    # Count the incoming edges\n    in_degree = {u: 0 for u in graph}\n    for u in graph:\n        for v in graph[u]:\n            in_degree[v] += 1\n    # Initialize the queue with nodes that have no incoming edges\n    queue = [u for u in graph if in_degree[u] == 0]\n    # Perform topological sort\n    while queue:\n        u = queue.pop(0)\n        result.append(u)\n        for v in graph[u]:\n            in_degree[v] -= 1\n            if in_degree[v] == 0:\n                queue.append(v)\n    # Check for cycles\n    if len(result) != len(graph):\n        return None\n    else:\n        return result\n\n# Read input\nfor line in sys.stdin:\n    n = int(line.strip())\n    if n == 0:\n        break\n    packages = []\n    for i in range(n):\n        line = input().strip().split()\n        package = line[0]\n        dependencies = line[1:]\n        packages.append((package, dependencies))\n    # Build graph\n    graph = {p[0]: set() for p in packages}\n    for p in packages:\n        for d in p[1]:\n            graph[d].add(p[0])\n    # Perform topological sort\n    order = topological_sort(graph)\n    if order is None:\n        print(\"cannot be ordered\")\n    else:\n        for package in order:\n            print(package)\n    print()"
 ],
 "3424": [
  "y, ell = map(int, input().split())\nb = 10\nwhile True:\n    digits = []\n    temp_y = y\n    while temp_y > 0:\n        digit = temp_y % b\n        if digit > 9:\n            break\n        digits.append(digit)\n        temp_y //= b\n    if temp_y == 0 and int(''.join(map(str, reversed(digits)))) >= ell:\n        print(b)\n        break\n    b -= 1"
 ],
 "3425": [
  "n, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\n\n# count number of usable cells\nnum_usable = sum(row.count('.') for row in grid)\n\nmax_num_queens = min(num_usable, 3) # maximum number of queens that can be placed\nnum_ways = 0 # number of ways to place the maximum number of queens\n\nif max_num_queens == 1:\n    num_ways = num_usable # all usable cells can have a queen\n    \nelif max_num_queens == 2:\n    # count number of rows and columns that don't have broken cells\n    num_rows = sum('.' in row for row in grid)\n    num_cols = sum('.' in col for col in zip(*grid))\n    num_ways = num_rows*m + num_cols*n - 2*num_rows*num_cols # exclude repeated cells\n    \nelse: # max_num_queens == 3\n    # count number of rows and columns that have at least one usable cell\n    rows_with_usable = [row.count('.') > 0 for row in grid]\n    cols_with_usable = [col.count('.') > 0 for col in zip(*grid)]\n    num_rows = sum(rows_with_usable)\n    num_cols = sum(cols_with_usable)\n    \n    num_ways += num_rows*num_cols*(num_usable-1) # choose three usable cells with replacement\n    num_ways += num_rows*sum(rows_with_usable)*m # choose two cells from a row and one from another row\n    num_ways += num_cols*sum(cols_with_usable)*n # choose two cells from a column and one from another column\n    \n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                continue\n            for k in range(j+1, m):\n                if grid[i][k] == '#':\n                    continue\n                for l in range(i+1, n):\n                    if grid[l][j] == '#':\n                        continue\n                    if grid[l][k] == '#' or grid[i][l] == grid[l][k-i+j] == '#':\n                        continue\n                    num_ways += 1 # add one valid triple of queens\n\nprint(max_num_queens, num_ways)"
 ],
 "3426": [
  "import heapq\nn, m = map(int, input().split())\ngraph = [[] for _ in range(n)]\ncables = []\nfor i in range(m):\n    a, b, l, c = input().split()\n    a, b, l, c = int(a) - 1, int(b) - 1, int(l) if l != '?' else None, int(c)\n    graph[a].append((b, l))\n    graph[b].append((a, l))\n    if c == 1:\n        cables.append((a, b))\n\ndist = [float('inf') for _ in range(n)]\ndist[0] = 0\nvisited = [False for _ in range(n)]\nvisited[0] = True\npq = [(0, 0)]\nwhile pq:\n    d, u = heapq.heappop(pq)\n    if dist[u] < d:\n        continue\n    for v, l in graph[u]:\n        if l is not None:\n            alt = dist[u] + l\n            if alt < dist[v]:\n                dist[v] = alt\n                heapq.heappush(pq, (alt, v))\n    for a, b in cables:\n        if a == u and not visited[b]:\n            visited[b] = True\n            heapq.heappush(pq, (dist[u], b))\n        elif b == u and not visited[a]:\n            visited[a] = True\n            heapq.heappush(pq, (dist[u], a))\n\nfor a, b, l, c in (line.split() for line in input().split('\\n')[:-1]):\n    a, b, l, c = int(a) - 1, int(b) - 1, int(l) if l != '?' else None, int(c)\n    if l is None:\n        if dist[a] < dist[b]:\n            a, b = b, a\n        print(dist[a] + int(c) * dist[b] + int(c) - dist[b])"
 ],
 "3427": [
  "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(100000)\n\ndef dfs(u, par):\n    global col\n    global sze\n    sze[u] = 1\n    for v in adj[u]:\n        if v == par or col[v] != -1:\n            continue\n        dfs(v, u)\n        sze[u] += sze[v]\ndef dfs_centroid(u, par, sz, mx):\n    global col\n    global sze\n    for v in adj[u]:\n        if v == par or col[v] != -1:\n            continue\n        dfs_centroid(v, u, sz, mx)\n    if max(sz - sze[u], mx) <= sz//2:\n        mx = max(mx, sz - sze[u])\n        centroid[0] = u\n        centroid[1] = mx\nn, m = map(int, input().split())\nadj = defaultdict(list)\nfor i in range(m):\n    u, v = map(int, input().split())\n    adj[u].append(v)\n    adj[v].append(u)\ncol = [-1]*n\nsze = [-1]*n\ncentroid = [-1]*2\ndfs(0, -1)\ndfs_centroid(0, -1, n, 0)\nq = [centroid[0]]\ncol[centroid[0]] = 0\nwhile q:\n    u = q.pop()\n    for v in adj[u]:\n        if col[v] == -1:\n            col[v] = col[u]+1\n            q.append(v)\nprint(centroid[1])"
 ],
 "3428": [
  "from math import gcd\nn = int(input())\na = list(map(int, input().split()))\ns = set()\nfor i in range(n):\n    g = 0\n    for j in range(i, n):\n        g = gcd(g, a[j])\n        s.add(g)\nprint(len(s))"
 ],
 "3429": [
  "import math \n \nx_s, y_s, s_s, r_i, r_f = map(int, input().split())\nx_a, y_a, s_a = map(int, input().split())\n \ndis = math.sqrt((x_a - x_s)**2 + (y_a - y_s)**2) - r_f\n \nif dis >= 0:\n    print(0.000000)\nelse:\n    time_at_r_f = max((dis + r_i)/s_s, 0) \n    time_to_reach_r_f = math.sqrt((x_a - x_s)**2 + (y_a - y_s)**2 - (r_i - r_f)**2) / s_a\n    total_time = time_at_r_f + time_to_reach_r_f\n \n    print(\"{:.6f}\".format(min(total_time * dis, 0 - dis)))"
 ],
 "3430": [
  "import sys\n\nn = int(input())\nadj_a = [[] for _ in range(n + 1)]\nfor i in range(n - 1):\n    u, v = map(int, input().split())\n    adj_a[u].append(v)\n    adj_a[v].append(u)\n\nm = int(input())\nadj_b = [[] for _ in range(m + 1)]\nfor i in range(m - 1):\n    u, v = map(int, input().split())\n    adj_b[u].append(v)\n    adj_b[v].append(u)\n\n# precompute depth and subtree size for each node in tree A\ndepth_a = [-1] * (n + 1)\nsize_a = [0] * (n + 1)\nstack = [1]  # start with root (node 1)\nwhile stack:\n    node = stack.pop()\n    size_a[node] = 1\n    for neighbor in adj_a[node]:\n        if depth_a[neighbor] == -1:\n            depth_a[neighbor] = depth_a[node] + 1\n            stack.append(neighbor)\n    size_a[parent] += size_a[neighbor]\n\n# precompute depth and subtree size for each node in tree B\ndepth_b = [-1] * (m + 1)\nsize_b = [0] * (m + 1)\nstack = [1]  # start with root (node 1)\nwhile stack:\n    node = stack.pop()\n    size_b[node] = 1\n    for neighbor in adj_b[node]:\n        if depth_b[neighbor] == -1:\n            depth_b[neighbor] = depth_b[node] + 1\n            stack.append(neighbor)\n    size_b[parent] += size_b[neighbor]\n\n# calculate cost of connecting each pair of nodes in A and B\ncost = 0\nfor node_a in range(1, n + 1):\n    for node_b in range(1, m + 1):\n        cost += depth_a[node_a] * size_b[node_b] + depth_b[node_b] * size_a[node_a] + (depth_a[node_a] + depth_b[node_b]) ** 2\n\n# find the minimum cost by connecting one node from A and one node from B\nmin_cost = sys.maxsize\nfor node_a in range(1, n + 1):\n    for node_b in range(1, m + 1):\n        new_cost = cost - depth_a[node_a] * size_b[1] - depth_b[1] * size_a[node_a] - (depth_a[node_a] + depth_b[1]) ** 2\n        new_cost += depth_a[node_a] * size_b[node_b] + depth_b[node_b] * size_a[node_a] + (depth_a[node_a] + depth_b[node_b]) ** 2\n        min_cost = min(min_cost, new_cost)\n\nprint(min_cost)"
 ],
 "3431": [
  "from heapq import heappush,heappop\ndef dist(x1,y1,x2,y2):\n    return abs(x1-x2)+abs(y1-y2)\nn=int(input())\np=[tuple(map(int,input().split())) for i in range(n)]\ng=[[] for i in range(n)]\nfor i in range(n):\n    for j in range(i+1,n):\n        d=dist(*p[i],*p[j])\n        g[i].append((j,d))\n        g[j].append((i,d))\nvis=[False]*n\nq=[(0,0)]\ntot=0\nwhile q:\n    d,x=heappop(q)\n    if vis[x]:continue\n    vis[x]=True\n    tot+=d\n    for y,d in g[x]:\n        if not vis[y]:\n            heappush(q,(d,y))\nprint(tot)"
 ],
 "3432": [
  "import sys\n\nn = int(sys.stdin.readline())\n\nfor _ in range(n):\n    a, b = map(int, sys.stdin.readline().split())\n    print(max(a, b)) "
 ],
 "3433": [
  "from collections import deque\n\nR, C = map(int, input().split())\nmaze = []\nvisited_fires = set()\ndirections = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\nfor i in range(R):\n    row = list(input().strip())\n    maze.append(row)\n    for j in range(C):\n        if row[j] == \"J\":\n            start = (i, j)\n        elif row[j] == \"F\":\n            visited_fires.add((i, j))\n\nq_fires = deque()\nfor fire in visited_fires:\n    q_fires.append(fire)\n\nq_joe = deque()\nq_joe.append(start)\ncnt = 0\n\nvisit_joe = set()\nvisit_joe.add(start)\n\nwhile q_joe:  \n    cnt += 1  \n    for _ in range(len(q_fires)):        \n        curr_fire = q_fires.popleft()\n        for direction in directions:\n            next_fire = tuple(map(sum, zip(curr_fire, direction)))\n            if 0 <= next_fire[0] < R and 0 <= next_fire[1] < C:\n                if maze[next_fire[0]][next_fire[1]] == \".\":\n                    maze[next_fire[0]][next_fire[1]] = \"F\"\n                    visited_fires.add(next_fire)\n                    q_fires.append(next_fire)\n    for _ in range(len(q_joe)):  \n        curr_joe = q_joe.popleft()\n        for direction in directions:\n            next_joe = tuple(map(sum, zip(curr_joe, direction)))\n            if 0 <= next_joe[0] < R and 0 <= next_joe[1] < C:\n                if maze[next_joe[0]][next_joe[1]] == \".\" and next_joe not in visit_joe:\n                    visit_joe.add(next_joe)\n                    q_joe.append(next_joe)\n            else:\n                print(cnt) \n                exit() \n    for fire in visited_fires:\n        if fire in visit_joe:\n            print(\"IMPOSSIBLE\")\n            exit()\nprint(\"IMPOSSIBLE\")"
 ],
 "3434": [
  "from math import comb\nfrom functools import lru_cache\n\nn, m, d = map(int, input().split())\nmy_healths = list(map(int, input().split()))\nopponent_healths = list(map(int, input().split()))\n\n@lru_cache(None)\ndef prob(my_healths, opponent_healths, left_damage):\n    if not opponent_healths:\n        return 1.0\n    if not left_damage or not my_healths:\n        return 0.0\n    total_prob = 0.0\n    total_health = sum(my_healths) + sum(opponent_healths)\n    for i in range(n):\n        if my_healths[i] > 0:\n            new_my_healths = list(my_healths)\n            new_my_healths[i] -= 1\n            total_prob += (my_healths[i] / total_health) * prob(tuple(new_my_healths), opponent_healths, left_damage - 1)\n    for i in range(m):\n        if opponent_healths[i] > 0:\n            new_opponent_healths = list(opponent_healths)\n            new_opponent_healths[i] -= 1\n            total_prob += (opponent_healths[i] / total_health) * prob(my_healths, tuple(new_opponent_healths), left_damage - 1)\n    return total_prob\n\nresult = prob(tuple(my_healths), tuple(opponent_healths), d)\nprint('{:.10f}'.format(result))"
 ],
 "3435": [
  "n = int(input())\np = input()\nans = 1\ncnt = p.count('*')\nif cnt == 0:\n    ans = 2 ** n\nelif cnt == 1:\n    if p[0] == '*' or p[-1] == '*':\n        ans = 2 ** (n - 1)\n    else:\n        ans = 2 ** n - 2 ** (n - p.index('*') - 1) - 2 ** (n - p[::-1].index('*') - 1) \nelse:\n    ans = 2 ** (n - cnt)\nprint(ans)"
 ],
 "3436": [
  "MOD = 10**9 + 7\n\ndef main():\n    x, y = map(int, input().split())\n    f_xy, f_x, f_y = 0, 1, 1  # Initialize f_xy, f_{i,0}, f_{0,j}\n\n    # Use the iterative formula to calculate f_{i,j}\n    for i in range(1, x+1):\n        f_x = (f_x + f_xy) % MOD\n        f_xy = f_x\n    \n    for j in range(1, y+1):\n        f_y = (f_y + f_xy) % MOD\n        f_xy = f_y\n    \n    print(f_xy)\n\nif __name__ == '__main__':\n    main()"
 ],
 "3437": [
  "from itertools import combinations\n\nL1, L2, N = map(int, input().split())\ntubes = sorted(int(input()) for _ in range(N))\n\nmax_length = 0\nfor t1, t2, t3, t4 in combinations(tubes, 4):\n    if t1 + t2 <= L1 and t3 + t4 <= L2:\n        max_length = max(max_length, t1 + t2 + t3 + t4)\n\nprint(max_length if max_length else \"Impossible\")"
 ],
 "3438": [
  "from collections import defaultdict\ncache_size, num_objects, num_accesses = map(int, input().split())\naccesses = [int(input()) for _ in range(num_accesses)]\nfreq = defaultdict(int)\ncache = []\n\ndef find_obj_to_evict(accesses, cache):\n    '''Find the object in the cache that will \n    be accessed the farthest in the future.'''\n    farthest_access = -1\n    obj_to_evict = None\n    for obj in cache:\n        try:\n            next_access = accesses.index(obj)\n        except ValueError:\n            return obj\n        if next_access > farthest_access:\n            farthest_access = next_access\n            obj_to_evict = obj\n    return obj_to_evict\n\nfor obj in accesses:\n    # object is already in cache\n    if obj in cache:\n        freq[obj] += 1\n        continue\n    # cache is not full\n    if len(cache) < cache_size:\n        cache.append(obj)\n        freq[obj] += 1\n    # evict object to make room\n    else:\n        obj_to_evict = find_obj_to_evict(accesses, cache)\n        cache.remove(obj_to_evict)\n        freq[obj_to_evict] += 1\n        cache.append(obj)\n        freq[obj] += 1\n\nprint(sum(freq.values()))"
 ],
 "3439": [
  "h, w = map(int, input().split())\ngrid = []\nfor _ in range(h):\n    grid.append(list(map(int, input().split())))\ni, j = map(int, input().split())\n\ntotal_water = 0\n\ndef dfs(x, y, max_height):\n    if grid[x][y] >= 0:\n        return\n    if visited[x][y]:\n        return\n    visited[x][y] = True\n    max_height = min(max_height, grid[x][y])\n    if x == 0 or x == h-1 or y == 0 or y == w-1:\n        perimeter_waters.append(max_height)\n    dfs(x+1, y, max_height)\n    dfs(x, y+1, max_height)\n    dfs(x-1, y, max_height)\n    dfs(x, y-1, max_height)\n    dfs(x+1, y+1, max_height)\n    dfs(x-1, y+1, max_height)\n    dfs(x+1, y-1, max_height)\n    dfs(x-1, y-1, max_height)\n    \nvisited = [[False]*w for _ in range(h)]\nperimeter_waters = []\ndfs(i-1, j-1, float('inf'))\n\nfor x in range(h):\n    for y in range(w):\n        if visited[x][y]:\n            if grid[x][y] < perimeter_waters[0]:\n                total_water += (perimeter_waters[0] - grid[x][y])\n\nprint(total_water)"
 ],
 "3440": [
  "INF = float(\"inf\")\nn, r = map(int, input().split())\ndp = [[INF] * n for _ in range(1 << n)]\nfor i in range(n):\n    dp[1 << i][i] = 0\nfor _ in range(r):\n    a, b, c = map(int, input().split())\n    a -= 1\n    b -= 1\n    dp[(1 << a) | (1 << b)][a] = dp[(1 << a) | (1 << b)][b] = c\nfor i in range(1 << n):\n    for j in range(n):\n        if not i & (1 << j):\n            continue\n        for k in range(n):\n            if i & (1 << k):\n                continue\n            dp[i | (1 << k)][k] = min(dp[i | (1 << k)][k], dp[i][j] + dp[(1 << k) | (1 << j)][k])\nadditional_flights = int(input())\nfor _ in range(additional_flights):\n    a, b, c = map(int, input().split())\n    a -= 1\n    b -= 1\n    for i in range(1 << n):\n        dp[i | (1 << a) | (1 << b)][a] = min(dp[i | (1 << a) | (1 << b)][a], dp[i][b] + c)\n        dp[i | (1 << a) | (1 << b)][b] = min(dp[i | (1 << a) | (1 << b)][b], dp[i][a] + c)\nprint(dp[(1 << n) - 1][0])"
 ],
 "3441": [
  "import sys\n\nn, m = map(int, input().split())\ngraph = [[] for _ in range(n)]\n\nfor _ in range(m):\n    x, y = map(int, input().split())\n    graph[x].append(y)\n\n# Check if graph is strongly connected\nstack = [0]\nvisited = set()\nwhile stack:\n    v = stack.pop()\n    if v in visited:\n        continue\n    visited.add(v)\n    for neighbor in graph[v]:\n        stack.append(neighbor)\n\nif len(visited) != n:\n    print(0)\n    sys.exit()\n\n# Find strongly connected components\ncomponents = []\nstack = []\nvisited = set()\n\nfor i in range(n):\n    if i not in visited:\n        stack.append(i)\n        curr_component = []\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            curr_component.append(v)\n            visited.add(v)\n            for neighbor in graph[v]:\n                stack.append(neighbor)\n        components.append(curr_component)\n\n# Count the number of components with more than one node\nmulti_node_components = 0\nfor component in components:\n    if len(component) > 1:\n        multi_node_components += 1\n\n# Output the number of unused one-way roads\nprint(max(0, multi_node_components - 1))"
 ],
 "3442": [
  "def is_sheldon(n):\n    binary = bin(n)[2:]\n    if len(binary) % 2 == 0:\n        return False\n    a = binary[0]\n    b = '0' if a == '1' else '1'\n    n_count = binary.count(a)\n    m_count = binary.count(b)\n    if n_count <= 0 or m_count <= 0:\n        return False\n    if binary[-1] == a:\n        pattern = a + (n_count * '1') + (m_count * '0')\n    else:\n        pattern = a + (n_count * '1') + (m_count * '0') + a\n    return binary == pattern\n\nx, y = map(int, input().split())\ncount = 0\nfor i in range(x, y+1):\n    if is_sheldon(i):\n        count += 1\nprint(count)"
 ],
 "3443": [
  "import numpy as np\n\ndef find_line_symmetry_point(x1, y1, x2, y2):\n    # Find the midpoint of the given line\n    mid_x = (x1 + x2) / 2\n    mid_y = (y1 + y2) / 2\n    \n    # Find the slope of the line\n    if x2 - x1 == 0:\n        slope = np.inf\n    else:\n        slope = (y2 - y1) / (x2 - x1)\n    \n    # Find the y intercept of the line\n    if slope == np.inf:\n        y_intercept = mid_x\n    else:\n        y_intercept = mid_y - slope * mid_x\n    \n    return (y_intercept, slope)\n\ndef count_additional_spots(points):\n    num_points = len(points)\n    min_additional_spots = num_points\n    \n    for i in range(num_points):\n        # Find symmetry around point i\n        x_i, y_i = points[i]\n        count_i = 0\n        for j in range(num_points):\n            x_j, y_j = points[j]\n            if (x_i, y_i) != (x_j, y_j):\n                x_diff = x_i - x_j\n                y_diff = y_i - y_j\n                if (x_i + x_diff, y_i + y_diff) in points:\n                    count_i += 1\n                    \n        min_additional_spots = min(min_additional_spots, num_points - count_i)\n        \n        for j in range(i + 1, num_points):\n            # Find symmetry around line ij\n            x_j, y_j = points[j]\n            y_intercept, slope = find_line_symmetry_point(x_i, y_i, x_j, y_j)\n            count_ij = 0\n            for k in range(num_points):\n                x_k, y_k = points[k]\n                if (x_k, y_k) != (x_i, y_i) and (x_k, y_k) != (x_j, y_j):\n                    if slope == np.inf:\n                        x_sym = y_intercept\n                        y_sym = y_k\n                    else:\n                        x_sym = (y_k - y_intercept) / slope\n                        y_sym = slope * x_sym + y_intercept\n                    if (x_sym, y_sym) in points:\n                        count_ij += 1\n                        \n            min_additional_spots = min(min_additional_spots, num_points - count_ij)\n            \n    return min_additional_spots\n\nn = int(input())\npoints = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    points.append((x, y))\n    \nprint(count_additional_spots(points))"
 ],
 "3444": [
  "n, m = map(int, input().split())\npistes = []\nfor _ in range(m):\n  a, b, w = map(float, input().split())\n  pistes.append((a, b, w))\n\nprobabilities = [0.0] * n\nprobabilities[0] = 1.0\nfor k in range(1, n):\n  new_probabilities = [0.0] * n\n  new_probabilities[0] = probabilities[0]\n  for a, b, w in pistes:\n    new_probabilities[b] = max(new_probabilities[b], probabilities[a] * (1 - w) + new_probabilities[a] * w)\n  probabilities = new_probabilities\n  if probabilities[n-1] > 0:\n    print(\"{:.9f}\".format(probabilities[n-1]), end=\" \")\n  else:\n    print(\"-1\", end=\" \")"
 ],
 "3445": [
  "n = int(input().strip())\nx_coords,y_coords = [],[]\nfor i in range(n):\n    x,y = map(int,input().split())\n    x_coords.append(x)\n    y_coords.append(y)\nx_coords.sort()\ny_coords.sort()\n# Case 1: Divide the customers into two sets with the same x-coordinates and minimize the maximum distance in the y-direction in each set\nmin_max_y = float(\"inf\")\nfor i in range(n//2):\n    min_max_y = min(min_max_y,y_coords[-i-1]-y_coords[i])\n# Case 2: Divide the customers into two sets with the same y-coordinates and minimize the maximum distance in the x-direction in each set\nmin_max_x = float(\"inf\")\nfor i in range(n//2):\n    min_max_x = min(min_max_x,x_coords[-i-1]-x_coords[i])\n# Output the maximum of the two minimum values\nprint(max(min_max_x,min_max_y))"
 ],
 "3446": [
  "from itertools import permutations\n\nk = int(input())\nsymbols = input().split()\n\nassembly_table = []\nfor _ in range(k):\n    row = input().split()\n    assembly_table.append([(int(time[:-2]), result) for time, result in zip(row[::2], symbols)])\n\nn = int(input())\nfor _ in range(n):\n    sequence = input().strip()\n    memo = {}\n\n    def dp(i, j):\n        if i == j:\n            return [(0, sequence[i])]\n        if (i, j) in memo:\n            return memo[(i, j)]\n        min_time = float('inf')\n        min_result = ''\n        for idx in range(i, j):\n            left = dp(i, idx)\n            right = dp(idx+1, j)\n            for pair in permutations(left+right, 2):\n                for time, row in assembly_table:\n                    if row.count(pair[0][1]) and row.count(pair[1][1]):\n                        temp_time = time[row.index(pair[0][1])][0] + time[row.index(pair[1][1])][0] + pair[0][0] + pair[1][0]\n                        temp_result = row[-1]\n                        if temp_time < min_time:\n                            min_time = temp_time\n                            min_result = temp_result\n                        elif temp_time == min_time and temp_result < min_result:\n                            min_result = temp_result\n        memo[(i, j)] = [(min_time, min_result)]\n        return memo[(i, j)]\n\n    print(dp(0, len(sequence) - 1)[0][0], dp(0, len(sequence) - 1)[0][1], sep='-')"
 ],
 "3447": [
  "from collections import defaultdict\n\n# Input\nn = int(input())\ndictionary = [input().strip() for _ in range(n)]\n# Convert dictionary words to sequences of digits\nword_to_digit = defaultdict(list)\nfor word in dictionary:\n    digits = \"\".join(str(2 + (ord(c) - ord('a')) // 3) for c in word)\n    word_to_digit[digits].append(word)\nq = int(input())\nto_type = [input().strip() for _ in range(q)]\n\n# Helper function for finding the closest index in a sorted list\ndef closest_index(lst, target):\n    lo, hi = 0, len(lst) - 1\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        if lst[mid] >= target:\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return lo\n\n# Helper function for finding the optimal keypress solution\ndef optimal_keypress(digits):\n    # Find the possible words in the dictionary\n    possible_words = word_to_digit.get(digits, [])\n    # Find the closest possible word to the given prefix\n    prefix = \"\"\n    i = 0\n    while i < len(digits):\n        prefix += digits[i]\n        matches = word_to_digit.get(prefix, [])\n        if not matches:\n            matches = possible_words\n        if len(matches) == 1:\n            break\n        j = closest_index(matches, possible_words[0])\n        if j == 0:\n            prefix = matches[0]\n            break\n        if j >= len(matches):\n            prefix = matches[-1]\n            break\n        left_dist = abs(ord(prefix[-1]) - ord(matches[j-1][-1]))\n        right_dist = abs(ord(prefix[-1]) - ord(matches[j][-1]))\n        if right_dist < left_dist:\n            prefix = matches[j]\n            break\n        i += 1\n    # Type out the word using minimal keypresses\n    result = \"\"\n    for c in prefix:\n        digit = str(2 + (ord(c) - ord('a')) // 3)\n        result += digit\n    if prefix in possible_words:\n        return result\n    for word in possible_words:\n        if word.startswith(prefix):\n            suffix = word[len(prefix):]\n            for c in suffix:\n                digit = str(2 + (ord(c) - ord('a')) // 3)\n                result += digit\n                result += \"R\"\n            return result[:-1] # Remove the last \"R\"\n    raise ValueError(\"Invalid input\")\n\n# Output the optimal keypress solutions for each query\nfor word in to_type:\n    digits = \"\".join(str(2 + (ord(c) - ord('a')) // 3) for c in word)\n    print(optimal_keypress(digits))"
 ],
 "3448": [
  "n, k = map(int, input().split())\nif k == 1:\n    if n < 3: \n        print(\"NO\")\n    else:\n        print(\"YES\")\n        print(\"1 2\")\n        print(\"1 3\")\nelse:\n    if n < 4 or k == 2:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        m_cable_cars = [(1, i+2) for i in range(k)]\n        v_cable_cars = [(2, i+3) for i in range(k)]\n        for i in range(k):\n            print(m_cable_cars[i][0], m_cable_cars[i][1])\n            print(v_cable_cars[i][0], v_cable_cars[i][1])"
 ],
 "3449": [
  "import itertools\n\nB = int(input())\nH = int(input())\nR, C = map(int, input().split())\nlights = [list(map(int, input())) for _ in range(R)]\n\ntotal_cost = 0\n\n# build edges first\nedges = []\nfor r in range(R):\n    for c in range(C):\n        if r == R - 1 and c == C - 1:  # don't build the last row and column\n            break\n        if r == R - 1:\n            edges.append(((r, c), (r, c + 1)))\n        elif c == C - 1:\n            edges.append(((r, c), (r + 1, c)))\n        else:\n            edges.extend([((r, c), (r, c + 1)), ((r, c), (r + 1, c))])\n\nfor edge in edges:\n    a, b = edge\n    ax, ay = a\n    bx, by = b\n    distance = ((ax - bx)**2 + (ay - by)**2 + H**2)**0.5\n    if sum(lights[ax][ay] / (distance**2 - i**2) for i in range(int(distance))) >= B and \\\n            sum(lights[bx][by] / (distance**2 - i**2) for i in range(int(distance))) >= B:\n        total_cost += 43\n    else:\n        total_cost += 11\n\nprint(total_cost)"
 ],
 "3450": [
  "from math import factorial\n\nn = int(input())\nfact = factorial(n)\n\nwhile fact % 1000 == 0:\n    fact = fact // 1000\n    \nprint(fact % 1000)"
 ],
 "3451": [
  "import sys\nfrom heapq import heappush, heappop\n\nINF = 10 ** 18  # A large enough number\n\nn, k = map(int, input().split())\ns = input().strip()\nc = [int(input()) for _ in range(n)]\n\nl, r, z = -1, n, -1\nst = []\nfor i in range(n):\n    if s[i] == '(':\n        st.append(i)\n    else:\n        if not st:\n            z = i\n        else:\n            st.pop()\n\n    if z >= 0 and k > 0:\n        if not st:\n            k -= 1\n            l, z = z, -1\n            continue\n\n        j = st.pop()\n        if k >= 2:\n            length = i - j + 1\n            if length <= 4:\n                c[j] += c[z]\n                c[z] = 0\n                k -= 2\n            else:\n                heappush(heap, (c[z] - c[j], j, z))\n        st.append(i)\n        z = -1\n\nif st:\n    ans = '?'\nelse:\n    heap = []\n    heappush(heap, (0, l, r))\n    ans = INF\n\n    while heap:\n        d, i, j = heappop(heap)\n        if i > j:\n            continue\n        k -= 1\n\n        if k < 0:\n            ans = min(ans, -d)\n            break\n\n        m = (i + j) // 2\n        heappush(heap, (d, i, m))\n        heappush(heap, (d, m + 1, j))\n\n        d += 2 * sum(c[m + 1:j]) - 2 * sum(c[i:m + 1])\n        ans = min(ans, -d)\n\nprint(ans)"
 ],
 "3452": [
  "from collections import deque\n\nn = int(input())\nrooms = [[] for i in range(n)]\n\nfor i in range(n):\n    temp = list(map(int, input().split()))\n    rooms[i] = temp[1:]\n\ndef bfs(u): \n    visited.add(u)\n    q = deque([u])\n    \n    while(q):\n        u = q.popleft()\n        component.add(u)\n        for v in rooms[u]:\n            if (v not in visited):\n                visited.add(v)\n                q.append(v)\n\nvisited = set()\nidentical_sets = []\nfor i in range(n):\n    if(i not in visited):\n        component = set()\n        bfs(i)\n        distinct_rooms = [len(set(rooms[j])) for j in component]\n        if len(set(distinct_rooms)) == 1:\n            identical_sets.append(component)\n\nif(len(identical_sets) == 0):\n    print(\"none\")\nelse:\n    identical_sets = sorted(identical_sets)\n    for i in identical_sets:\n        if(len(i) != 1):\n            print(*list(i))"
 ],
 "3453": [
  "mod = 10**9 + 7\n\nn, m = map(int, input().split())\n\ntot = [0] * n\nsub = [0] * n\nsz = [1] * n\nfor i in range(m):\n    u, v, w = map(int, input().split())\n    u, v = u - 1, v - 1\n    tot[u] += w\n    tot[v] += w\n    sub[u] += w\n    cur = (pow(2, sz[v], mod) - 1) * w % mod\n    sub[u] += cur\n    tot[u] += cur\n    sub[v] += w\n    cur = (pow(2, sz[u], mod) - 1) * w % mod\n    sub[v] += cur\n    tot[v] += cur\n    sz[u] += sz[v]\n    sz[v] = sz[u]\n\nans = [0] * n\nfor i in range(n):\n    ans[i] = (tot[i] - sub[i]) % mod\nprint(*ans)"
 ],
 "3454": [
  "MOD = 100003\n\nn, m = map(int, input().split())\nc = list(map(int, input().split()))\n\ndp = [[0] * (m+1) for i in range(n+1)]\ndp[0][0] = 1\n\nfor i in range(1, n+1):\n    for j in range(m+1):\n        if(j <= c[n-i]):\n            for k in range(m - (c[n-i] - j) + 1):\n                dp[i][j] += dp[i - 1][k]\n                dp[i][j] %= MOD\n\nans = dp[n][0] - 1\nfor i in range(1, m+1):\n    ans *= i\n    ans %= MOD\n\nans = [0, ans]\nwhile ans[1]:\n    ans[0] += ans[1] % 10\n    ans[1] //= 10\n\nprint(0, ans[0])"
 ],
 "3455": [
  "import heapq\n\nN, M, R = map(int, input().split())\n\ngraph = [[] for _ in range(N)]\nfor i in range(M):\n    lane, length, pos = map(int, input().split())\n    graph[lane].append((pos, length))\n\ndestination = N - 1\ndef dijkstra():\n    # min heap stores tuples of distance, lane, position\n    heap = [(0, 0, 0)]\n    # memoization stores the minimum distance to get to a lane, position\n    memo = {(0, 0): 0}\n    \n    while heap:\n        dist, lane, pos = heapq.heappop(heap)\n        if lane == destination:\n            return dist\n        \n        # move forward in the same lane\n        if pos + R >= memo.get((lane, pos), float(\"inf\")):\n            memo[(lane, pos)] = pos\n            for p2, l2 in graph[lane]:\n                d = max(0, p2 - pos - l2) # distance to closest car\n                heapq.heappush(heap, (dist + d, lane, p2 + l2))\n        \n        # switch to a neighboring lane\n        if lane < N - 1 and pos + R >= memo.get((lane + 1, pos), float(\"inf\")):\n            next_lane = lane + 1\n            memo[(next_lane, pos)] = pos\n            for p2, l2 in graph[next_lane]:\n                if pos - p2 - l2 - R >= 0: # destination has unoccupied space\n                    d = max(0, p2 - pos - l2) # distance to closest car\n                    heapq.heappush(heap, (dist + d, next_lane, p2 + l2))\n        \n        if lane > 0 and pos + R >= memo.get((lane - 1, pos), float(\"inf\")):\n            next_lane = lane - 1\n            memo[(next_lane, pos)] = pos\n            for p2, l2 in graph[next_lane]:\n                if pos - p2 - l2 - R >= 0: # destination has unoccupied space\n                    d = max(0, p2 - pos - l2) # distance to closest car\n                    heapq.heappush(heap, (dist + d, next_lane, p2 + l2))\n                    \n    return \"Impossible\"\n\nprint(\"{:.6f}\".format(dijkstra()))"
 ],
 "3456": [
  "n = int(input())\nstacks = list(map(int, input().split()))\n\ntotal_sum = sum(stacks)\ntarget = total_sum // n\n\nmoves = 0\ncurrent_sum = 0\nfor height in stacks:\n    current_sum += height\n    if current_sum != target * (moves + 1):\n        moves += 1\n\nprint(moves)"
 ],
 "3457": [
  "MOD = 10**9 + 7\n\nn, x, y = map(int, input().split())\n\n# Define a function to calculate the binomial coefficient.\ndef binom(n, k):\n    if k > n or k < 0:\n        return 0\n    res = 1\n    for i in range(k):\n        res *= (n - i)\n        res *= pow(i + 1, MOD - 2, MOD) # Mod inverse using Fermat's little theorem\n        res %= MOD\n    return res\n\n# Calculate the number of paths satisfying the given conditions.\nans = binom(n + x, n) - binom(n, n - y - 1)\nans %= MOD\n\nprint(ans)"
 ],
 "3458": [
  "n = int(input())\nnums = list(map(int, input().split()))\n\nmax_xor = 0\nprefix_set = set()\nprefix = 0\n\nfor num in nums:\n    prefix ^= num\n    max_xor = max(max_xor, prefix)\n    for prefix2 in prefix_set:\n        max_xor = max(max_xor, prefix2 ^ prefix)\n    prefix_set.add(prefix)\n\nprint(max_xor)"
 ],
 "3459": [
  "from collections import defaultdict\n\ndef dfs(i, has):\n    for club in clubs_of_resident[i]:\n        if not chosen[club] and len(has[parties_of_resident[i]]) < limit:\n            chosen[club] = True\n            for j in club_members[club]:\n                has[parties_of_resident[i]].add(j)\n                if dfs(j, has):\n                    return True\n                has[parties_of_resident[i]].remove(j)\n            chosen[club] = False\n    return False\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    residents = []\n    clubs_of_resident = defaultdict(list)\n    club_members = defaultdict(set)\n    parties_of_resident = {}\n    for i in range(n):\n        resident, party, num_clubs, *clubs = input().split()\n        residents.append(resident)\n        parties_of_resident[resident] = party\n        for club in clubs:\n            clubs_of_resident[resident].append(club)\n            club_members[club].add(i)\n    limit = (n + 1) // 2\n    has = defaultdict(set)\n    chosen = defaultdict(bool)\n    success = True\n    for i in range(n):\n        if dfs(i, has):\n            success = False\n            break\n    if success:\n        for club, member in chosen.items():\n            if member:\n                for i in club_members[club]:\n                    print(residents[i], club)\n                    break\n    else:\n        print(\"Impossible\")\n    if _ != t - 1:\n        print()"
 ],
 "3460": [
  "from bisect import bisect_left, bisect_right\n\nn = int(input())\ncans = []\n\nfor i in range(n):\n    x, r = map(int, input().split())\n    cans.append((x-r, x+r))\n    \ndef explosions(cans, target):\n    stack = [target]\n    exploded = set()\n    \n    while stack:\n        curr = stack.pop()\n        exploded.add(curr)\n        \n        left_idx = bisect_left(cans, (cans[curr][0],))\n        right_idx = bisect_right(cans, (cans[curr][1],))\n        \n        for i in range(left_idx, right_idx):\n            if i not in exploded:\n                stack.append(i)\n    \n    return len(exploded)\n\nfor i in range(n):\n    print(explosions(cans, i), end=\" \")"
 ],
 "3461": [
  "import sys\nfrom heapq import heappush, heappop\n\ndef main():\n    n = int(input())\n    hearings = []\n    for _ in range(n):\n        s, a, b = map(int, input().split())\n        hearings.append((s, a, b))\n        \n    # initialize heap with first hearing\n    heap = [(hearings[0][0] + hearings[0][1], hearings[0])] # (end time, hearing)\n    current_time = Heap[0][0]\n    num_hearings = 1\n    for i in range(1, n):\n        # remove finished hearings from heap\n        while heap and heap[0][0] < hearings[i][0]:\n            heappop(heap)\n        # calculate probability of attending this hearing given previous schedule\n        time_to_attend = max(current_time, hearings[i][0])\n        p = (min(hearings[i][2], heap[0][1][2]) - time_to_attend + 1) / (hearings[i][2] - hearings[i][1] + 1)\n        # update heap and schedule\n        if p > 0:\n            heappush(heap, (min(heap[0][0], max(current_time, hearings[i][0]) + hearings[i][1] - 1) + 1, hearings[i]))\n            current_time = max(current_time, hearings[i][0]) + int((heap[0][0] - max(current_time, hearings[i][0])) * p)\n            num_hearings += p\n    print(\"{:.3f}\".format(num_hearings))\n\nif __name__ == \"__main__\":\n    main()"
 ],
 "3462": [
  "import fnmatch\n\npattern = input().strip()\nn = int(input().strip())\nfiles = [input().strip() for _ in range(n)]\n\nfor file in fnmatch.filter(files, pattern):\n    print(file)"
 ],
 "3463": [
  "from math import comb\nn, m = map(int, input().split())\np = [float(input()) for _ in range(n+m-1)]\ndp = [[0 for _ in range(m+1)] for _ in range(n+1)]\ndp[0][0] = 1\nfor i in range(n+m-1):\n    for j in range(min(i+1,n),-1,-1):\n        k = i-j\n        if k >= m:\n            continue\n        dp[j][k+1] += dp[j][k]*p[i]\n        dp[j+1][k] += dp[j][k]*(1-p[i])\nans = 0\nfor i in range(n, n+m):\n    ans += dp[i][m-i]\nprint('%.6f' % ans)"
 ],
 "3464": [
  "x, p = map(float, input().split())\np /= 100  # converting percentage to decimal\n\nif p == 0:\n    print(0.0)\nelse:\n    q = 1 - p\n    # using geometric distribution formula to calculate expected number of losses\n    exp_losses = q / p\n    # calculating the expected refund amount\n    refund = x / 100 * exp_losses\n    # calculating the expected profit\n    expected_profit = p * (2 - 1 / exp_losses) - (1 - p) * refund\n\n    print(\"{:.3f}\".format(expected_profit))"
 ],
 "3465": [
  "n = int(input())\nroads = []\nfor i in range(n):\n    a, b = map(int, input().split())\n    roads.append((a, b, i+1))\n\nroads.sort(key=lambda x: x[0])\ncities = [0] * n\nfor i in range(n):\n    if not cities[roads[i][0]-1]:\n        cities[roads[i][0]-1] = roads[i][2]\n    else:\n        cities[roads[i][1]-1] = roads[i][2]\n\nfor i in range(n):\n    print(i+1, cities[i])"
 ],
 "3466": [
  "m, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nsousets = [0] * m\nfor i in b:\n    sousets[i-1] += 1\n\nl = 0\nr = 2 * 10**9 # sets an upper limit to prevent overflows\nwhile r - l > 1:\n    x = (l+r)//2\n    can = True\n    max_now = [sousets[i] + a[i]*x for i in range(m)]\n    min_now = [sousets[i] - a[i]*x for i in range(m)]\n    for i in range(m):\n        if max_now[i] < 0:\n            can = False\n        if sousets[i] > x * sum(a) or min_now[i] > x * sum(a):\n            can = False\n    if can:\n        l = x\n    else:\n        r = x\n        \nif l > 10**18:\n    print('forever')\nelse:\n    print(l)"
 ],
 "3467": [
  "n, m, s = map(int, input().split())\n\ntrams = [[] for i in range(n)]\nfor i in range(m):\n    u, v, t0, p, d = map(int, input().split())\n    trams[u].append((v, t0, p, d))\n\ndef possible(time):\n    dist = [float('inf') for i in range(n)]\n    dist[0] = 0\n    \n    visited = [False for i in range(n)]\n    visited[0] = True\n    \n    pq = [(0,0)]\n    \n    while pq:\n        (d,u) = heappop(pq)\n        \n        if visited[u]:\n            continue\n        visited[u] = True\n        \n        for vw in trams[u]:\n            v,w,p,d = vw\n            t = w + ((d - ((w - time) % d)) % d)\n            \n            if dist[v] > dist[u] + t - w:\n                dist[v] = dist[u] + t - w\n                heappush(pq, (dist[v],v))\n    \n    return dist[n-1] <= s\n\nlow = 0\nhigh = int(1e18)\nwhile low < high:\n    mid = (low + high + 1) // 2\n    \n    if possible(mid):\n        low = mid\n    else:\n        high = mid-1\n\nif low == 0:\n    print('impossible')\nelse:\n    print(low)"
 ],
 "3468": [
  "# Reading input\nn, c = map(int, input().split())\napps = [(d, s, i) for i, (d, s) in enumerate([map(int, input().split()) for _ in range(n)])]\n\n# Sorting apps based on maximum need (either download size or storage size)\napps = sorted(apps, key=lambda x: max(x[0], x[1]), reverse=True)\n\n# Initializing variables\ninstalled_apps = []\ninstalled_size = 0\n\n# Installing as many apps as possible in descending order of maximum need\nfor app in apps:\n    d, s, i = app\n    if installed_size + max(d, s) <= c:\n        installed_apps.append(i+1)\n        installed_size += max(d, s)\n\n# Printing output\nprint(len(installed_apps))\nprint(*installed_apps)"
 ],
 "3469": [
  "from math import ceil\n\ng = input()\nk = input()\np = float(input())\n\ngl = len(g)\nkl = len(k)\n\n# Calculate the probability that g appears before k\n# in a string of length n using the z function\ndef z_algorithm(pattern, text):\n    concat = pattern + '$' + text\n    n = len(concat)\n    z = [0] * n\n    z[0] = n\n    l, r, i = 0, 0, 1\n    while i < n:\n        if i > r:\n            l = r = i\n            while r < n and concat[r-l] == concat[r]:\n                r += 1\n            z[i] = r-l\n            r -= 1\n        else:\n            k = i-l\n            if z[k] < r-i+1:\n                z[i] = z[k]\n            else:\n                l = i\n                while r < n and concat[r-l] == concat[r]:\n                    r += 1\n                z[i] = r-l\n                r -= 1\n        i += 1\n    return z\n\npgk = z_algorithm(g, k + \"#\" + g)\npkg = z_algorithm(k, g + \"#\" + k)\n\n# Calculate probability of Gon winning using dynamic programming\ndp = [[0] * (kl + 1) for _ in range(gl + 1)]\ndp[0][0] = 1\nfor i in range(gl + 1):\n    for j in range(kl + 1):\n        if i < gl and g[i] == 'H':\n            dp[i+1][j] += dp[i][j] * (1 - p)\n        else:\n            dp[i][j] += dp[i][j] * (1 - p)\n        if j < kl and k[j] == 'H':\n            dp[i][j+1] += dp[i][j] * p\n        else:\n            dp[i][j] += dp[i][j] * p\n        if i >= pgk[j] and j >= pkg[i]:\n            dp[i][j] += dp[i-pgk[j]][j-pkg[i]]\nans = 0\nfor i in range(gl, 10**10):\n    j = kl\n    if i >= pgk[j] and j >= pkg[i]:\n        ans += pow(p, pgk[j]) * pow(1-p, i-pgk[j]-pkg[i]) * dp[i-pgk[j]][j-pkg[i]]\n    else:\n        break\nprint(\"%.10f\" % ans)"
 ],
 "3470": [
  "n = int(input())\nm = 2*n+2\nsafe_cells = []\nfor i in range(1, m+1):\n    x = (i-1) % (n+1)\n    y = (i-1) // (n+1)\n    if x > 0 and x < n and y > 0 and y < n and i <= 2*n+1:\n        if i-n-2 not in safe_cells:\n            safe_cells.append(i)\n    elif 1 < x < n and 1 < y < n and i > 2*n+2:\n        if i+n+2 not in safe_cells:\n            safe_cells.append(i)\nprint(len(safe_cells))\nprint(\" \".join(str(x) for x in sorted(safe_cells)))"
 ],
 "3471": [
  "from functools import reduce\nk = int(input())\na = list(map(int, input().split()))\nq = int(input())\nfor i in range(q):\n    l, r = map(int, input().split())\n    # Applying the XOR operation on the sublist using reduce function\n    xor_sublist = reduce(lambda x, y: x ^ y, a[l-1:r])\n    print(xor_sublist)"
 ],
 "3472": [
  "from math import gcd\nfrom fractions import Fraction         \n    \ndef slope(x1, y1, x2, y2):\n    if x2 - x1 == 0:\n        return float(\"inf\")\n    else:\n        return Fraction(y2 - y1, x2 - x1)\n        \ndef count_lines(w, lines):\n    # creating a dictionary to hold the slope value to count the no of lines\n    # with the same slope\n    slope_freq = {}\n    for x1, y1, x2, y2 in lines:\n        m = slope(x1, y1, x2, y2)\n        if m in slope_freq:\n            slope_freq[m] += 1\n        else:\n            slope_freq[m] = 1\n    \n    # checking if any warlord can get infinite space with the given lines\n    for k, v in slope_freq.items():\n        if v >= w:\n            return 0\n    \n    # checking if there is a solution where each warlord gets equal area of infinite space\n    # if not, then we need to add extra lines\n    lcm = 1\n    for i in range(w):\n        lcm = lcm * (i+1) // gcd(lcm, i+1)\n    for k, v in slope_freq.items():\n        diff = lcm % v\n        if diff != 0:\n            return lcm - diff\n    return lcm\n    \nW, N = map(int, input().split())\nlines = [list(map(int, input().split())) for _ in range(N)]\nprint(count_lines(W, lines))"
 ],
 "3473": [
  "# importing required modules\nfrom datetime import date, timedelta\n\n# taking input\nZ = int(input())\nF = int(input())\n\n# creating set of forbidden dates\nforbidden_dates = set()\nfor i in range(F):\n    year, month, day = map(int, input().split())\n    forbidden_dates.add(date(year, month, day))\n\n# setting initial values\ncurrent_date = date(2018, 10, 12)\nprevious_date = None\nsurprise_penalty = 0\nschedule = []\n\n# calculating schedule\nfor i in range(Z):\n    while True:\n        current_date += timedelta(days=7)\n        if ((current_date.month == 10 and current_date.day < 8) or\n            current_date in forbidden_dates):\n            continue\n        if previous_date:\n            surprise_penalty += (current_date - previous_date).days ** 2\n        previous_date = current_date\n        schedule.append(current_date)\n        break\n\n# printing output\nprint(surprise_penalty)\nfor s in schedule:\n    print(s.strftime('%Y %m %d'))"
 ],
 "3474": [
  "import sys\n\nfor line in sys.stdin:\n    x1, y1, x2, y2, x3, y3 = map(float, line.split())\n    \n    if x1 == x2:  # Vertical mirror\n        mirror_min_y = min(y1, y2)\n        mirror_max_y = max(y1, y2)\n        if x3 < x1:  # Laser on the left side of the mirror\n            y_intersection = y3 + (x1 - x3) * (y2 - y1) / (x2 - x1)\n            if y_intersection < mirror_min_y:\n                print(\"can't hit the wall\")\n            elif y_intersection > mirror_max_y:\n                print(\"can't hit the wall\")\n            else:\n                print(\"{:.4f}\".format(y_intersection))\n        elif x3 > x1:  # Laser on the right side of the mirror\n            y_intersection = y3 + (x1 - x3) * (y2 - y1) / (x2 - x1)\n            if y_intersection < mirror_min_y:\n                print(\"can't hit the wall\")\n            elif y_intersection > mirror_max_y:\n                print(\"can't hit the wall\")\n            else:\n                print(\"{:.4f}\".format(y_intersection))\n        else:  # Laser on the mirror\n            print(\"can't hit the wall\")\n            \n    else:  # Horizontal mirror\n        mirror_min_x = min(x1, x2)\n        mirror_max_x = max(x1, x2)\n        if y3 < y1:  # Laser below the mirror\n            x_intersection = x3 + (y1 - y3) * (x2 - x1) / (y2 - y1)\n            if x_intersection < mirror_min_x:\n                print(\"{:.4f}\".format(x_intersection))\n            elif x_intersection > mirror_max_x:\n                print(\"{:.4f}\".format(x_intersection))\n            else:\n                print(\"negative-infinity {} positive-infinity\".format(x_intersection))\n        elif y3 > y1:  # Laser above the mirror\n            x_intersection = x3 + (y1 - y3) * (x2 - x1) / (y2 - y1)\n            if x_intersection < mirror_min_x:\n                print(\"{:.4f}\".format(x_intersection))\n            elif x_intersection > mirror_max_x:\n                print(\"{:.4f}\".format(x_intersection))\n            else:\n                print(\"negative-infinity {} positive-infinity\".format(x_intersection))\n        else:  # Laser on the mirror\n            print(\"can't hit the wall\")"
 ],
 "3475": [
  "import sys\n\n# Reading input\nt, n = map(int, sys.stdin.readline().split())\n\n# Reading transportation types\ntransports = []\nfor i in range(t):\n    d_min, a = map(int, sys.stdin.readline().split())\n    transports.append((d_min, a))\n    \n# Reading point data\npoint_data = []\nfor i in range(n-1):\n    d_i, h_i = map(int, sys.stdin.readline().split())\n    point_data.append((d_i, h_i))\n\n# Initializing variables\ncurrent_transport = 0 # index of current transport type\nnum_switches = 0 # number of times transport type is switched\ncurrent_point = 0 # index of current point\nprev_point = None # index of previous point\nnum_points_covered = 1 # number of points covered so far (start with 1 for first point)\n\n# Loop through points and check if they can be covered by current transport type\nwhile current_point < n-1:\n    # Calculate the heading from the previous point to the current point\n    if prev_point == None:\n        # First point, so heading is 0\n        heading = 0\n    else:\n        d_i, h_i = point_data[current_point-1]\n        heading = h_i / 1000.0\n        \n    # Calculate the distance from the previous point to the current point\n    d_i, h_i = point_data[current_point]\n    distance = d_i\n    \n    # Check if the distance is greater than the minimum for the current transport type\n    if distance >= transports[current_transport][0]:\n        # Check if the heading change is within the range for the current transport type\n        if prev_point == None or abs(heading - h_i / 1000.0) <= (transports[current_transport][1] / 1000.0):\n            # Point can be covered by current transport type\n            prev_point = current_point\n            current_point += 1\n            num_points_covered += 1\n        else:\n            # Heading change is too large, switch transport types\n            current_transport += 1\n            num_switches += 1\n            prev_point = None\n            if current_transport == len(transports): # Out of transport options, impossible to complete journey\n                print(\"IMPOSSIBLE\")\n                sys.exit()\n    else:\n        # Distance is too small, try to combine with next points\n        next_point = current_point + 1\n        while next_point < n-1:\n            # Calculate the heading and distance to the next point\n            d_i, h_i = point_data[next_point]\n            heading_diff = abs(h_i / 1000.0 - heading)\n            if heading_diff > 180:\n                heading_diff = 360 - heading_diff\n            distance_diff = d_i\n            total_distance = distance + distance_diff\n            \n            # Check if the combined distance is greater than the minimum for the current transport type\n            if total_distance >= transports[current_transport][0]:\n                # Check if the heading change is within the range for the current transport type\n                if heading_diff <= (transports[current_transport][1] / 1000.0):\n                    # Next point and all following points up to this point can be covered by current transport type\n                    prev_point = None\n                    current_point = next_point\n                    num_points_covered += (current_point - prev_point)\n                    break\n                else:\n                    # Heading change is too large, switch transport types\n                    current_transport += 1\n                    num_switches += 1\n                    prev_point = None\n                    if current_transport == len(transports): # Out of transport options, impossible to complete journey\n                        print(\"IMPOSSIBLE\")\n                        sys.exit()\n                    break\n            else:\n                # Not enough distance yet, try to combine with more points\n                next_point += 1\n        else:\n            # Could not combine with any more points, switch transport types\n            current_transport += 1\n            num_switches += 1\n            prev_point = None\n            if current_transport == len(transports): # Out of transport options, impossible to complete journey\n                print(\"IMPOSSIBLE\")\n                sys.exit()\n\n# All points covered, print number of transport switches\nprint(num_switches)"
 ],
 "3476": [
  "import heapq\nfrom typing import List, Tuple\n\ndef neg_row(matrix: List[List[int]], row: int) -> List[List[int]]:\n    if any(elem < 0 for elem in matrix[row]):\n        return matrix\n    \n    for j in range(len(matrix[0])):\n        matrix[row][j] *= -1\n    \n    return matrix\n    \ndef neg_col(matrix: List[List[int]], col: int) -> List[List[int]]:\n    if any(matrix[i][col] < 0 for i in range(len(matrix))):\n        return matrix\n    \n    for i in range(len(matrix)):\n        matrix[i][col] *= -1\n        \n    return matrix\n    \ndef rotate_row(matrix: List[List[int]], row: int, k: int) -> List[List[int]]:\n    matrix[row] = matrix[row][-k:] + matrix[row][:-k]\n    return matrix\n\ndef rotate_col(matrix: List[List[int]], col: int, k: int) -> List[List[int]]:\n    rotated_col = [matrix[i][col] for i in range(len(matrix))]\n    rotated_col = rotated_col[-k:] + rotated_col[:-k]\n    \n    for i in range(len(matrix)):\n        matrix[i][col] = rotated_col[i]\n        \n    return matrix\n    \ndef calc_sum(matrix: List[List[int]]) -> int:\n    total = 0\n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            total += matrix[i][j]\n    return total\n    \ndef perform_op(op: str, params: Tuple[int, int], matrix: List[List[int]], \n               visited: set) -> Tuple[int, List[List[int]], str]:\n    r, c = params\n    \n    if op == \"negR\":\n        if \"negR\" in visited[r]:\n            return -1, matrix, \"\"\n        visited[r].add(\"negR\")\n        matrix = neg_row(matrix, r)\n        return 1, matrix, \"negR {} \\n\".format(str(r+1))\n    \n    elif op == \"negS\":\n        if \"negS\" in visited[c]:\n            return -1, matrix, \"\"\n        visited[c].add(\"negS\")\n        matrix = neg_col(matrix, c)\n        return 1, matrix, \"negS {} \\n\".format(str(c+1))\n    \n    elif op == \"rotR\":\n        if \"rotR\" in visited[r]:\n            return -1, matrix, \"\"\n        visited[r].add(\"rotR\")\n        matrix = rotate_row(matrix, r, c)\n        return 1, matrix, \"rotR {} {} \\n\".format(str(r+1), str(c))\n    \n    elif op == \"rotS\":\n        if \"rotS\" in visited[c]:\n            return -1, matrix, \"\"\n        visited[c].add(\"rotS\")\n        matrix = rotate_col(matrix, c, r)\n        return 1, matrix, \"rotS {} {} \\n\".format(str(c+1), str(r))\n    \n    \ndef maximize_sum(matrix: List[List[int]]) -> Tuple[int, int, List[str]]:\n    max_sum = calc_sum(matrix)\n    heap = [(0, matrix, \"\", set() for i in range(len(matrix)*len(matrix[0])))]\n    visited = [set() for i in range(len(matrix) + len(matrix[0]))]\n    \n    while heap:\n        ops_so_far, curr_matrix, ops_str, visited_copy = heapq.heappop(heap)\n        \n        if ops_so_far > 5*len(matrix)*len(matrix[0]):\n            continue\n        \n        curr_sum = calc_sum(curr_matrix)\n        \n        if curr_sum > max_sum:\n            max_sum = curr_sum\n            max_ops = ops_str\n            num_ops_used = ops_so_far\n        \n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                for op in [\"rotR\", \"rotS\", \"negR\", \"negS\"]:\n                    result, new_matrix, new_op_str = perform_op(op, (i, j), \n                                                                [x[:] for x in curr_matrix], \n                                                               visited_copy)\n                    if result > 0:\n                        new_visited = visited_copy[:]\n                        new_visited[i].add(op)\n                        new_visited[len(matrix) + j].add(op)\n                        heapq.heappush(heap, (ops_so_far + 1, new_matrix, ops_str + new_op_str, \n                                              new_visited))\n    \n    return max_sum, num_ops_used, max_ops\n    \n\nR, C = map(int, input().split())\nmatrix = []\nfor i in range(R):\n    matrix.append(list(map(int, input().split())))\n    \nmax_sum, num_ops_used, ops_string = maximize_sum(matrix)\nprint(max_sum, num_ops_used)\nprint(ops_string)"
 ],
 "3477": [
  "import heapq\n\nn, m = map(int, input().split())\nk = list(map(int, input().split()))\n\n# Initialize a priority queue with (score, energy) tuples\npq = []\nfor j in range(n):\n    score = k[j] * (j+1)**2\n    if len(pq) < m:\n        heapq.heappush(pq, (-score, j+1))\n    else:\n        if pq[0][0] < -score:\n            heapq.heapreplace(pq, (-score, j+1))\n\n# Calculate the output sum\noutput = 0\nfor i in range(n):\n    min_distance = float(\"inf\")\n    for j in range(m):\n        distance = (i+1 - pq[j][1])**2\n        min_distance = min(min_distance, distance)\n    output += k[i] * min_distance\n\nprint(\"{:.4f}\".format(output))"
 ],
 "3478": [
  "from collections import defaultdict, deque\n\nn, m = map(int, input().split())\ngraph = defaultdict(list)\nfor _ in range(m):\n    x, y = map(int, input().split())\n    graph[x].append(y)\n    graph[y].append(x)\n\n# BFS to find the connected components\ndef bfs(s):\n    visited = [False] * (n+1)\n    visited[s] = True\n    q = deque([s])\n    while q:\n        node = q.popleft()\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                q.append(neighbor)\n    return [i for i in range(1, n+1) if visited[i]]\n\n# find the connected components\ncomp1 = bfs(1)\ncomp2 = bfs(2)\n\n# check if all cities are in either comp1 or comp2\nif len(comp1) + len(comp2) != n:\n    print(\"impossible\")\nelse:\n    # output the two collections\n    print(1, *comp1)\n    print(2, *comp2)"
 ],
 "3479": [
  "import heapq\n\n# Input\nn, k = map(int, input().split())\ntimes = [int(input()) for _ in range(n)]\n\n# Sort the times in descending order\ntimes.sort(reverse=True)\n\n# Initialize heap with k cars, each with 1 driver\nheap = [(times[i], 1) for i in range(k)]\n\n# Iterate over the remaining people and assign them to a car\nfor i in range(k, n):\n    # Get the car with the earliest arrival time\n    time, passengers = heapq.heappop(heap)\n    # Add the new person's time to the car's arrival time\n    heapq.heappush(heap, (time + times[i], passengers + 1))\n\n# Keep removing cars from the heap and updating the arrival time until all people are at the stadium\nwhile heap:\n    time, passengers = heapq.heappop(heap)\n    # If there are still people at the house, add the time it takes to drive back to the house\n    if n > passengers:\n        time += times[n - passengers - 1]\n    n -= passengers\n    # If all people are at the stadium, return the total time\n    if n == 0:\n        print(time)\n        break"
 ],
 "3480": [
  "# Reading input\nL, D = map(int, input().split())\nlines = [input().strip().split() for _ in range(L*2)]\ntimes = [list(map(int, input().split())) for _ in range(L)]\n\n# Loop over each line of the song\nfor i in range(L):\n    # Separate the two voices in two different lists\n    voice1 = []\n    voice2 = []\n    \n    # Loop over each syllable in the line\n    for j, syllable in enumerate(lines[i*2]):\n        # Calculate the starting and ending time of each syllable for the two voices\n        t1_start = sum(times[i][:j]) + D\n        t1_end = t1_start + times[i][j]\n        t2_start = t1_start - D\n        t2_end = t2_start + times[i][j]\n        \n        # Add the corresponding underscores to align the syllables vertically\n        voice1.extend(list(syllable) + ['_']*(t1_end - len(voice1)))\n        voice2.extend(['_']*t2_start + list(syllable) + ['_']*(t2_end - len(voice2)))\n        \n    # Print the two voices for the current line\n    print(''.join(voice1))\n    if any(c != '_' for c in voice2):\n        print(''.join(voice2))\n    else:\n        print('/')\n    # Print an empty line between each pair of output lines\n    print()"
 ],
 "3481": [
  "from heapq import heappush,heappop\nfrom collections import defaultdict\nINF = 9999999999\ndef dijkstra(gp, start, finish):\n    minDist = {k: INF for k in gp}\n    minDist[start] = 0\n    visited = defaultdict(bool)\n    pq = []\n    heappush(pq, (0, start))\n    while pq:\n        (dist_u, u)  = heappop(pq)\n        if visited[u]: continue\n        visited[u] = True\n        for v, length_v in gp[u].items():\n            dist_v = length_v + dist_u\n            if minDist[v] > dist_v:\n                minDist[v] = dist_v\n                heappush(pq, (dist_v, v))\n    return minDist[finish]\n\nG, K, R = map(int, input().split())\ngraph = defaultdict(dict)\nfor i in range(R):\n    a, b, t = map(int, input().split())\n    graph[a][b] = t\n    graph[b][a] = t\n    \nmatrix = [[0 for i in range(K)] for j in range(K)]\nfor i in range(1,K+1):\n  for j in range(1, K+1):\n    if i == j:\n      matrix[i-1][j-1] = 0\n    elif i in graph and j in graph[i]:\n      matrix[i-1][j-1] = graph[i][j]\n    else:\n      matrix[i-1][j-1] = INF\n      \nfor k in range(K):\n  for i in range(K):\n    for j in range(K):\n      matrix[i][j] = min(matrix[i][j], matrix[i][k]+matrix[k][j])\n      \nevents = []\nfor i in range(G):\n    v, s, e, m = map(int, input().split())\n    events.append((s,e,m,v))\n    \ndp = [[-INF for j in range(K)] for i in range(1<<G)]\nfor i in range(1<<G):\n  for j in range(K):\n    if j == 0 and i == (1<<G)-1:\n      dp[i][j] = 0\n    for e, (s,_,m,v) in enumerate(events):\n      if i & (1<<e): continue # We have already covered this event\n      if matrix[j][v-1] <= s: # We have reached the venue before the start time of the event\n        dp[i | (1<<e)][v-1] = max(dp[i | (1<<e)][v-1], dp[i][j]+m)\n      \nprint(max(dp[(1<<G)-1]))"
 ],
 "3482": [
  "l = int(input())\np = list(map(int, input().split()))\nd = list(map(int, input().split()))\nt, n = map(int, input().split())\n\nintervals = []\nfor i in range(n):\n    a, b = map(int, input().split())\n    intervals.append((a, b))\n    \ncosts = [0] * (t+1)\ncur_price_idx = 0\ncur_days_left = d[cur_price_idx] if cur_price_idx < l-1 else float('inf')\n\nfor day in range(1, t+1):\n    if cur_days_left == 0:\n        cur_price_idx += 1\n        cur_days_left = d[cur_price_idx] if cur_price_idx < l-1 else float('inf')\n    costs[day] = costs[day-1] + p[cur_price_idx]\n    cur_days_left -= 1\n    for a, b in intervals:\n        if a <= day <= b:\n            costs[day] -= p[cur_price_idx]\n            \nprint(costs[t])"
 ],
 "3483": [
  "from itertools import combinations\nn = int(input())\nweights = list(map(int, input().split()))\n\n# finding maximum weight of 4-pack\nmax_weight = max([sum(combo) for combo in combinations(weights, 4)])\n\n# finding minimum weight of 4-pack\nmin_weight = min([sum(combo) for combo in combinations(weights, 4)])\n\n# finding number of distinct weights in 4-packs\ndistinct_weights = len(set([sum(combo) for combo in combinations(weights, 4)]))\n\n# finding expected weight of 4-pack\nexpected_weight = sum([sum(combo) for combo in combinations(weights, 4)]) / distinct_weights\n\nprint(max_weight, min_weight, distinct_weights, round(expected_weight, 4))"
 ],
 "3484": [
  "def check_valid(n, rows, curr_row, curr_col, num):\n    # check if num already exists in curr_row\n    if num in rows[curr_row]:\n        return False\n    # check if num already exists in curr_col\n    for i in range(n):\n        if rows[i][curr_col] == num:\n            return False\n    # check if num already exists in the same box\n    box_row = curr_row // 3\n    box_col = curr_col // 3\n    for i in range(box_row*3, box_row*3 + 3):\n        for j in range(box_col*3, box_col*3 + 3):\n            if rows[i][j] == num:\n                return False\n    # if all checks pass, then num is valid\n    return True\n\ndef solve_superdoku(n, k, rows):\n    # first, fill in the given rows\n    curr_row = k\n    curr_col = 0\n    while curr_row < n and curr_col < n:\n        # if current cell is already filled, move to next cell\n        if rows[curr_row][curr_col] != 0:\n            curr_col += 1\n            if curr_col == n:\n                curr_col = 0\n                curr_row += 1\n            continue\n        # try filling in valid number in current cell\n        for num in range(1, n+1):\n            if check_valid(n, rows, curr_row, curr_col, num):\n                rows[curr_row][curr_col] = num\n                break\n        # if no valid number found, backtrack\n        if rows[curr_row][curr_col] == 0:\n            if curr_col == 0:\n                curr_col = n-1\n                curr_row -= 1\n            else:\n                curr_col -= 1\n        else:\n            curr_col += 1\n            if curr_col == n:\n                curr_col = 0\n                curr_row += 1\n    # check if solution was found\n    for row in rows:\n        if 0 in row:\n            print(\"no\")\n            return\n    # solution found, print out the grid\n    print(\"yes\")\n    for row in rows:\n        print(\" \".join(str(num) for num in row))\n\n# read in inputs\nn, k = map(int, input().split())\nrows = []\nfor i in range(k):\n    row = list(map(int, input().split()))\n    rows.append(row)\nfor i in range(k, n):\n    rows.append([0]*n)\n# solve the superdoku puzzle\nsolve_superdoku(n, k, rows)"
 ],
 "3485": [
  "from sys import maxsize\nn = int(input())\ncards = list(map(int, input().split()))\n\n# Initialize variables to keep track of maximum payout and current sum/count of counted cards\nmax_payout = 0.0\ncounted_sum = 0\ncounted_count = 0\n\n# Loop through the deck of cards\nfor i in range(n):\n    # If the current card is negative, stop counting and calculate payout if there are counted cards\n    if cards[i] < 0:\n        if counted_count > 0:\n            max_payout = max(max_payout, counted_sum / counted_count)\n        # Reset variables for next round of counting\n        counted_sum = 0\n        counted_count = 0\n    # If the current card is positive, add it to the running total\n    else:\n        counted_sum += cards[i]\n        counted_count += 1\n        # If we have already stopped counting, calculate payout and update max_payout if needed\n        if counted_count > 0 and i < n - 1 and cards[i+1] < 0:\n            max_payout = max(max_payout, counted_sum / counted_count)\n        # If we haven't stopped counting yet, try to start counting on the next card\n        elif counted_count == 1 and i < n - 1 and cards[i+1] > 0:\n            temp_sum = counted_sum + cards[i+1]\n            temp_count = counted_count + 1\n            j = i + 2\n            # Iterate through remaining cards to see if starting counting now would result in a higher payout\n            while j < n:\n                if cards[j] < 0:\n                    break\n                temp_sum += cards[j]\n                temp_count += 1\n                if temp_count > 0:\n                    max_payout = max(max_payout, temp_sum / temp_count)\n                j += 1\n\n# Output the maximum payout with the required precision\nprint(\"%.10f\" % max_payout)"
 ],
 "3486": [
  "from math import gcd\nfrom functools import reduce\n\nMOD = 10**9 + 7\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\nn = int(input())\nnums = [int(input()) for _ in range(n)]\n\nlcm_num = reduce(lcm, nums) # find lcm of all numbers\ncount = sum(lcm_num // num for num in nums) # count number of factors of lcm_num that are divisible by each number in nums\nans = pow(2, n - 1, MOD) * count % MOD # multiply by 2^(n-1) to account for arranging the students in a circle\n\nprint(ans)"
 ],
 "3487": [
  "import heapq\nimport math\n\nn, p, v, a = map(float, input().split())\nn, p = int(n), int(p)\nedges = {i:[] for i in range(1, n+1)}\nfor i in range(p):\n    a, b, c = map(int, input().split())\n    e1 = [b, c, 0, None]\n    e2 = [a, c, 0, None]\n    edges[a].append(e1)\n    edges[b].append(e2)\nr = v/(v+1)\n\nclass Node: \n    def __init__(self, id, d): \n        self.id = id \n        self.d = d \n    def __lt__(self, other): \n        return self.d < other.d\n\ndef dijkstra(start, end):\n    dist = {i:math.inf for i in range(1, n+1)}\n    dist[start] = 0\n    queue = []\n    heapq.heappush(queue, Node(start, 0))\n    while queue:\n        node = heapq.heappop(queue)\n        if node.d == dist[node.id]:\n            for neighbor in edges[node.id]:\n                if neighbor[0] == end:\n                    if dist[node.id] + r*neighbor[1] < dist[end]:\n                        dist[end] = dist[node.id] + r*neighbor[1]\n                        neighbor[3] = neighbor[1]\n                        for back_edge in edges[end]:\n                            if back_edge[0] == neighbor[0]:\n                                back_edge[3] = -neighbor[1]\n                                break\n                else:\n                    delta = min((dist[node.id] + neighbor[1])/(v+1-node[2]), neighbor[1])\n                    if delta > 0 and dist[node.id] + delta*r < dist[neighbor[0]]:\n                        dist[neighbor[0]] = dist[node.id] + delta*r\n                        neighbor[3] = delta\n                        for back_edge in edges[neighbor[0]]:\n                            if back_edge[0] == node.id:\n                                back_edge[3] = -delta\n                                back_edge[2] += delta\n                                if back_edge[2] >= back_edge[1]:\n                                    heapq.heappush(queue, Node(node.id, dist[node.id]))\n                                    back_edge[2] -= back_edge[1]\n                                break\n                        heapq.heappush(queue, Node(neighbor[0], dist[neighbor[0]]))\n    return dist[end]\n\n# Calculate maximum value\n\nfw = dijkstra(2, 3)\nmin_fw = min(fw, v*fw/(v+1))\nmax_fw = min(fw+v, v*(fw+v)/(v+1))\nresult = 0.0\nf = 0.0\nwhile f <= max_fw:\n    w = min_fw\n    while w <= min(fw+v, v*(f+w)/(v+1)):\n        result = max(result, f**a*w**(1-a))\n        w += 0.0001\n    f += 0.0001\n\n# Calculate flows\n\ndijkstra(1, 3)\nfor i in range(1, n+1):\n    for edge in edges[i]:\n        if edge[2] is not None:\n            print(\"{:.8f} {:.8f}\".format(max(0, edge[2]), max(0, -edge[3])))\nprint(\"{:.10f}\".format(result))"
 ],
 "3488": [
  "import sys\nfrom collections import deque\n\ninput = sys.stdin.readline\n\nn = int(input())\na = [tuple(map(int, input().split())) for _ in range(n)]\nk = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(k)]\n\ndef dot(a, b, c):\n    return (a[0]-b[0])*(c[0]-b[0]) + (a[1]-b[1])*(c[1]-b[1])\n\ndef cross(a, b, c):\n    return (a[0]-b[0])*(c[1]-b[1]) - (a[1]-b[1])*(c[0]-b[0])\n\ndef inside_triangle(a, b, c, point):\n    x, y, z = abs(cross(a,b,point)), abs(cross(b,c,point)), abs(cross(c,a,point))\n    if x + y + z != abs(cross(a,b,c)):\n        return False\n    if dot(a, b, point) > 0 and dot(b, c, point) > 0 \\\n        and dot(c, a, point) > 0:\n        return True\n    return False\n\ndef intersect(a, b, c, d):\n    if max(a[0], b[0]) < min(c[0], d[0]):\n        return False\n    if max(c[0], d[0]) < min(a[0], b[0]):\n        return False\n    if max(a[1], b[1]) < min(c[1], d[1]):\n        return False\n    if max(c[1], d[1]) < min(a[1], b[1]):\n        return False\n    return cross(c, a, b) * cross(d, b, a) >= 0 and cross(a, c, d) * cross(b, d, c) >= 0\n\ndef contains(triangles, point):\n    for t in triangles:\n        if inside_triangle(*t, point):\n            return True\n    return False\n\nq = deque([(i, (i+1)%n) for i in range(n)])\ntriangles = [(a[i], a[j], p) for p in points for (i,j) in q if cross(a[j], p, a[i]) > 0]\nans = set()\nwhile triangles:\n    t = triangles.pop()\n    if all(not inside_triangle(*t, p) for p in points):\n        ans.add(tuple(sorted(a.index(v) for v in t)))\n        q.remove((a.index(t[0]), a.index(t[1])))\n        triangles += [(t[i], t[j], p) for (i,j) in [(0,1), (0,2), (1,2)] for p in points if inside_triangle(t[i], t[j], p, t[3-i-j]) and not contains(triangles, p)]\n\nprint(len(min(ans, key=len)))"
 ],
 "3489": [
  "from collections import defaultdict, deque\n\nn, head = map(int, input().split())\ngraph = defaultdict(list)\nfor i in range(n-1):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\ndef bfs(start):\n    queue = deque([start])\n    visited = {start}\n    distances = {start: 0}\n    \n    while queue:\n        node = queue.popleft()\n        distance = distances[node] + 1\n        \n        for neighbour in graph[node]:\n            if neighbour not in visited:\n                visited.add(neighbour)\n                queue.append(neighbour)\n                distances[neighbour] = distance\n    \n    return distances\n\ndist_from_headquarters = bfs(head)\n\nmax_distance = max(dist_from_headquarters.values())\n\nfarthest_node = None\nfor node, dist in dist_from_headquarters.items():\n    if dist == max_distance:\n        farthest_node = node\n        break\n\ndist_from_farthest_node = bfs(farthest_node)\n\nmax_distance = max(dist_from_farthest_node.values())\n\nfor node, dist in dist_from_farthest_node.items():\n    if dist == max_distance:\n        farthest_node2 = node\n\ndef find_path(node1, node2, parent):\n    path = []\n    while node1 != node2:\n        path.append((node1, parent[node1]))\n        node1 = parent[node1]\n    return path[::-1]\n\npath_from_headquarters = find_path(farthest_node, farthest_node2, dist_from_headquarters)\npath_from_farthest = find_path(farthest_node2, farthest_node, dist_from_farthest_node)\n\nprint(len(path_from_headquarters) + len(path_from_farthest))\nfor node1, node2 in path_from_headquarters:\n    print(node1, node2)\nfor node1, node2 in path_from_farthest:\n    print(node1, node2)"
 ],
 "3490": [
  "from math import sin, cos, fabs\n\nn = int(input())\n\nwitches = []\nfor i in range(n):\n    x_i, y_i, r_i = map(float, input().split())\n    witches.append((x_i, y_i, r_i))\n\nfor i in range(n):\n    for j in range(i + 1, n):\n        dist = fabs(witches[i][1] - witches[j][1])\n        angle = fabs(witches[i][2] - witches[j][2])\n        if dist <= 1 and dist * sin(angle) <= 1:\n            print(\"crash\")\n            exit()\n\nprint(\"ok\")"
 ],
 "3491": [
  "n, m = map(int, input().split())\n\ncur = []\nfor _ in range(m):\n    i, j = map(int, input().split())\n    cur.append((i, j))\n\ndes = []\nfor _ in range(m):\n    i, j = map(int, input().split())\n    des.append((i, j))\n\n\ndef move(start, end):\n    if start == end:\n        return []\n    if end == (start+1)%n:\n        return [('R', start), ('G', end)]\n    steps = []\n    if start == (end + 1) % n:\n        steps.append(('G', start))\n        start, end = end, start\n    if start > end:\n        end += n\n    if start == 0:\n        if end == n-1:\n            return steps + move(start+1, end-1) + [('R', 0), ('R', 0)] + move(end-1, start+1) + [('G', 0), ('R', 0), ('R', 0), ('G', 0)] + move(start+1, end-1) + [('G', 0)]\n        else:\n            steps.append(('R', 0))\n            return steps + move(start+1, end-1) + [('G', 0), ('R', 0), ('R', end), ('G', 0)] + move(end, start+1) + [('G', 0)]\n    else:\n        steps.append(('R', start))\n        return steps + move(start+1, end-1) + [('G', start), ('R', 0), ('R', end), ('G', start)] + move(end, start+1) + [('G', start)]\n\n\nsteps = []\nfor i in range(m):\n    if cur[i] != des[i]:\n        steps += move(cur[i][0], cur[i][1]) + [('R', cur[i][0]), ('R', cur[i][1]), ('G', cur[i][0]), ('G', cur[i][1])]\n\nprint(len(steps))\nfor step in steps:\n    print(step[0], step[1])"
 ],
 "3492": [
  "s, r, f, t = map(int, input().split())\nraw_materials = set(input().split())\nfactories = set(input().split())\n\ntransportation = {}\nfor i in range(t):\n    data = input().split()\n    allowed_states = set(data[1:])\n    for state in allowed_states:\n        if state in raw_materials:\n            raw_material_state = state\n        elif state in factories:\n            factory_state = state\n    transportation[(raw_material_state, factory_state)] = allowed_states\n\nmax_factories_supplied = 0\nfor factory_state in factories:\n    for raw_material_state in raw_materials:\n        for other_raw_material_state in raw_materials - {raw_material_state}:\n            transportation_for_raw_material = set()\n            for key, value in transportation.items():\n                if key[0] == raw_material_state and key[1] != factory_state:\n                    if other_raw_material_state not in value:\n                        transportation_for_raw_material.add(key)\n                elif key[0] == other_raw_material_state and key[1] != factory_state:\n                    if raw_material_state not in value:\n                        transportation_for_raw_material.add(key)\n            factories_supplied = set()\n            for key, _ in transportation_for_raw_material:\n                if key[1] not in factories_supplied:\n                    factories_supplied.add(key[1])\n            if len(factories_supplied) > max_factories_supplied:\n                max_factories_supplied = len(factories_supplied)\n\nprint(max_factories_supplied)"
 ],
 "3493": [
  "n = int(input())\npeople = []\nfor i in range(n):\n  people.append(list(input()))\nperms = []\n\ndef permute(people, curr_perm):\n  if len(curr_perm) == n:\n    perms.append(curr_perm[:])\n    return\n  for i in range(n):\n    if i not in curr_perm:\n      curr_person_can_stand = True\n      for j in range(len(curr_perm)):\n        if people[curr_perm[j]][i] == \"N\" or people[i][curr_perm[j]] == \"N\":\n          curr_person_can_stand = False\n          break\n      if curr_person_can_stand:\n        curr_perm.append(i)\n        permute(people, curr_perm)\n        curr_perm.pop()\n\npermute(people, [])\nmax_count, max_perm = 0, []\nfor perm in perms:\n  count = 1\n  for i in range(1, n):\n    j = 0\n    while j < i:\n      if perm[i] == perm[j]:\n        break\n      j += 1\n    if j == i:\n      count += 1\n  if count > max_count:\n    max_count = count\n    max_perm = perm[:]\n\nprint(max_count)\nfor i in range(max_count):\n  output = \"\"\n  for j in range(n):\n    if max_perm[i] == j:\n      output += str(j + 1) + \" \"\n  print(output.strip())"
 ],
 "3494": [
  "from math import dist\n\n# input\nR, S = map(int, input().split())\nmatrix = [input() for _ in range(R)]\nG = int(input())\napples = []\nfor _ in range(G):\n    r, s = map(int, input().split())\n    apples.append((r-1, s-1))\n\n# calculate distance\nfor apple in apples:\n    closest_dist = float('inf')\n    for r in range(R):\n        for s in range(S):\n            if matrix[r][s] == 'x':\n                closest_dist = min(closest_dist, dist((apple[0], apple[1]), (r, s)))\n    print(int(closest_dist**2))"
 ],
 "3495": [
  "import math\n\nN = int(input())\nL = [int(input()) for i in range(N)]\nx, y = map(int, input().split())\n\nangle_sum = 0\nsegments = []\n\nfor i in range(N-1):\n    d_x, d_y = x - segments[-1][0], y - segments[-1][1]\n    angle = math.atan2(d_y, d_x) \n    angle_diff = angle - angle_sum\n    angle_sum += angle_diff\n    segments.append((segments[-1][0] + L[i] * math.cos(angle_sum), segments[-1][1] + L[i] * math.sin(angle_sum)))\n\nd_x, d_y = x - segments[-1][0], y - segments[-1][1]\nangle_diff = math.atan2(d_y, d_x) - angle_sum\nangle_sum += angle_diff\nsegments.append((segments[-1][0] + L[-1] * math.cos(angle_sum), segments[-1][1] + L[-1] * math.sin(angle_sum)))\n\nfor segment in segments:\n    print('{:.4f} {:.4f}'.format(segment[0], segment[1]))"
 ],
 "3496": [
  "n, q = map(int, input().split())\nexplodification_energy = list(map(int, input().split()))\n\n# Calculate the minimum energy released for each k\ndp = [float('inf')] * (max(explodification_energy) + 1)\ndp[0] = 0\nfor i in range(1, len(dp)):\n    for j in range(min(i, n), 0, -1):\n        dp[i] = min(dp[i], dp[i-j] + explodification_energy[j-1])\n        \n# Output the minimum energy for each query k\nfor i in range(q):\n    k = int(input())\n    print(dp[k])"
 ],
 "3497": [
  "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(10**5)\n\ndef dfs(node, parent, graph, pigs, dp):\n    if node in pigs:\n        dp[node][1] = 0 # current node has pig\n        dp[node][0] = 1 # current node without pig is bad wolf\n    else:\n        dp[node][1]=1 # current node doesn't have pig and leaf nodes are always safe\n\n    for neighbour in graph[node]:\n        if neighbour == parent: \n            continue\n\n        dfs(neighbour,node,graph,pigs,dp)\n\n        dp[node][1] += dp[neighbour][0] #  If current node has no pig, and neighbour is bad wolf (without pig is 0), then current node becomes bad wolf\n        dp[node][0] += min(dp[neighbour][0],dp[neighbour][1]) # If current node is bad wolf (without pig is 0) and neighbour is also awolf, then current node becomes bad wolf if neighbour is bad wolf with or without pig. Thus the minimum is taken.\n        \n\ndef main():\n\n    V, P = map(int, input().split())\n    graph = defaultdict(list)\n    for i in range(V-1):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    pigs = set(map(int, input().split()))\n\n    dp = [[0,0] for i in range(V)] # 2D dp array\n\n    dfs(0,-1,graph,pigs,dp)\n\n    print(dp[0][1]) #output\n \nif __name__ == \"__main__\":\n    main()"
 ],
 "3498": [
  "import queue\n\n# Function to parse instructions of a task and generate instruction queue\ndef parse_instructions(line, resource_ceiling):\n    instructions = queue.Queue()\n    for i in range(3, len(line)):\n        if line[i][0] == 'C':\n            # Compute instruction\n            count = int(line[i][1:])\n            for j in range(count):\n                instructions.put(('compute',))\n        else:\n            # Lock or Unlock instruction\n            resource = int(line[i][1:])\n            instruction = 'lock' if line[i][0] == 'L' else 'unlock'\n            instructions.put((instruction, resource_ceiling[resource], resource))\n    return instructions\n\n\nt, r = map(int, input().split())\n\nqueue_list = []        # List of instruction queues for each task\nblocked_by = []        # List of sets of tasks blocked by each task\nresource_ceiling = [0] * (r + 1)   # Priority ceilings of resources\n\n# Initialize task queues and blocked-by sets\nfor i in range(t):\n    line = input().split()\n    start_time, base_priority, count = map(int, line[:3])\n    queue_list.append(parse_instructions(line, resource_ceiling))\n    blocked_by.append(set())\n    for j in range(1, len(line[3:]), 2):\n        resource = int(line[j][1:])\n        resource_ceiling[resource] = max(resource_ceiling[resource], base_priority)\n\nprocessor_time = 0   # Current processor time\ntask_list = list(range(t))   # List of tasks to be executed\n\n# Execute tasks\nwhile task_list:\n    running_tasks = []   # List of tasks currently running\n    for task in task_list:\n        # Check if task is running\n        if not queue_list[task].empty() and queue_list[task].queue[0][0] == 'compute' and processor_time >= start_time:\n            running_tasks.append(task)\n\n    # Remove running tasks from task_list\n    for task in running_tasks:\n        task_list.remove(task)\n\n    current_priorities = [queue_list[task].queue[0][1] for task in task_list]   # Current priorities of all tasks\n\n    # Check which running tasks are blocked\n    blocked_tasks = []\n    for i, task in enumerate(task_list):\n        if task in running_tasks:\n            continue\n        instruction = queue_list[task].queue[0][0]\n        if instruction == 'compute':\n            continue\n        resource = queue_list[task].queue[0][2]\n        blocked = False\n        for j, other_task in enumerate(task_list):\n            if other_task == task or other_task in blocked_by[task]:\n                continue\n            other_instruction = queue_list[other_task].queue[0][0]\n            other_resource = queue_list[other_task].queue[0][2] if other_instruction != 'compute' else -1\n            if other_resource == resource and other_task not in blocked_tasks:\n                blocked_tasks.append(task)\n                blocked = True\n                break\n            if other_resource != -1 and other_resource != resource and resource_ceiling[other_resource] >= queue_list[task].queue[0][1] and other_task not in blocked_tasks:\n                blocked_tasks.append(task)\n                blocked = True\n                break\n        if not blocked:\n            running_tasks.append(task)\n\n    # Update blocked_by sets\n    for task in blocked_tasks:\n        for other_task in task_list:\n            if queue_list[other_task].queue[0][0] != 'compute' and queue_list[other_task].queue[0][2] == queue_list[task].queue[0][2] and other_task not in blocked_tasks:\n                blocked_by[other_task].add(task)\n\n    # Remove blocked tasks from task_list\n    for task in blocked_tasks:\n        task_list.remove(task)\n\n    # Determine current priorities\n    for task in running_tasks:\n        current_priority = max(queue_list[task].queue[0][1], max(current_priorities))\n        for other_task in blocked_by[task]:\n            current_priority = max(current_priority, max(queue_list[other_task].queue[0][1], current_priorities[task_list.index(other_task)]))\n        queue_list[task].queue[0] = (queue_list[task].queue[0][0], current_priority, queue_list[task].queue[0][2])\n\n    # Execute the next instruction of the non-blocked running task (if any) with the highest current priority\n    if running_tasks:\n        running_tasks.sort(key=lambda task: queue_list[task].queue[0][1], reverse=True)\n        task = running_tasks[0]\n        if queue_list[task].queue[0][0] == 'compute':\n            processor_time += 1\n        queue_list[task].get()\n        if queue_list[task].empty():\n            print(processor_time)\n        else:\n            current_priority = max(queue_list[task].queue[0][1], max(current_priorities))\n            for other_task in blocked_by[task]:\n                current_priority = max(current_priority, max(queue_list[other_task].queue[0][1], current_priorities[task_list.index(other_task)]))\n            queue_list[task].queue[0] = (queue_list[task].queue[0][0], current_priority, queue_list[task].queue[0][2])\n            task_list.append(task)\n    else:\n        processor_time += 1"
 ],
 "3499": [
  "MOD = 10**9 + 7\n\nn = int(input())\ns = input()\n\ndp = [[0]*(n+1) for _ in range(n+1)]\nfor i in range(n+1):\n    dp[i][i] = 1\n\nfor l in range(2, n+1):\n    for i in range(n-l+1):\n        j = i + l - 1\n        if s[i] == s[j]:\n            dp[i][j] = (dp[i+1][j] + dp[i][j-1] + 1) % MOD\n        else:\n            dp[i][j] = (dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1] + MOD) % MOD\n\nans = 0\nfor i in range(n):\n    ans = (ans + dp[0][i]*dp[i+1][n-1]) % MOD\n    \nprint(ans)"
 ]
}