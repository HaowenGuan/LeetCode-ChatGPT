{
 "3500": [
  "from itertools import combinations\n\nn = int(input().strip())\n\ntickets = []\n\nfor _ in range(n):\n    ticket = []\n    for i in range(5):\n        ticket.append(set(map(int, input().split())))\n    tickets.append(ticket)\n\ncombs = combinations(range(n), 2)\n\nfor a, b in combs:\n    for i in range(5):\n        rows = [set(ticket[i]) for ticket in (tickets[a], tickets[b])]\n        if len(set.intersection(*rows)) >= 5:\n            print(a+1, b+1)\n            exit()\n\nprint(\"no ties\")"
 ],
 "3501": [
  "n = int(input())\njaap = list(map(int, input().split()))\njan = list(map(int, input().split()))\nthijs = list(map(int, input().split()))\n\ncount = 0\nfor i in range(n-1):\n    for j in range(i+1, n):\n        if (jaap.index(i+1) < jaap.index(j+1) and jan.index(i+1) < jan.index(j+1) and thijs.index(i+1) < thijs.index(j+1)) or (jaap.index(i+1) > jaap.index(j+1) and jan.index(i+1) > jan.index(j+1) and thijs.index(i+1) > thijs.index(j+1)):\n            count += 1\n\nprint(count)"
 ],
 "3502": [
  ""
 ],
 "3503": [
  "n = int(input())\npairs = []\nfor _ in range(n):\n    pairs.append(tuple(map(int, input().split())))\n\nresults = set()\nfor i in range(n):\n    a, b = pairs[i]\n    if a == b:\n        print(f\"{a} + {b} = {2*a}\")\n    elif (a, b) in results:\n        print(f\"{a} * {b} = {a*b}\")\n    else:\n        for op in [\"+\", \"-\", \"*\"]:\n            if op == \"+\":\n                res = a + b\n            elif op == \"-\":\n                res = a - b\n            else:\n                res = a * b\n            if res not in results:\n                results.add(res)\n                print(f\"{a} {op} {b} = {res}\")\n                break\n        else:\n            print(\"impossible\")"
 ],
 "3504": [
  "from bisect import bisect_left\nd, s = map(int, input().split())\ndrops = []\nfor i in range(d):\n    x, y = map(int, input().split())\n    drops.append((x, y))\nsensors = []\nfor i in range(s):\n    x1, x2, y = map(int, input().split())\n    sensors.append((y, x1, x2))\nsensors.sort(reverse=True)\nxs = sorted({x for x, _ in drops})\nys = [0] * d\nfor y, x1, x2 in sensors:\n    idx = bisect_left(xs, x1)\n    while idx < len(xs) and xs[idx] <= x2:\n        i = {x: i for i, (x, _) in enumerate(drops)}[xs[idx]]\n        if ys[i] == 0:\n            ys[i] = y\n        idx += 1\nfor y in ys:\n    print(y)"
 ],
 "3505": [
  "n = int(input())\na = list(map(int, input().split()))\n\nfreq = [0] * 100001\nfor i in a:\n    freq[i + 50000] += 1\n    \nans = 0\nfor i in range(100001):\n    if freq[i] == 0:\n        continue\n    for j in range(i, 100001):\n        if freq[j] == 0:\n            continue\n        k = j - i\n        if k < 0 or k > 100000 or freq[k] == 0:\n            continue\n        if i == j and j == k:\n            ans += (freq[i] * (freq[i] - 1) * (freq[i] - 2)) // 6\n        elif i == j:\n            ans += (freq[i] * (freq[i] - 1) // 2) * freq[k]\n        elif i == k:\n            ans += (freq[i] * (freq[i] - 1) // 2) * freq[j]\n        elif j == k:\n            ans += (freq[j] * (freq[j] - 1) // 2) * freq[i]\n        else:\n            ans += freq[i] * freq[j] * freq[k]\n            \nprint(ans)"
 ],
 "3506": [
  "n, t, m = map(int, input().split())\nsche = [0] * 100\ntotal_energy = n * t\n\nfor i in range(m):\n    start, end = map(int, input().split())\n    for j in range(start, end + 1):\n        sche[j] += 1\n\ngoals = [0] * 101\nfor i in range(t - 4):\n    score = sche[i:i+5]\n    if sum(score) > (5 * n) // 2:\n        goals[i+5] = 1\n\nfor i in range(t - 2, t - 8, -1):\n    goals[i] += goals[i+1]\n\nspoilify_score = sum(goals[45:])\ngoals = goals[:45] + goals[55:]\nsportify_score = sum(goals[5:])\n\nprint(sportify_score, spoilify_score)"
 ],
 "3507": [
  "MOD = 10**9 + 7\n\ndef calculate_combinations(n, k):\n    if k > n:\n        return 0\n    numerator = 1\n    denominator = 1\n    for i in range(1, k+1):\n        numerator = (numerator * (n-i+1)) % MOD\n        denominator = (denominator * i) % MOD\n    return (numerator * pow(denominator, MOD-2, MOD)) % MOD\n\ndef calculate_ways_to_arrange_wine_boxes(R, W, d):\n    if W == 0:\n        if R <= d:\n            return 1\n        else:\n            return calculate_combinations(R-1, d)\n    total_wine_boxes = R + W\n    dp = [[0 for j in range(2)] for i in range(total_wine_boxes+1)]\n    dp[1][0] = W\n    dp[1][1] = 1\n    for i in range(2, total_wine_boxes+1):\n        if i-1-W >= 0:\n            dp[i][0] = ((dp[i-1][0] + dp[i-1][1]) % MOD * (W+1)) % MOD\n            dp[i][1] = dp[i-1][0]\n        else:\n            dp[i][0] = ((dp[i-1][0] + dp[i-1][1]) % MOD * (W-i+2+min(d, R-i+1))) % MOD\n            dp[i][1] = dp[i-1][0] * calculate_combinations(min(d, R-i+1), R-i) % MOD\n    return (dp[total_wine_boxes][0] + dp[total_wine_boxes][1]) % MOD\n\nR, W, d = map(int, input().split())\nprint(calculate_ways_to_arrange_wine_boxes(R, W, d))"
 ],
 "3508": [
  "n = int(input())\na = list(map(int, input().split()))\n\n#calculating prefix sum\npre_sum = [a[0]]\nfor i in range(1, n):\n    pre_sum.append(pre_sum[-1]+a[i])\n\n#calculating suffix sum\nsuf_sum = [a[n-1]]\nfor i in range(n-2, -1, -1):\n    suf_sum.append(suf_sum[-1]+a[i])\nsuf_sum = suf_sum[::-1]\n\n#calculating minimum pillar value on the left of each pillar\nmin_left = [a[0]]\nfor i in range(1, n):\n    min_left.append(min(min_left[-1], a[i]))\n\n#calculating minimum pillar value on the right of each pillar\nmin_right = [a[n-1]]\nfor i in range(n-2, -1, -1):\n    min_right.append(min(min_right[-1], a[i]))\nmin_right = min_right[::-1]\n\n#checking which pillar to be removed gives maximum damage\nmax_damage = 0\npillar_to_remove = -1\nfor i in range(n):\n    damage = 0\n    if i == 0:\n        if min_right[i+1] < a[i]:\n            damage += 1\n    elif i == n-1:\n        if min_left[i-1] < a[i]:\n            damage += 1\n    else:\n        if min_left[i-1] < a[i] and min_right[i+1] < a[i]:\n            damage += 1\n        elif min_left[i-1] < a[i]:\n            damage += 1\n        elif min_right[i+1] < a[i]:\n            damage += 1\n    \n    if pre_sum[i-1] >= suf_sum[i+1]:\n        damage += 1\n    \n    if damage > max_damage:\n        max_damage = damage\n        pillar_to_remove = i\n\nprint(max_damage, pillar_to_remove)"
 ],
 "3509": [
  "INF = int(1e18)\n\n# Compute shortest paths using Bellman-Ford algorithm\ndef compute_shortest_paths(adj, cost, n, start):\n    dist = [INF]*n\n    dist[start] = 0\n    for i in range(n-1):\n        for u in range(n):\n            for j, v in enumerate(adj[u]):\n                if dist[v] > dist[u] + cost[u][j]:\n                    dist[v] = dist[u] + cost[u][j]\n    return dist\n\na, b = map(int, input().split())\nn, m = map(int, input().split())\nadj = [[] for _ in range(n)]\ncost = [[] for _ in range(n)]\nfor i in range(m):\n    u, v, t = map(int, input().split())\n    adj[u-1].append(v-1)\n    cost[u-1].append(t)\n\n# Compute shortest paths from Richard's house and to Janet's house\ndist_richard = compute_shortest_paths(adj, cost, n, 0)\ndist_janet = compute_shortest_paths(adj, cost, n, n-1)\n\n# Compute the earliest and latest possible arrival times to each intersection\nearliest_t = [INF]*n\nlatest_t = [0]*n\nfor u in range(n):\n    for j, v in enumerate(adj[u]):\n        earliest_t[v] = min(earliest_t[v], earliest_t[u] + cost[u][j])\n        latest_t[v] = max(latest_t[v], latest_t[u] + cost[u][j])\nearliest_richard = earliest_t[0]\nlatest_richard = latest_t[0]\n\n# Binary search to find the optimal waiting time\nlo = a + earliest_richard\nhi = b + latest_richard\nwhile lo < hi:\n    waiting_time = (lo + hi) // 2\n    earliest_janet = waiting_time - latest_richard\n    latest_janet = waiting_time - earliest_richard\n    \n    # Check if it's possible to reach Janet's house on time\n    if earliest_janet >= dist_richard[n-1]:\n        hi = waiting_time\n        continue\n    if latest_janet < dist_richard[n-1]:\n        lo = waiting_time + 1\n        continue\n    \n    # Compute the longest possible waiting time Janet might experience\n    max_wait = 0\n    for u in range(n):\n        for j, v in enumerate(adj[u]):\n            if dist_richard[u] + cost[u][j] + dist_janet[v] == dist_richard[n-1]:\n                max_wait = max(max_wait, latest_t[u] - earliest_janet)\n    if max_wait <= waiting_time:\n        hi = waiting_time\n    else:\n        lo = waiting_time + 1\n\nprint(lo - a)"
 ],
 "3510": [
  "from collections import deque\n\nn = int(input())\n\n# Create adjacency matrix\nadj_list = [[] for _ in range(n)]\nfor i in range(n):\n    line = input().split()\n    num_options = int(line[0])\n    for j in range(num_options):\n        option = line[j+1]\n        adj_list[i].append([ord(option[k])-ord('a') for k in range(len(option))])\n\n# Initialize distance matrix and queue\ndist = [[float('inf') for _ in range(n)] for _ in range(n)]\nfor i in range(n):\n    dist[i][i] = 0\n    q = deque([i])\n    while q:\n        curr = q.popleft()\n        for option in adj_list[curr]:\n            for nxt in option:\n                if dist[i][nxt] == float('inf'):\n                    dist[i][nxt] = dist[i][curr] + 1\n                    q.append(nxt)\n\n# Print distance matrix\nfor row in dist:\n    print(' '.join(str(d) if d != float('inf') else '-1' for d in row))"
 ],
 "3511": [
  "MOD = 10 ** 9 + 7\nN, Q = map(int, input().split())\nsums = [0] * (N + 1)\nsq_sums = [0] * (N + 1)\nfor _ in range(Q):\n    query = list(map(int, input().split()))\n    if len(query) == 2:  # Query Type 2\n        ans = sum(map(lambda x: x * x, sums)) % MOD\n        print(ans)\n    else:  # Query Type 1\n        u, v = query[1:]\n        for i in range(u, v + 1):\n            sums[i] += 1\n            sq_sums[i] += sums[i]\n        for i in range(u + 1, v + 1):\n            sq_sums[i] += sq_sums[i - 1]\n            sums[i] += sums[i - 1]"
 ],
 "3512": [
  "from itertools import permutations\n\nn = int(input())\ndistances = [list(map(int, input().split())) for _ in range(n)]\ntotal_distance = float('inf')\n\nfor path in permutations(range(n)):\n    for i in range(1, n):\n        if path[i] > path[i-1]:\n            break\n    else:\n        distance = sum(distances[path[i-1]][path[i]] for i in range(1, n))\n        distance += distances[path[-1]][path[0]]\n        total_distance = min(total_distance, distance)\n        \nprint(total_distance)"
 ],
 "3513": [
  "from math import sqrt\n\nX = int(input())\n\nk = 0\n\nfor i in range(2, int(sqrt(X))+1):\n    if X % i == 0:\n        cnt = 0\n        while X % i == 0:\n            cnt += 1\n            X //= i\n        if cnt > 0:\n            k += 1\n\nif X > 1:\n    k += 1\n\nprint(k)"
 ],
 "3514": [
  "r,c=map(int,input().split())\ngrid=[input() for _ in range(r)]\nrowBomb,colBomb=[0]*r,[0]*c\nfor i in range(r):\n  for j in range(c):\n    if grid[i][j]=='x':\n      rowBomb[i]+=1\n      colBomb[j]+=1\nans=0\nfor i in range(r):\n  for j in range(c):\n    if grid[i][j]=='.':\n      continue\n    if rowBomb[i]==1 and colBomb[j]==1:\n      ans=max(ans,1)\n    else:\n      ans=max(ans,2)\nprint(ans)"
 ],
 "3515": [
  "import heapq\n\ninf = 10 ** 18\n\nn = int(input())\ng = [[] for _ in range(n)]\n\nfor i in range(n):\n    y, d, r = map(int, input().split())\n    for j in range(i + 1, n):\n        if abs(y - int(input().split()[0])) >= d:\n            g[i].append((j, abs(y - int(input().split()[0])) + r))\n            g[j].append((i, abs(y - int(input().split()[0])) + r))\n\ndist = [inf] * n\ndist[0] = 0\n\nheap = [(0, 0)]\n\nwhile heap:\n    d, node = heapq.heappop(heap)\n    if dist[node] < d:\n        continue\n    for w, l in g[node]:\n        if d + l < dist[w]:\n            dist[w] = d + l\n            heapq.heappush(heap, (dist[w], w))\n\nfor i in range(1, n):\n    print(dist[i] if dist[i] < inf else -1) "
 ],
 "3516": [
  "import heapq\n\nn = int(input())\nlevels = []\nfor i in range(n):\n    x, s, *a = map(int, input().split())\n    # Add both the regular completion times and the shortcut time to the heap\n    # We also add n+1 to represent having the best item (highest number)\n    heap = [(a[j], j) for j in range(n+1)]\n    heap[x] = (s, x)\n    heapq.heapify(heap)\n    levels.append(heap)\n\n# Use a set to keep track of which levels we've completed\ncompleted = set()\n# Start with the best item (highest number) and add the completion time of the first level\ntime = levels[0][n][0]\ncompleted.add(levels[0][n][1])\n\nwhile len(completed) < n:\n    # Find the level that can be completed the fastest with the current inventory\n    min_time = float('inf')\n    min_level = None\n    for i in range(n):\n        if i not in completed and levels[i][0][1] not in completed and levels[i][0][0] < min_time:\n            min_time = levels[i][0][0]\n            min_level = i\n\n    # Check if we can complete the level using a shortcut\n    shortcut = levels[min_level][0][1]\n    if shortcut in completed:\n        time += min_time\n    else:\n        completed.add(shortcut)\n        time += levels[min_level][shortcut][0]\n\n    # Remove the completed level and update the inventories\n    completed.add(min_level)\n    for i in range(n):\n        # If the shortcut item for level i is the completed level, update it accordingly\n        if levels[i][0][1] == min_level:\n            levels[i][0] = (levels[i][shortcut][0], shortcut)\n        # Otherwise, just remove the completed level from the inventory\n        else:\n            for j in range(n+1):\n                if levels[i][j][1] == min_level:\n                    levels[i][j] = (float('inf'), -1)\n                    break\n\nprint(time)"
 ],
 "3517": [
  "import sys\nfrom collections import deque\n\ndef dfs(node):\n    global mx\n    global rvrse\n    for nd in rvrse[node]:\n        if nd not in done:\n            done.add(nd)\n            dfs(nd)\n    mx=max(mx,val[node])\n    return\n\nn=int(input().strip())\ndata=[]\nfor i in range(n):\n    temp=[int(k) for k in input().strip().split(\" \")]\n    if len(temp)==1:\n        temp.append(0)\n    else:\n        temp=temp[1:]\n    data.append(temp)\nedges=[[] for x in range(n)]\nrvrse=[[] for x in range(n)]\nfor i in range(n):\n    temp=[int(k)-1 for k in input().strip().split(\" \")]\n    for nd in temp[1:]:\n        edges[i].append(nd)\n        rvrse[nd].append(i)\n        pass\n    pass\n\ndone=set([n-1])\nmx=0\nval=[data[n-1][0]]\nfor ii in range(n-2,-1,-1):\n    if ii==0:\n        val.append(data[ii][0])\n    else:\n        best=10**100\n        for ed in edges[ii]:\n            best=min(best,val[ed])\n        val.append(data[ii][0]+best)\n        pass\n    pass\ndfs(0)\nans=mx\nfor ii in range(n):\n    if ii in done:\n        v1=mx-val[ii]\n        best=10**100\n        for ed in rvrse[ii]:\n            if ed not in done:\n                best=min(best,val[ed])\n                continue\n            pass\n        v1+=best\n        ans=min(ans,v1)\n    pass\n\nprint(ans)"
 ],
 "3518": [
  "from collections import defaultdict, deque\n\nn, m = map(int, input().split())\ngraph = defaultdict(list)\nfor i in range(m):\n    p, q, c = map(int, input().split())\n    graph[p].append((q, c))\n    graph[q].append((p, c))\n\nvisited = [False] * (n+1)\ntotal_co2 = 0\nfor i in range(1, n+1):\n    if not visited[i]:\n        group_co2 = 0\n        group_size = 0\n        q = deque([i])\n        while q:\n            curr = q.popleft()\n            if visited[curr]:\n                continue\n            visited[curr] = True\n            group_size += 1\n            for neighbor, co2 in graph[curr]:\n                if not visited[neighbor]:\n                    group_co2 += co2\n                    q.append(neighbor)\n        if group_size % 2 != 0:\n            print(\"impossible\")\n            break\n        else:\n            total_co2 += group_co2\n\nif all(visited):\n    print(total_co2)"
 ],
 "3519": [
  "n = int(input())\nprint(\"{:.9f}\".format(n + n/(n-1)))"
 ],
 "3520": [
  "n, p, c = map(int, input().split())\npills = []\nfor i in range(p):\n    t, x, y = map(int, input().split())\n    pills.append((t, x, y))\n\ndp = [0] * (n+1)  # dp[i] stores the maximum age at time i\nfor i in range(1, n+1):\n    dp[i] = dp[i-1] + 1\n    for t, x, y in pills:\n        if i >= t:\n            prev_time = max(0, i-x)  # the time taking the pill would start, making sure it doesn't go below 0\n            dp[i] = max(dp[i], dp[prev_time + t-x] + y)\n\nprint('{0:.9f}'.format(dp[n]))  # printing with 9 decimal places of precision"
 ],
 "3521": [
  "import math\n\nn = int(input())\n\nscore = 0\n\nfor i in range(n):\n    t, s, a = map(float, input().split())\n    score += t - s * min(abs(a - b) for b in [c[2] for c in stars])\n    \nprint(\"{:.6f}\".format(score))"
 ],
 "3522": [
  "import sys\n\nn, k = map(int, input().split())\nbatteries = sorted(list(map(int, input().split()))) # sort the batteries in ascending order\n\n# Use binary search to find the minimum difference d that satisfies the constraints\nleft = 0 # minimum possible difference\nright = 10**9 # maximum possible difference\nwhile left < right:\n    mid = (left + right) // 2 # middle value in the range\n    ok = True # set flag to true if we can find a valid allocation for this d\n    for i in range(n):\n        x = i * 2 * k # index of the first battery for machine i\n        a = batteries[x:x+k] # batteries for the first chip in machine i\n        b = batteries[x+k:x+2*k] # batteries for the second chip in machine i\n        for j in range(k):\n            if b[j] - a[k-1-j] > mid: # check if difference exceeds d\n                ok = False # set flag to false if difference is too large\n                break # no need to check further\n        if not ok:\n            break # no need to check further\n    if ok:\n        right = mid # d is too large, look for a smaller value\n    else:\n        left = mid + 1 # d is too small, look for a larger value\n\nprint(left)"
 ],
 "3523": [
  "# Read input values\nP = int(input())\nN1, N5, N10, N25 = map(int, input().split())\n\n# Calculate the maximum number of coins that can be used\nnum_coins = 0\nfor num_25 in range(N25 + 1):\n    for num_10 in range(N10 + 1):\n        for num_5 in range(N5 + 1):\n            num_1 = P - (num_25 * 25 + num_10 * 10 + num_5 * 5)\n            if num_1 >= 0 and num_1 <= N1:\n                num_coins = max(num_coins, num_25 + num_10 + num_5 + num_1)\n\n# Output the result\nif num_coins == 0:\n    print(\"Impossible\")\nelse:\n    print(num_coins)"
 ],
 "3524": [
  "s = input().strip()\ns1 = input().strip()\ns2 = input().strip()\n\nflag = True\nfor i in range(len(s1)-1):\n    if s.find(s1[i]) > s.find(s1[i+1]):\n        flag = False\n        break\n\nif flag:\n    for i in range(len(s2)-1):\n        if s.find(s2[i]) > s.find(s2[i+1]):\n            flag = False\n            break\n            \nif flag:\n    print(\"yes\")\nelse:\n    print(\"no\")"
 ],
 "3525": [
  "from collections import deque\n\nn, l, b = map(int, input().split())\ns, d = map(int, input().split())\n\ngraph = [[] for i in range(n + 1)]\nfor i in range(l):\n    a, b, x, y = map(int, input().split())\n    graph[a].append((b, x, y))\n    graph[b].append((a, x, y))\n\nvisited = [False] * (b + 1)\n\nq = deque()\nq.append((s, 0))\n\nans = 0\nwhile len(q) > 0:\n    curr, m = q.popleft()\n    if curr == d:\n        ans = m\n        break\n    for neighbor in graph[curr]:\n        next_node, lower, upper = neighbor\n        if not visited[lower] and b >= lower >= m:\n            visited[lower] = True\n            q.append((next_node, lower))\n        if not visited[upper] and b >= upper >= m:\n            visited[upper] = True\n            q.append((next_node, upper))\n\nprint(ans)"
 ],
 "3526": [
  "MOD = int(1e9+7)\n\nn, m = map(int, input().split())\n\nsame = [i for i in range(n+1)]   # same[i] represents the representative of the range i belongs to (initially each range has itself as the representative)\nsz = [1]*(n+1)     # sz[i] represents the size of the range i belongs to (initially each range has size 1)\ndiff_exists = [False]*(n+1)   # diff_exists[i] represents whether or not any range containing i has hint 'different'\n\ndef find(x):\n    if same[x] == x:\n        return x\n    same[x] = find(same[x])\n    return same[x]\n\ndef union(x, y):\n    x, y = find(x), find(y)\n    if x != y:\n        same[x] = y\n        sz[y] += sz[x]\n        diff_exists[y] = diff_exists[y] or diff_exists[x]\n\nfor i in range(m):\n    l, r, s = input().split()\n    l, r = int(l), int(r)\n    if s == 'same':\n        while l <= r:\n            union(l, r)\n            l += 1\n            r -= 1\n    else:\n        diff_exists[find(l)] = True\n\nans = 1\nfor i in range(1, n+1):\n    if same[i] == i:\n        if diff_exists[i]:\n            ans = (ans*2)%MOD\n        else:\n            ans = (ans*sz[i])%MOD\n\nprint(ans)"
 ],
 "3527": [
  "from collections import defaultdict\nfrom queue import Queue\n\n\ndef bfs(start, adj):\n    \"\"\"\n    BFS function to find the maximum number of hops starting from a given node\n    \"\"\"\n    visited = [False] * len(adj)\n    depth = [0] * len(adj)\n    q = Queue()\n    q.put(start)\n    visited[start] = True\n    while not q.empty():\n        u = q.get()\n        for v in adj[u]:\n            if not visited[v]:\n                visited[v] = True\n                depth[v] = depth[u] + 1\n                q.put(v)\n    return max(depth)\n\n\nc, l = map(int, input().split())\n\n# Creating an adjacency list for the existing network\nadj = defaultdict(list)\nfor _ in range(l):\n    a, b = map(int, input().split())\n    adj[a].append(b)\n    adj[b].append(a)\n\nmax_hops = 0\nfor i in range(c):\n    # Run BFS starting from each node\n    max_hops = max(max_hops, bfs(i, adj))\n\nprint(max_hops)"
 ],
 "3528": [
  "from operator import itemgetter\n\ndef area(p1, p2, p3):\n    return 0.5 * abs(p1[0]*p2[1] + p2[0]*p3[1] + p3[0]*p1[1] - p1[1]*p2[0] - p2[1]*p3[0] - p3[1]*p1[0])\n\nn = int(input())\nnails = []\nfor i in range(n):\n    nails.append(tuple(map(int, input().split())))\n\norder = input().strip()\npicks = []\nfor o in order:\n    if o == \"L\":\n        idx = min(range(len(nails)), key=itemgetter(0))\n    elif o == \"R\":\n        idx = max(range(len(nails)), key=itemgetter(0))\n    elif o == \"U\":\n        idx = max(range(len(nails)), key=itemgetter(1))\n    else:\n        idx = min(range(len(nails)), key=itemgetter(1))\n    picks.append(nails[idx])\n    del nails[idx]\n\nfor i in range(n-2):\n    print(\"{:.1f}\".format(area(picks[i], nails[i], picks[i+1])))"
 ],
 "3529": [
  "from collections import defaultdict\nfrom typing import List, Tuple\n\ndef is_spanning_tree_possible(n: int, edges: List[Tuple[str, int, int]], k: int) -> int:\n    blue_edges = 0\n    visited = [False] * n\n    graph = defaultdict(list)\n    for c, u, v in edges:\n        if c == 'B':\n            blue_edges += 1\n        graph[u].append(v)\n        graph[v].append(u)\n    if blue_edges < k:\n        return 0\n    \n    def dfs(u: int) -> int:\n        visited[u] = True\n        cnt_blue = 0\n        for v in graph[u]:\n            if not visited[v]:\n                cnt_blue += dfs(v)\n        return cnt_blue + (1 if u == 0 else 0)\n    \n    return 1 if dfs(0) == k else 0\n\nn, m, k = map(int, input().split())\nedges = []\nfor _ in range(m):\n    edge = input().split()\n    c, u, v = edge[0], int(edge[1]) - 1, int(edge[2]) - 1\n    edges.append((c, u, v))\nprint(is_spanning_tree_possible(n, edges, k))"
 ],
 "3530": [
  "n = int(input())\ncoasters = []\nfor i in range(n):\n    a_i, b_i, t_i = map(int, input().split())\n    coasters.append((a_i, b_i, t_i))\n\nq = int(input())\nfor i in range(q):\n    T_i = int(input())\n    total_fun = 0\n    for a_i, b_i, t_i in coasters:\n        num_runs = T_i // t_i\n        fun = max(0, a_i - (num_runs - 1)**2 * b_i)\n        total_fun += fun\n    print(total_fun)"
 ],
 "3531": [
  "import heapq\n\nn, m, k, w = map(int, input().split())\n\nspecial = set(int(input()) for _ in range(k))\ngraph = [[] for _ in range(n + 1)]\n\nfor _ in range(m):\n    a, b, c = map(int, input().split())\n    graph[a].append((b, c))\n    graph[b].append((a, c))\n    \ndef dijkstra(start):\n    dist = [float('inf')] * (n + 1)\n    dist[start] = 0\n    heap = [(0, start)]\n    \n    while heap:\n        d, node = heapq.heappop(heap)\n        \n        if dist[node] < d:\n            continue\n            \n        for neighbor, weight in graph[node]:\n            cost = weight\n            if node in special and neighbor not in special:\n                cost += w\n            if dist[neighbor] > dist[node] + cost:\n                dist[neighbor] = dist[node] + cost\n                heapq.heappush(heap, (dist[neighbor], neighbor))\n                \n    return dist\n\nmin_cost = float('inf')\n\nfor i in range(1, k + 1):\n    dist = dijkstra(i)\n    for j in range(1, n + 1):\n        if i != j:\n            if not(special & {i, j}):\n                min_cost = min(min_cost, dist[j])\n\nif min_cost == float('inf'):\n    print(-1)\nelse:\n    print(min_cost)"
 ],
 "3532": [
  "s = input().rstrip()\nexplosion = input().rstrip()\n\nstack = []\n\nfor c in s:\n    stack.append(c)\n    if len(stack) >= len(explosion) and stack[-len(explosion):] == list(explosion):\n        for _ in range(len(explosion)):\n            stack.pop()\n\nif stack:\n    print(\"\".join(stack))\nelse:\n    print(\"FRULA\")"
 ],
 "3533": [
  "n = int(input())\nentrances = []\nexits = []\nfor i in range(n):\n    a, b = map(int, input().split())\n    entrances.append(a)\n    exits.append(b)\n\ncost = sum([abs(e - entr) for e, entr in zip(exits, entrances)]) # initial cost\n\nfor i in range(n):\n    for j in range(i+1, n):\n        if entrances[i] != entrances[j] and exits[i] != exits[j]:\n            new_cost = cost - abs(exits[i] - entrances[i]) - abs(exits[j] - entrances[j]) + \\\n                abs(exits[i] - entrances[j]) + abs(exits[j] - entrances[i])\n            cost = min(cost, new_cost)\nprint(cost)"
 ],
 "3534": [
  "n = int(input())\na = list(map(int, input().split()))\n\nlow, high = 0, 2*10**9\nwhile low < high:\n    mid = (low+high)//2\n    prev = a[0]\n    cnt = 1\n    for i in range(1, n):\n        if a[i] == prev:\n            cnt += 1\n        elif a[i] > prev:\n            if (a[i]-prev)%mid != 0:\n                prev = a[i] - (a[i]-prev)%mid\n            cnt += 1\n        else:\n            if (prev-a[i])%mid != 0:\n                prev = a[i] + (prev-a[i])%mid\n            cnt += 1\n    if cnt == n:\n        break\n    elif cnt > n:\n        low = mid+1\n    else:\n        high = mid\n\nprint(n)\nprint(mid)"
 ],
 "3535": [
  "MOD = 10**9 + 7\n\ndef count_states(n, m, k, queries):\n    # Initializing the grid with unknown spin represented by 0\n    grid = [[0 for j in range(m)] for i in range(n)]\n    # Filling the grid with the known spin values from the queries\n    for s, y, x in queries:\n        grid[y-1][x-1] = 1 if s == '+' else -1\n    # Counting the number of subgrids that violate the condition\n    bad_count = 0\n    for i in range(n-1):\n        for j in range(m-1):\n            subgrid_sum = grid[i][j] + grid[i+1][j] + grid[i][j+1] + grid[i+1][j+1]\n            if subgrid_sum != 0:\n                bad_count += 1\n    # If there are any invalid subgrids, return 0\n    if bad_count > 0:\n        return 0\n    # Counting the number of unknown spin electrons\n    unknown_count = n * m - k\n    # Calculating the number of valid states using the formula\n    return pow(2, unknown_count, MOD)\n\nn, m, k = map(int, input().split())\nqueries = []\nfor i in range(k):\n    s, y, x = input().split()\n    queries.append((s, int(y), int(x)))\nprint(count_states(n, m, k, queries))"
 ],
 "3536": [
  "MOD = 10**9 + 7\n\ndef read():\n    return map(int, input().split())\n\nn = int(input())\np = [0] * (n + 1)\nb = [0] * (n + 1)\n\nfor i in range(1, n + 1):\n    b[i], p[i] = read()\n\nf = [[0] * (n + 1) for _ in range(n + 1)]\ng = [[0] * (n + 1) for _ in range(n + 1)]\n\nfor i in range(n, 0, -1):\n    if not p[i]:\n        f[i][0] = 1\n        g[i][0] = 1\n    else:\n        f[p[i]][0] = 1\n        g[p[i]][0] = 1\n        for j in range(b[i]):\n            f[p[i]][j + 1] = (f[p[i]][j + 1] + f[i][j]) % MOD\n            g[p[i]][j + 1] = (g[p[i]][j + 1] + g[i][j]) % MOD\n        for j in range(b[i] + 1, b[p[i]] + 1):\n            g[p[i]][b[i]] = (g[p[i]][b[i]] + f[i][j]) % MOD\n\nres = [1] + [0] * n\n\nfor i in range(1, n + 1):\n    for j in range(i):\n        for k in range(b[i]):\n            res[i] = (res[i] + res[j] * f[i][k] % MOD * g[i][k + 1] % MOD) % MOD\n\nfor i in range(1, n + 1):\n    for j in range(1, b[i] + 1):\n        f[i][j] = (f[i][j] + f[i][j - 1]) % MOD\n    for j in range(1, b[i]):\n        g[i][j] = (g[i][j] + g[i][j - 1]) % MOD\n\nAns = 0\n\nfor i in range(1, n + 1):\n    for j in range(b[i] + 1):\n        for k in range(j + 1, b[i] + 1):\n            Ans = (Ans + res[i] * f[i][j] % MOD * g[i][k] % MOD) % MOD\n\nprint(Ans * pow(2, MOD - 2, MOD) % MOD)"
 ],
 "3537": [
  "from heapq import heappop, heappush\n\nINF = 10 ** 18\n\n\ndef dijkstra(s, adj, dist):\n    hq = [(0, s)]\n    while hq:\n        w, u = heappop(hq)\n        if dist[u] < INF:\n            continue\n        dist[u] = w\n        for v, wt in adj[u]:\n            if dist[v] < INF:\n                continue\n            heappush(hq, (w + wt, v))\n\n\nn, m = map(int, input().split())\nadj = [[] for _ in range(n)]\nfor i in range(m):\n    a, b, s, e = map(int, input().split())\n    a -= 1\n    b -= 1\n    adj[a].append((b, (e - s) ** 2 + s ** 2 - 2 * s * e))\n    adj[b].append((a, (e - s) ** 2 + e ** 2 - 2 * s * e))\ndist = [INF] * n\ndijkstra(0, adj, dist)\nprint(dist[-1])"
 ],
 "3538": [
  "from heapq import heapify, heappush, heappop\n\nn, d = map(int, input().split())\n\nfrogs = []\n\nfor _ in range(n):\n    l, w, h = map(int, input().split())\n    frogs.append((h, l, w))\n\nheapify(frogs)\n\nstacks = []\nmax_frogs = 0\n\nwhile frogs:\n    curr_frog = heappop(frogs)\n    if curr_frog[0] + curr_frog[1] > d:\n        continue\n    new_stack = [(curr_frog[2], curr_frog[0])]\n    for idx, stack in enumerate(stacks):\n        if curr_frog[2] + sum(t[0] for t in stack) > d:\n            continue\n        new_stack = stack + new_stack\n        stacks.pop(idx)\n        break\n    stacks.append(new_stack)\n    size = sum([len(stack) for stack in stacks])\n    max_frogs = max(max_frogs, size)\n\nprint(max_frogs)"
 ],
 "3539": [
  "MOD = int(1e9) + 7\nn = int(input())\ncnt = 0\n\n# check if total vertices is odd\nfor i in range(n):\n    a, b = map(int, input().split())\n    cnt += (a * b) % 2\n\n# output based on parity of cnt\nif cnt == 0 or cnt == n:\n    print(pow(2, n, MOD))\nelse:\n    print(0)"
 ],
 "3540": [
  "from collections import deque\n\n# read the input\nstate = [input() for i in range(4)]\n\n# define the goal state\ngoal = ['RRRR', 'GGGG', 'BBBB', 'YYYY']\n\n# initialize the hash set to keep track of visited states\nvisited = set()\n\n# define the possible moves\nmoves = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n# define the BFS function to find the minimum number of moves to reach the goal state\ndef bfs(initial_state, goal_state):\n    # initialize the queue with the initial state and its distance\n    queue = deque([(initial_state, 0)])\n    # loop until the queue is empty\n    while queue:\n        # pop the first state in the queue and its distance\n        current, distance = queue.popleft()\n        # check if the current state is equal to the goal state\n        if current == goal_state:\n            return distance\n        # add the current state to the visited hash set\n        visited.add(tuple(current))\n        # loop over all possible moves\n        for move in moves:\n            # apply the move to the current state by shifting the rows or columns\n            new_state = [[0 for i in range(4)] for j in range(4)]\n            for i in range(4):\n                for j in range(4):\n                    new_i = (i + move[0]) % 4\n                    new_j = (j + move[1]) % 4\n                    new_state[new_i][new_j] = current[i][j]\n            # if the new state has not been visited, add it to the queue with its distance\n            if tuple(new_state) not in visited:\n                queue.append((new_state, distance + 1))\n\n# call the bfs function and print the minimum number of moves\nprint(bfs(state, goal))"
 ],
 "3541": [
  "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\ndiff = sum(a) - sum(b)\nres = [\"A\" if a[i] > b[i] else \"B\" for i in range(n)]\nres_diff = abs(diff)\n\nfor i in range(n):\n    for j in range(n):\n        if res[i] == \"B\" and res[j] == \"A\":\n            new_diff = diff + 2*(b[i] - a[i]) + 2*(a[j] - b[j])\n            if abs(new_diff) < res_diff:\n                res_diff = abs(new_diff)\n                res[i], res[j] = res[j], res[i]\n\nprint(\"\".join(res))"
 ],
 "3542": [
  "n, m = map(int, input().split())\na1_x, a1_y = map(int, input().split())\na2_x, a2_y = map(int, input().split())\nb1_x, b1_y = map(int, input().split())\nb2_x, b2_y = map(int, input().split())\n\n# check if the two wires share a common vertex\nif (a1_x == b1_x and a1_y == b1_y) or (a1_x == b2_x and a1_y == b2_y) or (a2_x == b1_x and a2_y == b1_y) or (a2_x == b2_x and a2_y == b2_y):\n    print(\"IMPOSSIBLE\")\nelse:\n    # calculate the minimum length of wire needed to connect the points\n    distance1 = abs(a1_x - a2_x) + abs(a1_y - a2_y)\n    distance2 = abs(b1_x - b2_x) + abs(b1_y - b2_y)\n    print(distance1 + distance2 + 2"
 ],
 "3543": [
  "n, m = map(int,input().split())\nwords = [input().strip() for i in range(n)]\n\npre_dict = {}\nfor w in words:\n    for i in range(1,len(w)+1):\n        pre_dict[w[:i]] = w\n\nfor i in range(m):\n    w = input().strip()\n    i, j, cnt = 0, 0, 0\n    while i<len(w):\n        cnt += 1\n        if w[i:] in pre_dict:\n            j = len(pre_dict[w[i:]])\n            i += j\n        else:\n            while j>0:\n                if w[i-j:i] in pre_dict:\n                    cnt += 1\n                    j = len(pre_dict[w[i-j:i]]) - j + 1\n                    break\n                j -= 1\n            else:\n                i += 1\n    print(cnt-1)"
 ],
 "3544": [
  "n = int(input())\ngroups = list(map(int, input().split()))\n\nmax_row_width = 1\nfor i in range(1, n+1):\n    group_size = i\n    num_groups = groups[i-1]\n\n    while num_groups > 0:\n        row_width = group_size * num_groups\n        if row_width > 12:\n            row_width = 12\n        max_row_width = max(max_row_width, row_width)\n\n        # reduce the number of groups that can still be seated\n        total_seats_used = row_width * (num_groups - 1) + group_size\n        num_groups -= 1 if total_seats_used >= sum(groups) else 0\n\nprint(max_row_width if max_row_width <= 12 else \"impossible\")"
 ],
 "3545": [
  "preorder = input().rstrip()\ninorder = input().rstrip()\npostorder = input().rstrip()\n\ndef build(pre, ino, po):\n    if not pre:\n        return None\n    node = pre[0]\n    left_ino = ino[:ino.index(node)]\n    right_ino = ino[ino.index(node)+1:]\n    left_pre = pre[1:len(left_ino)+1]\n    right_pre = pre[len(left_ino)+1:]\n    left_po = po[:len(left_ino)]\n    right_po = po[len(left_ino):-1]\n    return [\n        node,\n        build(left_pre, left_ino, left_po),\n        build(right_pre, right_ino, right_po)\n    ]\n\ndef traverse(pre, ino, post):\n    if not pre:\n        return []\n    if len(pre) == 1:\n        return [pre[0]]\n    root = pre[0]\n    left_subtree = ino[:ino.index(root)]\n    right_subtree = ino[ino.index(root)+1:]\n    left_pre = [pre[1+i] for i in range(len(left_subtree))]\n    right_pre = [pre[-1-len(right_subtree)+1+i] for i in range(len(right_subtree))]\n    left_post = [post[i] for i in range(len(left_subtree))]\n    right_post = [post[-1-len(right_subtree)+1+i] for i in range(len(right_subtree))]\n    return traverse(left_pre, left_subtree, left_post) + \\\n           traverse(right_pre, right_subtree, right_post) + \\\n           [root]\n\npossible_orders = [\n    (\"Pre Pre In In Post Post\", \"root Pre-order: \", \"In-order: \", \"Post-order: \"),\n    (\"Pre In Pre Post In Post\", \"root Pre-order: \", \"In-order: \", \"Post-order: \"),\n    (\"Post In Pre In Post Pre\", \"root Pre-order: \", \"In-order: \", \"Post-order: \"),\n    (\"Post In In Pre Pre Post\", \"root Pre-order: \", \"In-order: \", \"Post-order: \"),\n    (\"In Pre Pre Post In Post\", \"root Pre-order: \", \"In-order: \", \"Post-order: \"),\n    (\"In Post Pre In Post Pre\", \"root Pre-order: \", \"In-order: \", \"Post-order: \"),\n]\n\nfor order, pre_title, in_title, post_title in possible_orders:\n    calls = order.split()\n    reconstructed_pre = traverse(\n        [preorder[1+i] for i in range(len(calls[:2]))],\n        inorder,\n        [postorder[-2-i] for i in range(len(calls[:2]))]\n    )\n    reconstructed_in = traverse(\n        [preorder[preorder.index(calls[2])+1+i] for i in range(len(calls[2:4]))],\n        inorder[inorder.index(calls[2])+1:inorder.index(calls[3])],\n        [postorder[postorder.index(calls[3])+i] for i in range(len(calls[2:4]))]\n    )\n    reconstructed_post = traverse(\n        [preorder[-2-i] for i in range(len(calls[4:]))],\n        inorder,\n        [postorder[i] for i in range(len(calls[4:]))]\n    )\n    if reconstructed_pre and reconstructed_in and reconstructed_post:\n        print(order)\n        print(pre_title + ''.join(reconstructed_pre))\n        print(in_title + ''.join(reconstructed_in))\n        print(post_title + ''.join(reconstructed_post))\n        break"
 ],
 "3546": [
  "from itertools import product\n\nn = int(input())\n\nproofs = []\nfor i in range(n):\n    p, *dep = map(int, input().split())\n    proofs.append((p, dep))\n\nmin_length = float('inf')\n\nfor selected in product([True, False], repeat=n):\n    if not selected[0]:\n        continue\n    length = sum(proofs[i][0] for i in range(n) if selected[i])\n    deps = set()\n    for i in range(n):\n        if selected[i]:\n            deps |= set(proofs[i][1])\n    if all(selected[d] for d in deps):\n        min_length = min(min_length, length)\n\nprint(min_length)"
 ],
 "3547": [
  "n = int(input())\nplots = []\nfor i in range(n):\n    x1, y1, x2, y2 = map(float, input().split())\n    plots.append((x1, y1, x2, y2))\n\n# find the minimum and maximum x and y coordinates\nmin_x = min(plot[0] for plot in plots)\nmax_x = max(plot[2] for plot in plots)\nmin_y = min(plot[1] for plot in plots)\nmax_y = max(plot[3] for plot in plots)\n\n# initialize the area to 0\narea = 0\n\n# loop through all the points in the grid and check if they are covered by any of the plots\nfor x in range(int(min_x), int(max_x) + 1):\n    for y in range(int(min_y), int(max_y) + 1):\n        for plot in plots:\n            if x >= plot[0] and x < plot[2] and y >= plot[1] and y < plot[3]:\n                area += 1\n                break\n\n# output the area in the required format\nprint(\"{:.2f}\".format(area))"
 ],
 "3548": [
  "python\nMOD = 1000000007\n\nn,p = map(int, input().split())\nbad_pairs = []\nfor i in range(p):\n    a,b = map(int, input().split())\n    if(a>b):\n        a,b = b,a\n    bad_pairs.append((a,b))\n\nbad_pairs = sorted(bad_pairs, key = lambda x:(x[0],x[1]))\n\ndef find(n,k):\n    mul = 1\n    rem = n-k+1\n    while(n>k):\n        mul = mul*n%MOD\n        n -= 1\n    while(rem>1):\n        mul = mul*pow(rem, MOD-2, MOD)%MOD\n        rem -= 1\n    return mul\n\nans = 1\ncur_idx = 1\nfor pair in bad_pairs:\n    p,q = pair\n    if(q<cur_idx):\n        continue\n    x = q-cur_idx\n    if(x>=1):\n        y = min(p-cur_idx, x)\n        ans = ans*find(x,y)%MOD\n        cur_idx += y\n    if(cur_idx<q):\n        ans = 0\n        break\n\nif(cur_idx<=n):\n    ans = ans*find(n-cur_idx+1,n-cur_idx+1)%MOD\n\nprint(ans)"
 ],
 "3549": [
  "from math import gcd\nm1, m2, m3 = map(int, input().split())\nx1, x2, x3 = map(int, input().split())\ny1, y2, y3 = map(int, input().split())\nM = m1*m2*m3\nM1, M2, M3 = M//m1, M//m2, M//m3\n\ndef solve(m, x, y):\n    A, B = [], []\n    for i in range(y+1):\n        A.append((x+i)%m)\n        B.append((x-i)%m)\n    B.sort()\n    Ans = A[0]\n    st, fx = 0, 0\n    for i in range(y+1):\n        while fx+1<len(B) and B[fx+1] <= A[i]:\n            fx+=1\n        while st+1<=fx and B[st] < A[i]-y:\n            st+=1\n        if st<=fx:\n            Ans = min(Ans, B[st])\n    return Ans\n\nM1_inv = pow(M1% m1, -1, m1) \n\nans = x1 * M1 * M1_inv\nans = (ans + solve(m2, (x2 - ans % m2 + m2) % m2, y2) * M2) % M\nans = (ans + solve(m3, (x3 - ans % m3 + m3) % m3, y3) * M3) % M\n\nprint(ans)"
 ],
 "3550": [
  "variables = {}  # dictionary to store variable names and their values\n\ndef get_value(name):\n    \"\"\"\n    Gets the value of a variable.\n    If the name is a string literal (enclosed in quotes), returns the string without the quotes.\n    If the name is a template literal, evaluates the expressions inside and returns the resulting string.\n    \"\"\"\n    if name[0] == name[-1] == '\"':  # string literal: return the string without quotes\n        return name[1:-1]\n    elif name[0] == name[-1] == '`':  # template literal: evaluate expressions inside\n        result = \"\"\n        parts = name[1:-1].split(\"${\")  # split the template literal into parts separated by \"${\"\n        for i, part in enumerate(parts):\n            if i == 0:  # first part is not an expression, so just append it as is\n                result += part\n            else:\n                expr, rest = part.split(\"}\", maxsplit=1)  # get expression and rest of the string\n                result += str(evaluate(expr)) + rest  # evaluate expression and append rest of string\n        return result\n    else:  # variable name: return its value\n        return variables[name]\n\ndef evaluate(expr):\n    \"\"\"\n    Evaluates an expression in NenScript and returns the resulting value as a string.\n    The expression can be a variable name or a template literal.\n    \"\"\"\n    if expr in variables:  # variable name: return its value\n        return variables[expr]\n    else:  # template literal: evaluate expressions inside\n        return get_value(expr)\n\nwhile True:\n    command = input().strip()\n    if command == \"end.\":\n        break\n    elif command.startswith(\"var\"):  # variable declaration: add variable to dict with its value\n        parts = command.split(\" = \")\n        name = parts[0].split()[-1]\n        value = parts[1][:-1]  # remove semicolon at end\n        variables[name] = get_value(value)\n    elif command.startswith(\"print\"):  # print request: evaluate expression and print value\n        expr = command.split(\" \", maxsplit=1)[1][:-1]  # remove semicolon at end\n        print(evaluate(expr))"
 ],
 "3551": [
  "n = int(input())\nbottles = list(map(int, input().split()))\nT = int(input())\n\nmoves = []\n\nwhile T > 0:\n    # Check if T is already in one of the bottles\n    if T in bottles:\n        bottle_idx = bottles.index(T)\n        moves.append(f\"fill {bottle_idx+1}\")\n        T = 0\n    else:\n        # Check if T can be obtained by transferring from one bottle to another\n        found_transfer = False\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    # Transfer from bottle i to bottle j\n                    transfer_vol = min(bottles[i], bottles[j] - bottles[j])\n                    if transfer_vol > 0:\n                        moves.append(f\"transfer {i+1} {j+1}\")\n                        bottles[i] -= transfer_vol\n                        bottles[j] += transfer_vol\n                        if T == bottles[j]:\n                            moves.append(f\"fill {j+1}\")\n                            T = 0\n                        elif T == bottles[i]:\n                            moves.append(f\"discard {i+1}\")\n                            bottles[i] = 0\n                            found_transfer = True\n                            break\n            if found_transfer:\n                break\n        # If T still hasn't been obtained, fill a bottle\n        if T > 0:\n            for i in range(n):\n                if bottles[i] < bottles[bottles.index(max(bottles))]:\n                    moves.append(f\"fill {i+1}\")\n                    bottles[i] = max(bottles)\n                    break\n        # If all bottles are full and T still hasn't been obtained, it's impossible\n        if all(b == max(bottles) for b in bottles) and T > 0:\n            print(\"impossible\")\n            exit()\n\nfor move in moves:\n    print(move)"
 ],
 "3552": [
  "n, m, k = map(int, input().split())\n\n# If we only have one group, then we can just do n damage each turn until all gnomes are dead\nif m == 1:\n    print(n * (n+1) // 2)\nelse:\n    # First, divide the gnomes as evenly as possible among the groups\n    base = n // m\n    remain = n % m\n    \n    # Calculate the damage caused in each turn by the evenly-sized groups\n    damage = base * (base+1) // 2\n    remaining_damage = remain * (base+1) * (base+2) // 2\n    \n    # Calculate the total number of turns required to defeat all the gnomes\n    turns = n - (base * m + remain)\n    \n    # Calculate the remaining damage caused in each turn by the partially-full groups\n    partial_damage = (base * (base-1) // 2) * (m - remain) + (base * (base+1) // 2) * remain\n    \n    # In each turn, subtract the damage caused by the enemy's lightning bolt\n    # and add the damage caused by the gnomes\n    total_damage = damage * turns + remaining_damage\n    total_damage -= (turns // m) * k * m\n    total_damage -= (turns % m) * k\n    total_damage += partial_damage * turns\n    \n    print(total_damage)"
 ],
 "3553": [
  "n, k, m = map(int, input().split())\narr = list(map(int, input().split()))\n\ndef check_subarray():\n    if all(map(lambda x: x > 0, cnt)):\n        return r - l\n    return -1\n\ncnt = [0] * k\nl, r = 0, -1\nans = []\nfor i in range(m):\n    query = input().split()\n    if len(query) == 2:\n        ans.append(check_subarray())\n    else:\n        _, p, v = map(int, query)\n        p -= 1\n        cnt[arr[p]-1] -= 1\n        cnt[v-1] += 1\n        arr[p] = v\n    while l < n and all(map(lambda x: x > 0, cnt)):\n        ans.append(r - l + 1)\n        cnt[arr[l]-1] -= 1\n        l += 1\n    r += 1\nprint('\\n'.join(map(str, ans)))"
 ],
 "3554": [
  "import math\n\nD, W, C = map(int, input().split())\n\ndef calc_dist(x1, y1, x2, y2):\n    return math.sqrt((x1-x2)**2 + (y1-y2)**2)\n\ndef calc_consumption(dist):\n    return dist * 1.0\n\ndef solve(curr_pos, carried_smoothies, remaining_smoothies):\n    # Base case: reached destination, no smoothies left to carry\n    if curr_pos >= D and remaining_smoothies <= 0:\n        return 0\n    \n    # Base case: no smoothies left to carry, but not at destination\n    if remaining_smoothies <= 0:\n        return W - carried_smoothies\n    \n    # Base case: Reached destination, but still have smoothies left to carry\n    if curr_pos >= D:\n        space_available = min(C - carried_smoothies, remaining_smoothies)\n        return space_available + solve(curr_pos, carried_smoothies+space_available, remaining_smoothies-space_available)\n    \n    # Recursive case: try all combinations of taking, leaving or moving containers\n    max_smoothies = 0\n    for i in range(len(smoothie_containers)):\n        for j in range(i, len(smoothie_containers)):\n            x1, y1 = smoothie_containers[i]\n            x2, y2 = smoothie_containers[j]\n            \n            # Try picking up one container\n            if carried_smoothies + y1 <= C:\n                consumption = calc_consumption(calc_dist(curr_pos, 0, x1, y1)) + calc_consumption(calc_dist(x1, y1, x2, y2))\n                max_smoothies = max(max_smoothies, solve(calc_dist(x2, y2, D, 0), carried_smoothies+y1, remaining_smoothies-y1) - consumption)\n                \n            # Try picking up two containers\n            if carried_smoothies + y1 + y2 <= C:\n                consumption = calc_consumption(calc_dist(curr_pos, 0, x1, y1)) + calc_consumption(calc_dist(x1, y1, x2, y2))\n                max_smoothies = max(max_smoothies, solve(calc_dist(x2, y2, D, 0), carried_smoothies+y1+y2, remaining_smoothies-y1-y2) - consumption)\n                \n    # Try not picking up any containers\n    max_smoothies = max(max_smoothies, solve(curr_pos + 1, carried_smoothies, remaining_smoothies))\n    \n    return max_smoothies\n\n# Dummy container at position 0, 0 with 0 smoothies\nsmoothie_containers = [(0, 0)] * (W // 1000)\n\nprint(\"{:.10f}\".format(solve(0, 0, W))) "
 ],
 "3555": [
  "import math\n\nn, m = map(int, input().split())\ntoys = [tuple(map(int, input().split())) for _ in range(n)]\ntrees = [tuple(map(int, input().split())) for _ in range(m)]\nmax_dist = 0\n\nfor i in range(n):\n    curr_pos = toys[i]\n    next_pos = toys[i + 1] if i + 1 < n else (0, 0)\n    dist_to_next = math.dist(curr_pos, next_pos)\n    dist_to_tree = float('inf')\n    for tree in trees:\n        if math.dist(curr_pos, tree) < dist_to_next:\n            dist_to_tree = min(dist_to_tree, math.dist(curr_pos, tree))\n    max_dist = max(max_dist, dist_to_next + dist_to_tree)\n\nprint(\"{:.2f}\".format(max_dist))"
 ],
 "3556": [
  "n, q = map(int, input().split())\n\n# dictionary to store employee information by ID\nemployees = {}\n\n# read employee information\nfor i in range(n):\n    id, salary, height = map(int, input().split())\n    employees[id] = {\"salary\": salary, \"height\": height, \"boss\": None, \"subordinates\": 0}\n\n# sort employees by salary and height to get chairperson\nsorted_employees = sorted(employees.items(), key=lambda x: (-x[1][\"salary\"], -x[1][\"height\"]))\nchairperson_id = sorted_employees[0][0]\n\n# assign immediate boss for each employee\nfor id, info in sorted_employees:\n    boss_id = None\n    for other_id, other_info in sorted_employees:\n        if other_info[\"height\"] >= info[\"height\"] and other_info[\"salary\"] > info[\"salary\"]:\n            boss_id = other_id\n            break\n    info[\"boss\"] = boss_id\n    if boss_id:\n        employees[boss_id][\"subordinates\"] += 1\n\n# handle queries\nfor i in range(q):\n    query_id = int(input())\n    boss_id = employees[query_id][\"boss\"]\n    num_subordinates = employees[query_id][\"subordinates\"]\n    print(f\"{boss_id or 0} {num_subordinates}\")"
 ],
 "3557": [
  "import math\n\nn = int(input())\np = list(map(int, input().split()))\nblown_up_coaches = list(map(int, input().split()))\n\ntotal_chaos = 0\nnum_segments = 1\ncurr_seg_chaos = 0\n\nfor i in range(n):\n    coach_index = blown_up_coaches[i] - 1\n    passengers = p[coach_index]\n    curr_seg_chaos = max(curr_seg_chaos, math.ceil(passengers / 10) * 10)\n    total_chaos += curr_seg_chaos\n    if i == n - 1:\n        break\n    # Start a new segment if the next coach is more than 1 index away\n    if abs(blown_up_coaches[i+1] - blown_up_coaches[i]) > 1:\n        num_segments += 1\n        total_chaos *= num_segments\n        curr_seg_chaos = 0\n\nprint(total_chaos)"
 ],
 "3558": [
  "from math import sqrt\nn, d = map(int, input().split())\ncoord = [0]*n\nfor i in range(n):\n    coord[i] = tuple(map(int, input().split()))\n\n#initialize variables \nans,j = 0,0\nlst = []\n\n#add variables to list\nfor i in range(n):\n    point_location = coord[i][0]\n    x_cord = coord[i][1]\n    height = coord[i][2]\n    while j>0 and lst[j-1][1]>height:\n        j -= 1\n    while lst and x_cord-lst[j-1][0]<=d**2-(height-lst[j-1][1])**2:\n        j -= 1\n    lst[j:j] = [(x_cord,sqrt(d**2-height**2))]\n    if point_location == 1:\n        location_cord = x_cord\n        start = j\n        while j<len(lst)-1 and lst[j+1][1]<=lst[j][1]+x_cord-lst[j][0]:\n            j += 1\n        ans = max(ans,lst[j][0]-location_cord)\n        j = start\nprint(ans)"
 ],
 "3559": [
  "N = int(input())\natt1, armor1 = map(int, input().split())\natt2, armor2 = map(int, input().split())\n\ngrid = []\nfor i in range(N):\n    grid.append(list(input().strip()))\n\nturns = int(input())"
 ],
 "3560": [
  "n = int(input())\nwords = []\nfor i in range(n):\n    words.append(input())\n\nprefixes = {}\nfor word in words:\n    for i in range(len(word)):\n        prefix = word[:i+1]\n        if prefix in prefixes:\n            prefixes[prefix].add(word)\n        else:\n            prefixes[prefix] = {word}\n\nq = int(input())\nshown_words = []\nfor i in range(q):\n    query = list(input().split())\n    if query[0] == '1':\n        shown_words.append(query[1])\n    else:\n        s = int(query[1])\n        count = 0\n        for word in shown_words:\n            for i in range(len(word)):\n                prefix = word[:i+1]\n                if prefix in prefixes and words[s-1] in prefixes[prefix]:\n                    count += 1\n                    break\n        print(count)"
 ],
 "3561": [
  "w, s, c, k = map(int, input().split())\nif max(w, s, c) <= k and min(w, s) + max(w, s, c) <= 2*k:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "3562": [
  "import sys\nfrom scipy.optimize import minimize\n\ndef f(x):\n    total = 0\n    for i in range(n):\n        a,b,c = subj[i]\n        t = x[i]\n        total += (a*t*t + b*t + c)/n\n    return -total\n\nn, T = map(int, input().split())\nsubj = []\nfor i in range(n):\n    subj.append(list(map(float, input().split())))\n\nx0 = [0]*n\nbounds = [(0, T)]*n\n\nres = minimize(f, x0, bounds=bounds)\n\nprint(\"{:.10f}\".format(-res.fun))"
 ],
 "3563": [
  "n = int(input())\nholes = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    holes.append((x,y))\n\nlines = set()\nfor i in range(n-1):\n    for j in range(i+1, n):\n        line = ((holes[i][1]-holes[j][1]), (holes[j][0]-holes[i][0]), (holes[i][0]*holes[j][1]-holes[j][0]*holes[i][1]))\n        if all(line[0]*x + line[1]*y + line[2] >= 0 for x,y in holes) or all(line[0]*x + line[1]*y + line[2] < 0 for x,y in holes):\n            lines.add(line)\n\nprint(len(lines))"
 ],
 "3564": [
  "import math\n\ndef dist(x1, y1, x2, y2):\n    return math.sqrt((x1-x2)**2 + (y1-y2)**2)\n\nn, m, k = map(int, input().split())\n\nislands = []\nfor i in range(n):\n    islands.append(list(map(int, input().split())))\n\npalm_trees = []\nfor i in range(m):\n    palm_trees.append(list(map(int, input().split())))\n\ndistances = {}\nfor i in range(n):\n    for j in range(i+1, n):\n        center1 = (islands[i][0], islands[i][1])\n        center2=  (islands[j][0], islands[j][1])\n        length = dist(*center1, *center2) - islands[i][2] - islands[j][2]\n        if length < 0:\n            length = 0\n        distances[(i, j)] = length\n        distances[(j, i)] = length\n\nfor i in range(n):\n    for j in range(m):\n        center1 = (islands[i][0], islands[i][1])\n        center2 = (palm_trees[j][0], palm_trees[j][1])\n        length = dist(*center1, *center2) - islands[i][2]\n        if length < 0:\n            length = 0\n        distances[(i, j+n)] = length\n        distances[(j+n, i)] = length\n\nfor i in range(m):\n    for j in range(i+1, m):\n        center1 = (palm_trees[i][0], palm_trees[i][1])\n        center2 = (palm_trees[j][0], palm_trees[j][1])\n        length = dist(*center1, *center2) - (palm_trees[i][2] + palm_trees[j][2]) * k\n        if length < 0:\n            length = 0\n        distances[(i+n, j+n)] = length\n        distances[(j+n, i+n)] = length\n\nfor i in range(n):\n    distances[(i, i)] = 0\n\nfor i in range(n+m):\n    for j in range(n+m):\n        if i != j and (i, j) not in distances:\n            distances[(i, j)] = float(\"inf\")\n\nfor k in range(n+m):\n    for i in range(n+m):\n        for j in range(n+m):\n            distances[(i, j)] = min(distances[(i, j)], distances[(i, k)]+distances[(k, j)])\n\nans = float(\"inf\")\nfor i in range(n):\n    for j in range(i+1, n):\n        ans = min(ans, distances[(i, j)] + islands[i][2] + islands[j][2])\n\nif ans == float(\"inf\"):\n    print(\"impossible\")\nelse:\n    print(round(ans))"
 ],
 "3565": [
  "from typing import List, Tuple\nfrom heapq import heappush, heappop\nINF = 10 ** 9\n\n\ndef dijkstra(n: int, adj: List[List[Tuple[int, int]]], start: int) -> List[int]:\n    \"\"\"Dijkstra algorithm to find the shortest paths from a start node to all other nodes in a graph\"\"\"\n    pq = [(0, start)]\n    dist = [INF] * n\n    dist[start] = 0\n    while pq:\n        d, u = heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, w in adj[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                heappush(pq, (dist[v], v))\n    return dist\n\n\nn, m = map(int, input().split())\ncities = [input() for _ in range(n)]\ncity_to_id = {c: i for i, c in enumerate(cities)}\nadj = [[] for _ in range(n)]\nfor _ in range(m):\n    c1, c2, cost = input().split()\n    u, v, w = city_to_id[c1], city_to_id[c2], int(cost)\n    adj[u].append((v, w))\n    adj[v].append((u, w))\n\nstart_nodes = [city_to_id[input().split()[0]] for _ in range(4)]\ntotal_cost = 0\nfor start_node in start_nodes:\n    dist = dijkstra(n, adj, start_node)\n    min_cost = INF\n    for u in range(n):\n        for v, w in adj[u]:\n            cand_cost = dist[u] + w + dijkstra(n, adj, v)[start_node]\n            if cand_cost < min_cost and all(city_to_id[c] in {u, v} for c in start_nodes):\n                min_cost = cand_cost\n    total_cost += min_cost\nprint(total_cost)"
 ],
 "3566": [
  "from bisect import bisect_left\n\nn, q = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculate the initial difference\nleft_sum = sum(a[:n//2])\nright_sum = sum(a[n//2:])\ndiff = abs(left_sum - right_sum)\n\n# Iterate through the queries and update the answer accordingly\nfor _ in range(q):\n    i, x = map(int, input().split())\n    if i < n//2:\n        left_sum += x - a[i]\n    else:\n        right_sum += x - a[i]\n    a[i] = x\n    \n    # Binary search for the optimal position of the food truck\n    left_idx = bisect_left(a[:n//2], x)\n    right_idx = bisect_left(a[n//2:], x)\n    new_diff = abs(sum(a[:left_idx]) - sum(a[left_idx:n//2])) + abs(sum(a[n//2:right_idx+n//2]) - sum(a[right_idx+n//2:]))\n    new_diff += abs(len(a[:left_idx]) - len(a[left_idx:n//2])) + abs(len(a[n//2:right_idx+n//2]) - len(a[right_idx+n//2:]))\n    if new_diff < diff:\n        diff = new_diff\n        print(left_idx+1)\n    else:\n        print(left_idx if len(a[:left_idx]) <= len(a[left_idx:n//2]) else left_idx-1)"
 ],
 "3567": [
  "n, k = map(int, input().split())\ncharacters = [input() for _ in range(n)]\n\ntira_character = ['0'] * k\nfor i in range(k):\n    if all(char[i] == '0' for char in characters) or all(char[i] == '1' for char in characters):\n        tira_character[i] = '0'\n    else:\n        tira_character[i] = '1'\n\nprint(''.join(tira_character))"
 ],
 "3568": [
  "def can_play_frequencies():\n    f = int(input())\n    head_moves = []\n    for _ in range(f):\n        t, n = map(int, input().split())\n        intervals = []\n        for _ in range(n):\n            start, end = map(int, input().split())\n            intervals.append((start, end))\n        intervals.append((float('inf'), float('inf')))\n        current_pos = 0\n        for start, end in intervals:\n            while current_pos != start:\n                current_pos = current_pos + t if current_pos < start else current_pos - t\n                if current_pos < 0:\n                    return \"impossible\"\n            current_pos = end\n    return \"possible\"\n\n\nprint(can_play_frequencies())"
 ],
 "3569": [
  "import math\n\ndef count_opponents(n, opponents):\n    max_opponents = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            # distance between opponent centers\n            d = math.sqrt((opponents[i][0]-opponents[j][0])**2 + (opponents[i][1]-opponents[j][1])**2)\n            # angle between opponent centers and the x-axis\n            theta = math.atan2(opponents[j][1]-opponents[i][1], opponents[j][0]-opponents[i][0])\n            # angle from opponent centers to intersection point(s) with ray from origin\n            phi = math.acos(d/(2*opponents[i][2]))\n            # number of opponents hit by the ray\n            hits = sum(1 for o in opponents if o != opponents[i] and o != opponents[j] and math.sqrt(o[0]**2 + o[1]**2) <= 2*o[2]*math.cos(phi-theta))\n            if hits > max_opponents:\n                max_opponents = hits\n    return max_opponents\n\nn = int(input())\nopponents = []\nfor i in range(n):\n    opponents.append(tuple(map(float, input().split())))\nprint(count_opponents(n, opponents))"
 ],
 "3570": [
  "from collections import deque\n\nnum_events = int(input())\n\nevents = deque()\ndreams = deque()\ndream_count = 0\npossible_events = set()\n\nfor i in range(num_events):\n    line = input().split()\n    action = line[0]\n    \n    if action == \"E\":\n        event = line[1]\n        \n        if event in possible_events:\n            events.append(\"D\")\n            dreams.append(dream_count)\n            possible_events = set()\n            \n        events.append(event)\n        possible_events.add(event)\n        \n    elif action == \"D\":\n        dreams.append(dream_count)\n        dream_count += int(line[1])\n        possible_events = set()\n        \n        while events and events[-1] == \"D\":\n            events.pop()\n            dream_count -= dreams.pop()\n    \n    else:\n        scenario_possible = True\n        \n        k = int(line[1])\n        scenario_events = set(line[2:])\n        \n        for event in scenario_events:\n            if event.startswith(\"!\"):\n                if event[1:] in possible_events:\n                    scenario_possible = False\n                    break\n            \n            else:\n                if event not in possible_events:\n                    scenario_possible = False\n                    break\n        \n        if scenario_possible:\n            print(\"Yes\")\n        else:\n            scenario_possible_with_dream = True\n            \n            if dreams:\n                r = dream_count - dreams[-1]\n                for i in range(r + 1):\n                    possible_dream_events = possible_events.union(set(events[-i-dream_count:-i]))\n                    \n                    dream_scenario_possible = True\n                    \n                    for event in scenario_events:\n                        if event.startswith(\"!\"):\n                            if event[1:] in possible_dream_events:\n                                dream_scenario_possible = False\n                                break\n                            \n                        else:\n                            if event not in possible_dream_events:\n                                dream_scenario_possible = False\n                                break\n                    \n                    if dream_scenario_possible:\n                        print(f\"{r} Just A Dream\")\n                        scenario_possible_with_dream = False\n                        break\n            \n            if scenario_possible_with_dream:\n                print(\"Plot Error\")"
 ],
 "3571": [
  "W, H, F, N = map(int, input().split())\nlines = []\nfor _ in range(N):\n    lines.append(input().strip())\n\nL = sum((len(line)-1)//W + 1 for line in lines)\n\nDENOMINATOR = L - H\nNUMERATOR = F * H\nT = NUMERATOR // DENOMINATOR\n\nprint('+' + '-'*(W-2) + '+-+')\nstart_line = T\nfor i in range(H-2):\n    end_line = start_line + 1\n    if end_line >= len(lines):\n        end_line = len(lines)\n        start_line = end_line - 1\n    else:\n        while end_line < len(lines) and len(lines[end_line]) <= W:\n            end_line += 1\n            start_line += 1\n    window = lines[start_line][:W-1]\n    if len(lines[start_line]) > W:\n        window += 'X'\n    else:\n        window += ' '\n    print('|' + window + '|^|' if i == T else '|' + window + '| |')\n    start_line = end_line\nprint('+' + '-'*(W-2) + '+-+')"
 ],
 "3572": [
  "n, L = map(int, input().split())\nd = [list(map(int, input().split())) for _ in range(n)]\n\n# Floyd-Warshall algorithm for all-pairs shortest paths\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            d[i][j] = min(d[i][j], d[i][k] + d[k][j])\n\n# Try all permutations of control points\nfrom itertools import permutations\nfor perm in permutations(range(n)):\n    # Calculate total distance of the race\n    dist = sum(d[perm[i]][perm[i + 1]] for i in range(n - 1)) + d[perm[-1]][perm[0]]\n    # Check if the distance is exactly L\n    if dist == L:\n        print(\"possible\")\n        break\nelse:\n    print(\"impossible\")"
 ],
 "3573": [
  "import math\n\ndef nCr(n, r):\n    return math.factorial(n) // (math.factorial(r) * math.factorial(n - r))\n\ndef probability(d, i, j, n):\n    return nCr(i, d) * nCr(n - i, d) * nCr(j, d) * nCr(n - j, d) / nCr(n, 2 * d)\n\nn, d, c = map(int, input().split())\n\ncesar_numbers = list(map(int, input().split()))\nraul_numbers = list(map(int, input().split()))\n\ntotal_rounds = 0\nfor i in range(1, n+1):\n    cesar_wins = False\n    raul_wins = False\n    for j in range(1, n+1):\n        if cesar_wins or raul_wins:\n            break\n        prob = probability(d, len(set(cesar_numbers) - set(range(1,i))), len(set(raul_numbers) - set(range(1,j))), n)\n        if set(range(1,i)).issubset(set(cesar_numbers)):\n            cesar_wins = True\n            total_rounds += prob\n        if set(range(1,j)).issubset(set(raul_numbers))):\n            raul_wins = True\n            total_rounds += prob\n        if set(range(1,i)).issubset(set(raul_numbers))):\n            cesar_wins = True\n            total_rounds += prob\n        if set(range(1,j)).issubset(set(cesar_numbers))):\n            raul_wins = True\n            total_rounds += prob\n    if not cesar_wins and not raul_wins:\n        total_rounds += 1\n\nprint(\"{:.8f}\".format(total_rounds))"
 ],
 "3574": [
  "n = int(input())\nnums = list(map(int, input().split()))\nq = int(input())\n\nfor i in range(q):\n    l, r = map(int, input().split())\n    sub_arr = nums[l-1:r]\n    min_el = min(sub_arr)\n    max_el = max(sub_arr)\n    length = r - l + 1\n    if min_el == sub_arr[0] and max_el == sub_arr[length-1]:\n        print(length)\n    else:\n        left = 0\n        while sub_arr[left] != min_el:\n            left += 1\n        right = length - 1\n        while sub_arr[right] != max_el:\n            right -= 1\n        max_len = max(right - left + 1, length - 1)\n        print(max_len)"
 ],
 "3575": [
  "import random\n\nn, m = map(int, input().split())\n\n# adjacency list representation of the graph\ngraph = [[] for _ in range(n)]\nfor _ in range(m):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n    graph[v].append(u)\n\ns, t = map(int, input().split())\n\n# function to simulate the meeting process\ndef simulate(s, t):\n    curr_time = 0       # current time\n    a_pos, b_pos = s, t  # current positions of Alice and Bob\n\n    while a_pos != b_pos:\n        a_neighbours = graph[a_pos]\n        b_neighbours = graph[b_pos]\n\n        # if no neighbors, cannot meet\n        if not a_neighbours or not b_neighbours:\n            return None\n\n        # increment the current time\n        curr_time += 1\n\n        # move to a neighbouring station uniformly at random\n        a_pos = random.choice(a_neighbours)\n        b_pos = random.choice(b_neighbours)\n\n    return curr_time\n\n# run the simulations and compute the expected time\nn_trials = 10**6    # number of times to simulate the meeting process\ntotal_time = 0\nnum_meetings = 0\nfor _ in range(n_trials):\n    meeting_time = simulate(s, t)\n    if meeting_time is not None:\n        total_time += meeting_time\n        num_meetings += 1\n\nif num_meetings > 0:\n    expected_time = total_time / num_meetings\n    print(expected_time)\nelse:\n    print(\"never meet\")"
 ],
 "3576": [
  "R, C, K = map(int, input().split())\n\nMOD = 10**11 + 3\n\n# function to calculate modular exponentiation (a**b % m)\ndef mod_exp(a, b, m):\n    result = 1\n    while b > 0:\n        if b % 2 == 1:\n            result = (result * a) % m\n        a = (a*a) % m\n        b = b // 2\n    return result\n\n# function to calculate modular inverse (a**-1 % m)\ndef mod_inv(a, m):\n    return mod_exp(a, m-2, m)\n\n# numerator\nnumerator = ((2*R - 1) * (2*C - 1)) % MOD\n\n# denominator\ndenominator = ((R*C) % MOD) * (R*C - 1) % MOD\ndenominator = (denominator * mod_inv(2, MOD)) % MOD\ndenominator = (denominator * mod_inv(K+1, MOD)) % MOD\ndenominator = (denominator * mod_inv(K, MOD)) % MOD\n\n# output answer\nanswer = (numerator * mod_inv(denominator, MOD)) % MOD\nprint(answer)"
 ],
 "3577": [
  "n = int(input()) # input number of days\n\nplants = [] \nflowers = [0]*n \n\nfor i in range(n): \n    l, r = map(int, input().split()) \n    plants.append((l, r)) \n\nfor i in range(n): \n    for j in range(i): \n        if plants[i][0] <= plants[j][1] and plants[i][1] >= plants[j][0]: \n            flowers[i] += 1 \n\nprint('\\n'.join(str(f) for f in flowers)) "
 ],
 "3578": [
  "n, r = map(int, input().split())\nflights = [[float('inf')]*n for _ in range(n)]\nfor _ in range(r):\n    a, b, c = map(int, input().split())\n    flights[a-1][b-1] = flights[b-1][a-1] = c\nfor i in range(n):\n    flights[i][i] = 0\nfor k in range(n):\n    for i in range(n):\n        for j in range(n):\n            flights[i][j] = min(flights[i][j], flights[i][k] + flights[k][j])\nf = int(input())\nfor _ in range(f):\n    a, b, c = map(int, input().split())\nprint(min(flights[0][i]+flights[i][0]+min(flights[a-1][i]+flights[b-1][i] for i in range(n)) for a in range(n) for b in range(n)))"
 ],
 "3579": [
  "import numpy as np\n\ndef rectangle_densities(s, a, b):\n    # create an integral image of statisticians\n    integral_image = np.cumsum(np.cumsum(s, axis=0), axis=1)\n    densities = []\n    # loop over all possible rectangle sizes\n    for h in range(1, len(s)+1):\n        for w in range(1, len(s[0])+1):\n            area = h*w\n            if a <= area <= b:\n                # calculate the density of statisticians in the rectangle\n                # using the integral image\n                top_row = range(h, len(s)+1)\n                left_column = range(w, len(s[0])+1)\n                bottom_row = [i-h for i in top_row]\n                right_column = [i-w for i in left_column]\n                numerator = integral_image[top_row, left_column] - \\\n                    integral_image[top_row, right_column] - \\\n                    integral_image[bottom_row, left_column] + \\\n                    integral_image[bottom_row, right_column]\n                density = numerator/(h*w)\n                densities.extend(density.flatten().tolist())\n    return densities\n\nh, w = map(int, input().split())\na, b = map(int, input().split())\ns = np.zeros((h, w))\nfor i in range(h):\n    s[i] = np.array(list(map(int, input().split())))\n\ndensities = rectangle_densities(s, a, b)\nmad = np.median(densities)\nprint('{:.10f}'.format(mad))"
 ],
 "3580": [
  "from collections import defaultdict\n\nn = int(input())\narr = list(map(int, input().split()))\n\n# Build dictionary of indices for each element in the array\nindex_dict = defaultdict(list)\nfor i, a_i in enumerate(arr):\n    index_dict[a_i].append(i)\n\nq = int(input())\nfor _ in range(q):\n    i, m = map(int, input().split())\n    b = set(map(int, input().split()))\n\n    # Initialize variables for the longest subsequence\n    longest_subseq_start = i\n    longest_subseq_end = i - 1\n    longest_subseq_length = 0\n\n    # Iterate through each index of b_1 in the given range\n    for j in index_dict[b.pop()]:\n        if j < i:\n            continue\n\n        # Iterate through each subsequent element of b\n        curr_subseq_start = j\n        curr_subseq_end = j\n        curr_subseq_length = 1\n        for b_i in b:\n            possible_indices = index_dict[b_i]\n            idx = bisect_left(possible_indices, curr_subseq_end)\n            if idx == len(possible_indices):\n                # There is no subsequent occurrence of b_i in the array\n                break\n            else:\n                curr_subseq_end = possible_indices[idx]\n                curr_subseq_length += 1\n\n        # Update variables for the longest subsequence\n        if curr_subseq_length > longest_subseq_length:\n            longest_subseq_start = curr_subseq_start\n            longest_subseq_end = curr_subseq_end\n            longest_subseq_length = curr_subseq_length\n\n    # Output length of longest subsequence\n    print(longest_subseq_length)"
 ],
 "3581": [
  "import sys\ninput = sys.stdin.readline\n\nn = int(input().strip()) # number of rows\nh = n*(n+1)//2 # number of holes\n\nv = list(map(int, input().split())) # payouts\np = [list(map(float, input().split())) for _ in range(h)] # transition probabilities\n\n# Compute the expected payout using dynamic programming\ndp = [0]*h # dp[i] = expected payout starting from hole i\ndp[-1] = v[-1] # the expected payout for the last hole is just its payout value\n\nfor i in range(h-2, -1, -1): # looping over holes from last to first\n    for j in range(5): # looping over possible bounces\n        nxt = i+j+1 # next hole index\n        \n        # Check if next hole exists (it might not exist if the current hole is close to the boundary)\n        if nxt >= h or nxt//n != (i+j)//n + 1:\n            nxt = i # if next hole does not exist, we stay at the same hole\n        \n        # Compute the expected payout using the transition probabilities and the previously computed values\n        dp[i] += p[i][j]*dp[nxt]\n    \n    dp[i] += v[i] # add the payout value for the current hole\n\nprint(\"{:.10f}\".format(dp[0])) # print the expected payout for the starting hole (hole 0)"
 ],
 "3582": [
  "n = int(input())\na = [int(x)-1 for x in input().split()]\nin_degrees = [0] * n\nadj_list = [[] for _ in range(n)]\nfor i, mentor in enumerate(a):\n    adj_list[mentor].append(i)\n    in_degrees[i] += 1\nq = [i for i in range(n) if in_degrees[i] == 0]\nwhile q:\n    i = q.pop()\n    if not adj_list[i]: # isolated node\n        j = (i+1) % n # choose lowest numbered person as mentor\n        adj_list[i].append(j)\n        in_degrees[j] += 1\n    for j in adj_list[i]:\n        in_degrees[j] -= 1\n        if in_degrees[j] == 0:\n            q.append(j)\n            sorted_mentors = sorted(adj_list[j], key=lambda x: (a[x] != j, a[x]))\n            for k in range(len(sorted_mentors)):\n                prev, cur = sorted_mentors[k-1], sorted_mentors[k]\n                if cur != j:\n                    if prev == j: # keep original mentor if possible\n                        adj_list[j] = [cur] + adj_list[j]\n                    else:\n                        adj_list[cur] = adj_list[cur] + [j]\n                    break\nb = [str(x+1) for x in a]\nprint(' '.join(b))"
 ],
 "3583": [
  "import math\n\nn = int(input())\npoints = []\nfor _ in range(n):\n    x, y = map(int, input().split())\n    points.append((x, y))\n\ndef dist(a, b):\n    return math.sqrt((a[0]-b[0])**2 + (a[1]-b[1])**2)\n\ndef circum(a, b, c, d, e, f):\n    return dist(a, b) + dist(b, c) + dist(c, d) + dist(d, e) + dist(e, f)\n\nresult = []\nfor i in range(n):\n    dists = []\n    for j in range(-2, 3):\n        if i + j < 0:\n            k = n + (i+j)\n        else:\n            k = (i+j) % n\n        dists.append((dist(points[i], points[k]), k))\n    dists.sort(reverse=True)\n    max_circum = 0\n    for a in range(3):\n        for b in range(a+1, 4):\n            for c in range(b+1, 5):\n                cur_circum = circum(points[i], points[dists[a][1]], points[dists[b][1]], \n                                    points[dists[c][1]], points[dists[c+1][1]], points[dists[c-1][1]])\n                max_circum = max(max_circum, cur_circum)\n    result.append(max_circum)\n\nfor r in result:\n    print(r)"
 ],
 "3584": [
  "from itertools import combinations\n\nn, m, k = map(int, input().split())\n\nonions = [tuple(map(int, input().split())) for _ in range(n)]\n\nfence_posts = [tuple(map(int, input().split())) for _ in range(m)]\n\ncount = 0\n\nfor comb in combinations(range(m), k):\n    poly = [fence_posts[i] for i in comb]\n    for onion in onions:\n        if all((x2-x1)*(y-y1)-(y2-y1)*(x-x1)<=0 for ((x1,y1),(x2,y2)) in zip(poly,poly[1:]+[poly[0]])) :\n            count += 1\n            break\n\nprint(count)"
 ],
 "3585": [
  "m, k = map(int, input().split())\nMOD = 998244353\nn = 1\nmax_bags = 1\nwhile m >= n and max_bags < k:\n    max_bags = max_bags * k + 1\n    n += 1\nprint((max_bags - 1) % MOD)"
 ],
 "3586": [
  "n = int(input())\ns = set()\nfor i in range(n):\n    s.add(int(input()))\n\nmax_sum = -536870912-1\nfor a in s:\n    for b in s:\n        if a == b:\n            continue\n        c = a + b\n        if c in s and c != a and c != b:\n            max_sum = max(max_sum, c)\nif max_sum == -536870912-1:\n    print(\"no solution\")\nelse:\n    print(max_sum)"
 ],
 "3587": [
  "import sys\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        current = self.root\n        for char in word:\n            if char not in current.children:\n                current.children[char] = TrieNode()\n            current = current.children[char]\n        current.is_end_of_word = True\n\n    def find_longest_non_substring(self, word):\n        current = self.root\n        i = 0\n        longest_non_substring = ''\n\n        while i < len(word):\n            char = word[i]\n\n            if char in current.children:\n                i += 1\n                current = current.children[char]\n            else:\n                break\n\n        # If we're at the end of the word and it's not a substring,\n        # then the word is itself the longest non-substring.\n        if i == len(word) and not current.is_end_of_word:\n            return word\n\n        # If we're not at the end of the word, traverse the Trie\n        # looking for the longest possible non-substring.\n        stack = [(current, i, '')]\n        while stack:\n            current, i, candidate = stack.pop()\n            if current.is_end_of_word:\n                if len(candidate) > len(longest_non_substring):\n                    longest_non_substring = candidate\n                elif len(candidate) == len(longest_non_substring) and candidate < longest_non_substring:\n                    longest_non_substring = candidate\n\n            if i == len(word):\n                continue\n\n            char = word[i]\n\n            if char not in current.children:\n                continue\n\n            stack.append((current, i+1, candidate))\n\n            next_node = current.children[char]\n            next_candidate = candidate+char\n\n            stack.append((next_node, i+1, next_candidate))\n\n        return longest_non_substring or '-1'\n\nif __name__ == '__main__':\n    n = int(sys.stdin.readline().strip())\n\n    # Build the Trie with the taboo strings.\n    trie = Trie()\n    for i in range(n):\n        s = sys.stdin.readline().strip()\n        trie.insert(s)\n\n    # Find the longest non-substring.\n    output = trie.find_longest_non_substring('')\n    if output:\n        print(output)\n    else:\n        print('-1')"
 ],
 "3588": [
  "from collections import defaultdict\n\n# Taking input\nC = int(input())\nrecords = defaultdict(int)\nfor _ in range(C):\n    K = int(input())\n    for _ in range(K):\n        N, D = map(int, input().split())\n        records[D] += N\n\n# Sorting and printing output\nfor day in sorted(records.keys()):\n    print(records[day], end=' ')"
 ],
 "3589": [
  "L, R = map(int, input().split())\n\ndef digit_product(n):\n    res = 1\n    while n > 0:\n        if n % 10 != 0:\n            res *= n % 10\n        n //= 10\n    return res\n\ncounts = [0]*9\nfor i in range(L, R+1):\n    digit = digit_product(i)\n    counts[digit-1] += 1\n\nprint(*counts)"
 ],
 "3590": [
  "import math\n\ndef distance(x1, y1, x2, y2):\n    return math.sqrt((x1-x2)**2 + (y1-y2)**2)\n\ndef compute_distance(Ax, Ay, Bx, By, Cx, Cy):\n    AB = distance(Ax, Ay, Bx, By)\n    AC = distance(Ax, Ay, Cx, Cy)\n    BC = distance(Bx, By, Cx, Cy)\n    if AB**2 + AC**2 <= BC**2:\n        return AC\n    if AB**2 + BC**2 <= AC**2:\n        return BC\n    return abs((Bx-Ax)*(Cy-Ay) - (By-Ay)*(Cx-Ax)) / AB \n\ndef solve(A, B):\n    n = len(A)\n    m = len(B)\n    ans = float('inf')\n    for i in range(m):\n        Bx, By = B[i]\n        Ax, Ay = B[(i-1+m)%m] # previous point of B\n        j = 0\n        while True:\n            # find the next point of A that can form a cut with (Ax, Ay) and (Bx, By)\n            Cx, Cy = A[j]\n            Dx, Dy = A[(j-1+n)%n] # previous point of A\n            k = compute_distance(Ax, Ay, Bx, By, Cx, Cy) < compute_distance(Ax, Ay, Bx, By, Dx, Dy)\n            if k:\n                ans = min(ans, compute_distance(Ax, Ay, Bx, By, Cx, Cy))\n            else:\n                ans = min(ans, compute_distance(Ax, Ay, Bx, By, Dx, Dy))\n            j = (j+1) % n\n            if j == 0:\n                break\n    return ans * m\n\nn = int(input())\nA = [list(map(int, input().split())) for _ in range(n)]\nm = int(input())\nB = [list(map(int, input().split())) for _ in range(m)]\nprint(\"{:.10f}\".format(solve(A, B)))"
 ],
 "3591": [
  "k = int(input())\nresult = []\nfor _ in range(k):\n    n = int(input())\n    heights = list(map(int, input().split()))\n    alice_index = -1\n    bob_index = -1\n    for i in range(n):\n        if alice_index == -1 and heights[i] > heights[0]:\n            alice_index = i\n        elif bob_index == -1 and heights[i] > heights[alice_index]:\n            bob_index = i\n            break\n    if alice_index < bob_index - 1:\n        result.append(str(_+1))\nprint(len(result))\nprint(\"\\n\".join(result))"
 ],
 "3592": [
  "import math\n\nprofit, pita_profit, pizza_profit = map(float, input().split())\n\npita_count = 0\npizza_count = 0\npossible_combinations = []\n\nfor i in range(math.ceil(profit/pita_profit) + 1):\n    pita_count = i\n    pizza_count = (profit - (pita_profit * pita_count)) / pizza_profit\n    if pizza_count.is_integer() and pizza_count >= 0:\n        possible_combinations.append((int(pita_count), int(pizza_count)))\n\nif possible_combinations:\n    for combination in possible_combinations:\n        print(combination[0], combination[1])\nelse:\n    print(\"none\")"
 ],
 "3593": [
  "n, k = map(int, input().split())\nboard = []\nfor i in range(n):\n  row = list(map(int, input().split()))\n  board.append(row)\n\nsums = []\nfor i in range(n):\n  for j in range(3):\n    if j == 0:\n      sums.append(board[i][j] + board[i][j+1])\n    elif j == 1:\n      sums.append(board[i][j-1] + board[i][j] + board[i][j+1])\n    else:\n      sums.append(board[i][j-1] + board[i][j])\n      \nsums.sort(reverse=True)\nans = 0\nfor i in range(k):\n  ans += sums[i]\nprint(ans)"
 ],
 "3594": [
  "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef get_next_moves(n):\n    moves = []\n    if n == 1:\n        return []\n    for i in range(2, n):\n        if n % i == 0 and is_prime(i):\n            moves.append(i)\n    if is_prime(n):\n        moves.append(n - 1)\n    return moves + [n + 1]\n\ndef play_round(player, n):\n    moves = get_next_moves(n)\n    if not moves:\n        return [player, n]\n    if player == 'O':\n        best_move = min([(n - m, m) for m in moves])\n        return play_round('E', best_move[1])\n    elif player == 'E':\n        best_move = min([(n - m, m) for m in moves])\n        return play_round('I', best_move[1])\n    else:\n        best_move = min([(n - m, m) for m in moves])\n        return [best_move[1], n]\n\nn = int(input())\nscores = {'O': 0, 'E': 0, 'I': 0}\nfor i in range(n):\n    player, n = input().split()\n    player_score, round_num = play_round(player, int(n))\n    scores[player] += round_num\n    scores['O'] += player_score == 'O'\n    scores['E'] += player_score == 'E'\n    scores['I'] += player_score == 'I'\nprint(scores['O'], scores['E'], scores['I'])"
 ],
 "3595": [
  "import math\nn, l = map(int, input().split())\n\nrooms = []\nfor _ in range(n):\n    x1, y1, x2, y2 = map(int, input().split())\n    rooms.append([x1, y1, x2, y2])\n\ndef get_direction(x, y, angle):\n    return [x + l * math.cos(angle), y + l * math.sin(angle)]\n\ndef count_rooms(angle):\n    hits = 0\n    for x1, y1, x2, y2 in rooms:\n        # check if any of the corners of the room is hit by the beam\n        for x, y in [(x1, y1), (x2, y1), (x1, y2), (x2, y2)]:\n            dx, dy = x - x_center, y - y_center\n            if abs(angle - math.atan2(dy, dx)) <= beam_width:\n                hits += 1\n                break \n        else:\n            # check if any of the sides of the room is hit by the beam\n            if x_center - beam_width <= x1 and x2 <= x_center + beam_width:\n                w = x2 - x1\n                if y_center <= y2 and y2 <= y_center + l * math.sin(beam_width) + w * math.cos(beam_width):\n                    hits += 1\n                elif y_center >= y1 and y1 >= y_center - l * math.sin(beam_width) - w * math.cos(beam_width):\n                    hits += 1\n                elif y1 < y_center < y2:\n                    hits += 1\n            elif y_center - beam_width <= y1 and y2 <= y_center + beam_width:\n                h = y2 - y1\n                if x_center <= x2 and x2 <= x_center + l * math.cos(beam_width) + h * math.sin(beam_width):\n                    hits += 1\n                elif x_center >= x1 and x1 >= x_center - l * math.cos(beam_width) - h * math.sin(beam_width):\n                    hits += 1\n                elif x1 < x_center < x2:\n                    hits += 1\n    return hits\n\n# precompute some values that we will reuse\nbeam_width = math.asin(0.5 * l / max(rooms, key=lambda room: max(room)).max())\nx_center = sum(room[0] + room[2] for room in rooms) / n * 0.5\ny_center = sum(room[1] + room[3] for room in rooms) / n * 0.5\n\n# try out different angles and count the number of hits for each\nmax_hits = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        for k in range(4):\n            angle = math.atan2(rooms[i][k % 2 + 2] - rooms[j][k % 2], rooms[i][k % 2] - rooms[j][k % 2 + 2])\n            hits = count_rooms(angle)\n            max_hits = max(max_hits, hits)\nprint(max_hits)"
 ],
 "3596": [
  "from scipy.special import gamma, erf, jv\nimport numpy as np\n\na, b, c = map(float, input().split())\nt1, t2, t3, t4 = map(int, input().split())\nn, k, r, s, l = map(int, input().split())\n\ndef f(x):   \n    return c * ((t1 * gamma(x)) + (np.power(np.log(erf(t3 * x)), 1/t2)) - np.power(jv(k, x), t4))\n\nP = np.zeros(r+1)\nfor i in range(r+1):\n    P[i] = f(0)/np.math.factorial(i)\n\nfor i in range(n):\n    new_p = np.zeros(r+i+1)\n    for j in range(r+i+1):\n        for k in range(j+1):\n            new_p[j] += P[k]*P[i+j-k]\n    P = new_p\n    \ng = np.polyder(P, r+s+1)\n\nans = (g(n)+l)**2/(np.pi*np.exp(1)*l+1)\nprint('%.2f' % ans)"
 ],
 "3597": [
  "from math import sin, cos, acos, atan2, pi, hypot\n\ndef collision(A, B, r):\n    ab = [B[0]-A[0], B[1]-A[1]]\n    ab_mod = hypot(ab[0], ab[1])\n    r2 = r*2\n    if ab_mod > r2:\n        return None\n    delta = cos(acos(ab_mod/2/r)-pi/2)\n    return [delta*ab[0], delta*ab[1]]\n\ndef solve(w, l, r, x1, y1, x2, y2, x3, y3, h):\n    table = [(0,0), (0,l), (w,l), (w,0)]\n    balls = [(x1, y1), (x2, y2), (x3, y3)]\n    for i in range(3):\n        if balls[i][1] > h-r or balls[i][0] < r or balls[i][0] > w-r:\n            return 'impossible'\n\n    lo, hi = 0, w\n    while lo <= hi:\n        d = (lo+hi)/2\n        cue_pos = (d, h-r)\n        b1_pos = (x1, y1)\n        b2_pos = (x2, y2)\n        b3_pos = (x3, y3)\n\n        cue_vel = collision(cue_pos, b1_pos, r)\n        if cue_vel is None:\n            lo = d\n            continue\n        b1_vel = collision(b1_pos, cue_pos, r)\n        if b1_vel is None:\n            lo = d\n            continue\n        b2_vel = collision(b2_pos, b1_pos, r)\n        if b2_vel is None:\n            lo = d\n            continue\n        b3_vel = collision(b3_pos, b1_pos, r)\n        if b3_vel is None:\n            lo = d\n            continue\n\n        cue_vel_angle = atan2(-cue_vel[1], cue_vel[0])\n        b2_final_pos = (0, l+r)\n        b3_final_pos = (w, l+r)\n        b2_final_pos_angle = atan2(b2_final_pos[1]-b2_pos[1], b2_final_pos[0]-b2_pos[0])\n        b3_final_pos_angle = atan2(b3_final_pos[1]-b3_pos[1], b3_final_pos[0]-b3_pos[0])\n        b2_vel_angle = atan2(-b2_vel[1], b2_vel[0])\n        b3_vel_angle = atan2(-b3_vel[1], b3_vel[0])\n\n        def simulate_until_rebound(pos, vel):\n            t, rebounded = 0, False\n            while not rebounded:\n                potential_new_pos = [pos[0]+vel[0], pos[1]+vel[1]]\n                is_moving_to_left = vel[0] < 0\n                is_moving_to_right = vel[0] > 0\n                is_moving_down = vel[1] < 0\n\n                for i in range(4):\n                    A, B, C = table[i-1], table[i], potential_new_pos\n                    if A[1] == B[1] == C[1] and min(A[0], B[0]) <= C[0] <= max(A[0], B[0]):\n                        t = A[1] - pos[1]\n                        pos = [pos[0] + vel[0]*t, A[1]]\n                        vel = [vel[0], -vel[1]]\n                    elif A[0] == B[0] == C[0] and min(A[1], B[1]) <= C[1] <= max(A[1], B[1]):\n                        rebounded = True  # out of the table\n                        break\n                    else:\n                        u, v = B[0]-A[0], B[1]-A[1]\n                        uu, vv = u*u, v*v\n                        uv = u*v\n                        cu, cv = C[0]-A[0], C[1]-A[1]\n                        Fab = cu*v-cv*u\n                        Fbc = cu*vv-cv*uv\n                        Fca = cu*uv-cv*uu\n                        if all(sign(v)>=0 for sign, v in zip((c1, c2, Fab, Fbc, Fca), (u, v, cu*v-cv*u, cu*vv-cv*uv, cu*uv-cv*uu))):\n                            l = hypot(cu, cv)\n                            normal = [-v/l, u/l]\n                            dot = normal[0]*vel[0] + normal[1]*vel[1]\n                            vel = [vel[0]-2*dot*normal[0], vel[1]-2*dot*normal[1]]\n                            pos = potential_new_pos\n\n                            if i==0 and not is_moving_to_left:\n                                rebounded = True\n                                break\n                            if i==2 and not is_moving_to_right:\n                                rebounded = True\n                                break\n                            if i==1 and is_moving_down:\n                                rebounded = True\n                                break\n\n                t2=3.4028234e+38\n                def time_to_rebind(wall):\n                    t_v = (wall[1]-pos[1])/vel[1]\n                    if t_v>0 and wall[0]-r<pos[0]+vel[0]*t_v<wall[0]+r:\n                        return t_v\n                    t_h = (wall[0]-r-pos[0])/vel[0]\n                    if t_h>0 and wall[1]-r<pos[1]+vel[1]*t_h<wall[1]+r:\n                        return t_h\n                    return None\n\n                for wall in table:\n                    t_wall = time_to_rebind(wall)\n                    if t_wall is not None and t_wall<t2:\n                        t2 = t_wall\n                t += t2\n                pos[0] += vel[0]*t2\n                pos[1] += vel[1]*t2\n            return pos, vel, t\n\n        b2_pos, b2_vel, t2 = simulate_until_rebound(b2_pos, b2_vel)\n        if b2_pos[1]+r > l:\n            lo = d\n            continue\n        b2_vel_angle = atan2(-b2_vel[1], b2_vel[0])\n\n        b3_pos, b3_vel, t3 = simulate_until_rebound(b3_pos, b3_vel)\n        if b3_pos[1]+r > l:\n            lo = d\n            continue\n        b3_vel_angle = atan2(-b3_vel[1], b3_vel[0])\n\n        b2_delta_angle = b2_final_pos_angle - b2_vel_angle\n        b3_delta_angle = b3_final_pos_angle - b3_vel_angle\n\n        if abs(cue_vel_angle-b2_delta_angle) > pi/2:\n            lo = d\n            continue\n        if abs(b2_delta_angle-b3_delta_angle) > pi/2:\n            lo = d\n            continue\n\n        return f\"{d:.2f} {b2_delta_angle*180/pi:.2f}\"\n\n    return 'impossible'\n\nif __name__ == '__main__':\n    w, l = map(int, input().split())\n    r, x1, y1, x2, y2, x3, y3, h = map(int, input().split())\n    print(solve(w, l, r, x1, y1, x2, y2, x3, y3, h))"
 ],
 "3598": [
  "n = int(input())\nmagnets = [input().strip() for i in range(n)]\nzero = []\nsix = []\neight = []\nother = []\nfor magnet in magnets:\n    if magnet.count(\"0\") == len(magnet):\n        zero.append(magnet)\n    elif \"6\" in magnet and \"9\" not in magnet:\n        six.append(magnet)\n    elif \"9\" in magnet and \"6\" not in magnet:\n        six.append(magnet[::-1])\n    elif magnet.count(\"8\") == len(magnet):\n        eight.append(magnet)\n    else:\n        other.append(magnet)\nsorted_other = sorted(other, key=lambda x: int(''.join(['6' if i == '9' else '9' if i == '6' else i for i in x[::-1]])))\nfinal = zero + eight + six + sorted_other\nprint(''.join(final))"
 ],
 "3599": [
  "T, N = map(int, input().split())\nbreaks = sorted(list(map(int, input().split())))\nschedule = [0] * N\n\nfor i in range(N):\n    if i < 2:\n        # first two musicians can start immediately\n        schedule[i] = breaks[i]\n    else:\n        # schedule musician i while keeping at most two on break at any time\n        if schedule[i-2] + breaks[i-2] <= schedule[i-1] + breaks[i-1]:\n            schedule[i] = schedule[i-2] + breaks[i-2]\n        else:\n            schedule[i] = schedule[i-1] + breaks[i-1]\n\n# output the time each musician spends on stage before taking a break\nfor time in schedule:\n    print(time, end=\" \")"
 ],
 "3600": [
  "from itertools import combinations\n\ndef dfs(u, p, g, vis, f):\n    if not f:\n        vis[u] = True\n        for v in g[u]:\n            if not vis[v]:\n                dfs(v, u, g, vis, not f)\n    else:\n        vis[u] = False\n        for v in g[u]:\n            if not vis[v]:\n                dfs(v, u, g, vis, not f)\n\nk = int(input())\nn = int(input())\ng = [[] for _ in range(n)]\nfor i in range(n):\n    l = list(map(int, input().split()))[1:]\n    for j in l:\n        g[i].append(j - 1)\n        g[j - 1].append(i)\n\nif k >= n:\n    print(\"possible\")\n    exit()\n\nfor subset in combinations(range(n), k):\n    vis = [False] * n\n    is_possible = True\n    for i in subset:\n        if vis[i]:\n            continue\n        dfs(i, -1, g, vis, False)\n    for i in subset:\n        if vis[i]:\n            is_possible = False\n            break\n    if is_possible:\n        print(\"possible\")\n        exit()\n\nprint(\"impossible\")"
 ],
 "3601": [
  "import math\n\ndef distance(x1, y1, x2, y2):\n    return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n\nn1 = int(input())\nmisha_path = []\nfor _ in range(n1):\n    x, y = map(int, input().split())\n    misha_path.append((x, y))\n\nn2 = int(input())\nnadia_path = []\nfor _ in range(n2):\n    x, y = map(int, input().split())\n    nadia_path.append((x, y))\n\ndp = [[None] * n1 for _ in range(n2)]\n\nfor i in range(n2):\n    for j in range(n1):\n        if i == 0 and j == 0:\n            dp[i][j] = distance(misha_path[j][0], misha_path[j][1], nadia_path[i][0], nadia_path[i][1])\n            continue\n\n        ans = float(\"inf\")\n        if i > 0:\n            ans = min(ans, dp[i - 1][j])\n\n        if j > 0:\n            ans = min(ans, dp[i][j - 1])\n\n        if i > 0 and j > 0:\n            ans = min(ans, dp[i - 1][j - 1])\n\n        dp[i][j] = distance(misha_path[j][0], misha_path[j][1], nadia_path[i][0], nadia_path[i][1]) + ans\n\nif dp[n2 - 1][n1 - 1] >= float(\"inf\"):\n    print(\"impossible\")\nelse:\n    print(\"%.6f\" % dp[n2 - 1][n1 - 1])"
 ],
 "3602": [
  "from collections import defaultdict\n\n# Function to check if a given square is illuminated\ndef is_illuminated(rows, cols, lamps, r, i, j):\n    for lamp in lamps:\n        lamp_i, lamp_j = lamp\n        if abs(lamp_i - i) + abs(lamp_j - j) <= r:\n            if abs(lamp_i - i) <= r:\n                if rows[i][min(lamp_j, j):max(lamp_j, j)+1] == [0]*(max(lamp_j, j)-min(lamp_j, j)+1):\n                    return False\n            if abs(lamp_j - j) <= r:\n                if cols[j][min(lamp_i, i):max(lamp_i, i)+1] == [0]*(max(lamp_i, i)-min(lamp_i, i)+1):\n                    return False\n    return True\n\n# Read input\nn, r, k = map(int, input().split())\nlamps = [tuple(map(int, input().split())) for _ in range(k)]\n\n# Precompute rows and columns that can be illuminated by each lamp\nrows = defaultdict(list)\ncols = defaultdict(list)\nfor lamp in lamps:\n    i, j = lamp\n    rows[i] += [j]\n    cols[j] += [i]\nfor i in range(1, n+1):\n    rows[i].sort()\nfor j in range(1, n+1):\n    cols[j].sort()\n\n# Check if each square in the grid can be illuminated\nfor i in range(1, n+1):\n    for j in range(1, n+1):\n        if not is_illuminated(rows, cols, lamps, r, i, j):\n            print(0)\n            exit()\nprint(1)"
 ],
 "3603": [
  "from collections import defaultdict\n\nn, m = map(int, input().split())\nlang_to_trans = defaultdict(list)\nfor i in range(m):\n    lang1, lang2 = map(int, input().split())\n    lang_to_trans[lang1].append(i)\n    lang_to_trans[lang2].append(i)\n\nif m % 2 == 1:\n    print(\"impossible\")\nelse:\n    pairs = []\n    used = set()\n    for l, trans in lang_to_trans.items():\n        for i in range(0, len(trans), 2):\n            if i + 1 < len(trans):\n                t1, t2 = trans[i], trans[i+1]\n                if (t1, t2) not in used and (t2, t1) not in used:\n                    pairs.append((t1, t2))\n                    used.add((t1, t2))\n                    used.add((t2, t1))\n                    break\n        else:\n            print(\"impossible\")\n            break\n    else:\n        for t1, t2 in pairs:\n            print(t1, t2)"
 ],
 "3604": [
  "from math import sqrt\n\ndef can_communicate(s1, s2, d):\n    \"\"\"Returns True if sensors s1 and s2 can communicate directly, False otherwise\"\"\"\n    x1, y1 = s1\n    x2, y2 = s2\n    distance = sqrt((x1-x2)**2 + (y1-y2)**2)\n    return distance <= d\n\nn, d = map(int, input().split())\n\n# Read sensor coordinates\nsensors = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    sensors.append((x, y))\n\n# Initialize largest subset to include only the first sensor\nlargest_subset = [1]\n\n# Iterate over all sensors to find the largest subset\nfor i in range(1, n):\n    current_subset = [i+1] # include current sensor in subset\n    for j in largest_subset:\n        if not can_communicate(sensors[i], sensors[j-1], d): # subtract one to convert sensor index to list index\n            break\n    else:\n        largest_subset = current_subset\n\n# Output results\nprint(len(largest_subset))\nprint(*largest_subset) # * is used to unpack list elements as separate arguments to print function"
 ],
 "3605": [
  "n,k=map(int,input().split())\na=[int(x) for x in input().split()]\ndiff=[]\nfor i in range(n-k+1):\n    diff.append(max(a[i:i+k])-min(a[i:i+k]))\nprint(min(diff))"
 ],
 "3606": [
  "n, k = map(int, input().split())\ndirections = input().rstrip()\nplants = []\nfor _ in range(n):\n    plant = tuple(map(int, input().split()))\n    plants.append(plant)\n\ncurrent_pos = plants[0]\nfor direction in directions:\n    next_pos = None\n    if direction == \"A\":\n        for plant in plants:\n            if plant[0] >= current_pos[0] and plant[1] >= current_pos[1]:\n                if next_pos is None or plant < next_pos:\n                    next_pos = plant\n    elif direction == \"B\":\n        for plant in plants:\n            if plant[0] >= current_pos[0] and plant[1] <= current_pos[1]:\n                if next_pos is None or (plant[0], -plant[1]) < (next_pos[0], -next_pos[1]):\n                    next_pos = plant\n    elif direction == \"C\":\n        for plant in plants:\n            if plant[0] <= current_pos[0] and plant[1] >= current_pos[1]:\n                if next_pos is None or (-plant[0], plant[1]) < (-next_pos[0], next_pos[1]):\n                    next_pos = plant\n    else:\n        for plant in plants:\n            if plant[0] <= current_pos[0] and plant[1] <= current_pos[1]:\n                if next_pos is None or (-plant[0], -plant[1]) < (-next_pos[0], -next_pos[1]):\n                    next_pos = plant\n    if next_pos is not None:\n        plants.remove(current_pos)\n        current_pos = next_pos\n\nprint(current_pos[0], current_pos[1])"
 ],
 "3607": [
  "# Python 3 code\n\nvariables = {} # initialize global variables to store values\n\n# function to evaluate arithmetic statements\ndef evaluate_arithmetic(statement):\n    values = statement.split()\n    # if there is only one token, it must be a variable or a constant\n    if len(values) == 1:\n        if values[0] in variables:\n            return variables[values[0]]\n        else:\n            return int(values[0])\n    # if there are three tokens, it must be an arithmetic expression\n    elif len(values) == 3:\n        x = values[0]\n        operator = values[1]\n        y = values[2]\n        # evaluate x and y as variables or constants\n        if x in variables:\n            x = variables[x]\n        else:\n            x = int(x)\n        if y in variables:\n            y = variables[y]\n        else:\n            y = int(y)\n        # perform arithmetic operation\n        if operator == '+':\n            return x + y\n        elif operator == '-':\n            return x - y\n        elif operator == '*':\n            return x * y\n        elif operator == '/':\n            return x // y # perform integer division\n    else:\n        return None\n\n# read input and split into lines\nprogram = []\nwhile True:\n    try:\n        line = input()\n        program.append(line)\n    except:\n        break\n\n# find the smallest and largest label in the program\nsmallest_label = float('inf')\nlargest_label = float('-inf')\nfor line in program:\n    label = int(line.split()[0])\n    smallest_label = min(smallest_label, label)\n    largest_label = max(largest_label, label)\n\ncurrent_label = smallest_label\nwhile current_label <= largest_label:\n    for line in program:\n        label, command, statement = line.split(' ', 2)\n        label = int(label)\n        # execute command only if label matches current label\n        if label == current_label:\n            # LET command\n            if command == 'LET':\n                variable, statement = statement.split(' = ')\n                variables[variable] = evaluate_arithmetic(statement)\n            # IF command\n            elif command == 'IF':\n                condition, goto_label = statement.split(' THEN GOTO ')\n                x, operator, y = condition.split()\n                x = evaluate_arithmetic(x)\n                y = evaluate_arithmetic(y)\n                if operator == '=':\n                    if x == y:\n                        current_label = int(goto_label)\n                        break\n                elif operator == '>':\n                    if x > y:\n                        current_label = int(goto_label)\n                        break\n                elif operator == '<':\n                    if x < y:\n                        current_label = int(goto_label)\n                        break\n                elif operator == '<>':\n                    if x != y:\n                        current_label = int(goto_label)\n                        break\n                elif operator == '<=':\n                    if x <= y:\n                        current_label = int(goto_label)\n                        break\n                elif operator == '>=':\n                    if x >= y:\n                        current_label = int(goto_label)\n                        break\n            # PRINT and PRINTLN commands\n            elif command == 'PRINT':\n                statement = statement.strip('\"')\n                if statement in variables:\n                    print(variables[statement], end='')\n                else:\n                    print(statement, end='')\n            elif command == 'PRINTLN':\n                statement = statement.strip('\"')\n                if statement in variables:\n                    print(variables[statement])\n                else:\n                    print(statement)\n    current_label += 1"
 ],
 "3608": [
  "MOD = 1000000007\nn = int(input())\ntasks = list(map(int, input().split()))\nconsec_tasks = list(map(int, input().split()))\ntotal_ways = 1\nfor i in range(n):\n    if i == 0:\n        if consec_tasks[i] == 0:\n            total_ways *= tasks[i]\n        else:\n            total_ways *= consec_tasks[i]\n    else:\n        if consec_tasks[i-1] == 0:\n            total_ways *= tasks[i]\n        else:\n            total_ways *= consec_tasks[i-1]\n            consec_tasks[i-1] -= 1\n            total_ways %= MOD\n            total_ways *= (tasks[i]-consec_tasks[i-1]) % MOD\nprint(total_ways % MOD)"
 ],
 "3609": [
  "n = int(input())\nedges = []\nfor i in range(2*n-1):\n    u,v = map(int,input().split())\n    edges.append((u,v))\nleft = [0]*(n+1)\nright = [0]*(n+1)\nfor u,v in edges:\n    if u>v: u,v = v,u\n    if u==1 or v==n:\n        left[u] += 1\n        right[v] += 1\nif left[1]==1 and right[n]==1 and all(left[i]<=left[i-1] and right[i]<=right[i-1] for i in range(2,n)):\n    res = ''\n    for u,v in edges:\n        if u>v: u,v = v,u\n        if (u==1 and v!=n and right[v]>0) or (v==n and u!=1 and left[u]>0):\n            res += 'L'\n            left[u] -= 1\n        else:\n            res += 'R'\n            right[v] -= 1\n    print(res)\nelse:\n    print('impossible')"
 ],
 "3610": [
  "from collections import defaultdict\n\n# Reading Input\nm = int(input())\nteams = []\nfor _ in range(m):\n    teams.append(tuple(map(int, input().split())))\n\n# Building Graph\ngraph = defaultdict(list)\nfor i, j in teams:\n    graph[i].append(j)\n    graph[j].append(i)\n\n# BFS Traversal\nvisited = set()\ncomponent_sizes = []\nfor node in graph:\n    if node not in visited:\n        queue = [node]\n        visited.add(node)\n        size = 1\n        while queue:\n            curr_node = queue.pop(0)\n            for adj_node in graph[curr_node]:\n                if adj_node not in visited:\n                    visited.add(adj_node)\n                    queue.append(adj_node)\n                    size += 1\n        component_sizes.append(size)\n\n# Output\nnum_invites = len(component_sizes)\ninvites = []\nfor node in graph:\n    if 1009 <= node <= 1999:\n        for adj_node in graph[node]:\n            if 2000 <= adj_node <= 2999:\n                invites.append(node)\n                break\n    elif 2000 <= node <= 2999:\n        for adj_node in graph[node]:\n            if 1009 <= adj_node <= 1999:\n                invites.append(node)\n                break\nif 1009 not in invites and any(size == 1 for size in component_sizes):\n    index = component_sizes.index(1)\n    component_sizes.pop(index)\n    num_invites -= 1\nprint(num_invites)\nfor invite in invites:\n    print(invite)"
 ],
 "3611": [
  "import heapq\n\nINF = int(1e18)\n\nn, m = map(int, input().split())\ngraph_fwd = [[] for _ in range(n)]\ngraph_bwd = [[] for _ in range(n)]\nfor _ in range(m):\n    u, v, w = map(int, input().split())\n    graph_fwd[u].append((v, w))\n    graph_bwd[v].append((u, w))\ns, t = map(int, input().split())\n\ndist_fwd = [INF] * n\ndist_bwd = [INF] * n\ndist_fwd[s] = 0\ndist_bwd[t] = 0\n\npq_fwd = [(0, s)]\npq_bwd = [(0, t)]\n\nwhile pq_fwd:\n    d, u = heapq.heappop(pq_fwd)\n    if d > dist_fwd[u]:\n        continue\n    for v, w in graph_fwd[u]:\n        if dist_fwd[v] > d + w:\n            dist_fwd[v] = d + w\n            heapq.heappush(pq_fwd, (dist_fwd[v], v))\n\nwhile pq_bwd:\n    d, u = heapq.heappop(pq_bwd)\n    if d > dist_bwd[u]:\n        continue\n    for v, w in graph_bwd[u]:\n        if dist_bwd[v] > d + w:\n            dist_bwd[v] = d + w\n            heapq.heappush(pq_bwd, (dist_bwd[v], v))\n\nmn = dist_fwd[t]\nans = []\nfor u in range(n):\n    for v, w in graph_fwd[u]:\n        if dist_fwd[u] + w + dist_bwd[v] == mn:\n            ans.append(u)\n\nprint(*sorted(ans))"
 ],
 "3612": [
  "import math\n\n# function to check if a move is possible between two squares\ndef valid_move(h1, h2):\n    return abs(h1-h2) <= 1\n\n# function to check if a square is dry at a given time\ndef is_dry(v, h):\n    return v - h >= 0\n\n# function to check if it's safe to walk on a path\ndef is_safe(path, squares, m):\n    n = len(path)\n    t = 0\n    for i in range(n-1):\n        x1, y1 = path[i]\n        x2, y2 = path[i+1]\n        d = math.sqrt((x2-x1)**2 + (y2-y1)**2)\n        t += d*m\n        if not is_dry(v(t), squares[x2][y2]):\n            return False\n    return True\n\n# function to find maximum distance for safe walking\ndef max_distance(squares, m):\n    n = len(squares)\n    m = len(squares[0])\n    \n    # function to calculate water level at a given time\n    def v(t):\n        return 0.5*a*(math.cos(t*2*math.pi/12)+1)\n    \n    # coordinate of home\n    xh, yh = home\n    \n    # function to calculate coordinate of a square\n    def coord(x, y):\n        # shift by 5 units to get center of square\n        cx, cy = 5+x*10, 5+y*10\n        return cx, cy\n    \n    a = float(input())\n    m = float(input())\n    w, h, x, y = map(int, input().split())\n    home = x, y\n    \n    # list of all possible moves\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # BFS to find all reachable squares from home\n    q = [(xh, yh)]\n    visited = set()\n    visited.add((xh, yh))\n    while q:\n        x, y = q.pop(0)\n        for dx, dy in moves:\n            nx, ny = x+dx, y+dy\n            if 0<=nx<w and 0<=ny<h and valid_move(squares[x][y], squares[nx][ny]) and (nx,ny) not in visited:\n                q.append((nx, ny))\n                visited.add((nx, ny))\n    \n    # convert set to list for easier indexing\n    reachable = list(visited)\n\n    # binary search to find maximum distance\n    lo, hi = 0, 2000*(w+h)\n    while lo <= hi:\n        mid = (lo+hi)/2\n        path = []\n        for x, y in reachable:\n            cx, cy = coord(x, y)\n            if math.sqrt((cx-xh)**2 + (cy-yh)**2) <= mid:\n                path.append((cx, cy))\n        if len(path) == 0:\n            hi = mid-1\n            continue\n        if is_safe(path, squares, m):\n            lo = mid+1\n            ans = mid\n        else:\n            hi = mid-1\n    return ans\n\n# main program to read input and call max_distance function\na, m = map(float, input().split())\nw, h, x, y = map(int, input().split())\nsquares = []\nfor i in range(h):\n    row = list(map(int, input().split()))\n    squares.append(row)\nprint(max_distance(squares, m))"
 ],
 "3613": [
  "from itertools import permutations, product\n\nn = int(input())\nteacher = []\npreference = []\n\nfor i in range(n):\n    t, *p = map(int, input().split())\n    teacher.append(t)\n    preference.append(p)\n\nans = float('inf')\nfor perm in permutations(range(n)):\n    classes = [[], [], []]\n    for p in perm:\n        classes[teacher[p]].append(p)\n\n    for t1, t2, t3 in product(range(n), repeat=3):\n        if t1 == t2 or t1 == t3 or t2 == t3:\n            continue\n        good = True\n        for p in range(n):\n            if p in classes[t1]:\n                for q in preference[p][:ans]:\n                    if q in classes[t1]:\n                        break\n                    if q not in classes[t2][:ans] and q not in classes[t3][:ans]:\n                        break\n                else:\n                    continue\n                good = False\n                break\n            elif p in classes[t2]:\n                for q in preference[p][:ans]:\n                    if q in classes[t2]:\n                        break\n                    if q not in classes[t1][:ans] and q not in classes[t3][:ans]:\n                        break\n                else:\n                    continue\n                good = False\n                break\n            else:\n                for q in preference[p][:ans]:\n                    if q in classes[t3]:\n                        break\n                    if q not in classes[t1][:ans] and q not in classes[t2][:ans]:\n                        break\n                else:\n                    continue\n                good = False\n                break\n        if good:\n            ans = min(ans, ans)\nprint(ans)"
 ],
 "3614": [
  "n = int(input())\nr, c = map(int, input().split())\npetals = [list(map(int, input().split())) for _ in range(n)]\nvisited = [[False] * n for _ in range(n)]\n\ndef dfs(row, col, prev_petals):\n    if row < 0 or row >= n or col < 0 or col >= n or visited[row][col] or petals[row][col] <= prev_petals:\n        return 0\n    visited[row][col] = True\n    max_flowers = 0\n    for r, c in [(row-2,col), (row+2,col), (row,col-2), (row,col+2)]:\n        max_flowers = max(max_flowers, dfs(r, c, petals[row][col]))\n    for r, c in [(row-1,col), (row+1,col), (row,col-1), (row,col+1)]:\n        max_flowers = max(max_flowers, dfs(r, c, petals[row][col]))\n    visited[row][col] = False\n    return 1 + max_flowers\n\nprint(dfs(r-1, c-1, -1))"
 ],
 "3615": [
  "from math import sqrt\nfrom collections import deque\n\ndef dist(t1, t2):\n    x1, y1 = t1\n    x2, y2 = t2\n    return sqrt((x1-x2)**2 + (y1-y2)**2)\n\nn = int(input())\ntowers = [tuple(map(float, input().split())) for _ in range(n)]\n\nadj_list = [[] for _ in range(n)] # adjacency list for the graph\nfor i in range(n):\n    for j in range(i+1, n):\n        if dist(towers[i], towers[j]) <= 2: # towers within 2km can communicate\n            adj_list[i].append(j)\n            adj_list[j].append(i)\n\n# performs bfs on the graph\ndef bfs(node, adj_list, visited):\n    q = deque([node])\n    visited[node] = True\n    while len(q) > 0:\n        curr = q.popleft()\n        for neighbor in adj_list[curr]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                q.append(neighbor)\n\nmax_towers = 0\n# check each node as potential new tower location\nfor i in range(n):\n    new_adj_list = [[] for _ in range(n+1)]\n    for j in range(n):\n        if dist(towers[i], towers[j]) <= 2:\n            new_adj_list[n].append(j)\n            new_adj_list[j].append(n)\n        new_adj_list[j].extend(adj_list[j])\n    visited = [False] * (n+1)\n    bfs(n, new_adj_list, visited)\n    if all(visited[:-1]):\n        max_towers = n+1\n        break\n    else:\n        max_towers = max(max_towers, sum(visited))\n\nprint(max_towers)"
 ],
 "3616": [
  "from itertools import combinations\n\nk = int(input())\ndurations = [int(input()) for _ in range(k)]\n\n# generate all possible test schemes using combinations\ntest_schemes = []\nfor i in range(1, k + 1):\n    test_schemes.extend(combinations(durations, i))\n\n# calculate the shortest conclusive non-adaptive test scheme\nshortest_scheme = float('inf')\nfor scheme in test_schemes:\n    max_duration = max(scheme)\n    days = ((max_duration - 1) * 2) + len(scheme)\n    shortest_scheme = min(shortest_scheme, days)\n\nprint(shortest_scheme)"
 ],
 "3617": [
  "n, T = map(int, input().split())\nA, B, C, t0 = map(int, input().split())\n\npenalty_mod = 1000000007\n\nmins = [t0]\nfor i in range(1, n):\n    ti = ((A * mins[i-1] + B) % C) + 1\n    mins.append(ti)\n\nmins.sort()\n\nproblems_solved = 0\npenalty = 0\nfor i in range(n):\n    if mins[i] > T:\n        break\n    problems_solved += 1\n    penalty += (T - mins[i])\n    penalty %= penalty_mod\n\nprint(problems_solved, penalty)"
 ],
 "3618": [
  "n = int(input().strip())\ndp = [[0]*10 for i in range(n)]\n\nfor i in range(10):\n    dp[0][i] = 1\n\nfor i in range(1,n):\n    for j in range(10):\n        if j==0:\n            dp[i][j] = dp[i-1][1] % 998244353\n        elif j==9:\n            dp[i][j] = dp[i-1][8] % 998244353\n        else:\n            dp[i][j] = (dp[i-1][j-1]+dp[i-1][j+1]) % 998244353\n\nans = 0\nfor i in range(1,10):\n    ans += dp[n-1][i]\n\nprint(ans%998244353)"
 ],
 "3619": [
  "from functools import lru_cache\nn, k = map(int, input().split())\nemployee = [[0,0,0]] + [list(map(int, input().split())) for _ in range(n)]\nemployee.sort()\ndp = [[-1e18]*(k+1) for _ in range(n+1)]\ndp[0][0] = 0\n@lru_cache(None)\ndef recur(idx, cnt):\n    if dp[idx][cnt]!=-1e18:\n        return dp[idx][cnt]\n    if cnt==0:\n        return 0\n    if idx<=0:\n        return -1e18\n    salary, prod, rec = employee[idx]\n    dp[idx][cnt] = recur(idx-1, cnt)\n    if rec<=idx and rec<=n-k+cnt-1:\n        dp[idx][cnt] = max(dp[idx][cnt], recur(idx-1, cnt-1)+(prod/(salary+recur(rec, 1))))\n    return dp[idx][cnt]\n    \nans = recur(n, k)\nprint(f\"{ans:.3f}\")"
 ],
 "3620": [
  "from collections import defaultdict\nfrom itertools import product\n\n\ndef dfs(graph, node, visited):\n    visited.add(node)\n    comp = [node]\n    for neigh in graph[node]:\n        if neigh not in visited:\n            comp.extend(dfs(graph, neigh, visited))\n    return comp\n\n\nMOD = int(2e9)\nN, M, k, P = map(int, input().split())\ngraph = defaultdict(list)\nfor i in range(M):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\nvisited = set()\ncomps = []\nfor i in range(1, N + 1):\n    if i not in visited:\n        comp = dfs(graph, i, visited)\n        comps.append(set(comp))\n\ncounts = [0] * k\nfor comp in comps:\n    size = len(comp)\n    if size < k:\n        counts[size] += 1\n    else:\n        counts[k] += 1\n\ndp = [[0 for _ in range(k + 1)] for _ in range(N)]\nfor i in range(N):\n    dp[i][1] = 1\n\nfor color in range(2, k + 1):\n    for size in range(2, N + 1):\n        if size < color:\n            dp[size - 1][color] = counts[size]\n            continue\n        prod = 1\n        for comp in comps:\n            if len(comp) < color:\n                continue\n            avail_nodes = comp - visited\n            if len(avail_nodes) < color:\n                continue\n            visited |= avail_nodes\n            prod1 = sum(dp[node - 1][color - 1] for node in avail_nodes) % MOD\n            prod = prod * prod1 % MOD\n        dp[size - 1][color] = prod\n\nprint(dp[N - 1][k] % P)"
 ],
 "3621": [
  "mod = 10**9+7\nn = int(input())\nc = [list(map(int, input().split())) for _ in range(n)]\nm = max(max(ci) for ci in c)\n\nfac = [1] * (n+1)\nfor i in range(1, n+1):\n    fac[i] = fac[i-1] * i % mod\n    \niv = [1] * (n+1)\nifac = [1] * (n+1)\nfor i in range(2, n+1):\n    iv[i] = (mod - mod//i) * iv[mod%i] % mod\n    ifac[i] = ifac[i-1] * iv[i] % mod\n\nbinom = [[0] * (n+1) for _ in range(n+1)]\nfor i in range(n+1):\n    binom[i][0] = 1\nfor i in range(1, n+1):\n    for j in range(1, n+1):\n        binom[i][j] = (binom[i-1][j-1] + binom[i-1][j]) % mod\n\ndpc = [0] * (m+1)\nfor i in range(1, n+1):\n    for j in range(i, n+1):\n        dpc[c[i-1][j-1]] += 1\ndp = [[0] * (m+1) for _ in range(n+1)]\nfor i in range(1, n+1):\n    for t in range(1, m+1):\n        if not dpc[t]: continue\n        dp[i][t] = fac[dpc[t]] * ifac[dpc[t]-1] * (pow(fac[dpc[t]-1], mod-2, mod)) % mod\n    for j in range(1, i):\n        cnt = 0\n        for t in range(1, m+1):\n            if dp[j][t] != 0 and dp[i][t] != 0:\n                cnt += 1\n        for t in range(1, m+1):\n            if dp[j][t] != 0 and dp[i][t] != 0:\n                dp[i][t] = dp[i][t] * dp[j][t] % mod\n\nans = 0\nfor i in range(1, n+1):\n    for j in range(i, n+1):\n        tmp = dp[i][c[i-1][j-1]] * fac[n-i] % mod * fac[i-1] % mod\n        tmp = tmp * binom[n-1][i-1] % mod\n        ans += tmp\n        ans %= mod\n\nprint(ans)"
 ],
 "3622": [
  "import sys\n\nw, h = map(int, input().split())\nu, d, l, r = map(int, input().split())\ngrid = []\nfor i in range(h):\n    row = list(input().strip())\n    if 'T' in row:\n        targets = [(i, j) for j, c in enumerate(row) if c == 'T']\n    grid.append(row)\n\nP = [[0] * w for _ in range(h)]\n\nfor j in range(w):\n    P[0][j] = 1 / (w - grid[0].count('X')) if grid[0][j] == '.' else 0\n\nfor i in range(1, h):\n    for j in range(w):\n        if grid[i][j] == 'X':\n            continue\n        \n        top = P[i-1][j] * u / 100 if i > 0 else 0\n        bottom = P[i-1][j] * d / 100 if i < h-1 else 0\n        left = P[i][j-1] * l / 100 if j > 0 and grid[i][j-1] != 'X' else 0\n        right = P[i][j+1] * r / 100 if j < w-1 and grid[i][j+1] != 'X' else 0\n        P[i][j] = top + bottom + left + right\n\nfor i, j in targets:\n    print('{:.9f}'.format(P[i][j]))"
 ],
 "3623": [
  "import math\na, b, c, d = map(float, input().split())\ns1 = math.tan(math.radians(a))*math.tan(math.radians(d))/2\ns2 = math.tan(math.radians(b))*math.tan(math.radians(c))/2\ns = math.tan(math.radians(a)) + math.tan(math.radians(b)) + math.tan(math.radians(c)) + math.tan(math.radians(d))\ns += 2*math.sqrt(math.tan(math.radians(a))*math.tan(math.radians(c))*math.tan(math.radians(b))*math.tan(math.radians(d)))\nproportion = (1-s1-s2)/(1-s)\nprint(\"{:.7f}\".format(proportion))"
 ],
 "3624": [
  "import heapq\n\nn, m = map(int, input().split())\n\ngraph = [[] for i in range(n)]\nfor i in range(m):\n    u, v, d = map(int, input().split())\n    graph[u].append((v, d))\n    graph[v].append((u, d))\n\nvisited = [False] * n\ndist = [float('inf')] * n\n\n# Dijkstra Algorithm - Knight's path\npq = []\nheapq.heappush(pq, (0, 0)) # (time, node)\nwhile len(pq) > 0:\n    t, node = heapq.heappop(pq)\n    if visited[node]:\n        continue\n    visited[node] = True\n    dist[node] = t\n    for neighbor, time in graph[node]:\n        if t + time <= 12:\n            heapq.heappush(pq, (t+time, neighbor))\n\nknight_time = dist[-1]\n\nvisited = [False] * n\ndist = [float('inf')] * n\n\n# Dijkstra Algorithm - Day's path\npq = []\nheapq.heappush(pq, (0, n-1)) # (time, node)\nwhile len(pq) > 0:\n    t, node = heapq.heappop(pq)\n    if visited[node]:\n        continue\n    visited[node] = True\n    dist[node] = t\n    for neighbor, time in graph[node]:\n        if t + time <= 12:\n            heapq.heappush(pq, (t+time, neighbor))\n\nday_time = dist[0]\n\nprint(max(0, day_time - knight_time))"
 ],
 "3625": [
  "n = int(input())\n\nmax_harvest = 0\n\nfor i in range(n):\n    Y, I, S, B = map(int, input().split())\n    current_harvest = min(Y*I, S) # maximum possible harvest before starting to decrease\n    extra_years = max(0, Y - ((S + I - 1) // I)) # years when harvest will still decrease but population is not 0 yet\n    remaining_population = max(0, S - Y*I) # population left after the extra years and maximum harvest\n    if extra_years > 0:\n        time_until_death = (remaining_population + extra_years*I-1) // (extra_years*I) # years until population becomes 0 after extra years\n        current_harvest += min(time_until_death*I, remaining_population) # harvest during the years until population becomes 0\n    max_harvest += current_harvest\n\nprint(max_harvest)"
 ],
 "3626": [
  "n = int(input())\nrectangles = []\nfor i in range(n):\n    x1, y1, x2, y2 = map(int, input().split())\n    rectangles.append((x1, y1, x2, y2))\n\nfor i in range(n):\n    for j in range(i+1, n):\n        if rectangles[i][2] <= rectangles[j][0] or rectangles[i][0] >= rectangles[j][2] or rectangles[i][3] <= rectangles[j][1] or rectangles[i][1] >= rectangles[j][3]:\n            continue\n        else:\n            print(1)\n            exit()\nprint(0)"
 ],
 "3627": [
  "R, C = map(int, input().split())\n\ncliff_top = input().split()\ncliff_arr = []\nfor _ in range(R):\n    cliff_row = list(map(int, input().split()))\n    cliff_arr.append(cliff_row)\nstart_points = input().split()\n\nINF = float('inf')\ndp = [[-INF] * C for _ in range(R)]\nfor i in range(R-1, -1, -1):\n    for j in range(C-1, -1, -1):\n        energy = cliff_arr[i][j]\n        if i == R-1 and j == C-1:\n            dp[i][j] = max(1, 1-energy)\n        elif i == R-1:\n            dp[i][j] = max(1, dp[i][j+1]-energy)\n        elif j == C-1:\n            dp[i][j] = max(1, dp[i+1][j]-energy)\n        else:\n            dp[i][j] = max(1, min(dp[i][j+1], dp[i+1][j])-energy)\n            \nprint(dp[0][0])"
 ],
 "3628": [
  "from itertools import permutations\nn = int(input())\na = list(map(int, input().split()))\n\nfor p in permutations(range(1, n+1)):\n    sigma = [(a[i] - p[i] + n) % n for i in range(n)]\n    if set(sigma) == set(range(1, n+1)):\n        print(' '.join(map(str, p)))\n        print(' '.join(map(str, sigma)))\n        break\nelse:\n    print('impossible')"
 ],
 "3629": [
  "import math\n\ndef overlap(x1,y1,r1,x2,y2,r2):\n    d = math.dist((x1,y1),(x2,y2))\n    if r1+r2<=d:\n        return False\n    if d+r1<r2 or d+r2<r1:\n        return False\n    return True\n\nn=int(input())\nt=[]\nfor _ in range(n):\n    x,y,r=map(int,input().split())\n    t.append((x,y,r))\n\nb,d=map(int,input().split())\n\ndef check(theta):\n    dx=math.cos(theta)*d\n    dy=math.sin(theta)*d\n    for x,y,r in t:\n        if overlap(dx,dy,b,x,y,r):\n            return False\n    return True\n\ndef search(l,r):\n    for i in range(50):\n        m=(l+r)/2\n        \n        if check(m):\n            r=m\n        else:\n            l=m\n    return l\n\nans=0\nfor i in range(1500):\n    theta=i*math.pi/750\n    if check(theta):\n        ans+=search(theta,theta+2*math.pi/1500)\nprint(ans/(2*math.pi))"
 ],
 "3630": [
  "from collections import deque\ns1, s2 = input().split()\n\ndef bfs(initial):\n    queue = deque()\n    visited = {}\n    queue.append(([initial], 0))\n    visited[initial] = True\n    while queue:\n        path, count = queue.popleft()\n        curr_state = path[-1]\n        if curr_state == s2:\n            return count\n        for i in range(len(s2)):\n            if curr_state[i] == 'a' or curr_state[i] == 'z':\n                continue\n            forward = curr_state[:i] + chr(ord(curr_state[i]) + 1) + curr_state[i+1:]\n            backward = curr_state[:i] + chr(ord(curr_state[i]) - 1) + curr_state[i+1:]\n            if forward not in visited:\n                visited[forward] = True\n                queue.append((path + [forward], count+1))\n            if backward not in visited:\n                visited[backward] = True\n                queue.append((path + [backward], count+1))\n\nprint(bfs(s1))"
 ],
 "3631": [
  "import math\ndef dist(a,b):\n    return ((a[0]-b[0])**2+(a[1]-b[1])**2)**0.5\ndef isPossible(k1,k2,c):\n    '''Returns True if there is no peak between beacons k1 and k2'''\n    for i in range(c):\n        if ((peaks[i][0]-beacons[k1][0])**2+(peaks[i][1]-beacons[k1][1])**2)**0.5<=peaks[i][2]:\n            if ((peaks[i][0]-beacons[k2][0])**2+(peaks[i][1]-beacons[k2][1])**2)**0.5<=peaks[i][2]:\n                return False\n            num=((beacons[k2][1]-beacons[k1][1])*peaks[i][0]-(beacons[k2][0]-beacons[k1][0])*peaks[i][1]+beacons[k2][0]*beacons[k1][1]-beacons[k2][1]*beacons[k1][0])\n            if num*num<=dist(beacons[k1],beacons[k2])**2*peaks[i][2]**2:\n                return False\n    return True\ndef message():\n    '''Returns the number of riders needed'''\n    messages=0\n    for i in range(n-1):\n        for j in range(i+1,n):\n            if isPossible(i,j,m):\n                messages+=1\n    return messages\nn,m=map(int,input().split())\nbeacons=[[]*2 for i in range(n)]\npeaks=[[]*3 for i in range(m)]\nfor i in range(n):\n    beacons[i]=list(map(int,input().split()))\nfor i in range(m):\n    peaks[i]=list(map(int,input().split()))\nprint(message())"
 ],
 "3632": [
  "MOD = 10**9 + 7\n\n# calculate nCr % MOD using modular inverse and fermat's little theorem \ndef nCr(n, r, p):\n    if r == 0:\n        return 1\n    fac = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fac[i] = (fac[i - 1] * i) % p\n    inv = [1] * (n + 1)\n    inv[n] = pow(fac[n], p - 2, p)\n    for i in range(n - 1, 0, -1):\n        inv[i] = (inv[i + 1] * (i + 1)) % p\n    return (fac[n] * inv[r] % p * inv[n - r] % p) % p\n\nn, k = map(int, input().split())\nstrings = [input().strip() for _ in range(n)]\ntest_string = input().strip()\n\n# count the number of strings that come before the test string in sorted order\ncount = 0\nfor i in range(k):\n    pos = ord(test_string[i]) - ord('a')\n    # count the number of strings in strings[:pos] that can be appended to the first i characters of the test string \n    count += nCr(n - 1 - i, k - 1 - i, MOD) * (pos - i)\n    count %= MOD\n\n    # if the (i+1)-th character of test_string has character code less than the (i+1)-th character of string j,\n    # then all strings formed by appending strings in strings[j+1:] to the first i characters of test_string come after\n    # the string formed by appending the (i+1)-th character of string j to the first i characters of test_string, so we can break the loop\n    for j in range(n):\n        if strings[j][i] < test_string[i]:\n            count += nCr(n - 1 - i, k - 1 - i, MOD)\n            count %= MOD\n        if strings[j][i] != test_string[i]:\n            break\n\n# add 1 to get the 1-indexed position of the test string in sorted order \nprint(count + 1)"
 ],
 "3633": [
  "from heapq import heapify, heappop, heappush\nn, m, k = map(int, input().split())\na = list(map(int, input().split()))\nind = list(range(n))\nind.sort(key=lambda i: a[i], reverse=True)\nans = [0] * n\nsum_score = 0\nh = []\nheapify(h)\nfor i in ind:\n    if len(h) > 0 and sum_score / len(h) < a[i]:\n        num = m if sum_score / len(h) <= k / (n - i) else 0\n        while len(h):\n            ans[heappop(h)] = i\n        sum_score = 0\n    sum_score += a[i]\n    heappush(h, i)\nif len(h) > 0 and sum_score / len(h) == k / len(h):\n    while len(h):\n        ans[heappop(h)] = i\n    print(*map(lambda i: i + 1, ans))\nelse:\n    print(\"impossible\")"
 ],
 "3634": [
  "MOD = 1000000009\n\nn = int(input())\nranges = []\nfor i in range(n):\n    a, b = map(int, input().split())\n    ranges.append((a, b))\n\nif n < 3:\n    print(\"shovel time!\")\nelse:\n    ranges.sort()\n    dp = [0]*n\n    dp[0] = 1\n    dp[1] = 1 if ranges[0][1] < ranges[1][0] else 0\n    for i in range(2, n):\n        for j in range(i-1, -1, -1):\n            if ranges[j][1] < ranges[i][0]:\n                break\n            elif ranges[j][0] <= ranges[i][0] <= ranges[j][1]:\n                break\n            dp[i] = (dp[i] + dp[j]) % MOD\n    ans = 0\n    for i in range(1, n-1):\n        if ranges[n-1][0] <= ranges[i][1] and ranges[i][0] <= ranges[0][1]:\n            ans = (ans + dp[i]*dp[n-1-i]) % MOD\n    print(ans)"
 ],
 "3635": [
  "n = int(input())\nbriefcases = sorted(list(map(int, input().split())))\n\nprefix_sum = [briefcases[0]]\nfor i in range(1, n):\n    prefix_sum.append(prefix_sum[-1] + briefcases[i])\n\nans = 1\nfor i in range(1, n):\n    if prefix_sum[i-1] * 2 >= briefcases[i]:\n        ans += 1\n    else:\n        break\n\nprint(ans)"
 ],
 "3636": [
  "n, m, p = map(int, input().split())\n\n# count number of 2x2 subgrids in the n x m grid\nnum_subgrids = (n - 1) * (m - 1)\n\n# calculate number of ways to place minimum number of obstacles \n# to cover all 2x2 subgrids (either 0, 1, or 2 obstacles)\n# using dynamic programming\ndp = [1] * (num_subgrids + 1)\nfor i in range(2, n+m):\n    new_dp = [0] * (num_subgrids + 1)\n    for j in range(num_subgrids + 1):\n        for k in range(j+1):\n            new_dp[k] = (new_dp[k] + dp[j]) % p\n            if j+k+2 <= num_subgrids:\n                new_dp[j+k+2] = (new_dp[j+k+2] - dp[j] + new_dp[k]) % p\n    dp = new_dp\n\n# output number of ways to place obstacles for the minimum number of obstacles\nans = (dp[0] - num_subgrids) % p\nprint(ans)"
 ],
 "3637": [
  "from collections import defaultdict\n\nn = int(input())\nwish_count = defaultdict(int)\nwishes = defaultdict(set)\n\nfor i in range(n):\n    wish_list = input().split()[1:]\n    for wish in wish_list:\n        wish_count[wish] += 1\n        wishes[i].add(wish)\n\nresult = []\nfor wish in wish_count:\n    if wish_count[wish] * 3 > n:\n        fulfilled = 0\n        for i in range(n):\n            if wish in wishes[i]:\n                fulfilled += 1\n        if fulfilled * 3 > 2 * n:\n            result.append(wish)\n\nprint(*result, sep=\"\\n\")"
 ],
 "3638": [
  "n, s = map(int, input().split())\nseqs = [input().strip() for i in range(s)]\ncount = {seq: 0 for seq in seqs}\nfor i in range(n):\n    plays = input().strip()\n    for j in range(s):\n        if seqs[j] in plays:\n            count[seqs[j]] += 1\nsorted_seqs = sorted(seqs, key=lambda x: (-count[x], seqs.index(x)))\nprint('\\n'.join(sorted_seqs))"
 ],
 "3639": [
  "from math import inf\nfrom scipy.optimize import minimize_scalar\n\nT = int(input())\nc, d = map(float, input().split())\nr = [int(input()) for _ in range(T)]\n\ndef wetness(v):\n    rain, sweat = 0, 0\n    for i in range(T):\n        t = (d / v) / 60 # time in hours\n        sweat += c * (v / 3.6)**2 * t # convert v to m/s\n        rain += r[i] * t\n    return rain + sweat\n\nres = minimize_scalar(wetness, bounds=(0, 100), method='bounded')\nprint(\"{:.6f}\".format(res.fun))"
 ],
 "3640": [
  "import sys\n\ndef meow_factor(s):\n    n = len(s)\n    meow = \"meow\"\n    dp = [[sys.maxsize]*(n+1) for _ in range(5)]\n    for i in range(n+1):\n        for j in range(5):\n            if j == 0:\n                dp[j][i] = i\n            elif i == 0:\n                dp[j][i] = sys.maxsize\n            elif s[i-1] == meow[j-1]:\n                dp[j][i] = dp[j-1][i-1]\n            else:\n                dp[j][i] = 1 + min(dp[j][i-1], dp[j-1][i], dp[j-1][i-1], dp[j-2][i-2] if j > 1 and s[i-1] == meow[j-2] and s[i-2] == meow[j-1] else sys.maxsize)\n    return -1 if dp[4][n] == sys.maxsize else dp[4][n]\n\ns = input().strip()\nprint(meow_factor(s))"
 ],
 "3641": [
  "k, n = map(int, input().split())\nbead_weights = list(map(int, input().split()))\n\ntotal_weight = sum(bead_weights)\nif total_weight % k != 0:\n    print(\"NO\")\nelse:\n    segment_weight = total_weight // k\n    current_weight = 0\n    segments = 0\n    for weight in bead_weights:\n        current_weight += weight\n        if current_weight == segment_weight:\n            segments += 1\n            current_weight = 0\n        elif current_weight > segment_weight:\n            print(\"NO\")\n            break\n    if segments == k:\n        print(\"YES\")\n    else:\n        print(\"NO\")"
 ],
 "3642": [
  "from collections import defaultdict\nfrom fractions import Fraction\n\n# function to calculate the magic of a path\ndef magic(f, u, v):\n    if depth[u] < depth[v]:\n        u, v = v, u\n    ans = f[u] * f[v]\n    while depth[u] > depth[v]:\n        ans /= depth[u] - depth[parent[u]]\n        u = parent[u]\n    while u != v:\n        ans /= depth[u] - depth[parent[u]]\n        ans *= f[parent[u]]\n        u = parent[u]\n        ans /= depth[v] - depth[parent[v]]\n        ans *= f[parent[v]]\n        v = parent[v]\n    return ans/abs(depth[u] - depth[parent[u]])\n\n# function for dfs to calculate depths and parents of nodes\ndef dfs(u, par, d):\n    depth[u] = d\n    parent[u] = par\n    for v in tree[u]:\n        if v != par:\n            dfs(v, u, d+1)\n\nn = int(input())\ntree = defaultdict(list)\nf = [0]*(n+1)\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    tree[u].append(v)\n    tree[v].append(u)\ndepth = [0]*(n+1)\nparent = [0]*(n+1)\nfor i in range(1, n+1):\n    f[i] = int(input())\ndfs(1, 0, 1)\n# binary search to find the minimum magic path\nans = float('inf')\nlow, high = 0, 1000000000000000000\nwhile low <= high:\n    mid = (low+high)//2\n    flag = False\n    for u in range(1, n+1):\n        for v in tree[u]:\n            ans = magic(f, u, v)\n            if ans <= mid:\n                flag = True\n                break\n        if flag:\n            break\n    if flag:\n        high = mid - 1\n    else:\n        low = mid + 1\nres = Fraction(low, 1)\nprint(res)"
 ],
 "3643": [
  "import sys\ninput=sys.stdin.readline\n\nn= int(input())\nl,r = zip(*[map(float,input().split()) for i in range(n)])\n\nL=l[-1]\nR=r[0]\nresults = 0\nfor i in range(n-1,0,-1):\n    l_i,r_i=l[i],r[i]\n    mini = int(L-l_i)\n    maxi = int(R-r_i)\n    results += (maxi*(maxi+1) - mini*(mini-1)) / 2\n    L = l_i\n    R = r_i\n\nprint('{:.15f}'.format(results/n/n))"
 ],
 "3644": [
  "import heapq\n\nn = int(input())\ndeltas = []\nfor i in range(n):\n    f, h = map(int, input().split())\n    deltas.append((f-h, f, h))\n\ndeltas.sort()\n\nhr_needed = 1\nhr_assignment = [1] * n\navailable_hr = [1]\nheapq.heapify(available_hr)\n\nfor delta in deltas:\n    f_h_diff, f, h = delta\n    while available_hr[0] <= f and available_hr:\n        heapq.heappop(available_hr)\n\n    if not available_hr:\n        hr_needed += 1\n        available_hr.append(hr_needed)\n\n    hr_assignment[deltas.index(delta)] = available_hr[0]\n    available_hr.append(available_hr[0])\n    if f_h_diff > 0:\n        for i in range(1, f_h_diff+1):\n            available_hr.append(hr_needed+i)\n\n    heapq.heapify(available_hr)\n\nprint(hr_needed)\nprint(*hr_assignment)\n"
 ],
 "3645": [
  "n = int(input())\na = list(map(int, input().split()))\n\nunique = list(set(a))\n\nif len(unique) == n:\n    for i in range(n):\n        diff = abs(a[(i+1)%n] - a[i])\n        if diff > n/2:\n            diff = n - diff\n        if diff != 1 and diff != n-1:\n            print(a[i])\n            break\nelse:\n    print(\"none\")"
 ],
 "3646": [
  "n = int(input())\npebbles = list(map(int, input().split()))\n\nmax_jump = 0\nfor i in range(n):\n    for j in range(i + max_jump + 1, n):\n        if pebbles[i] + pebbles[j] == j - i:\n            max_jump = j - i\n            last_pebble = j\n\nprint(last_pebble)"
 ],
 "3647": [
  "from collections import deque\n\nC, R = map(int, input().split())\n\nmaze = []\nfor _ in range(R):\n    row = input().strip()\n    maze.append(row)\n\ngoal = None\nfor r in range(R):\n    for c in range(C):\n        if maze[r][c] == 'M':\n            goal = (r, c)\n\n# Define the four possible directions to move in (up, down, left, right)\ndirections = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n# Initialize a 2D list to store the minimum number of moves needed to reach the goal from each square\ndistances = [[-1 for _ in range(C)] for _ in range(R)]\n\n# Define a function to check if a square is within the bounds of the maze and is not an obstacle\ndef in_bounds(row, col):\n    return row >= 0 and row < R and col >= 0 and col < C and maze[row][col] != '#'\n\n# Define a function to compute the minimum number of moves needed to reach the goal from a starting square\ndef bfs(start_row, start_col):\n    queue = deque([(start_row, start_col, 0)])  # Add the starting square to the queue\n    visited = set([(start_row, start_col)])  # Mark the starting square as visited\n    while queue:\n        row, col, dist = queue.popleft()\n        if maze[row][col] == 'M':  # If we have reached the goal, return the distance\n            return dist\n        for d_row, d_col in directions:  # Otherwise, try to move in each of the four directions\n            new_row, new_col = row + d_row, col + d_col\n            if in_bounds(new_row, new_col) and (new_row, new_col) not in visited:  # If the new square is valid and has not been visited yet\n                visited.add((new_row, new_col))  # Mark the new square as visited\n                if maze[new_row][new_col] == '_':  # If the new square is ice, keep moving in the same direction until a different square is reached\n                    while True:\n                        new_row += d_row\n                        new_col += d_col\n                        if not in_bounds(new_row, new_col):  # If we have gone out of bounds, break the loop\n                            break\n                        if maze[new_row][new_col] != '_':  # If we have reached a new square, add it to the queue\n                            queue.append((new_row - d_row, new_col - d_col, dist + 1))\n                            break\n                else:  # If the new square is not ice, simply add it to the queue\n                    queue.append((new_row, new_col, dist + 1))\n    return -1  # If we have exhausted all possible moves without reaching the goal, return -1\n\n# Compute the minimum number of moves needed to reach the goal from each square in the maze\nfor r in range(R):\n    for c in range(C):\n        if maze[r][c] != '#':\n            distances[r][c] = bfs(r, c)\n\n# Output the result\nfor row in distances:\n    print(' '.join(map(str, row))"
 ],
 "3648": [
  "import heapq\nINF = float('inf')\nn, m, p = map(int, input().split())\ninsecure = set(map(int, input().split()))\ngraph = {i: [] for i in range(1, n+1)}\nfor _ in range(m):\n    a, b, w = map(int, input().split())\n    graph[a].append((b, w))\n    graph[b].append((a, w))\n\ndef dijkstra(start, dest):\n    dist = [-INF]*(n+1)\n    dist[start] = INF\n    heap = []\n    heapq.heappush(heap, (dist[start], start))\n\n    while heap:\n        d, node = heapq.heappop(heap)\n\n        if dist[node] > d:\n            continue\n\n        for neigh, w in graph[node]:\n            new_dist = min(dist[node], w)\n            if neigh in insecure:\n                continue\n            if new_dist > dist[neigh]:\n                dist[neigh] = new_dist\n                heapq.heappush(heap, (new_dist, neigh))\n\n    return dist[dest]\n\nresult = dijkstra(1, n)\n\nif result > 0:\n    print(result)\nelse:\n    print(\"impossible\")"
 ],
 "3649": [
  "a, b, c, d = map(int, input().split())\n\nif abs(a + b - c - d) > 1:\n    print(\"impossible\")\nelse:\n    if c > a and c > d:\n        print(\"impossible\")\n    elif a == c and b > 0 and d == 0:\n        print(\"0\" * (a + 1) + \"1\" * b)\n    elif d == c and b > 0 and a == 0:\n        print(\"1\" * (c + 1) + \"0\" * b)\n    elif a > c and d > c:\n        print(\"0\" * (a + 1) + \"1\" * b + \"0\" * (d - c))\n    elif d > c and a >= c:\n        print(\"1\" * (d + 1) + \"0\" * b + \"1\" * (a - c))\n    elif c == a + 1 == d and b == 0:\n        print(\"0\" * a + \"1\" * c)\n    elif c == d + 1 == a and b == 0:\n        print(\"1\" * d + \"0\" * c)\n    else:\n        print(\"impossible\")"
 ],
 "3650": [
  "n, m, b = map(int, input().split())\ntarget = set(tuple(map(int, input().split())) for _ in range(b))\ninit = {target.pop()} # initialize the initial board with the first block from target board\nparents = {} # a dictionary to store the parent of each block\nq = set(init) # a set to store the blocks which will be used to explore the tree structure\nwhile q: # BFS algorithm to explore the tree structure of the target board\n    block = q.pop()\n    r, c = block\n    for nr, nc in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]:\n        if 1 <= nr <= n and 1 <= nc <= m and (nr, nc) not in parents and (nr, nc) in target:\n            parents[nr, nc] = (r, c)\n            q.add((nr, nc))\n            target.remove((nr, nc))\nif target: # all blocks from target board should be explored completely\n    print(\"impossible\")\nelse:\n    print(\"possible\")\n    goal = parents.popitem()[0] # the last block from target board is the goal block\n    moves = []\n    while goal in parents: # trace back from the goal block to the initial block\n        pr, pc = parents[goal]\n        if goal[0] < pr:\n            moves.append((\"^\", goal[1]))\n        elif goal[0] > pr:\n            moves.append((\"v\", goal[1]))\n        elif goal[1] < pc:\n            moves.append((\"<\", goal[0]))\n        else:\n            moves.append((\">\", goal[0]))\n        goal = pr, pc\n    moves.reverse()\n    for c, k in moves:\n        print(c, k)"
 ],
 "3651": [
  "import itertools\nimport math\n\nn = int(input())\nplanets = []\nfor i in range(n):\n    planets.append(list(map(int, input().split())))\n\n# generate all possible portal pairs\nportals = list(itertools.combinations(range(n), 2))\n\n# function to calculate distance between two planets\ndef get_distance(p1, p2):\n    return math.sqrt(sum([(p1[i] - p2[i])**2 for i in range(3)]))\n\n# initialize minimum distance to a large value\nmin_distance = float(\"inf\")\n\n# loop through all possible sequences of visiting planets\nfor seq in itertools.permutations(range(n)):\n    # calculate distance of flying directly between planets in sequence\n    direct_distance = sum([get_distance(planets[seq[i]], planets[seq[i+1]]) for i in range(n-1)])\n    # loop through all non-repeating portal pairs\n    for portal_pair in portals:\n        # calculate distance of using portal and then flying directly\n        portal_distance = get_distance(planets[portal_pair[0]], planets[portal_pair[1]])\n        # calculate total distance of sequence using this portal pair\n        total_distance = direct_distance - portal_distance + get_distance(planets[portal_pair[0]], planets[portal_pair[1]]) + get_distance(planets[seq[0]], planets[portal_pair[0]]) + get_distance(planets[seq[-1]], planets[portal_pair[1]])\n        # update minimum distance if necessary\n        min_distance = min(min_distance, total_distance)\n\n# output result\nprint(\"{:.6f}\".format(min_distance))"
 ],
 "3652": [
  "n = int(input())\na = list(map(int,input().split()))\nb = list(map(int,input().split()))\nc = list(map(int,input().split()))\n\nd = []\nfor i in range(n):\n    d.append((a[i],b[i],c[i]))\n\nd.sort()\n\ni = 0\nj = 0\nk = 0\nans = 0\n\nwhile i < n and j < n and k < n:\n    x = d[i][0]\n    y = d[j][1]\n    z = d[k][2]\n    if x == y and y == z:\n        i += 1\n        j += 1\n        k += 1\n    else:\n        if y < x or z < x:\n            ans += 1\n            j += 1\n            k += 1\n        elif x < y or z < y:\n            ans += 1\n            i += 1\n            k += 1\n        elif x < z or y < z:\n            ans += 1\n            i += 1\n            j +=1\n\nprint(ans)"
 ],
 "3653": [
  "from math import sqrt, atan2, degrees\nl = int(input())\nx1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\nh = sqrt((x2-x1)**2 + (y2-y1)**2)\na = degrees(atan2(y2-y1, x2-x1))\nif a < 0:\n    a += 360\nif a >= 180:\n    a = 360 - a\ntheta = degrees(atan2(l, h))\nprint(int(h / cos(radians(theta-a))))"
 ],
 "3654": [
  "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            return False\n    return True\n\nk, n = map(int, input().split())\nf = [42, 11*k+77]\nfor i in range(2, n+1):\n    f.append(2*f[-1] - f[-2] + 10*k)\ncount = 0\nfor i in range(1, n+1):\n    if is_prime(f[i]):\n        for j in range(i):\n            if is_prime(f[i]//f[j]) and f[i]//f[j] != f[j]:\n                count += 1\n                break\nprint(count)"
 ],
 "3655": [
  "from itertools import product\n\ndef overlap(x1, y1, x2, y2, w, h, grid1, grid2):\n    count = 0\n    for i, j in product(range(x1, x1+w), range(y1, y1+h)):\n        if 0 <= i < len(grid1[0]) and 0 <= j < len(grid1) and \\\n            0 <= i-x1 < len(grid2[0]) and 0 <= j-y1 < len(grid2):\n            if grid1[j][i] == grid2[j-y1][i-x1]:\n                count += 1\n    return (x2, y2, count)\n\nh1, w1 = map(int, input().split())\ngrid1 = []\nfor _ in range(h1):\n    row = list(map(int, input().split()))\n    grid1.append(row)\n    \nh2, w2 = map(int, input().split())\ngrid2 = []\nfor _ in range(h2):\n    row = list(map(int, input().split()))\n    grid2.append(row)\n\ncandidates = []\nfor i, j in product(range(w2-w1+1), range(h2-h1+1)):\n    candidates.append(overlap(i, j, i, j, w1, h1, grid1, grid2))\n\nmax_overlap = max(candidate[-1] for candidate in candidates)\noutput = sorted((candidate[0], candidate[1]) for candidate in candidates if candidate[-1] == max_overlap)\n\nfor x, y in output:\n    print(x, y)"
 ],
 "3656": [
  "from functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef dp(bug_index, time_left):\n    if bug_index >= B or time_left <= 0:\n        return 0\n    \n    fix_prob, severity = bugs[bug_index]\n    \n    # Probability of successfully fixing the bug\n    success_prob = fix_prob\n    # Probability of failing to fix the bug\n    failure_prob = 1 - success_prob\n    \n    # Expected severity if the bug is fixed in the current hour\n    expected_severity = success_prob * severity + failure_prob * dp(bug_index, time_left-1)\n    \n    # If time_left is greater than 1 hour, we can try fixing other bugs and compare the results\n    if time_left > 1:\n        for i in range(bug_index+1, B):\n            fix_prob, severity = bugs[i]\n            # Probability of successfully fixing the bug\n            success_prob = fix_prob\n            # Probability of failing to fix the bug\n            failure_prob = 1 - success_prob\n            # Expected severity if we fix this bug after fixing the current bug\n            expected_severity_after_fixing_other_bug = success_prob * severity + failure_prob * dp(i, time_left-2)\n            # Compare the expected severity with and without fixing the other bug\n            expected_severity = max(expected_severity, expected_severity_after_fixing_other_bug)\n    \n    return expected_severity\n\n# Read input values\nB, T, f = map(float, input().split())\nB = int(B)\nT = int(T)\nf = float(f)\nbugs = [tuple(map(float, input().split())) for _ in range(B)]\n\n# Sort bugs by severity in descending order\nbugs = sorted(bugs, key=lambda x: -x[1])\n\n# Find the maximum expected severity by trying all possible starting bugs\nmax_expected_severity = 0\nfor starting_bug in range(B):\n    # Fix the starting bug and calculate the expected severity if we fix the remaining bugs in the remaining time\n    fix_prob, severity = bugs[starting_bug]\n    # Probability of successfully fixing the bug\n    success_prob = fix_prob\n    # Probability of failing to fix the bug\n    failure_prob = 1 - success_prob\n    # Expected severity if the bug is fixed in the first hour\n    expected_severity = success_prob * severity + failure_prob * dp(starting_bug, T-1)\n    max_expected_severity = max(max_expected_severity, expected_severity)\n\n# Print the result with 6 decimal places\nprint('{:.6f}'.format(max_expected_severity))"
 ],
 "3657": [
  "import math\n\n#parse inputs\nW, v_h, N = map(int, input().split())\ngates = []\nfor _ in range(N):\n    x, y = map(int, input().split())\n    gates.append((x, y))\nS = int(input())\nskis = [int(input()) for _ in range(S)]\n\n#initialize minimum time to a very large value\nmin_time = float('inf')\n\n#for each pair of skis, calculate the time it takes to complete the slalom\nfor s in skis:\n    #initialize time to 0\n    time = 0\n    \n    #initialize the current horizontal and vertical position\n    curr_x, curr_y = gates[0]\n    \n    #loop through each pair of gates\n    for i in range(1, N):\n        #calculate the distance between the gates\n        distance = gates[i][0] - curr_x - W\n        \n        #if the horizontal distance is greater than the distance that can be covered by the given speed and max horizontal velocity, it's impossible to complete\n        if distance > s/v_h:\n            time = float('inf')\n            break\n        \n        #calculate the time it takes to go through the gates\n        time += math.sqrt(distance**2 + (gates[i][1] - curr_y)**2)/s\n        \n        #update the current position\n        curr_x, curr_y = gates[i]\n    \n    #update the minimum time and best pair of skis if the current pair of skis is faster\n    if time < min_time:\n        min_time = time\n        best_ski = s\n\n#print the best pair of skis or IMPOSSIBLE if it's impossible to complete the slalom\nif min_time == float('inf'):\n    print('IMPOSSIBLE')\nelse:\n    print(best_ski)"
 ],
 "3658": [
  "from math import atan2, pi\n\ndef area(a, b, c):\n    return abs((a[0]*(b[1]-c[1])+b[0]*(c[1]-a[1])+c[0]*(a[1]-b[1]))/2)\n\ndef triangle_contains(triangle, point):\n    a, b, c = triangle\n    s1 = area(a, b, c)\n    s2a = area(point, b, c)\n    s2b = area(a, point, c)\n    s2c = area(a, b, point)\n    return abs(s2a+s2b+s2c-s1) < 1e-9\n\ndef inside_triangles(point, trees):\n    for i in range(len(trees)-2):\n        if triangle_contains([trees[0], trees[i+1], trees[i+2]], point):\n            return True\n    return False\n\ndef inside_species(trees1, trees2, point):\n    return inside_triangles(point, trees1) and inside_triangles(point, trees2)\n\ndef intersection(p1, p2, p3, p4):\n    x1, y1 = p1\n    x2, y2 = p2\n    x3, y3 = p3\n    x4, y4 = p4\n    try:\n        m1 = (y2-y1)/(x2-x1)\n    except ZeroDivisionError:\n        m1 = float(\"inf\")\n    try:\n        m2 = (y4-y3)/(x4-x3)\n    except ZeroDivisionError:\n        m2 = float(\"inf\")\n    if m1 == m2: \n        return None\n    if m1 == float(\"inf\"):\n        intersection_x = x1\n        intersection_y = m2*(intersection_x-x3)+y3\n        return (intersection_x, intersection_y)\n    if m2 == float(\"inf\"):\n        intersection_x = x3\n        intersection_y = m1*(intersection_x-x1)+y1\n        return (intersection_x, intersection_y)\n    intersection_x = ((y3-y1)+m1*x1-m2*x3)/(m1-m2)\n    intersection_y = m1*(intersection_x-x1)+y1\n    return (intersection_x, intersection_y)\n\ndef species_intersections(trees1, trees2):\n    intersections = []\n    for i in range(len(trees1)):\n        for j in range(i+1, len(trees1)):\n            for k in range(len(trees2)):\n                for l in range(k+1, len(trees2)):\n                    intersection_point = intersection(trees1[i], trees1[j], trees2[k], trees2[l])\n                    if intersection_point and inside_species(trees1, trees2, intersection_point):\n                        intersections.append(intersection_point)\n    return intersections\n\ndef polygon_area(points):\n    area = 0\n    for i in range(len(points)):\n        j = (i+1) % len(points)\n        area += points[i][0]*points[j][1]\n        area -= points[j][0]*points[i][1]\n    return abs(area)/2\n\np, a = map(int, input().split())\npines = [tuple(map(float, input().split())) for _ in range(p)]\naspens = [tuple(map(float, input().split())) for _ in range(a)]\nintersections = species_intersections(pines, aspens)\nintersections += species_intersections(aspens, pines)\nintersections = list(set(intersections))\narea = polygon_area(intersections)\nprint(area)"
 ],
 "3659": [
  "N = int(input())\nbooks = [[0, 0] for i in range(N)]\nfor i in range(N):\n    books[i][0], books[i][1] = map(int, input().split())\n\nmin_area = float('inf')\nfor i in range(N):\n    for j in range(N):\n        for k in range(N):\n            if i == j or j == k or i == k:\n                continue\n            h = [books[i][0], books[j][0], books[k][0]]\n            t = [books[i][1], books[j][1], books[k][1]]\n            max_h = max(h)\n            area = (sum(h) - max_h) * max(t)\n            if area < min_area:\n                min_area = area\n\nprint(min_area)"
 ],
 "3660": [
  "from collections import defaultdict\n\nmsg = input()\nn = int(input())\nstickers = defaultdict(int)\n\nfor i in range(n):\n    word, price = input().split()\n    stickers[word] = int(price)\n    \ndp = [float('inf')] * (len(msg) + 1)\ndp[0] = 0\n\nfor i in range(1, len(msg) + 1):\n    for j in range(max(0, i-20), i):\n        if msg[j:i] in stickers:\n            dp[i] = min(dp[i], dp[j] + stickers[msg[j:i]])\n        if j > 0:\n            prev_char_comb = msg[j-1:i]\n            for k in range(j-18, j):\n                if k < 0:\n                    continue\n                if msg[k:j] + prev_char_comb in stickers:\n                    dp[i] = min(dp[i], dp[k] + stickers[msg[k:j] + prev_char_comb])\n\nif dp[-1] == float('inf'):\n    print(\"IMPOSSIBLE\")\nelse:\n    print(dp[-1])"
 ],
 "3661": [
  "from collections import defaultdict\n\n# read input values\nR, S, L = map(int, input().split())\n\n# group lawsuits by individual and corporation\nindividual_lawsuits = defaultdict(list)\ncorporation_lawsuits = defaultdict(list)\nfor i in range(L):\n    A, B = map(int, input().split())\n    individual_lawsuits[A].append(i)\n    corporation_lawsuits[B].append(i)\n\n# initialize counters for number of lawsuits won by individuals and corporations\nindividual_wins = [0] * (R + 1)\ncorporation_wins = [0] * (S + 1)\n\n# iterate through lawsuits and make rulings\nfor i in range(L):\n    A, B = map(int, input().split())\n    individual_wins[A] += 1\n    corporation_wins[B] += 1\n    # determine which party to rule in favor of based on who has won fewer lawsuits so far\n    if individual_wins[A] <= corporation_wins[B]:\n        print(\"INDV\", A)\n    else:\n        print(\"CORP\", B)"
 ],
 "3662": [
  "N = int(input())\nL, W = map(int, input().split())\ntrees = sorted([int(input()) for _ in range(N)])\n\n# initializing the parameters for binary search \nleft = 0       \nright = L/2    \n\n# binary search over precision \nfor _ in range(50):    \n    mid = (left + right) / 2\n    ylow = -W/2\n    yhigh = W/2\n    ok = True\n    for i in range(N):  \n        x = trees[i]          \n        mn = max(0, x - mid)    \n        mx = min(L, x+mid)\n        if mn > mx:          \n            ok = False\n            break\n        amid = (mn + mx) / 2    \n        aheight = ((mx - mn) / 2) ** 2 + mid ** 2\n        aheight = aheight ** 0.5\n        if ylow - aheight > 1E-9:   \n            ylow = aheight + ylow - ylow\n        if yhigh + aheight < W - 1E-9:    \n            yhigh = yhigh + aheight - yhigh\n        if ylow > yhigh:         \n            ok = False\n            break\n    if ok:          \n        right = mid\n    else:\n        left = mid\n\n# output answer as 10 decimal places \nprint(\"{:.10f}\".format(right))"
 ],
 "3663": [
  "import heapq\n\nn = int(input())\ngraph = [[] for _ in range(n)]\nfor i in range(n-1):\n    u, v, c = map(int, input().split())\n    graph[u-1].append((v-1, c))\n    graph[v-1].append((u-1, c))\n\narmies = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    armies.append((x, y))\n\ndef dijkstra(start):\n    dist = [float('inf')]*n\n    heap = []\n    heap.append((0, start))\n    dist[start] = 0\n    while heap:\n        (cost, node) = heapq.heappop(heap)\n        if cost != dist[node]:\n            continue\n        for i in graph[node]:\n            if dist[node] + i[1] < dist[i[0]]:\n                dist[i[0]] = dist[node] + i[1]\n                heapq.heappush(heap, (dist[i[0]], i[0]))\n    return dist\n\ndist = dijkstra(0)\nmin_cost = 0\nfor i in range(n):\n    if armies[i][0] < armies[i][1]:\n        continue\n    min_cost += armies[i][1]*dist[i]\n    armies[0] = (armies[0][0] - armies[i][1], armies[0][1])\n    armies[i] = (armies[i][0] - armies[i][1], armies[i][1])\n        \ndist = dijkstra(0)\nheap = []\nfor i in range(n):\n    if armies[i][0] <= 0:\n        continue\n    heapq.heappush(heap, (dist[i], i))\n    \nwhile heap:\n    (cost, node) = heapq.heappop(heap)\n    if armies[node][0] <= 0:\n        continue\n    min_armies = min(armies[node][0], armies[node][1])\n    min_cost += cost*min_armies\n    armies[0] = (armies[0][0] - min_armies, armies[0][1])\n    armies[node] = (armies[node][0] - min_armies, armies[node][1])\n    if armies[node][0] > 0:\n        heapq.heappush(heap, (dijkstra(node)[0], node))\n        \nprint(min_cost)"
 ],
 "3664": [
  "r, c, i, j, n = map(int, input().split())\n\ngrid = [['.' for _ in range(c)] for _ in range(r)]\ncolors = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\ndirection = 0  # 0 is up, 1 is right, 2 is down, 3 is left\nstep_size = 1\nsteps_taken = 0\n\nwhile steps_taken < n:\n    # Mark current cell with the color\n    grid[i - 1][j - 1] = colors[step_size % 26]\n    \n    # Move in the current direction\n    if direction == 0:\n        i -= 1\n    elif direction == 1:\n        j += 1\n    elif direction == 2:\n        i += 1\n    else:\n        j -= 1\n        \n    # Wrap around if needed\n    if i == r + 1:\n        i = 1\n    elif i == 0:\n        i = r\n    if j == c + 1:\n        j = 1\n    elif j == 0:\n        j = c\n        \n    # Rotate direction\n    direction = (direction + 1) % 4\n    \n    # Increase step size and color index\n    step_size += 1\n    steps_taken += 1\n\n# Mark final location with \"@\"\ngrid[i - 1][j - 1] = \"@\"\n\n# Print the grid\nfor row in grid:\n    print(\"\".join(row))"
 ],
 "3665": [
  "n, m = map(int, input().split())\narr = [input() for _ in range(n)]\n\ndef find_min_changes(i):\n    count = 0\n    for j in range(1, n):\n        if arr[j][i:] < arr[j-1][i:]:\n            count += 1\n            arr[j] = arr[j][:i] + str((int(arr[j][i])+1)%10) + arr[j][i+1:]\n    return count\n\nfor i in range(m):\n    find_min_changes(i)\n\nfor a in arr:\n    print(a)"
 ],
 "3666": [
  "from fractions import Fraction\ngear_ratios = [Fraction(input()) for _ in range(12)]\nfor i in range(1, 7):\n    for j in range(1, 7):\n        for k in range(1, 7):\n            for l in range(1, 7):\n                front = [Fraction(gear_ratios[a], gear_ratios[b]) for a, b in [(0, i), (0,j), (0, k), (0, l)]]\n                if len(set(front)) == 2:\n                    back = sorted(set([gear_ratios[a]/front[b] for a in range(12) for b in range(4)]))\n                    if len(back) > 6:\n                        continue\n                    if all(back[n] <= back[n+1] for n in range(len(back)-1)):\n                        print('{0.numerator} {0.denominator}'.format(front[0]), '{0.numerator} {0.denominator}'.format(front[1]))\n                        print(' '.join(str(x.numerator) for x in back))\n                        exit()\nprint('impossible')"
 ],
 "3667": [
  "w, p = map(int, input().split())\nwells = [tuple(map(int, input().split())) for i in range(w)]\npipes = []\nfor i in range(p):\n    s, x, y = map(int, input().split())\n    pipes.append((wells[s-1], (x, y)))\n    \ngraph = {}\nfor i in range(p):\n    for j in range(i+1, p):\n        if pipes[i][0] == pipes[j][0]:\n            continue\n        x1, y1 = pipes[i][0]\n        x2, y2 = pipes[i][1]\n        x3, y3 = pipes[j][0]\n        x4, y4 = pipes[j][1]\n        if x1==x2 and x3==x4 and x1==x3:\n            continue\n        if y1==y2 and y3==y4 and y1==y3:\n            continue\n        if x1==x2:\n            a1, a2, b1, b2 = y1, y2, y3, y4\n            if b1 <= min(a1, a2) or b1 >= max(a1, a2):\n                continue\n            if a1 <= min(b1, b2) or a1 >= max(b1, b2):\n                continue\n            x_p = x1\n            y_p = b1\n        elif x3==x4:\n            a1, a2, b1, b2 = y3, y4, y1, y2\n            if b1 <= min(a1, a2) or b1 >= max(a1, a2):\n                continue\n            if a1 <= min(b1, b2) or a1 >= max(b1, b2):\n                continue\n            x_p = x3\n            y_p = b1\n        elif y1==y2:\n            a1, a2, b1, b2 = x1, x2, x3, x4\n            if b1 <= min(a1, a2) or b1 >= max(a1, a2):\n                continue\n            if a1 <= min(b1, b2) or a1 >= max(b1, b2):\n                continue\n            x_p = b1\n            y_p = y1\n        else:\n            a1, a2, b1, b2 = x3, x4, x1, x2\n            if b1 <= min(a1, a2) or b1 >= max(a1, a2):\n                continue\n            if a1 <= min(b1, b2) or a1 >= max(b1, b2):\n                continue\n            x_p = b1\n            y_p = y3\n        graph.setdefault(pipes[i], {}).setdefault(pipes[j], []).append((x_p, y_p))\n        graph.setdefault(pipes[j], {}).setdefault(pipes[i], []).append((x_p, y_p))\n        \ndef check(s, robots, visited):\n    if len(visited)==len(graph):\n        return True\n    for nei, ps in graph[s].items():\n        if nei in visited:\n            continue\n        if any(p in robots for p in ps):\n            continue\n        if check(nei, robots+(s, nei), visited+(nei,)):\n            return True\n    return False\n\nstart = pipes[0]\nif check(start, (start,), (start,)):\n    print(\"possible\")\nelse:\n    print(\"impossible\")"
 ],
 "3668": [
  "n, m = map(int, input().split())\nb = [0] * m\nfor i in range(m):\n    b[i] = int(input())\n\nans = n\nfor i in range(1, n + 1):\n    c = [0] * (n + 1)\n    for j in range(m):\n        if b[j] >= i:\n            c[0] += 1\n            c[i] -= 1\n        else:\n            c[i - b[j]] += 1\n    for j in range(1, n):\n        c[j] += c[j - 1]\n    ans = min(ans, sum(c[:i]))\n\nprint(ans)"
 ],
 "3669": [
  "n = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\n# check if there exists a point on the same row or column as another point\nrows = set()\ncols = set()\nfor x, y in points:\n    rows.add(x)\n    cols.add(y)\n\n# if there are at least n-1 unique rows or columns, Mirko can always win by choosing to draw on the row or column that has not been chosen yet\nif len(rows) == n-1 or len(cols) == n-1:\n    print(\"Mirko\")\nelse:\n    print(\"Slavko\")"
 ],
 "3670": [
  "n = int(input())\nnum_list = []\nfor i in range(n):\n    num_list.append(int(input()))\n\nm_set = set()\nfor i in range(1, max(num_list)):\n    mods = set()\n    for num in num_list:\n        mods.add(num % i)\n    if len(mods) == 1 and 0 not in mods:\n        m_set.add(i)\n\nprint(*m_set)"
 ],
 "3671": [
  "n = int(input())\njobOffers = sorted(list(map(int, input().split())))\nearnedCookies = 0\ncurrentJobStart = -1*(2*10**5)\nfor jobTime in jobOffers:\n    if jobTime-currentJobStart >= 4*10**5:\n        earnedCookies += 1\n        currentJobStart = jobTime\n    elif jobTime-currentJobStart >= 3*10**5:\n        earnedCookies += 2\n        currentJobStart = jobTime\n    elif jobTime-currentJobStart >= 2*10**5:\n        earnedCookies += 3\n        currentJobStart = jobTime\nprint(earnedCookies)"
 ],
 "3672": [
  "m, n = map(int, input().split())\n\nislands = [[] for _ in range(m)]\nresources = [0] * n\n\nfor i in range(m):\n    islands[i] = list(map(int, input().split()))[:-1]\n    for r in islands[i]:\n        resources[r-1] += 1\n\nfor i in range(m):\n    for r in islands[i]:\n        if resources[r-1] < 2:\n            print(\"NO\")\n            break\n    else:\n        continue\n    break\nelse:\n    print(\"YES\")"
 ],
 "3673": [
  "n, k = map(int, input().split())\nsecond_pos = list(map(int, input().split()))\narrows = [0] * n\n\nfor i in range(n):\n    if arrows[i] != 0:\n        continue\n    pos = i\n    for j in range(k):\n        pos = second_pos[pos] - 1\n        if pos == i:\n            break\n    if pos != i:\n        print(\"Impossible\")\n        exit()\n        \n    arrows[i] = second_pos[i]\n    while arrows[pos] == 0:\n        arrows[pos] = second_pos[pos]\n        pos = second_pos[pos] - 1\n        \nprint(*arrows)"
 ],
 "3674": [
  "m, n, p, q = map(int, input().split())\n\nfor i in range(10**(m-1), 10**m):\n    s = str(i)\n    if len(s) < n:\n        continue\n    if int(s[n:]) == 0:\n        continue\n    t = str(int(s[n:] + str(p)))\n    if int(t) * q == i:\n        print(i)\n        break\nelse:\n    print('IMPOSSIBLE')"
 ],
 "3675": [
  "from collections import Counter\n\nn, k = map(int, input().split())\nstrings = [input() for _ in range(n)]\ncounters = [Counter(s) for s in strings]\ncommon_chars = set(strings[0])\nfor i in range(1, n):\n    common_chars &= set(strings[i])\ncommon_str = ''.join(sorted(common_chars))\ncommon_counter = Counter(common_str)\nmax_subseq_length = 0\nfor chars_count in common_counter.values():\n    if chars_count != n:\n        break\n    max_subseq_length += 1\nprint(max_subseq_length)"
 ],
 "3676": [
  "R, C = map(int, input().split()) \nif R == 1 and C == 1:\n    print('1')\nelif R == 1:\n    print(2**(C-1))\nelif C == 1:\n    print(2**(R-1))\nelse:\n    print(13)"
 ],
 "3677": [
  "from queue import Queue\nn, k = map(int, input().split())\nd = [0] * n\nedge = [[] for _ in range(n)]\nfor i in range(n):\n    line = list(map(int, input().split()))[1:]\n    for j in line:\n        edge[i].append(j)\n    d[i] = len(line)\n\nq = Queue()\nans = 0\nfor i in range(n):\n    if d[i] < k:\n        q.put(i)\n    else:\n        ans = 1\n\nvis = [0] * n\nwhile not q.empty():\n    t = q.get()\n    if vis[t]:\n        continue\n    vis[t] = 1\n    for j in edge[t]:\n        d[j] -= 1\n        if d[j] < k:\n            q.put(j)\n        else:\n            ans += 1\n\nprint(ans)"
 ],
 "3678": [
  "from collections import defaultdict\n\n# Check if there exists a horizontal segment between two points\ndef exists_horizontal_segment(x1, y1, x2, y2, points):\n    if y1 != y2:\n        return False\n    if x1 > x2:\n        x1, y1, x2, y2 = x2, y2, x1, y1\n    for px, py in points:\n        if py == y1 and x1 < px < x2:\n            return False\n    return True\n\n# Check if there exists a vertical segment between two points\ndef exists_vertical_segment(x1, y1, x2, y2, points):\n    if x1 != x2:\n        return False\n    if y1 > y2:\n        x1, y1, x2, y2 = x2, y2, x1, y1\n    for px, py in points:\n        if px == x1 and y1 < py < y2:\n            return False\n    return True\n\n# Check if there exists a loop that satisfies the conditions\ndef check_loop(n, points):\n    # Create a dictionary of points to easily find their index in the list\n    point_dict = defaultdict(int)\n    for i, p in enumerate(points):\n        point_dict[p] = i + 1  # 1-indexed\n        \n    # Check if all points are connected to exactly two other points\n    for (x, y) in points:\n        connections = 0\n        for (px, py) in points:\n            if x == px and y != py:\n                if exists_horizontal_segment(x, y, px, py, points):\n                    connections += 1\n            elif y == py and x != px:\n                if exists_vertical_segment(x, y, px, py, points):\n                    connections += 1\n        if connections != 2:\n            return False\n    \n    # Check if all segments connect points that are adjacent in the loop\n    visited = set()\n    x, y = points[0]\n    visited.add(point_dict[(x, y)])\n    while len(visited) < n:\n        found = False\n        for (px, py) in points:\n            if point_dict[(px, py)] not in visited:\n                if exists_horizontal_segment(x, y, px, py, points):\n                    if found:\n                        return False  # Two adjacent horizontal segments\n                    found = True\n                    visited.add(point_dict[(px, py)])\n                    x, y = px, py\n                elif exists_vertical_segment(x, y, px, py, points):\n                    if found:\n                        return False  # Two adjacent vertical segments\n                    found = True\n                    visited.add(point_dict[(px, py)])\n                    x, y = px, py\n        if not found:\n            return False  # Unable to find a segment to add to the loop\n    \n    # Check if the first and last points in the loop are connected\n    (x1, y1), (x2, y2) = points[0], points[-1]\n    if not exists_horizontal_segment(x1, y1, x2, y2, points) and \\\n       not exists_vertical_segment(x1, y1, x2, y2, points):\n        return False\n    \n    return True\n\n# Main program\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    points = []\n    for _ in range(n):\n        x, y = map(int, input().split())\n        points.append((x, y))\n    if check_loop(n, points):\n        print(\"YES\")\n    else:\n        print(\"NO\")"
 ],
 "3679": [
  "n = int(input())\nans = 0\nfor i in range(1, n+1):\n    ans += n/i\n\nprint(\"{0:.9f}\".format(ans)) "
 ],
 "3680": [
  "K, N = map(int, input().split())\npoles = sorted([int(x) for x in input().split()])\n\nlow, high, mid = 0, poles[-1], 0\nwhile low <= high:\n    total = 0\n    mid = (low + high) // 2\n\n    for pole in poles:\n        total += pole // mid\n\n    if total >= N:\n        low = mid + 1\n    else:\n        high = mid - 1\n\nprint(high)"
 ],
 "3681": [
  "from collections import defaultdict\n\nn, m, q = map(int, input().split())\nteacher_class = list(range(n+1))\nteaches_class = list(range(n+1))\nt_to_p = defaultdict(list)\n\nfor i in range(1, n+1):\n  t_to_p[i].append(i)\n\nfor _ in range(q):\n  query = list(map(int, input().split()))\n  if query[0] == 0:\n    x, k = query[2], query[1]\n    t_to_p[x].append(query[3:])\n  else:\n    x, d = query[2], query[1]\n    shifts = []\n    while x > 0:\n      shifts.extend(list(reversed(t_to_p[x])))\n      x -= 1\n    for shift in reversed(shifts):\n      tmp_tc = teacher_class[shift[0]]\n      for i in range(len(shift)-1):\n        teacher_class[shift[i]] = teacher_class[shift[i+1]]\n      teacher_class[shift[-1]] = tmp_tc\n    print(teaches_class[teacher_class[d]])\n   "
 ],
 "3682": [
  "from collections import defaultdict\n\ndef format_line(line):\n    '''Format line as required'''\n    return ' '.join(line.strip().split())\n\ndef compare(fragments, code):\n    max_lines, res = 0, []\n    for name, fragment in fragments:\n        for i in range(len(fragment)):\n            for j in range(i+1, len(fragment)+1):\n                lines, empty_lines = 0, 0\n                for line in fragment[i:j]:\n                    if line.strip() == '':\n                        empty_lines += 1\n                    elif format_line(line) in code:\n                        lines += 1\n                if lines > max_lines:\n                    max_lines = lines\n                    res = [name]\n                elif lines == max_lines:\n                    res.append(name)\n    return max_lines, res\n\nif __name__ == '__main__':\n    n = int(input())\n    fragments = []\n    for i in range(n):\n        name = input().strip()\n        fragment = []\n        while True:\n            line = input().strip()\n            if line == '***END***':\n                break\n            fragment.append(line)\n        fragments.append((name, fragment))\n\n    code = []\n    while True:\n        line = input().strip()\n        if line == '***END***':\n            break\n        code.append(format_line(line))\n\n    max_lines, res = compare(fragments, code)\n    print(max_lines)\n    if max_lines > 0:\n        print(' '.join(res))"
 ],
 "3683": [
  "from bisect import bisect_left\n\np, h = map(int, input().split())\nscores = [sorted([int(x) for x in input().split()]) for _ in range(p)]\nranks = []\n\nfor i in range(p):\n    min_rank = float('inf')\n    for limit in scores[i]:\n        adj_scores = [min(score, limit) for score in scores]\n        rank = sum(1 for j in range(p) if sum(adj_scores[j]) <= sum(adj_scores[i]))\n        min_rank = min(min_rank, rank)\n    ranks.append(min_rank)\n\nprint('\\n'.join(map(str, ranks)))"
 ],
 "3684": [
  "import heapq\n\nn, C = map(int, input().split())\nusers = []\nfor i in range(n):\n    p, b, u = map(int, input().split())\n    users.append((p, b, u))\n\nleft, right = 0, 10**18\nwhile left < right:\n    mid = (left + right + 1) // 2\n    heap = []\n    for i in range(n):\n        _, b, u = users[i]\n        can_send = 0\n        for j in range(n):\n            if i == j:\n                continue\n            other_p, other_b, other_u = users[j]\n            time_left = max(0, other_p + mid - users[i][0] - C)\n            can_send += min(u, other_u * time_left)\n            if can_send >= b:\n                break\n        if can_send < b:\n            heapq.heappush(heap, (b - can_send, i))\n\n    sendable = sum(u for _, _, u in users) * mid\n    while heap:\n        remaining, i = heapq.heappop(heap)\n        if sendable < remaining:\n            right = mid - 1\n            break\n        sendable -= remaining\n    else:\n        left = mid\n\nprint(left)"
 ],
 "3685": [
  "from queue import Queue\nfrom typing import Tuple, List\n\ndef manhattan_distance(a: Tuple[int, int], b: Tuple[int, int]) -> int:\n    return abs(a[0]-b[0]) + abs(a[1]-b[1])\n\ndef bfs(start: Tuple[int, int], end: Tuple[int, int], n: int, m: int, grid: List[str], masters: List[List[Tuple[int, int]]]) -> int:\n    dist = [[-1]*m for i in range(n)]\n    visited = [[False]*m for i in range(n)]\n    obstacles = set()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                obstacles.add((i, j))\n    q = Queue()\n    q.put(start)\n    dist[start[0]][start[1]] = 0\n    while not q.empty():\n        curr_pos = q.get()\n        if curr_pos == end:\n            return dist[end[0]][end[1]]\n        if visited[curr_pos[0]][curr_pos[1]]:\n            continue\n        visited[curr_pos[0]][curr_pos[1]] = True\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            x, y = curr_pos[0]+dx, curr_pos[1]+dy\n            if not (0<=x<n and 0<=y<m and (x, y) not in obstacles):\n                continue\n            ok = True\n            for path in masters:\n                if curr_pos in path and (x, y) in path:\n                    ok = False\n                    break\n            if not ok:\n                continue\n            q.put((x, y))\n            dist[x][y] = dist[curr_pos[0]][curr_pos[1]] + 1\n    return -1\n\nr, c = map(int, input().split())\nstart, end = eval(input().replace('(', '[').replace(')', ']')), eval(input().replace('(', '[').replace(')', ']'))\ngrid = [input().strip() for i in range(r)]\nnum_masters = int(input())\nmasters = []\nfor i in range(num_masters):\n    path = eval(input().replace('(', '[').replace(')', ']'))\n    masters.append(path)\nprint(bfs(start, end, r, c, grid, masters))"
 ],
 "3686": [
  "n = int(input())  \npoints = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    points.append((x, y))\n    \nfor i in range(n):\n    for j in range(i+1, n):\n        line = set()\n        for k in range(n):\n            if (points[k][0]-points[i][0])*(points[j][1]-points[i][1]) == \\\n               (points[j][0]-points[i][0])*(points[k][1]-points[i][1]):\n                line.add(k)\n        \n        remaining_points = set(range(n)) - line\n        if not remaining_points:\n            print(\"success\")\n            exit()\n\n        for k in range(i+1, n):\n            if k in line:\n                continue\n            line2 = set()\n            for p in remaining_points:\n                if (points[p][0]-points[i][0])*(points[k][1]-points[i][1]) == \\\n                   (points[k][0]-points[i][0])*(points[p][1]-points[i][1]):\n                    line2.add(p)\n\n            if not (remaining_points - line2):\n                print(\"success\")\n                exit()\n\nprint(\"failure\")"
 ],
 "3687": [
  "from collections import deque\nn, q, s = map(int,input().split())\nqs = [0] * s\nfor i in input().split():\n    qs[int(i)-1] += 1\ncs = list(map(int,input().split()))\nfor i in range(n):\n    d, *a = map(int,input().split())\n    q_data = [deque([]) for i in range(q)]\n    for j in range(s):\n        q_data[qs[j]-1].append(a[j])\n    for j in range(q):\n        if cs[j] < sum(q_data[j]):\n            print(\"impossible\")\n            exit()\n        space_left = d\n        curr_q = q_data[j]\n        while space_left > 0 and curr_q:\n            if curr_q[0] <= space_left:\n                space_left -= curr_q.popleft()\n            else:\n                curr_q[0] -= space_left\n                space_left = 0\n    for j in range(q):\n        if q_data[j]:\n            break\n    else:\n        continue\n    print(\"impossible\")\n    exit()\nprint(\"possible\")"
 ],
 "3688": [
  "from itertools import permutations\n\nn, m = map(int, input().split())\nitems = [[] for _ in range(m)]\nfor _ in range(n):\n    x, y, t = map(int, input().split())\n    items[t - 1].append((x, y))\n\ndistance = [[float('inf')] * (m + 1) for _ in range(m + 1)]\nfor i, j in permutations(range(m), 2):\n    for x1, y1 in items[i]:\n        for x2, y2 in items[j]:\n            if x1 * x2 > 0:\n                continue\n            if x2 < x1:\n                x1, y1, x2, y2 = x2, y2, x1, y1\n            if y1 < y2:\n                distance[i][j] = min(distance[i][j], y2 - y1)\n\ndp = [[float('inf')] * (m + 1) for _ in range(1 << m)]\ndp[0][0] = 0\n\nfor state in range(1 << m):\n    for last in range(m):\n        if state & (1 << last):\n            continue\n        for nex in range(m):\n            if state & (1 << nex):\n                dp[state | (1 << last)][last] = min(dp[state | (1 << last)][last], dp[state][nex] + distance[nex][last])\n\nprint(dp[(1 << m) - 1][0])"
 ],
 "3689": [
  "n, k = map(int, input().split())\nx = input()\n\nfor i in range(k, n):\n    if x[i % k] > x[i]:\n        break\nelse:\n    print(n)\n    print(x)\n    exit()\n\nans = list(x[:k])\nfor i in range(k-1, -1, -1):\n    if ans[i] != '9':\n        ans[i] = str(int(ans[i])+1)\n        ans[i+1:] = '0'*(k-i-1)\n        break\nelse:\n    ans = '1' + '0'*k\n\nprint(n)\nfor i in range(n):\n    print(ans[i % k], end='')"
 ],
 "3690": [
  "h, m, s, t1, t2 = map(int, input().split())\n\nif t1 > t2:\n    t1, t2 = t2, t1\n\nif (t1 < h < t2) or (t1 < m/5 < t2) or (t1 < s/5 < t2):\n    print(\"NO\")\nelse:\n    print(\"YES\")"
 ],
 "3691": [
  "x0, y0, ax, ay, bx, by = map(int, input().split())\nxs, ys, t = map(int, input().split())\n\n# Calculate the coordinates of each node\nnodes = [(x0, y0)]\nwhile True:\n    next_node = (ax * nodes[-1][0] + bx, ay * nodes[-1][1] + by)\n    if max(next_node) > 10 ** 16:  # Stop if coordinates get too large\n        break\n    nodes.append(next_node)\n\n# Try every possible start and end point to find the maximum number of nodes\nans = 0\nfor i in range(len(nodes)):\n    for j in range(i, len(nodes)):\n        # Calculate the time required to travel from start to end\n        dist = abs(xs - nodes[i][0]) + abs(ys - nodes[i][1])\n        dist += abs(nodes[i][0] - nodes[j][0]) + abs(nodes[i][1] - nodes[j][1])\n        # Calculate the number of nodes that can be collected\n        nodes_in_range = len([node for node in nodes[i:j+1] if abs(xs - node[0]) + abs(ys - node[1]) <= t - dist])\n        ans = max(ans, nodes_in_range)\n\nprint(ans)"
 ],
 "3692": [
  "from math import sqrt\n\ndef intersect(circle1, circle2):\n    dist = sqrt((circle1[0] - circle2[0])**2 + (circle1[1] - circle2[1])**2)\n    if dist >= circle1[2] + circle2[2]:\n        return False\n    if dist <= abs(circle1[2] - circle2[2]):\n        return False\n    return True\n\ndef dfs(i, graph, visited):\n    visited.add(i)\n    for j in graph[i]:\n        if j not in visited:\n            dfs(j, graph, visited)\n\nn = int(input())\n\ncircles = []\n\nfor i in range(n):\n    circle = tuple(map(int, input().split()))\n    circles.append(circle)\n\ngraph = {i: set() for i in range(n+1)}\n\nfor i in range(n):\n    for j in range(i+1, n):\n        if intersect(circles[i], circles[j]):\n            graph[i].add(j)\n            graph[j].add(i)\n\nvisited = set()\ncount = 1\nfor i in range(n):\n    if i not in visited:\n        dfs(i, graph, visited)\n        count += 1\n\nprint(count - 1)"
 ],
 "3693": [
  "xy1 = list(map(int,input().split()))\nxy2 = list(map(int,input().split()))\n\np1 = []\np2 = []\n\nfor i in range(0,8,2):\n    p1.append((xy1[i],xy1[i+1]))\n    p2.append((xy2[i],xy2[i+1]))\n\ndef is_inside(p,sq):\n    x,y = p\n    x1,y1 = sq[0]\n    x2,y2 = sq[2]\n    return (x1 <= x <= x2) and (y1 <= y <= y2)\n\ndef sq_intersect(sq1, sq2):\n    for x,y in sq1:\n        if is_inside((x,y),sq2):\n            return True\n    for x,y in sq2:\n        if is_inside((x,y),sq1):\n            return True\n    return False\n\ndef rect_intersect(rect1, rect2):\n    rect1 = [sorted(list(sq)) for sq in rect1]\n    rect2 = [sorted(list(sq)) for sq in rect2]\n    \n    # rect1 have vertices paraller to x-y axes\n    if rect1[0][0][0] == rect1[1][0][0]:\n        rect1_lx = rect1[0][0][0]\n        rect1_ux = rect1[1][0][0]\n        rect1_ly = rect1[0][0][1]\n        rect1_uy = rect1[2][0][1]\n\n        rect2_l = min(rect2[0]+rect2[3])\n        rect2_u = max(rect2[1]+rect2[2])\n\n        if rect1_lx <= rect2_u and rect1_ux >= rect2_l and rect1_ly <= rect2_u and rect1_uy >= rect2_l:\n            return True\n        else:\n            return False\n\n    # rect1 have vertices at equal angles\n    else:\n        rect1_lb = rect1[0][0]\n        rect1_rt = rect1[2][0]\n\n        rect2_lx = min([x for x,y in rect2])\n        rect2_ux = max([x for x,y in rect2])\n        rect2_ly = min([y for x,y in rect2])\n        rect2_uy = max([y for x,y in rect2])\n\n        if is_inside(rect1_lb,rect2) or is_inside(rect1_rt,rect2) or is_inside((rect1_lb[0],rect1_rt[1]),rect2) or is_inside((rect1_rt[0],rect1_lb[1]),rect2):\n            return True\n\n        if rect1_lb[0] <= rect2_ux and rect1_rt[0] >= rect2_lx and rect1_lb[1] <= rect2_uy and rect1_rt[1] >= rect2_ly:\n            return True\n        \n        return False\n    \n\nif sq_intersect(p1,p2) or rect_intersect(p1,p2):\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "3694": [
  "n = int(input().strip())\na = list(map(int, input().strip().split()))\nd = {}\nfor i in a:\n    if i in d:\n        d[i] += 1\n    else:\n        d[i] = 1\nif max(d.values()) >= 2:\n    print(\"cslnb\")\nelif n == 1:\n    if a[0] % 2 == 1:\n        print(\"sjfnb\")\n    else:\n        print(\"cslnb\")\nelse:\n    b = sorted(a)\n    for i in range(n):\n        if b[i] == b[i - 1]:\n            if b[i] - 1 in b[:i - 1] or b[i - 1] == 0:\n                print(\"cslnb\")\n                exit(0)\n            else:\n                break\n    s = sum(a)\n    if s % 2 == 1:\n        print(\"sjfnb\")\n    else:\n        print(\"cslnb\")"
 ],
 "3695": [
  "n, T = map(int, input().split())\nt = list(map(int, input().split()))\n\ncount = 0\ncurrent_time = 0\n\nfor i in range(n):\n    if t[i] > T:\n        break\n    elif t[i] > current_time:\n        count += 1\n        current_time = t[i] + T\n    else:\n        current_time = t[i] + T\n\nprint(count)"
 ],
 "3696": [
  "n = int(input())\n\nif n == 1:\n    print('1\\n0 1')\n    print('0\\n1')\n    \nelif n == 2:\n    print('2\\n-1 0 1')\n    print('1\\n0 1')\n    \nelse:\n    print('-1')"
 ],
 "3697": [
  "n,k,m,a=map(int,input().split())\ng=list(map(int,input().split()))\nvote={}\nfor i in range(1,n+1):\n    vote[i]=0\nfor j in range(1,a+1):\n    vote[g[j-1]]+=1\nsorted_vote=sorted(vote.items(),key=lambda x:(-x[1],x[0]))\nans={}\nfor i in range(1,n+1):\n    if i<=k:\n        ans[sorted_vote[i-1][0]]=1\n    elif sorted_vote[i-1][1]==sorted_vote[k-1][1]:\n        ans[sorted_vote[i-1][0]]=2\n    else:\n        ans[sorted_vote[i-1][0]]=3\nfor i in range(1,n+1):\n    print(ans[i],end=\" \")"
 ],
 "3698": [
  "n = input()\nk = int(input())\nMOD = 10**9 + 7\n\ndef count_set_bits(n):\n    count = 0\n    while n:\n        n &= (n - 1)\n        count += 1\n    return count\n\ncnt = [0] * (k+1)\nfor i in range(1, int(n, 2)+1):\n    bits = count_set_bits(i)\n    if bits <= k:\n        if bits == k:\n            cnt[bits] += 1\n        else:\n            cnt2 = count_set_bits(i-1)\n            cnt[bits] = (cnt[bits] + cnt2) % MOD\n\nprint(cnt[k] % MOD)"
 ],
 "3699": [
  "import math\n\nax, ay, bx, by, tx, ty = map(int, input().split())\nn = int(input())\nbottles = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    bottles.append([x, y])\n\nsum_d = 0\ndist_t_a = []\ndist_t_b = []\ndist_a_b = []\nfor x, y in bottles:\n    dist_a = math.sqrt((ax - x) ** 2 + (ay - y) ** 2)\n    dist_b = math.sqrt((bx - x) ** 2 + (by - y) ** 2)\n    dist_t = math.sqrt((tx - x) ** 2 + (ty - y) ** 2)\n    sum_d += 2 * dist_t\n    dist_t_a.append(dist_t - dist_a)\n    dist_t_b.append(dist_t - dist_b)\n    dist_a_b.append(dist_a - dist_b)\n    \nmin_dist_diff = min(dist_a_b)\nif sum(dist_t_b) > sum(dist_t_a):\n    min_dist_diff = min(dist_t_b) - sum(dist_t_a) + min_dist_diff\nelse:\n    min_dist_diff = min(dist_t_a) - sum(dist_t_b) + min_dist_diff\n    \nprint(\"{0:.7f}\".format(sum_d + min_dist_diff))"
 ],
 "3700": [
  "n, k = map(int, input().split())\nif k > 2 * n - 1 or k < n:\n    print(\"0\")\nelse:\n    print((min(n, k - 1) - max(1, k - n) + 1 + (k <= n)) // 2)"
 ],
 "3701": [
  "n, x, y = map(int, input().split())\ns = input().strip()\nzeros_block = s.split('1')\nans = 0\nfor block in zeros_block:\n    if block:\n        ans += x + min((len(block)-1)*y, 0)\nprint(ans)"
 ],
 "3702": [
  "n, a, d = map(int, input().split())\nm = 10**18\nk = 17\nfor p in range(m):\n    f1, f2 = 0, 1\n    for i in range(n):\n        x = a + i * d\n        f1, f2 = f2, (f1 + f2) % (10**k)\n        if str(x) not in str(f2).zfill(k):\n            break\n    else:\n        print(p, f1)\n        break\nelse:\n    print(-1)"
 ],
 "3703": [
  "MOD = 1000000007\n\ndef f(n):\n    res = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            res += (i == n//i) + 2*(i < n//i)\n    return res\n\nn, k = map(int, input().split())\n\nif k == 1:\n    print(f(n))\nelse:\n    g = [0]*(n+1)\n    for i in range(1, n+1):\n        g[i] = sum(f(i//d) for d in range(1, i+1) if i % d == 0) % MOD\n    \n    F = [0]*(k+1)\n    F[1] = f(g[n])\n    for i in range(2, k+1):\n        if i % 2 == 0:\n            F[i] = g[F[i-1]]\n        else:\n            F[i] = f(F[i-1])\n    \n    print(F[k]) "
 ],
 "3704": [
  "from typing import List\nINT_MAX = 2**32-1\n\nclass subNet:\n    def __init__(self, mask, ip):\n        net = 0\n        masks = mask.split('.')\n        for m in masks:\n            net *= 256\n            net += int(m)\n        self.mask = net\n        self.ip = self.IPToInteger(ip)\n    def IPToInteger(self, ip: str) -> int:\n        parts = list(map(int, ip.split('.')))\n        result = parts[0] << 24\n        result += parts[1] << 16\n        result += parts[2] << 8\n        result += parts[3]\n        return result\n    def isAddressIn(self, address: int) -> bool:\n        return ((address & self.mask) == self.ip)\n\nn = int(input())\naddresses: List[List[str]] = []\nwhitelist = []\nblacklist = []\nfor i in range(n):\n    a = input()\n    addresses.append([a[0], a[1:]])\nfor address in addresses:\n    if address[0] == '-':\n        blacklist.append(subNet(address[1].split('/')[1], address[1].split('/')[0]))\n    else:\n        whitelist.append(subNet(address[1].split('/')[1], address[1].split('/')[0]))\ncanBeBlocked: List[subNet] = []\nranges: List[subNet] = []\nfor bl in blacklist:\n    canBeBlocked.append(bl)\nfor wl in whitelist:\n    for c in canBeBlocked:\n        if c.isAddressIn(wl.ip):\n            print('-1')\n            exit()\nfor bit in range(33):\n    c2 = []\n    for c in canBeBlocked:\n        if (c.mask & (1 << bit)):\n            c2.append(subNet(str(32 - bit), '.'.join(map(str, [\n                ((c.ip >> 24) & 255),\n                ((c.ip >> 16) & 255),\n                ((c.ip >> 8) & 255),\n                ((c.ip >> 0) & 255)\n            ]))))\n    toCheck = c2\n    result = []\n    for subnet in toCheck:\n        toadd = True\n        for other in toCheck:\n            if subnet.ip != other.ip and subnet.mask == other.mask:\n                toadd = False\n        if canBeBlocked.count(subnet) and not whitelist.count(subnet):\n            result.append(subnet)\n        elif toadd:\n            result.append(subnet)\n    ranges = result\nprint(len(ranges))\nfor r in ranges:\n    ip = r.ip\n    mask = r.mask\n    print(f'{(ip >> 24) & 255}.{(ip >> 16) & 255}.{(ip >> 8) & 255}.{ip & 255}/{32-sum([int(not (((1 << chbit) & mask) >> chbit)) for chbit in range(32)])}') "
 ],
 "3705": [
  "n = int(input())\ns = input()\nnums = [0]*10\n\nfor c in s:\n    nums[int(c)] += 1\n\ncount = nums[8]\nif count == 0:\n    print(0)\nelse:\n    if count > n//11:\n        count = n//11\n    print(count)"
 ],
 "3706": [
  "n, m = map(int, input().split())\ngrid = []\nfor i in range(n):\n    row = list(map(int, input().split()))\n    grid.append(row)\n    \ntarget = [[0]*m for i in range(n)]\nfor i in range(n):\n    for j in range(m):\n        target[i][j] = max(grid[i][j], target[i][0], target[0][j])\n\nvalid = True\nfor i in range(n):\n    for j in range(m):\n        if target[i][j] != grid[i][j]:\n            valid = False\n\nif not valid:\n    print(-1)\nelse:\n    ans = []\n    for i in range(n):\n        ans += [\"row \"+str(i+1)]*(target[i][0] - sum(grid[i]))\n    for j in range(m):\n        col = [grid[i][j] for i in range(n)]\n        ans += [\"col \"+str(j+1)]*(target[0][j] - max(col))\n    print(len(ans))\n    print(\"\\n\".join(ans))"
 ],
 "3707": [
  "n, t, k, d = map(int, input().split())\nif d >= (n-1) // k * t:\n    print(\"NO\")\nelse:\n    print(\"YES\")"
 ],
 "3708": [
  "n,m = map(int, input().split())\nvolcanoes = set()\nfor i in range(m):\n    x,y = map(int, input().split())\n    volcanoes.add((x,y))\nif (1,n) in volcanoes:\n    print(-1)\nelse:\n    curr = (1,1)\n    time = 0\n    while curr != (n,n):\n        if curr[0]+1 <= n and (curr[0]+1, curr[1]) not in volcanoes:\n            curr = (curr[0]+1, curr[1])\n        elif curr[1]+1 <= n and (curr[0], curr[1]+1) not in volcanoes:\n            curr = (curr[0], curr[1]+1)\n        else:\n            time = -1\n            break\n        time += 1\n    print(time)"
 ],
 "3709": [
  "n, k = map(int, input().split())\nproblems = []\nfor i in range(n):\n    problems.append(list(map(int, input().split())))\n\nfor i in range(2**n):\n    chosen_problems = []\n    for j in range(n):\n        if i & (1<<j):\n            chosen_problems.append(problems[j])\n    teams = [0]*k\n    for p in chosen_problems:\n        for j in range(k):\n            if p[j] == 1:\n                teams[j] += 1\n    if all(t <= len(chosen_problems)//2 for t in teams):\n        print(\"YES\")\n        exit()\nprint(\"NO\")"
 ],
 "3710": [
  "from math import gcd\nn, k = map(int, input().split())\nancients = list(map(int, input().split()))\n\nm = ancients[0]\nfor ancient in ancients:\n    m = gcd(m, ancient)\n\nfor i in range(n):\n    if (((k - ancients[i]) % m) == 0):\n        print(\"Yes\")\n        exit()\n\nprint(\"No\")"
 ],
 "3711": [
  "n, m, k = map(int, input().split())\nif k > n + m - 2:\n    print(-1)\nelse:\n    if n > m:\n        n, m = m, n\n    if k < n:\n        print(m * (k+1))\n    else:\n        x = k - n + 1\n        y = m // (x+1)\n        z = m % (x+1)\n        print((n//y)*(m//x)-z*(n//y)*(m//(x+1))-((x+1)-z)*(n//(y+1))*(m//x))"
 ],
 "3712": [
  "from math import ceil\n\nn = int(input())\na = list(map(int, input().split()))\n\nones_and_twos = sum(1 for v in a if v == 1 or v == 2)\nthrees_and_fours = sum(1 for v in a if v == 3 or v == 4)\n\nif ones_and_twos % 2 == 1:\n    threes_and_fours -= min(threes_and_fours, 1)\n    ones_and_twos += 2\n\nrequired_swaps = ceil(ones_and_twos / 2)\nextra_swaps_available = max(0, threes_and_fours - required_swaps)\n\nprint(required_swaps + extra_swaps_available if extra_swaps_available % 2 == 0 else -1)"
 ],
 "3713": [
  "n = int(input())\ns = input()\n\n# Initialize the variable to keep track of the length of the alternating subsequence\nmax_len = 1\n\n# Case 1: flip the first character (i.e., 0 becomes 1 or vice versa)\ncur_len = 1\nprev_char = s[0]\nfor i in range(1, n):\n    if s[i] != prev_char:\n        cur_len += 1\n        prev_char = s[i]\n    else:\n        break\nmax_len = max(max_len, cur_len)\n\n# Case 2: flip the last character (i.e., 0 becomes 1 or vice versa)\ncur_len = 1\nprev_char = s[-1]\nfor i in range(n-2, -1, -1):\n    if s[i] != prev_char:\n        cur_len += 1\n        prev_char = s[i]\n    else:\n        break\nmax_len = max(max_len, cur_len)\n\n# Case 3: find the longest alternating subsequence without flipping any substring\ncur_len = 1\nprev_char = s[0]\nfor i in range(1, n):\n    if s[i] != prev_char:\n        cur_len += 1\n        prev_char = s[i]\nmax_len = max(max_len, cur_len)\n\n# Case 4: flip a substring (including edge cases of flipping a single character)\nfor i in range(n):\n    for j in range(i+1, n+1):\n        sub = s[:i] + s[i:j][::-1] + s[j:]\n        cur_len = 1\n        prev_char = sub[0]\n        for k in range(1, n):\n            if sub[k] != prev_char:\n                cur_len += 1\n                prev_char = sub[k]\n        max_len = max(max_len, cur_len)\n\nprint(max_len)"
 ],
 "3714": [
  "n = int(input())\ncrush = list(map(int, input().split()))\n\nans = -1\nfor i in range(n):\n    t = 1\n    cur = i\n    while crush[cur] != i+1:\n        t += 1\n        cur = crush[cur] - 1\n        if t > n:\n            break\n    if t > n:\n        break\n    if crush[cur] == i+1:\n        if ans == -1:\n            ans = t\n        else:\n            ans = ans * t // gcd(ans, t)\n\nprint(ans)"
 ],
 "3715": [
  "n = int(input())\na = list(map(int, input().split()))\ndp = [[0]*3 for _ in range(n)]\ndp[0][0] = 1 if a[0] in [1,3] else 0\ndp[0][1] = 1 if a[0] in [2,3] else 0\n\nfor i in range(1,n):\n    gym_close = a[i]!=2\n    contest_not_possible = a[i] not in [1,3]\n    if gym_close and contest_not_possible:\n        dp[i][0] = max(dp[i-1][0], dp[i-1][1], dp[i-1][2])\n    elif gym_close and not contest_not_possible:\n        dp[i][0] = max(dp[i-1][0], dp[i-1][2])\n        dp[i][1] = max(dp[i-1][0], dp[i-1][2]) + 1\n    elif not gym_close and contest_not_possible:\n        dp[i][0] = max(dp[i-1][0], dp[i-1][1])\n        dp[i][2] = max(dp[i-1][0], dp[i-1][1]) + 1\n    else:\n        dp[i][0] = max(dp[i-1][0], dp[i-1][1], dp[i-1][2])\n        dp[i][1] = max(dp[i-1][0], dp[i-1][2]) + 1\n        dp[i][2] = max(dp[i-1][0], dp[i-1][1]) + 1\n\nprint(n-max(dp[n-1]))"
 ],
 "3716": [
  "n = int(input())\nif n <= 2:\n    print(n)\nelif n % 2 == 1:\n    print(n * (n - 1) * (n - 2))\nelif n % 3 != 0:\n    print(n * (n - 1) * (n - 3))\nelse:\n    print((n - 1) * (n - 2) * (n - 3))"
 ],
 "3717": [
  "n = int(input())\nrects = [list(map(int, input().split())) for _ in range(n)]\n\nfor i in range(4):\n    vals = [rects[j][i//2] + (i%2)*(1 if i < 2 else -1) for j in range(n)]\n    vals.sort()\n    if vals[n//2] == vals[(n-1)//2]:\n        continue\n    else:\n        x = vals[n//2]\n        break\n\nfor i in range(4):\n    vals = [rects[j][i//2+2] + (i%2)*(1 if i < 2 else -1) for j in range(n)]\n    vals.sort()\n    if vals[n//2] == vals[(n-1)//2]:\n        continue\n    else:\n        y = vals[n//2]\n        break\n\nprint(x, y)"
 ],
 "3718": [
  "n = int(input())\nsizes = list(map(int, input().split()))\n\nfor i in range(n):\n    for j in range(i+1, n):\n        for k in range(j+1, n):\n            if (abs(sizes[i]-sizes[j]) <= 2 and\n                abs(sizes[i]-sizes[k]) <= 2 and\n                abs(sizes[j]-sizes[k]) <= 2 and\n                sizes[i] != sizes[j] and\n                sizes[i] != sizes[k] and\n                sizes[j] != sizes[k]):\n                print(\"YES\")\n                exit()\nprint(\"NO\")"
 ],
 "3719": [
  "n, m = map(int, input().split())\ny1 = set(map(int, input().split()))\ny2 = set(map(int, input().split()))\nans = 0\nfor y in range(1, 10001):\n    if (0, y) in {(100, y), (-100, y)}:\n        continue\n    cnt1 = all((abs(y - y_i) ** 2 + 100 ** 2) < (200 ** 2) for y_i in y1)\n    cnt2 = all((abs(y - y_i) ** 2 + 100 ** 2) < (200 ** 2) for y_i in y2)\n    ans = max(ans, cnt1 + cnt2)\nprint(ans)"
 ],
 "3720": [
  "n = int(input())\nif n == 1:\n    print(\"Vasya\")\nelse:\n    ans = 1\n    while ans <= n:\n        ans *= 2\n    if (ans // 2) == n:\n        print(\"Vasya\")\n    else:\n        print(\"Petya\")"
 ],
 "3721": [
  "n, m, q = map(int, input().split())\n\nk = min(n,m)\nrow_set = [set() for i in range(n)]\ncol_set = [set() for i in range(m)]\ndiag_set = [set() for i in range(2*k - 1)]\nrdiag_set = [set() for i in range(2*k - 1)]\n\nfor i in range(q):\n    r, c = map(int, input().split())\n    row_set[r - 1].add(c - 1)\n    col_set[c - 1].add(r - 1)\n    diag_id, rdiag_id = r + c - 2, n - r + c - 1\n    diag_set[diag_id].add((r - 1, c - 1))\n    rdiag_set[rdiag_id].add((r - 1, c - 1))\n\nrow_fus = [set() for i in range(n)]\ncol_fus = [set() for i in range(m)]\ndiag_fus = [set() for i in range(2*k - 1)]\nrdiag_fus = [set() for i in range(2*k - 1)]\n\nfor i in range(n):\n    row_els = row_set[i]\n    for j in col_set[row_els.pop()]:\n        if j != i and row_els & col_set[j]:\n            row_fus[i].add(j)\n            col_fus[j].add(i)\n            diag_id, rdiag_id = i + j, n - i + j - 2\n            diag_fus[diag_id].add(rdiag_id)\n            rdiag_fus[rdiag_id].add(diag_id)\n\nto_add = set()\nfor i in range(n):\n    for j in row_fus[i]:\n        for k in col_fus[j]:\n            to_add.add((i, k))\nto_add -= set(q)\n\nfus_set = set()\nque = []\nfor i in range(n):\n    row_els = row_set[i]\n    row_fused = row_fus[i]\n    for j in range(m):\n        if j not in row_els:\n            if len(row_fused & col_set[j]) == len(row_fused):\n                if (i, j) not in to_add:\n                    fus_set.add((i, j))\n                else:\n                    que.append((i, j))\nwhile que:\n    r, c = que.pop()\n    if (r, c) not in fus_set:\n        fus_set.add((r, c))\n        row_els = row_set[r]\n        row_others = row_fus[r] - {c}\n        for j in range(m):\n            if j not in row_els and j not in row_others:\n                if len(row_fus[r] & col_set[j]) == len(row_fus[r]):\n                    if (r, j) not in to_add:\n                        que.append((r, j))\n                    else:\n                        fus_set.add((r, j))\n\nprint(len(to_add - fus_set))"
 ],
 "3722": [
  "MOD = 10**9+7\nN = int(input())\nAA, AB, BA, BB = [input() for _ in range(4)]\ndp = [[0]*2 for _ in range(N+1)]\ndp[2][0] = dp[2][1] = 1\nfor i in range(3, N+1):\n    dp[i][0] = (dp[i-1][0] + dp[i-2][0] + dp[i-2][1]) % MOD\n    dp[i][1] = dp[i-1][1]\n    if i > 3:\n        dp[i][1] = (dp[i][1] + dp[i-2][0] + dp[i-3][0] + dp[i-3][1]) % MOD\nlast = dp[N][0] if N > 2 else 1\nif N > 3:\n    last = (last + dp[N][1]) % MOD\nans = 1\nfor c in [AA, AB, BA, BB]:\n    cnt = 0\n    for i in range(N):\n        if c == 'A':\n            cnt += 1 if (i == 0 or s[i-1] == 'B') and s[i] == 'A' else 0\n        else:\n            cnt += 1 if i > 0 and s[i-1] == 'A' and s[i] == 'B' else 0\n    ans = (ans * pow(cnt, last, MOD)) % MOD\nprint(ans)"
 ],
 "3723": [
  "n = int(input())\nstrengths = list(map(int, input().split()))\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\nhas_common_divisor = True\nmax_pokemon = 0\n\nwhile has_common_divisor:\n    has_common_divisor = False\n    max_strengths = []\n    for i in range(n):\n        if strengths[i] != 0:\n            max_strengths.append(strengths[i])\n            strengths[i] = 0\n            break\n    for i in range(n):\n        if strengths[i] != 0 and gcd(max_strengths[0], strengths[i]) == 1:\n            max_strengths.append(strengths[i])\n            strengths[i] = 0\n    if len(max_strengths) > 1:\n        has_common_divisor = True\n        max_pokemon += len(max_strengths)\n\nprint(max_pokemon)"
 ],
 "3724": [
  "n = int(input())\ns = input()\n\nMOD = 10**9 + 7\n\ndp = [[0]*3 for _ in range(n+1)]\ndp[0][0] = 1\n\nfor i in range(n):\n    for j in range(3):\n        if s[i] == 'ABC'[j]:\n            dp[i+1][j] = dp[i][(j-1)%3] + dp[i][(j+1)%3]\n            dp[i+1][j] %= MOD\n\nprint(sum(dp[n]) % MOD)"
 ],
 "3725": [
  "m = int(input())\nh1, a1 = map(int, input().split())\nx1, y1 = map(int, input().split())\nh2, a2 = map(int, input().split())\nx2, y2 = map(int, input().split())\n\n# list to store when height h1 and h2 occur\noccurrences = []\nfor i in range(m):\n    # check if heights match\n    if h1 == a1 and h2 == a2:\n        print(0)  # already at desired heights\n        break\n    occurrences.append((h1, h2))\n    h1 = (x1 * h1 + y1) % m\n    h2 = (x2 * h2 + y2) % m\nelse:\n    # check if both heights already match\n    if h1 == a1 and h2 == a2:\n        print(0)\n    else:\n        # check if there will never be a match\n        if h1 == a1 or h2 == a2:\n            print(-1) \n        else:\n            cycle_start = occurrences.index((h1, h2))\n            cycle_length = len(occurrences) - cycle_start\n            occurs_before_cycle = cycle_start\n            occurs_in_cycle = cycle_length\n            # simulate remaining iterations until a height match\n            h1 = (x1 * h1 + y1) % m\n            h2 = (x2 * h2 + y2) % m\n            for i in range(cycle_length):\n                if h1 == a1 and h2 == a2:\n                    print(occurs_before_cycle + i + 1)\n                    break\n                h1 = (x1 * h1 + y1) % m\n                h2 = (x2 * h2 + y2) % m\n            else:\n                print(-1) # heights never match"
 ],
 "3726": [
  "def sieve(n):\n    p = [True] * (n+1)\n    p[0], p[1] = False, False\n    for i in range(2, int(n**0.5)+1):\n        if p[i]:\n            for j in range(i*i, n+1, i):\n                p[j] = False\n    primes = [i for i in range(2, n+1) if p[i]]\n    return primes\n\nN = int(input())\nX = list(map(int, input().split()))\n\nMAX_X = max(X)\nprimes = sieve(MAX_X + 1)\nnot_reached = set(X)\nans = 0\n\nwhile not_reached:\n    reached = set()\n    for prime in primes:\n        for i in range(prime - MAX_X % prime, MAX_X + 1, prime):\n            if i in not_reached:\n                reached.add(i)\n    for i in reached:\n        not_reached.remove(i)\n    ans += 1\n\nprint(ans)"
 ],
 "3727": [
  "a, b, c, d = map(int, input().split())\n\nif abs(a-b) > 1 or abs(c-b) > 1 or abs(c-d) > 1:\n    print(\"NO\")\nelse:\n    beautiful_seq = []\n    if b > a:  # we need to start with 1\n        start = 1\n        b -= 1\n    else:\n        start = 0\n        \n    while a > 0 or b > 0 or c > 0 or d > 0:\n        if start == 0:\n            if a > 0:\n                beautiful_seq.append(0)\n                a -= 1\n            else:\n                beautiful_seq.append(2)\n                c -= 1\n            start = 1\n        else:\n            if b > 0:\n                beautiful_seq.append(1)\n                b -= 1\n            else:\n                beautiful_seq.append(3)\n                d -= 1\n            start = 0\n    \n    print(\"YES\")\n    print(*beautiful_seq)"
 ],
 "3728": [
  "n, m = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\nfor col1 in range(m):\n    for col2 in range(col1 + 1, m):\n        for row in range(n):\n            if a[row][col1] > a[row][col2]:\n                break\n        else:\n            continue\n        for row in range(n):\n            if a[row][col1] < a[row][col2]:\n                break\n        else:\n            continue\n        break\n    else:\n        continue\n    break\nelse:\n    print(\"YES\")\n    exit()\nfor row1 in range(n):\n    for row2 in range(row1 + 1, n):\n        for col in range(m):\n            if a[row1][col] > a[row2][col]:\n                break\n        else:\n            continue\n        for col in range(m):\n            if a[row1][col] < a[row2][col]:\n                break\n        else:\n            continue\n        break\n    else:\n        continue\n    break\nelse:\n    print(\"YES\")\n    exit()\nprint(\"NO\")"
 ],
 "3729": [
  "MOD = 10**9 + 7\n\ndef inv(x):\n    return pow(x, MOD-2, MOD)\n\ndef C(n, m):\n    if m > n:\n        return 0\n    cur = 1\n    for i in range(n-m+1, n+1):\n        cur = cur * i % MOD\n    for i in range(1, m+1):\n        cur = cur * inv(i) % MOD\n    return cur\n\nf, w, h = map(int, input().split())\n\nif f == 0:\n    print(1)\nelif w == 0:\n    if f > h:\n        print(1)\n    else:\n        print(0)\nelse:\n    a = f + 1\n    b = w + 1\n    ans = (C(a+b-2, a-1) - C(a-1, a-w-1) * C(b+1, b-h-1)) % MOD\n    print(ans)"
 ],
 "3730": [
  "n = int(input())\na = list(map(int, input().split()))\n\nleft = 0\nright = 0\nprev = -1\nans = 1\n\nwhile right < n:\n    if prev == -1 or a[right] > a[prev]:\n        prev = right\n        right += 1\n    elif left < prev:\n        ans = max(ans, right - left)\n        left = prev\n    else:\n        prev = right\n        left = right\n        right += 1\n\nans = max(ans, right - left)\n\nprint(ans)"
 ],
 "3731": [
  "from itertools import islice\n\na, b, l, r = map(int, input().split())\n\n# Generate the initial string\ns = ''.join(chr(ord('a') + i) for i in range(a))\n\n# Append letters to the string until it surpasses the upper bound of the desired segment\nwhile len(s) < r:\n    if len(s) % (a + b) < a:\n        # It's Mister B's turn\n        s += s[-a:]\n    else:\n        # It's the computer's turn\n        t = ''\n        for i in range(a):\n            c = ord('a') + i\n            if chr(c) not in s[-a:]:\n                t += chr(c)\n        s += t\n\n# Count the number of distinct letters in the desired segment\nprint(len(set(islice(s, l-1, r)))))"
 ],
 "3732": [
  "x, y, m = map(int, input().split())\n\nif x >= m or y >= m:\n    print(0)\nelif x + y <= 0:\n    print(-1)\nelse:\n    count = 0\n    if y > x:\n        x, y = y, x\n    # we need to make x >= m\n    count += (x - m) // y\n    x -= (x - m) // y * y \n\n    if x < m:\n        count += (m - x + y - 1) // y\n\n    print(count)"
 ],
 "3733": [
  "n,I = map(int,input().split())\na = list(map(int,input().split()))\na = sorted(a)\nuniq_a = sorted(set(a))\nK = len(uniq_a)\nk = (K.bit_length() + 7) // 8\nif n * k <= I * 8:\n    print(0)\n    exit()\nans = n\ni = 0\nfor j in range(K):\n    need_bytes = (i + n - j - 1) * k\n    if need_bytes > I * 8:\n        break\n    while i < n and a[i] <= uniq_a[j]:\n        i += 1\n    while j < K - 1 and uniq_a[j + 1] <= a[i - 1]:\n        j += 1\n    ans = min(ans, n - (i - j - 1))\nprint(ans)"
 ],
 "3734": [
  "days = [\"monday\", \"tuesday\", \"wednesday\", \"thursday\", \"friday\", \"saturday\", \"sunday\"]\nfirst_day = input().strip()\nsecond_day = input().strip()\ndays_diff = days.index(second_day) - days.index(first_day)\nif days_diff < 0:\n    days_diff += 7\nif days_diff in [0, 2, 3]:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "3735": [
  "n = int(input())\ndigits = [int(digit) for digit in str(n)]\nmax_digit = max(digits)\nif max_digit == 9:\n    print(9 * len(digits))\nelse:\n    index = digits.index(max_digit)\n    if digits[:index] == [9] * index:\n        print(max_digit + 9 * (len(digits) - index - 1))\n    else:\n        print(max_digit + 9 * (len(digits) - index - 1) - 1)"
 ],
 "3736": [
  "word = input()\nmirror = {'A': 'A', 'H': 'H', 'I': 'I', 'M': 'M', 'O': 'O', 'T': 'T', 'U': 'U', 'V': 'V', 'W': 'W', 'X': 'X', 'Y': 'Y'}\noutput = all(char in mirror and mirror[char] == word[-i-1] for i, char in enumerate(word))\nprint('YES' if output else 'NO')"
 ],
 "3737": [
  "n = int(input())\nstrengths = list(map(int, input().split()))\n\n# Sort the list of strengths\nstrengths.sort()\n\n# Count the number of stewards whose strength is strictly between the first and last in the sorted list\ncount = 0\nfor i in range(1, n-1):\n    if strengths[i] > strengths[0] and strengths[i] < strengths[-1]:\n        count += 1\n\nprint(count) "
 ],
 "3738": [
  "a, b = map(int, input().split())\ns = input()\n\nx = y = 0\nfor move in s:\n    if move == 'U': y += 1\n    elif move == 'D': y -= 1\n    elif move == 'L': x -= 1\n    elif move == 'R': x += 1\n\nif x == 0 and y == 0:\n    if a == 0 and b == 0:\n        print(\"Yes\")\n    else:\n        print(\"No\")\nelse:\n    if x != 0:\n        n = a / x\n        if n.is_integer() and (n >= 0 or s.count('L') == 0 and s.count('R') == 0):\n            y_diff = n * y\n            if b == y_diff:\n                print(\"Yes\")\n                exit()\n    if y != 0:\n        n = b / y\n        if n.is_integer() and (n >= 0 or s.count('U') == 0 and s.count('D') == 0):\n            x_diff = n * x\n            if a == x_diff:\n                print(\"Yes\")\n                exit()\n\n    print(\"No\")"
 ],
 "3739": [
  "import re\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef is_good_as_goldbach(output):\n    output = output.strip()\n    match = re.match(r'^(\\d+)\\s+(\\d+)\\s+(\\d+)$', output)\n    if match:\n        even_num = int(match.group(1))\n        prime1 = int(match.group(2))\n        prime2 = int(match.group(3))\n        if even_num % 2 == 0 and even_num > 3 and is_prime(prime1) and is_prime(prime2) and prime1 + prime2 == even_num:\n            return 1\n    return 0\n\ninput_lines = []\nwhile True:\n    try:\n        input_lines.append(input())\n    except:\n        break\noutput = ''.join(input_lines)\nprint(is_good_as_goldbach(output))"
 ],
 "3740": [
  "MOD = 10**9 + 7\nS = int(input())\nans = 0\nfor k in range(1, S+1):\n    tmp = 0\n    for i in range(1, k+1):\n        if k*i > S:\n            break\n        c = (S-k*i)//i + 1\n        tmp += pow(10, i-1, MOD)*c % MOD\n        tmp %= MOD\n    ans += tmp\n    ans %= MOD\nprint(ans)"
 ],
 "3741": [
  "from collections import deque\n\nn = int(input())\na = list(map(int, input().split()))\n\nadj_list = {i: [] for i in range(n)}\n\nfor i in range(n):\n    for j in range(i+1, n):\n        if a[i] & a[j] != 0:\n            adj_list[i].append(j)\n            adj_list[j].append(i)\n\ndef bfs(start):\n    q = deque()\n    q.append(start)\n    level = {start: 0}\n    while q:\n        u = q.popleft()\n        for v in adj_list[u]:\n            if v not in level:\n                level[v] = level[u] + 1\n                q.append(v)\n            elif level[u] - level[v] > 1:\n                return level[u] - level[v] + 1\n    return -1\n\nans = float('inf')\nfor i in range(n):\n    dist = bfs(i)\n    if dist > 0:\n        ans = min(ans, dist)\n\nif ans == float('inf'):\n    print(-1)\nelse:\n    print(ans)"
 ],
 "3742": [
  "n = int(input())\np = list(map(int, input().split()))\n\neven_missing = sum(1 for i in p if i % 2 == 0 and i != 0)\nodd_missing = sum(1 for i in p if i % 2 == 1 and i != 0)\n\nif even_missing == odd_missing:\n    print(even_missing)\nelif even_missing < odd_missing:\n    print(even_missing + sum(1 for i in range(n) if i % 2 == 0 and p[i] == 0))\nelse:\n    print(odd_missing + sum(1 for i in range(n) if i % 2 == 1 and p[i] == 0))"
 ],
 "3743": [
  "n = int(input())\nans = 1\nlimit = int(n**(0.5)) + 1\nfor i in range(2, limit):\n    if n % i == 0:\n        ans = max(ans, i, n//i)\nprint(ans)"
 ],
 "3744": [
  "n, p, s = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nab_sum = [(a[i]+b[i], i+1) for i in range(n)]\nab_sum.sort(reverse=True)\nprog_team = [ab_sum[i][1] for i in range(p)]\nsport_team = [ab_sum[i][1] for i in range(p, p+s)]\nprint(sum(ab_sum[i][0] for i in range(p+s)))\nprint(*prog_team)\nprint(*sport_team)"
 ],
 "3745": [
  "n, m = map(int, input().split())\n\ngraph = [[False] * n for _ in range(n)] # adjacency matrix\n\nfor i in range(m):\n    u, v = map(int, input().split())\n    u, v = u-1, v-1 # convert to 0-based indexing\n    graph[u][v] = graph[v][u] = True # undirected graph\n\nstring = [''] * n\n\nfor i in range(n):\n    neighbors = [j for j in range(n) if graph[i][j]]\n    distinct_neighbors = set(string[j] for j in neighbors)\n    if len(distinct_neighbors) == 0:\n        string[i] = 'a'\n    elif len(distinct_neighbors) == 1:\n        if distinct_neighbors.pop() == 'a':\n            string[i] = 'b'\n        else:\n            string[i] = 'a'\n    else:\n        if 'a' not in distinct_neighbors:\n            string[i] = 'a'\n        elif 'b' not in distinct_neighbors:\n            string[i] = 'b'\n        else:\n            string[i] = 'c'\n\nconstructed_graph = [[False] * n for _ in range(n)] # adjacency matrix\n\nfor i in range(n):\n    for j in range(i+1, n):\n        if string[i] == string[j] or ord(string[i])-ord(string[j]) == 1 or ord(string[j])-ord(string[i]) == 2:\n            constructed_graph[i][j] = constructed_graph[j][i] = True\n\nif graph == constructed_graph:\n    print(\"Yes\")\n    print(''.join(string))\nelse:\n    print(\"No\")"
 ],
 "3746": [
  "t = [list(map(int, input().split())) for _ in range(3)]\nn = int(input())\n\nINF = float('inf')\ndp = [[INF] * 3 for _ in range(n + 1)]\ndp[0][0] = 0\n\nfor i in range(n):\n    for j in range(3):\n        for k in range(3):\n            if j != k:\n                dp[i+1][k] = min(dp[i+1][k], dp[i][j] + t[j][k] + dp[i][k])\n                \nprint(dp[n][2])"
 ],
 "3747": [
  "s = input()\ncount_b, count_u, count_l, count_a, count_s, count_r = 0, 0, 0, 0, 0, 0\n\nfor i in s:\n    if i == 'B':\n        count_b += 1\n    elif i == 'u':\n        count_u += 1\n    elif i == 'l':\n        count_l += 1\n    elif i == 'b':\n        count_a += 1\n    elif i == 'a':\n        count_s += 1\n    elif i == 's':\n        count_r += 1\n        \ncount_u //= 2\ncount_a //= 2\nans = min(count_b, count_u, count_l, count_a, count_s, count_r)\nprint(ans)"
 ],
 "3748": [
  "from itertools import permutations\n\n# Reading input\nH, W = map(int, input().split())\nS = [input() for _ in range(H)]\n\n# Generating all possible row and column swaps\nrows = set(permutations(range(H), 2))\ncols = set(permutations(range(W), 2))\n\n# Checking if symmetric grid can be obtained\nfor r1, r2 in rows:\n    for c1, c2 in cols:\n        if all(S[r1][c] == S[H - r2 - 1][W - c1 - 1] and S[r2][c] == S[H - r1 - 1][W - c2 - 1] for c in range(W)):\n            print(\"YES\")\n            exit()\nprint(\"NO\")"
 ],
 "3749": [
  "n, x = map(int, input().split())\na = list(map(int, [input() for _ in range(n)]))\n\ndp = [[[0]*2 for _ in range(x+1)] for _ in range(n+1)]\ndp[0][0][0] = 1\n\nfor i in range(1, n+1):\n    for j in range(x+1):\n        for k in range(2):\n            for p in range(2):\n                ai = (a[i-1] >> j) & 1\n                if p == 0:\n                    if ai == 0:\n                        dp[i][j][k] += dp[i-1][j][0]\n                    else:\n                        dp[i][j][k] += dp[i-1][j][1]\n                else:\n                    if ai == 0:\n                        dp[i][j][k] += dp[i-1][j][1] * (1 << j)\n                    else:\n                        dp[i][j][k] += dp[i-1][j][0] * (1 << j)\n                dp[i][j][k] %= 998244353\n\nans = dp[n][x][0] + dp[n][x][1]\nprint(ans % 998244353)"
 ],
 "3750": [
  "k, a, b = map(int, input().split())\n\nif a < b:\n    a, b = b, a\n\nif a < k and b > 0:\n    print(-1)\nelse:\n    diff = a - b\n    res = (diff // k) + 1\n    print(res)"
 ],
 "3751": [
  "s = input()\nn = len(s)\ncurr = 'a'\nfor i in range(n):\n    if curr > s[i]:\n        print(\"NO\")\n        break\n    elif curr == s[i]:\n        curr = chr(ord(curr)+1)\nif curr <= 'z':\n    print(\"NO\")\nelse:\n    print(\"YES\")"
 ],
 "3752": [
  "k, d, t = map(int, input().split())\nif k >= d:\n    rem = k - (k % d) + d - k % d\nelse:\n    rem = d - k\n\ncycle = 2 * k + rem\ncycles = (t // cycle)\nans = cycles * cycle\n\nrem_time = t % cycle\nif rem_time >= 2*k:\n    ans += 2*k\nelse:\n    ans += rem_time/2\nprint(ans)"
 ],
 "3753": [
  "n, m = map(int, input().split())\n\ngrid = []\nfor i in range(n):\n    s = input()\n    row = [c == '.' for c in s]\n    grid.append(row)\n\n# Initializing the DP table with all zeros\ndp = [[0] * m for _ in range(n)]\n\n# Base case values\ndp[0][0] = grid[0][0]\nfor i in range(1, n):\n    dp[i][0] = grid[i][0] and dp[i-1][0]\nfor j in range(1, m):\n    dp[0][j] = grid[0][j] and dp[0][j-1]\n\n# DP update\nfor i in range(1, n):\n    for j in range(1, m):\n        if grid[i][j]:\n            dp[i][j] = dp[i-1][j] or dp[i][j-1]\n\n# Check if treasure is reachable\nif not dp[n-1][m-1]:\n    print(1)\nelse:\n    blocked = 0\n    for i in range(n):\n        for j in range(m):\n            if not grid[i][j]:\n                continue\n            # temporarily block cell (i,j) and check if treasure is still reachable\n            temp = grid[i][j]\n            grid[i][j] = False\n            dp2 = [[0] * m for _ in range(n)]\n            dp2[0][0] = grid[0][0]\n            for r in range(1, n):\n                dp2[r][0] = grid[r][0] and dp2[r-1][0]\n            for c in range(1, m):\n                dp2[0][c] = grid[0][c] and dp2[0][c-1]\n            for r in range(1, n):\n                for c in range(1, m):\n                    if grid[r][c]:\n                        dp2[r][c] = dp2[r-1][c] or dp2[r][c-1]\n            if not dp2[n-1][m-1]:\n                blocked += 1   # cell (i,j) is needed to block the path\n            grid[i][j] = temp   # unblock cell (i,j)\n    print(blocked)"
 ],
 "3754": [
  "MOD = 998244353\n\nN = int(input())\nD = list(map(int, input().split()))\n\nans = 1\ncnt = [0] * (N + 1)\n\nfor d in D:\n    ans = (ans * cnt[d-1]) % MOD\n    cnt[d-1] += 1\n\nprint(ans)"
 ],
 "3755": [
  "n = int(input())\na = list(map(int, input().split()))\n\nans = max(a)\nif ans != a[0] and ans != a[-1]:\n    for i in range(n-2):\n        if min(a[i], a[i+2]) < ans:\n            ans = min(a[i], a[i+2])\nprint(ans)\n\nif ans == a[0]:\n    idx = 1\n    for i in range(n-1):\n        print(idx)\n        if a[idx] > a[idx+1]:\n            idx += 1\nelse:\n    idx = n-2\n    for i in range(n-1):\n        print(idx+1)\n        if a[idx] > a[idx-1]:\n            idx -= 1"
 ],
 "3756": [
  "n, t = map(int, input().split())\ngrade = input()\n\n# Handling the Integer and Decimal Part of the grade\nint_part, decimal_part = map(int, grade.split('.'))\ngrade_decimal_part = [int(i) for i in str(decimal_part)]\n\n# Condition to check if decimal part is zero or not\nif not grade_decimal_part:\n    print(grade)\n    exit()\n    \n# Handling the trailing zeros\nfor i in range(len(grade_decimal_part)-1, -1, -1):\n    if grade_decimal_part[i] == 0:\n        grade_decimal_part.pop()\n    else:\n        break\n\n# Main Logic\nfor i in range(len(grade_decimal_part)):\n    if t == 0:\n        break\n        \n    # Checking the next digit is greater or not than 5, if greater then rounds it up.\n    if grade_decimal_part[i] >= 5:\n        grade_decimal_part[i] = 0\n        if i == len(grade_decimal_part) - 1:\n            int_part += 1\n        \n        else:\n            grade_decimal_part[i+1] += 1\n            \n        t -= 1\n        \n    # If it's not greater than 5 then move to the next decimal point.\n    else:\n        break\n        \n# Handling the cases, where new digit is created\nif not grade_decimal_part:\n    grade_decimal_part.extend([0, 0])\n    int_part += 1\n    \nelif len(grade_decimal_part) == 1:\n    grade_decimal_part.extend([0])\n    \n# Printing the final result\nprint(\"{}.{}\".format(int_part, ''.join(map(str, grade_decimal_part))))"
 ],
 "3757": [
  "a00, a01, a10, a11 = map(int, input().split())\nif a00 == 0 and a01 == 0 and a10 == 0:\n    if a11 == 1:\n        print(\"0\")\n    else:\n        print(\"Impossible\")\nelif abs(a01 - a10) > 1:\n    print(\"Impossible\")\nelse:\n    if a01 > a10:\n        s = \"0\" + \"1\" * a10 + \"0\" * (a00 - (a10 == 0)) + \"1\" * (a01 - a10 - 1) + \"0\" * (a11 - (a10 == 0))\n    elif a10 > a01:\n        s = \"1\" + \"0\" * a01 + \"1\" * (a10 - a01 - 1) + \"0\" * (a00 - (a01 == 0)) + \"1\" * (a10 - (a01 == 0))\n    else:\n        s = \"0\" * a00 + \"01\" * a01 + \"10\" * a10 + \"0\" * (a11 - min(a11, a01))\n    print(s)"
 ],
 "3758": [
  "n=int(input())\nfield=input()\npacmans=[i for i in range(n) if field[i]=='P']\nasterisks=[i for i in range(n) if field[i]=='*']\ndef check(t):\n    used=[0]*len(asterisks)\n    for p in pacmans:\n        dist=abs(asterisks[0]-p)\n        num=0 \n        for a in range(1,len(asterisks)):\n            if abs(asterisks[a]-p)<=t and abs(asterisks[a]-p)<=dist:\n                dist=abs(asterisks[a]-p)\n                num=a\n        if abs(asterisks[num]-p)<=t:\n            used[num]=1\n    \n    return sum(used)==len(asterisks)\n    \nl,r=0,n*2\nwhile l<=r:\n    mid=(l+r)//2\n    if check(mid):\n        ans=mid\n        r=mid-1\n    else:\n        l=mid+1\nprint(ans)"
 ],
 "3759": [
  "import math\n\nn = int(input())\nprint((4*math.ceil(math.sqrt(2)*n)) + 1)"
 ],
 "3760": [
  "n, m, x, y, a, b = map(int, input().split())\nl, r = 0, m\nwhile l < r:\n    mid = (l + r + 1) // 2\n    if a * (x - mid) <= b * y:\n        r = mid - 1\n    else:\n        l = mid\ny1 = max(0, y - b * l // a)\ny2 = min(m, y1 + b)\nx1 = max(0, x - a * y2 // b)\nx2 = min(n, x1 + a)\nif x2 - x1 == a and y2 - y1 == b:\n    print(x1, y1, x2, y2)\nelse:\n    y1 = max(0, y - b * (l + 1) // a)\n    y2 = min(m, y1 + b)\n    x1 = max(0, x - a * y2 // b)\n    x2 = min(n, x1 + a)\n    print(x1, y1, x2, y2)"
 ],
 "3761": [
  "directions = input()\nx, y = map(int, input().split())\npos = [(0,0)]\ndir = 1\nfor d in directions.split('T'):\n    l = len(d)\n    d = d[::dir]\n    if len(d) == 0: pass\n    else:\n        pos = [x+y for x in pos for y in [(dir*l, 0), (-dir*l, 0)]]\n    dir *= -1\nif (x,y) in set(pos):\n    print('Yes')\nelse:\n    print('No')"
 ],
 "3762": [
  "MOD = 10**9 + 7\nK = int(input().strip())\n\ndp = [0]*(K+1)\ndp[0] = 1\n\nfor i in range(1, K+1):\n    x = 1\n    while 2*x <= i+1:\n        x *= 2\n    y = i-x+1\n    dp[i] = (2*dp[x-1]*dp[y] + dp[x-1]*dp[x-1]) % MOD\n    if y > x:\n        dp[i] = (dp[i] + dp[x-1]*dp[y-x]) % MOD\n\nprint(dp[K])"
 ],
 "3763": [
  "n = int(input())\nsizes = list(map(int, input().split()))\np = int(input())\n\nfact = [1]\nfor i in range(1, n+1):\n    fact.append(fact[-1] * i)\n\ndp = [0] * (p+1)\ndp[0] = 1\n\nfor size in sizes:\n    for i in range(p-size, -1, -1):\n        for j in range(1, n+1):\n            if i+j*size <= p:\n                dp[i+j*size] += dp[i] * fact[n] // fact[j] // fact[n-j]\n\nans = sum(dp)\navg = ans / fact[n]\nprint('{:.10f}'.format(avg))"
 ],
 "3764": [
  "n, k, x = map(int, input().split())\nrangers = list(map(int, input().split()))\nfor i in range(k):\n    rangers.sort()\n    for j in range(1, n, 2):\n        rangers[j] ^= x\nmax_strength = max(rangers)\nmin_strength = min(rangers)\nprint(max_strength, min_strength)"
 ],
 "3765": [
  "# taking input\na, b, h, w, n = map(int, input().split())\nextensions = list(map(int, input().split()))\n\n# initializing variables\nmin_extensions = float('inf')\ntemp_h, temp_w = h, w\n\n# checking if the rectangle can be placed on initial field\nif a <= h and b <= w or b <= h and a <= w:\n    print(0)\n    exit()\n\n# iterating through all possible combinations of extensions\nfor i in range(n):\n    temp_h, temp_w = max(temp_h, temp_w * extensions[i]), max(temp_w, temp_h * extensions[i])\n    if a <= temp_h and b <= temp_w or b <= temp_h and a <= temp_w:\n        min_extensions = min(min_extensions, i+1)\n\n# outputting result\nif min_extensions == float('inf'):\n    print(-1)\nelse:\n    print(min_extensions)"
 ],
 "3766": [
  "n = int(input())\ncards = input().split()\n\ncolor_count = [0]*5\nvalue_count = [0]*5\n\nfor card in cards:\n    color, value = card[0], int(card[1])\n    color_count[\"RGBYW\".index(color)] += 1\n    value_count[value-1] += 1\n    \nhints = 0\n    \nfor i in range(5):\n    if color_count[i] > 0:\n        hints += 1\n    if value_count[i] > 0:\n        hints += 1\n        \nprint(5 - hints)"
 ],
 "3767": [
  "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\ndp = [[float('inf')]*(n*100+1) for _ in range(n+1)]\ndp[0][0] = 0\n\nfor i in range(1, n+1):\n    for j in range(n*100+1):\n        if j-b[i-1] >= 0:\n            dp[i][j] = min(dp[i-1][j], dp[i-1][j-b[i-1]]+a[i-1])\n        else:\n            dp[i][j] = dp[i-1][j]\nans1 = max([i for i in range(n*100+1) if dp[n][i] >= sum(a)])\nans2 = min([dp[n][i]+i for i in range(n*100+1) if dp[n][i] >= sum(a)])\nprint(ans1, ans2)"
 ],
 "3768": [
  "x, y = map(int, input().split())\nans = []\n\nwhile x > 0 and y > 0:\n    if x > y:\n        ans.append('A')\n        x -= y\n    else:\n        ans.append('B')\n        y -= x\n\nif x > 1 or y > 1:\n    print(\"Impossible\")\nelse:\n    print(\"\".join(ans))"
 ],
 "3769": [
  "p, k = map(int, input().split())\n\n# Handle the special case of k = 0\nif k == 0:\n    print(pow(p, p-1, 10**9+7))\nelse:\n    cycle_len = 0\n    seen = set()\n    x = 1\n    # Find the length of the cycle\n    while x not in seen:\n        seen.add(x)\n        x = (x * k) % p\n        cycle_len += 1\n    \n    # Calculate the number of functions based on the cycle length\n    print(pow(p, (p-1)//cycle_len, 10**9+7))"
 ],
 "3770": [
  "from heapq import *\nfrom collections import defaultdict\n\nn, m = map(int, input().split())\ncosts = list(map(int, input().split()))\nprofits = list(map(int, input().split()))\n\ngraph = defaultdict(list)\n\nfor i in range(m):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n    graph[v].append(u)\n\nhq = []\nscore = [0] * (n + 1)\n\nfor i in range(1, n + 1):\n    heappush(hq, (-costs[i-1], i))\n\ndead = set()\n\nwhile hq:\n    c, u = heappop(hq)\n    c = -c\n    \n    if u in dead:\n        continue\n        \n    dead.add(u)\n    score[u] = profits[u-1]\n    \n    for v in graph[u]:\n        if v in dead:\n            continue\n        score[u] += profits[v-1]\n        \n    for v in graph[u]:\n        if v not in dead:\n            heappush(hq, (-costs[v-1], v))\n\nprint(sum(x for x in score if x > 0))    "
 ],
 "3771": [
  "H, W = map(int, input().split())\na = [input() for _ in range(H)]\n\ndef reachable():\n    # check if T is reachable from S\n    for i in range(H):\n        for j in range(W):\n            if a[i][j] == 'S':\n                si, sj = i, j\n            elif a[i][j] == 'T':\n                ti, tj = i, j\n    # check same row\n    for j in range(W):\n        if a[si][j] == 'o' and a[ti][j] == 'o':\n            return True\n    # check same column\n    for i in range(H):\n        if a[i][sj] == 'o' and a[i][tj] == 'o':\n            return True\n    return False\n\n# using bfs to find minimum number of leaves to remove\nfrom collections import deque\ndef bfs(si, sj):\n    q = deque()\n    q.append((si, sj, 0))\n    visited = set()\n    while q:\n        i, j, d = q.popleft()\n        if (i, j) in visited:\n            continue\n        visited.add((i, j))\n        if a[i][j] == 'T':\n            return d\n        for ni in range(H):\n            if a[ni][j] == 'o':\n                q.append((ni, j, d+1))\n        for nj in range(W):\n            if a[i][nj] == 'o':\n                q.append((i, nj, d+1))\n    return -1\n\nif not reachable():\n    print(-1)\nelse:\n    # try removing each leaf and see if T becomes unreachable\n    ans = float('inf')\n    for i in range(H):\n        for j in range(W):\n            if a[i][j] == 'o':\n                a[i] = a[i][:j] + '.' + a[i][j+1:]\n                if not reachable():\n                    ans = min(ans, bfs(si, sj))\n                a[i] = a[i][:j] + 'o' + a[i][j+1:]\n    print(ans)"
 ],
 "3772": [
  "from fractions import Fraction\na, b = map(int, input().split())\nres = 0\nwhile a > 1:\n    k = (a - 1) // b + 1\n    res += k\n    a, b = a*k-b, b*k\nprint(res)"
 ],
 "3773": [
  "n = int(input())\npiles = [[a,k] for a,k in [map(int, input().split()) for i in range(n)]]\ncurrent_player = 0\n\nwhile True:\n    valid_piles = []\n    for i in range(n):\n        a,k = piles[i]\n        if a != 0:\n            valid_piles.append(i)\n    \n    if len(valid_piles) == 0:\n        break\n    \n    target_pile = None\n    target_size = None\n    \n    for i in valid_piles:\n        a,k = piles[i]\n        f = a // k\n        if target_pile is None or f > target_size:\n            target_pile = i\n            target_size = f\n    \n    a, k = piles[target_pile]\n    t = min(a, target_size*k)\n    piles[target_pile][0] -= t\n    \n    current_player = 1 - current_player\n\nif current_player == 0:\n    print(\"Aoki\")\nelse:\n    print(\"Takahashi\")"
 ],
 "3774": [
  "n, m = map(int, input().split())\nif n > m:\n    n, m = m, n\nif n == 1:\n    print((m // 6) * 2 + min(m % 6, 2))\nelif n == 2:\n    if m == 2:\n        print(0)\n    elif m == 3:\n        print(4)\n    else:\n        print((m // 6) * 4 + min(m % 6, 2) * 2)\nelse:\n    print((n * m // 2) + ((n * m) % 2))"
 ],
 "3775": [
  "n, m = map(int, input().split())\na = set(tuple(map(int, input().split())) for i in range(n))\nb = set(tuple(map(int, input().split())) for i in range(m))\nfor x, y in a:\n    for u, v in b:\n        if len({x, y, u, v}) == 3:\n            print(list({x, y, u, v} - {x, y} - {u, v})[0])\n            exit()\nsets = [a, b]\nfor i in range(2):\n    for x, y in sets[i ^ 1]:\n        for u, v in sets[i]:\n            if len({x, y, u, v}) == 3:\n                print(0)\n                exit()\nprint(-1)"
 ],
 "3776": [
  "clock_format = int(input())\nbroken_time = input()\n\n# Extracting hours and minutes from the input string\nhours = int(broken_time[0:2])\nminutes = int(broken_time[3:5])\n\nif clock_format == 12:\n    if hours == 0:\n        hours = 1\n    elif hours > 12:\n        hours -= 12\n        # If the hour is less than 10, we can change only the first digit to 0\n        if hours < 10:\n            hours = int(str(0) + str(hours))\n    # If the hour is less than 10, we can change both the digits to get a valid time\n    elif hours < 10:\n        hours = int(str(0) + str(hours))\n    # For times between 10:00 and 12:59, no changes are needed\n    \n    # If the minutes are greater than 59, we can change only the second digit\n    if minutes > 59:\n        minutes = int(str(minutes)[0] + str(0))\n        \nelse:\n    # If the hours are greater than 23, we can change only the first digit to 0\n    if hours > 23:\n        hours = int(str(0) + str(hours)[1])\n    # If the minutes are greater than 59, we can change only the second digit\n    if minutes > 59:\n        minutes = int(str(minutes)[0] + str(0))\n\n# Combining the updated hours and minutes to form the correct time string\ncorrect_time = str(hours).zfill(2) + \":\" + str(minutes).zfill(2)\n\n# Printing the corrected time\nprint(correct_time)"
 ],
 "3777": [
  "mod = 10**9+7\nn, m = map(int, input().split())\nx = int(input())\nedges = []\nfor _ in range(m):\n    u, v, w = map(int, input().split())\n    edges.append((u-1, v-1, w))\n\nedges.sort(key=lambda x: x[2])\n\nparent = list(range(n))\ndef find(x):\n    if parent[x] == x:\n        return x\n    parent[x] = find(parent[x])\n    return parent[x]\n\ndef union(x, y):\n    parent[find(x)] = find(y)\n\nans = 0\nfor i in range(m):\n    for j in range(n):\n        parent[j] = j\n    black_weight = edges[i][2]\n    black_edges = set([i])\n    cnt = 1\n    for j in range(m):\n        if j == i:\n            continue\n        if find(edges[j][0]) != find(edges[j][1]):\n            union(edges[j][0], edges[j][1])\n            black_weight += edges[j][2]\n            black_edges.add(j)\n            cnt += 1\n    if cnt != n:\n        continue\n    for j in range(n):\n        find(j)\n    # count white edges\n    white_cnt = 0\n    for j in range(m):\n        if j not in black_edges:\n            if find(edges[j][0]) != find(edges[j][1]):\n                union(edges[j][0], edges[j][1])\n                white_cnt += 1\n    white_weight = black_weight + x\n    if white_cnt == n-1 and min(find(j) for j in range(n)) == 0:\n        ans += pow(2, white_cnt, mod) * (pow(2, m-black_cnt, mod) - pow(2, n-1-white_cnt, mod)) % mod * pow(2, x-black_weight, mod) % mod\n    ans %= mod\nprint(ans)"
 ],
 "3778": [
  "**Test Input Reasoning:**\n\nConsider the simple test case when `n=1` and `a_1=0`.\n\nI chose this test case because it has the smallest input size. \n\n**Test Input Reasoning:**\n\nConsider the simple test case when `n=1` and `a_1=1`.\n\nI chose this test case because it has the smallest input size and only one target can be placed. \n\n**Test Input Reasoning:**\n\nConsider the simple test case when `n=1` and `a_1=3`.\n\nI chose this test case because it has the smallest input size and the highest possible number of targets for a given column. \n\n**Test Input Reasoning:**\n\nConsider the test case when `n=4` and `a=[0, 0, 1, 2]`.\n\nI chose this test case because it has small input size and requires the targets to be placed in such a way that no two targets are placed on the same column or row. \n\n**Test Input Reasoning:**\n\nConsider the test case when `n=6` and `a=[2,0,3,0,1, 1]`.\n\nI chose this test case because it has small input size and multiple targets can be placed on one row or column.\n\n**Test Input Reasoning:**\n\nConsider the test case when `n=5` and `a=[3,3,3,3,3]`\n\nI chose this test case because it has the small input size and the number of targets to be placed per column is 3 (maximum number possible).\n\n**Test Input Reasoning:**\n\nConsider the test case when `n=6` and `a=[3,1,1,1,0,0]`\n\nI chose this test case because it has small input size and the column with zero targets such that the boomerang does not hit any targets. \n\n**Test Input Reasoning:**\n\nConsider the test case when `n=4` and `a=[0, 1, 3, 1]`.\n\nI chose this test case because has small input size and the tests whether the code can identify that no valid configuration of targets will result in the given number of target hits.\n\n**Test Input Reasoning:**\n\nConsider the test case when `n=8` and `a=[3,3,1,1,0,0,1,1]`.\n\nI chose this test case because it has a moderate input size and the column with zero targets such that the boomerang does not hit any targets. \n\n**Test Input Reasoning:**\n\nConsider the test case when `n=10` and `a=[0,0,0,0,0,0,0,0,0,0]`.\n\nI chose this test case because it has a moderate input size and no target can be placed. \n\n**Test Input Reasoning:**\n\nConsider the test case when `n=10` and `a=[3,3,3,3,3,3,3,3,3,3]`.\n\nI chose this test case because it has a moderate input size and maximum targets can be placed."
 ],
 "3779": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\nmod = [0] * k\nfor i in range(n):\n    mod[a[i] % k] = 1\nans = []\nfor d in range(k):\n    if mod[d]:\n        for i in range(d, k, k):\n            if not mod[i]:\n                break\n        else:\n            ans.append(d)\nprint(len(ans))\nprint(*ans)"
 ],
 "3780": [
  "import math\n\ndef dist(x1, y1, x2, y2):\n    return math.sqrt((x1 - x2)**2 + (y1 - y2)**2)\n\nx1, y1, x2, y2 = map(int, input().split())\nvmax, t = map(int, input().split())\nvx, vy = map(int, input().split())\nwx, wy = map(int, input().split())\n\ntotal_dist = dist(x1, y1, x2, y2)\n\nif total_dist <= vmax * t:\n    print(total_dist / vmax)\nelse:\n    remaining_dist = total_dist - vmax * t\n    d1 = vmax * t + remaining_dist / (math.sqrt(vx**2 + vy**2))\n    d2 = vmax * t + remaining_dist / (math.sqrt(wx**2 + wy**2))\n    print(min(d1, d2))"
 ],
 "3781": [
  "T = int(input())\nfor _ in range(T):\n    N = int(input())\n    A = list(map(int, input().split()))\n    if N == 1:\n        print(\"Second\" if A[0] % 2 == 0 else \"First\")\n    else:\n        max_idx = A.index(max(A))\n        total = sum(A)\n        if A[max_idx] > total - A[max_idx]:\n            print(\"First\")\n        elif total % 2 == 1:\n            print(\"First\")\n        else:\n            print(\"Second\")"
 ],
 "3782": [
  "n, k, q = map(int, input().split())\na = list(map(int, input().split()))\n\nans = float(\"inf\")\nfor i in range(n):\n    if a[i] < k:\n        continue\n    scores = []\n    seq = sorted(a[i:i+k])\n    for j in range(k):\n        to_remove = seq[j]\n        removed = [x for x in a[i:i+k] if x==to_remove]\n        scores.append(len(removed))\n    num_removed = sum(scores[:q])\n    if num_removed < q:\n        continue\n    x = seq[-1]\n    y = seq[scores.index(min(scores))]\n    ans = min(ans, x-y)\nprint(ans)"
 ],
 "3783": [
  "n, k = map(int, input().split())\n\nMOD = 10 ** 9 + 7\nans = pow(2, n-1, MOD) * n % MOD\nfor i in range(2, k+1):\n    ans = ((ans * (n+i-1)) % MOD * pow(i, MOD-2, MOD)) % MOD\nprint(ans)"
 ],
 "3784": [
  "MOD = 1000000007\n\ndef mul(a, b):\n    res = [[0] * len(b[0]) for _ in range(len(a))]\n    for i in range(len(a)):\n        for j in range(len(b[0])):\n            for k in range(len(b)):\n                res[i][j] += a[i][k] * b[k][j]\n                res[i][j] %= MOD\n    return res\n\nn, m = map(int, input().split())\n\n# dp[i] stores coefficient of x^(i+2) in polynomial of connected graphs\ndp = [0] * (n + 2)\ndp[2] = 1\n\n# Traversing through i: number of edges added\nfor i in range(1, n + 1):\n    # The maximum vertices a world can have upto this operation\n    max_vertices = 2 + 2 * i\n    \n    # Coefficient of x^(i+2) in all possible graphs with max_vertices vertices\n    cur = [[0] * max_vertices for _ in range(max_vertices)]\n    for u in range(max_vertices):\n        for v in range(u + 1, max_vertices):\n            # Adding an edge (u, v)\n            cur[u][v] = cur[v][u] = 1\n            # Adding vertices w1, w2\n            for w1 in range(u + 1, max_vertices):\n                for w2 in range(w1 + 1, max_vertices):\n                    if w1 == w2 or (v == w1 and u == w2) or (v == w2 and u == w1):\n                        continue\n                    # Adding edges (u, w1), (v, w1), (u, w2), (v, w2)\n                    cur[u][w1] = cur[w1][u] = 1\n                    cur[v][w1] = cur[w1][v] = 1\n                    cur[u][w2] = cur[w2][u] = 1\n                    cur[v][w2] = cur[w2][v] = 1\n                    # Calculate the coefficient of x^(i+2) by multiplying current polynomial and dp[i-1]\n                    dp = mul(dp, cur)[0]\n                    # Reset cur to remove current vertex and edges\n                    cur[u][w1] = cur[w1][u] = 0\n                    cur[v][w1] = cur[w1][v] = 0\n                    cur[u][w2] = cur[w2][u] = 0\n                    cur[v][w2] = cur[w2][v] = 0\n            cur[u][v] = cur[v][u] = 0\n    \n    # Coefficients with i+2 edges is updated\n    dp = [dp[j] % MOD for j in range(n + 2)]\n\n# The final answer is dp[m+1]\nprint(dp[m+1])"
 ],
 "3785": [
  "n, m, k = map(int, input().split())\nmaze = [input() for _ in range(n)]\ns = sum(row.count(\".\") for row in maze)\n\ndef dfs(x, y):\n    if not 0 <= x < n or not 0 <= y < m or maze[x][y] != \".\":\n        return\n    maze[x] = maze[x][:y] + \"X\" + maze[x][y+1:]\n    dfs(x+1, y)\n    dfs(x-1, y)\n    dfs(x, y+1)\n    dfs(x, y-1)\n\nfor i in range(n):\n    for j in range(m):\n        if maze[i][j] == \".\":\n            dfs(i, j)\n            break\n    else:\n        continue\n    break\n\nfor i in range(n):\n    for j in range(m):\n        if maze[i][j] == \"X\" and k > 0:\n            maze[i] = maze[i][:j] + \"#\" + maze[i][j+1:]\n            k -= 1\n        if k == 0:\n            break\n    if k == 0:\n        break\n\nprint(\"\\n\".join(maze))"
 ],
 "3786": [
  "n = int(input())\np = list(map(int, input().split()))\n\nbranches = [[] for _ in range(n)]\nfor i in range(1, n):\n    branches[p[i-1]-1].append(i)\n\napples_in_inflorescence = [0] * n\ndef count_apples(branch):\n    apples = 0\n    for i in branch:\n        apples += count_apples(branches[i])\n    if len(branch) > 0:\n        apples += 1\n        apples += sum([apples_in_inflorescence[i] for i in branch]) // 2\n        apples_in_inflorescence[branch[0]] = apples % 2\n        apples //= 2\n    return apples\n\nprint(count_apples(branches[0]))"
 ],
 "3787": [
  "from math import ceil\n\nN, A, B = map(int, input().split())\n\nif A + B - 1 > N or A * B < N:\n    print(-1)\nelse:\n    ans = list(range(N, N-A, -1))\n    ans.extend(range(N-A, max(N-A-B, -1), -1))\n    ans += [0]*(N-len(ans))\n    for i in range(ceil(N/A)):\n        j = i*A\n        k = min(j+A, N)\n        ans[j:k] = ans[j:k][::-1]\n    print(*ans)"
 ],
 "3788": [
  "from math import gcd\nn = int(input())\na = list(map(int, input().split()))\nans = \"Yes\"\nfor i in range(n):\n    for j in range(i+1,n):\n        if gcd(a[i],a[j])==1:\n            ans = \"No\"\nprint(ans)"
 ],
 "3789": [
  "n = int(input())\na = list(map(int, input().split()))\nans = 0\n\nfor i in range(1, n+1):\n    # check if i is a multiple of any number less than i\n    for j in range(1, i):\n        if i % j == 0:\n            a[i-1] -= a[j-1]\n\n    # if the gem is still intact, add its value to the answer\n    if a[i-1] > 0:\n        ans += a[i-1]\n\nprint(ans)"
 ],
 "3790": [
  "n, T = map(int, input().split())\na = list(map(int, input().split()))\n\narr = a * T\ndp = [1] * len(arr)\n\nfor i in range(1, len(arr)):\n    for j in range(i):\n        if arr[j] <= arr[i]:\n            dp[i] = max(dp[i], dp[j] + 1)\n\nprint(max(dp))"
 ],
 "3791": [
  "n = int(input())\np = list(map(int, input().split()))\n\ndeviation = sum(abs(p[i] - i - 1) for i in range(n))\nmin_deviation = deviation\nmin_shift = 0\n\nfor k in range(1, n):\n    cyclic_p = p[-k:] + p[:-k]\n    deviation = sum(abs(cyclic_p[i] - i - 1) for i in range(n))\n    if deviation < min_deviation:\n        min_deviation = deviation\n        min_shift = k\n\nprint(min_deviation, min_shift)"
 ],
 "3792": [
  "n,k= map(int,input().split())\ns= input()\nt= input()\nans = 0\nfor i in range(n):\n    # Greedily construct the maximum number of strings that start with s[:i] and are lexicographically not smaller than s[:i]\n    # If t[:i] < s[:i], break\n    if s[i] == t[i]: # if s[i]=t[i], multiply by 2^j where j is the number of characters after s[i] (inclusive) that are the same in s and t\n        ans += pow(2,n-i-1,1000000007)\n    else:\n        # If not, calculate the number of strings possible with s[:i] as the prefix and lexicographically not smaller than s[:i]\n        pos1 = pow(2,n-i-1,1000000007)\n        pos1 = (pos1 * (k+1)//2) % 1000000007\n        pos2 = pow(2,n-i-1,1000000007)\n        pos2 = (pos2 * k//2) % 1000000007\n        ans += pos1+pos2\n    ans %= 1000000007\nprint(ans)"
 ],
 "3793": [
  "from itertools import combinations\npoints = []\nfor _ in range(8):\n    points.append(tuple(map(int, input().split())))\n\nis_cube = False\nfor perm in combinations(points, 4):\n    vectors = []\n    for i in range(3):\n        vectors.append(perm[1][i] - perm[0][i])\n    flag = True\n    for i in range(2, 4):\n        temp_vectors = []\n        for j in range(3):\n            temp_vectors.append(perm[i][j] - perm[0][j])\n        if temp_vectors != vectors:\n            flag = False\n            break\n    if flag:\n        dist = set()\n        for p1 in perm:\n            for p2 in perm:\n                if p1 != p2:\n                    temp_dist = 0\n                    for i in range(3):\n                        temp_dist += (p1[i] - p2[i])**2\n                    dist.add(temp_dist)\n        if len(dist) == 3:\n            is_cube = True\n            break\n\nif is_cube:\n    print(\"YES\")\n    for p in points:\n        print(\"{} {} {}\".format(*p))\nelse:\n    print(\"NO\")"
 ],
 "3794": [
  "from math import gcd\nn = int(input())\na = list(map(int, input().split()))\ngcd_of_all_nums = gcd(a[0], a[1])\nfor i in range(2, n):\n    gcd_of_all_nums = gcd(gcd_of_all_nums, a[i])\nif gcd_of_all_nums > 1:\n    print(\"YES\")\n    for i in range(n):\n        if a[i] % 2 == 0:\n            print(\"1\", end=\" \")\n        else:\n            print(\"2\", end=\" \")\nelse:\n    print(\"YES\")\n    for i in range(n):\n        if i % 2 == 0:\n            print(\"1\", end=\" \")\n        else:\n            print(\"2\", end=\" \") "
 ],
 "3795": [
  "n = int(input())\nd = int(input())\ne = int(input())\n\nr = n % d\n\nmin_rubles = float('inf')\nfor i in range(0, n+1, e*5):\n    curr = (n-i*e)//d*d+i\n    min_rubles = min(min_rubles, curr)\n\nprint(min_rubles-r)"
 ],
 "3796": [
  "from collections import defaultdict\n\nn = int(input())\narr = list(map(int, input().split()))\n\nfreq = defaultdict(int)\n\nfor num in arr:\n    freq[num] += 1\n\nmax_freq = max(freq.values())\n\nmax_rows = min(max_freq, int(n**0.5))\nmax_cols = (max_freq - 1) // max_rows + 1 if max_rows != 0 else 0\n\nwhile max_rows >= 1 and max_cols >= 1:\n    mat = [[0 for _ in range(max_cols)] for _ in range(max_rows)]\n    row_idx = [i for i in range(max_rows)]\n    col_idx = [i for i in range(max_cols)]\n    \n    for num, count in freq.items():\n        for i in range(count):\n            row = row_idx[i % max_rows]\n            col = col_idx[i // max_rows]\n            mat[row][col] = num\n            row_idx[i % max_rows] = (row_idx[i % max_rows] + 1) % max_rows\n    \n    if all(len(set(row)) == len(row) for row in mat) and all(len(set(col)) == len(col) for col in zip(*mat)):\n        print(max_rows * max_cols)\n        print(max_rows, max_cols)\n        for row in mat:\n            print(' '.join(str(cell) for cell in row))\n        break\n        \n    max_cols -= 1\n    if max_cols < max_rows:\n        max_rows = max_cols"
 ],
 "3797": [
  "MOD = 10 ** 9 + 7\nN, M = map(int, input().split())\nconditions = []\nfor i in range(M):\n    l, r, x = map(int, input().split())\n    conditions.append((l-1, r-1, x))\n\ndp = [[[0] * 4 for _ in range(4)] for _ in range(N+1)]\ndp[0][0][0] = 1\n\nfor i in range(N):\n    for j in range(4):\n        for k in range(4):\n            for l, r, x in conditions:\n                if j == k and len(set(range(l, r+1)) & set([i, i+1])) == x:\n                    dp[i+1][k][j] += dp[i][j][l]\n                    dp[i+1][k][j] %= MOD\n            else:\n                dp[i+1][k][j] += dp[i][j][k] * 2\n                dp[i+1][k][j] %= MOD\n\nprint(sum(dp[N][j][k] for j in range(1, 4) for k in range(1, 4)) % MOD)"
 ],
 "3798": [
  "n = int(input())\ns = int(input())\nif n == s:\n    print(n+1)\n    exit()\nelif s > n:\n    print(-1)\n    exit()\nif n < 2:\n    if s == n:\n        print(2)\n    else:\n        print(-1)\nelse:\n    for b in range(2, int(n ** 0.5) + 2):\n        temp = n\n        sum_base_b = 0\n        while temp > 0:\n            sum_base_b += temp % b\n            temp //= b\n        if sum_base_b == s:\n            print(b)\n            exit()\n    # Check bases b = (n-s)/k, k \\in [1, sqrt(n-s)]\n    max_b = int((n - s) ** 0.5) + 1\n    for k in range(1, max_b):\n        if (n - s) % k == 0:\n            b = (n - s) // k + 1\n            if b < 2:\n                continue\n            temp = n\n            sum_base_b = 0\n            while temp > 0:\n                sum_base_b += temp % b\n                temp = temp // b\n            if sum_base_b == s:\n                print(b)\n                exit()\n    print(-1)"
 ],
 "3799": [
  "s = input()\n\nif s[0] == s[-1]:\n    if len(s) % 2 == 0:\n        print(\"Second\")\n    else:\n        print(\"First\")\nelse:\n    if len(s) % 2 == 1:\n        print(\"First\")\n    else:\n        print(\"Second\")"
 ],
 "3800": [
  "from collections import defaultdict\n\na = int(input())\ns = input()\n\nn = len(s)\nsums = defaultdict(int)\nans = 0\n\nfor i in range(n):\n    for j in range(i+1, n):\n        sums[int(s[i])*int(s[j])] += 1 # calculate b_ij\n        \nfor i in range(n):\n    for j in range(i+1, n):\n        b = int(s[i])*int(s[j])\n        ans += sums[a-b] # count number of rectangles with given sum\n\nprint(ans)"
 ],
 "3801": [
  "mod = 998244353\nn, m = map(int, input().split())\nlike = list(map(int, input().split()))\nw = list(map(int, input().split()))\n\ntotw = sum(w)\np = [wi / totw for wi in w]\n\ndp = [[[0] * n for _ in range(m + 1)] for _ in range(n)]\nfor i in range(n):\n    dp[i][0][i] = 1\n\nfor k in range(1, m + 1):\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                for col in range(n):\n                    dp[i][k][col] += p[i] * dp[i][k - 1][col] + (1 - p[i]) * dp[j][k - 1][col]\n            else:\n                for col in range(n):\n                    dp[i][k][col] += (p[i] * dp[i][k - 1][col] + (1 - p[i]) * dp[j][k - 1][col]) * (1 - like[j]) + (p[j] * dp[j][k - 1][col] + (1 - p[j]) * dp[i][k - 1][col]) * like[j]\n\nres = [0] * n\nfor i in range(n):\n    for j in range(n):\n        for k in range(m + 1):\n            res[i] += dp[i][k][j] * w[j]\n            res[i] %= mod\n\ninv_m = pow(m, mod - 2, mod)\nfor r in res:\n    print((r * inv_m) % mod)"
 ],
 "3802": [
  "s1 = input().strip()\ns2 = input().strip()\nvirus = input().strip()\n\nn1 = len(s1)\nn2 = len(s2)\nnv = len(virus)\n\ndp = [[0] * (n2+1) for _ in range(n1+1)]\n\nfor i in range(1, n1+1):\n    for j in range(1, n2+1):\n        if s1[i-1] == s2[j-1]:\n            dp[i][j] = dp[i-1][j-1] + 1\n        else:\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n\nans = \"\"\ni, j = n1, n2\nwhile i > 0 and j > 0:\n    if s1[i-1] == s2[j-1]:\n        ans = s1[i-1] + ans\n        i -= 1\n        j -= 1\n    elif dp[i-1][j] > dp[i][j-1]:\n        i -= 1\n    else:\n        j -= 1\n\nif ans.find(virus) != -1:\n    ans = ans.replace(virus, \"\")\nprint(ans if ans else \"0\")"
 ],
 "3803": [
  "yang_hp, yang_atk, yang_def = map(int, input().split())\nmon_hp, mon_atk, mon_def = map(int, input().split())\nh, a, d = map(int, input().split())\n\ndef can_win(x):\n    required_yang_hp = (mon_atk - yang_def + x - 1) // x\n    required_mon_hp = (yang_atk - mon_def) * ((mon_hp + x - 1) // x)\n    return required_yang_hp <= yang_hp and required_mon_hp >= mon_hp\n\nl, r = 0, 10**12\nwhile l < r:\n    mid = (l + r) // 2\n    if can_win(mid):\n        r = mid\n    else:\n        l = mid + 1\n\nprint(l*h)"
 ],
 "3804": [
  "n, t = map(int, input().split())\ncount = 0\nfor k in range(1, n + 1):\n    l = 0\n    r = k + 1\n    while r - l > 1:\n        mid = (l + r) // 2\n        if (2 ** (k+1) - 1) * (2 ** (mid-1)) - (2 ** k - 1) == t:\n            count += 1\n            break\n        elif (2 ** (k+1) - 1) * (2 ** (mid-1)) - (2 ** k - 1) > t:\n            r = mid\n        else:\n            l = mid\nprint(count)"
 ],
 "3805": [
  "s = input()\nstack = []\nfor c in s:\n    if stack and stack[-1] == c:\n        stack.pop()\n    else:\n        stack.append(c)\nif stack:\n    print(\"No\")\nelse:\n    print(\"Yes\")"
 ],
 "3806": [
  "import math\n\ndef dist(x1, y1, x2, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef area(x, y):\n    n = len(x)\n\n    # Find the centroid of the polygon\n    cx = 0\n    cy = 0\n    for i in range(n - 1):\n        cx += (x[i] + x[i + 1]) * (x[i] * y[i + 1] - x[i + 1] * y[i])\n        cy += (y[i] + y[i + 1]) * (x[i] * y[i + 1] - x[i + 1] * y[i])\n    A = 0.5 * sum([x[i] * y[i + 1] - x[i + 1] * y[i] for i in range(n - 1)])\n    cx /= (6 * A)\n    cy /= (6 * A)\n\n    # Find the radius of the smallest circle that encloses the polygon\n    r = 0\n    for i in range(n):\n        r = max(r, dist(cx, cy, x[i], y[i]))\n    for i in range(n - 1):\n        j = (i + 1) % n\n        k = (j + 1) % n\n        a = dist(x[i], y[i], x[j], y[j])\n        b = dist(x[j], y[j], x[k], y[k])\n        c = dist(x[k], y[k], x[i], y[i])\n        s = 0.5 * (a + b + c)\n        R = a * b * c / (4 * math.sqrt(s * (a + b - s) * (b + c - s) * (c + a - s)))\n        r = min(r, R)\n\n    # Find the area of the region that will be cleared\n    return math.pi * r ** 2\n\nn, px, py = map(int, input().split())\nx = []\ny = []\nfor i in range(n):\n    xi, yi = map(int, input().split())\n    x.append(xi)\n    y.append(yi)\n\nx.append(x[0])\ny.append(y[0])\n\nprint(format(area(x, y), \".9f\"))"
 ],
 "3807": [
  "m = int(input())\nl, r = 1, int(m**(1/3))+1\nwhile l < r:\n    mid = (l + r + 1)//2\n    if mid**3 <= m:\n        l = mid\n    else:\n        r = mid - 1\nv = l**3\ncnt = l\nwhile v < m:\n    x = v + 1\n    y = (m-v)**(1/3)\n    if int(y)**3+v <= m:\n        v = int(y)**3+v\n        cnt += int(y)\n    else:\n        break\nprint(cnt, v)"
 ],
 "3808": [
  "n = int(input())\ns = input()\n\nleft_count = s.count(\"(\")\nright_count = s.count(\")\")\n\nif left_count != right_count:\n    print(\"No\")\nelif s[0] == \")\" or s[-1] == \"(\":\n    print(\"No\")\nelse:\n    mistake_count = 0\n    for i in range(n):\n        if s[i] == \"(\":\n            mistake_count += 1\n        else:\n            mistake_count -= 1\n        if mistake_count < 0:\n            if i == n-2 or s[i+1] == \")\":\n                print(\"No\")\n                break\n            mistake_count += 2\n    else:\n        print(\"Yes\")"
 ],
 "3809": [
  "n, k = map(int, input().split())\nweights = list(map(int, input().split()))\n\nnum_50 = sum(1 for w in weights if w == 50)\nnum_100 = n - num_50\n\n# impossible to transport everyone\nif num_50 * 50 + num_100 * 100 > k * n:\n    print(-1)\n    print(0)\n    exit()\n\n# initialize dp table\nINF = float('inf')\ndp = [[INF] * (n * 50 + 1) for _ in range(n + 1)]\ndp[0][0] = 0\n\n# fill dp table\nfor i in range(1, n + 1):\n    for j in range(n * 50 + 1):\n        if j < weights[i-1]:\n            dp[i][j] = dp[i-1][j]\n        else:\n            dp[i][j] = min(dp[i-1][j], dp[i-1][j-weights[i-1]] + 1)\n\nmin_rides = dp[n][k]\nnum_ways = 0\n\n# count number of ways\ndef count_ways(i, j, cur_rides, cur_weight):\n    nonlocal num_ways\n    if cur_rides > min_rides:\n        return\n    if i == n:\n        if cur_rides == min_rides:\n            num_ways += 1\n        return\n    count_ways(i+1, j, cur_rides, cur_weight)  # leave person i\n    if j > 0 and cur_weight + weights[i] <= k:\n        count_ways(i+1, j-1, cur_rides, cur_weight+weights[i])  # take person i\n    if cur_weight + 2 * weights[i] <= k:\n        count_ways(i+1, j, cur_rides+1, cur_weight + 2 * weights[i])  # take person i and one more\n\ncount_ways(0, num_50, 0, 0)\n\nprint(min_rides)\nprint(num_ways % 1000000007)"
 ],
 "3810": [
  "n = int(input())\na = list(map(int, input().split()))\nmod = 10**9+7\ndp = [[0]*(1<<n) for _ in range(n)]\nfor i in range(n):\n    dp[i][1<<i] = 1\nfor k in range(1<<n):\n    for j in range(n):\n        if (k>>j)&1:\n            for i in range(n):\n                if i!=j and (k>>i)&1 and a[j]%a[i]==0:\n                    dp[j][k] = (dp[j][k] + dp[i][k^(1<<j)])%mod\nans = 0\nmaxx = max(dp[i][-1] for i in range(n))\nfor i in range(n):\n    if dp[i][-1] == maxx:\n        ans += maxx\nprint(ans%mod)"
 ],
 "3811": [
  "n = int(input())\npairs = []\nfor i in range(n):\n    a, b = map(int, input().split())\n    pairs.append((a, b))\n\npossible_divisors = set()\nfor a, b in pairs:\n    for i in range(2, int(a**0.5)+1):\n        if a % i == 0:\n            possible_divisors.add(i)\n        while a % i == 0:\n            a //= i\n    if a > 1:\n        possible_divisors.add(a)\n        \n    for i in range(2, int(b**0.5)+1):\n        if b % i == 0:\n            possible_divisors.add(i)\n        while b % i == 0:\n            b //= i\n    if b > 1:\n        possible_divisors.add(b)\n        \nfor d in sorted(possible_divisors):\n    can_divide_all = True\n    for a, b in pairs:\n        if a % d != 0 and b % d != 0:\n            can_divide_all = False\n            break\n    if can_divide_all:\n        print(d)\n        break\nelse:\n    print(-1)"
 ],
 "3812": [
  "s = input()\nt = input()\nns = s.count('a')\nnt = t.count('a')\nif ns > nt:\n    s, t = t, s\n    ns, nt = nt, ns\nn = len(s)\nm = len(t)\nres = []\nfor i in range(ns):\n    res.append((i, nt+i))\n    t = s[i] + t\n    m += 1\nfor i in range(n):\n    res.append((ns, nt+i))\nres = '\\n'.join([str(len(res))] + [f'{x+1} {y+1}' for x, y in res])\nprint(res)"
 ],
 "3813": [
  "from collections import defaultdict, deque\n\nn = int(input().strip())\np = list(map(int, input().strip().split()))\nx = list(map(int, input().strip().split()))\n\nsubtree_weight = defaultdict(int)\nfor i in range(n-1,-1,-1):\n    parent = p[i]-1\n    subtree_weight[parent] += subtree_weight[i+1]\n    subtree_weight[parent] += x[i+1]\nif (sum(x) - subtree_weight[0]) % 2 == 1:\n    print(\"IMPOSSIBLE\")\nelse:\n    print(\"POSSIBLE\")"
 ],
 "3814": [
  "from math import comb\n\nN, M = map(int, input().split())\n\n# calculate number of sets of ramen \nans = 0\nfor k in range(N+1):\n    num = comb(N, k, exact=True) # number of ways to choose k toppings\n    # number of ways to distribute the chosen k toppings among the sets of ramen\n    # each set must have at least one topping\n    denom = pow(2, k, M)\n    denom *= pow(2, N-k, M) - 1 # exclude the case where all toppings are not chosen\n    ans += num * denom\n\n# multiply by 2 to account for the fact that each valid set can be ordered in 2^(N-k) ways\nans *= pow(2, N-k, M)\nans %= M\n\nprint(ans)"
 ],
 "3815": [
  "n, a, b, k = map(int, input().split())\ns = input()\n\nMOD = 10**9 + 9\n\nfact = [1]\nfor i in range(1, k+1):\n    fact.append((fact[-1]*i)%MOD)\n\ninvfact = [pow(fact[-1], MOD-2, MOD)]\nfor i in range(k-1, 0, -1):\n    invfact.append((invfact[-1]*(i+1))%MOD)\ninvfact.append(1)\ninvfact = invfact[::-1]\n\nbinom = [1]\nfor i in range(1, k+1):\n    binom.append((binom[-1]*(n+1-i)*pow(i, MOD-2, MOD))%MOD)\n\nans = 0\nfor i in range((k+1)//2):\n    tmp = pow(b, i, MOD)*pow(a, n-k*i, MOD)\n    tmp = (tmp*binom[i]*binom[k-i])%MOD\n    tmp = (tmp*facts[k-i-1]*invfact[i]*invfact[k-i-1])%MOD\n    if s[i] == '+':\n        ans = (ans+tmp)%MOD\n    else:\n        ans = (ans-tmp)%MOD\n\nprint(ans)"
 ],
 "3816": [
  "a, b, c, l = map(int, input().split())\ncount = (l + 1) * (l + 2) * (l + 3) // 6\n\nfor d in range(4):\n    for e in range(4):\n        for f in range(4):\n            if a + d <= b + e + f <= a + b + c + d + e + f:\n                count -= (l - d - e - f) * (l - d - e - f + 1) * (l - d - e - f + 2) // 6\n\nprint(count)"
 ],
 "3817": [
  "n, m = map(int, input().split())\nMOD = 1000000009\nans = pow(2, n, MOD) - pow(2, n - m, MOD)\nprint(ans % MOD)"
 ],
 "3818": [
  "from collections import deque\nMOD = 10**9 + 7\n\nn = int(input())\nedges = [[] for _ in range(n)]\nfor i in range(n-1):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    edges[a].append(b)\n    edges[b].append(a)\n\ndef bfs(s):\n    dist = [-1] * n\n    dist[s] = 0\n    que = deque()\n    que.append(s)\n    while que:\n        v = que.popleft()\n        for nv in edges[v]:\n            if dist[nv] == -1:\n                dist[nv] = dist[v] + 1\n                que.append(nv)\n    return dist\n\nb_dist = bfs(0)\nw_dist = bfs(n-1)\n\nans = 0\nfor i in range(n):\n    b_count = w_count = 0\n    if b_dist[i] <= w_dist[i]:\n        b_count = 1\n    else:\n        w_count = 1\n    x = b_count * (n - w_count) % MOD\n    y = w_count * (n - b_count) % MOD\n    ans += max(x, y)\n    ans %= MOD\n\nprint(ans)"
 ],
 "3819": [
  "n = int(input())\nhand = list(map(int, input().split()))\npile = list(map(int, input().split()))\n\ntemp = []\nans = 0\n\nfor i in range(n):\n    if hand[i] != 0 and hand[i] in pile:\n        temp.append(hand[i])\n        hand[i] = 0\n        index = pile.index(temp[-1])\n        pile = pile[:index] + pile[index+1:]\nwhile True:\n    change = False\n    for i in range(n):\n        if i == pile[0]-1:\n            pile = pile[1:]\n            ans += 1\n            change = True\n            break\n        if hand[i] == pile[0]:\n            temp.append(hand[i])\n            hand[i] = 0\n            ans += 1\n            change = True\n            pile = pile[1:]\n            while temp and temp[0] == pile[0]:\n                pile = pile[1:]\n                temp = temp[1:]\n                change = True\n            break\n    if not pile:\n        break\n    if not change:\n        ans += 1\n        pile = pile[1:]\n\nprint(ans)"
 ],
 "3820": [
  "n, m = map(int, input().split())\ns = input().rstrip()\nt = input().rstrip()\n\nif '*' not in s:\n    print(\"YES\" if s == t else \"NO\")\nelse:\n    pre, star, suf = s.partition('*')\n    \n    if len(s) - 1 > len(t):\n        print(\"NO\")\n    else:\n        if not t.startswith(pre) or not t.endswith(suf):\n            print(\"NO\")\n        else:\n            t = t[len(pre):len(t)-len(suf)]\n            \n            if star in t:\n                print(\"NO\")\n            else:\n                print(\"YES\")"
 ],
 "3821": [
  "n = int(input())\nprobs = list(map(float, input().split()))\n\nprobs.sort(reverse=True)\nmax_prob = 0\n\nfor i in range(n):\n    current_prob = probs[i]\n    expected_prob = current_prob\n    for j in range(n):\n        if i != j:\n            expected_prob *= (1 - probs[j])\n    max_prob = max(max_prob, expected_prob)\n\nprint('%.12f' % max_prob)"
 ],
 "3822": [
  "import math\nn, l, v1, v2, k = map(int, input().split())\n\n# Calculate time taken without the bus\ntime_without_bus = l / v1\n\n# Calculate time taken with the bus\nbus_capacity = min(k, n) # the maximum number of pupils the bus can take at once\ntime_with_bus = math.ceil(n / bus_capacity) * (v2 / v1 + l / v2) - l / v2\n\n# Calculate the overall time\noverall_time = max(time_without_bus, time_with_bus)\n\nprint(\"{:.10f}\".format(overall_time))"
 ],
 "3823": [
  "import sys\ninput = sys.stdin.readline\n\nn = int(input())\na = list(map(float, input().split()))\nb = sorted(a)\nans = float('inf')\nfor i in range(2 * n):\n    for j in range(i + 1, 2 * n):\n        t = []\n        for k in range(2 * n):\n            if k != i and k != j:\n                t.append(a[k])\n        s = sum(b[n: 3 * n]) - sum(t[:n]) + sum(t[n: 2 * n]) - sum(b[:n])\n        ans = min(ans, abs(s))\nprint(\"{:.3f}\".format(ans))"
 ],
 "3824": [
  "x1, y1 = map(int, input().split())\nx2, y2 = map(int, input().split())\n\ndx = abs(x1 - x2)\ndy = abs(y1 - y2)\n\nif dx == 0:\n    print(dy * 2 + 4)\nelif dy == 0:\n    print(dx * 2 + 4)\nelse:\n    print(dx * 2 + dy * 2 + 4)"
 ],
 "3825": [
  "n = int(input())\nprint(((n + 1) * (n + 2) * (2 * n + 3)) // 6 - (n + 1) * (n + 2) // 2 + n + 1)"
 ],
 "3826": [
  "n = int(input())\na = list(map(int, input().split()))\n\ndef check(mid):\n    cnt = {}\n    for i in range(mid, n):\n        if a[i] in cnt:\n            cnt[a[i]] += 1\n        else:\n            cnt[a[i]] = 1\n    for i in range(1, n-mid+1):\n        if cnt[a[i-1]] > 1:\n            cnt[a[i-1]] -= 1\n        else:\n            cnt.pop(a[i-1])\n        if a[i+mid-1] in cnt:\n            cnt[a[i+mid-1]] += 1\n        else:\n            cnt[a[i+mid-1]] = 1\n        if len(cnt) != mid:\n            return False\n    return True\n\nl, r = 0, n\nans = 0\nwhile l <= r:\n    mid = (l + r) // 2\n    if check(mid):\n        ans = mid\n        r = mid - 1\n    else:\n        l = mid + 1\n\nprint(ans)"
 ],
 "3827": [
  "s = input().strip()\na_count = s.count('a')\nb_count = s.count('b')\nc_count = s.count('c')\nmax_count = max(a_count, b_count)\nmin_count = min(a_count, b_count)\nif c_count == max_count or c_count == min_count or c_count == max_count + min_count:\n    print('YES')\nelse:\n    print('NO')"
 ],
 "3828": [
  "n=int(input())\nlst=list(map(int,input().split()))\nmin_moves=0\nfor i in range(1,n+1):\n    if lst[i-1]!=i:\n        if (i-1!=0 and lst[i-2]==i):\n            lst[i-2:i]=lst[i-1:i+1]\n            min_moves+=1\n        else:\n            lst[i-1:i+1]=lst[i:i-1 if i!=n else None:-1]\n            min_moves+=1\nprint(min_moves)"
 ],
 "3829": [
  "m, n = map(int, input().split())\n\nsum = 0\nfor i in range(1, m+1):\n  sum += i * ((i/m)**n - ((i-1)/m)**n)\n\nprint('{:.12f}'.format(sum))"
 ],
 "3830": [
  "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input()\n    count = 0\n    for i in range(n):\n        if s[i] == '-':\n            count += 1\n        elif i == n-1:\n            if s[0] == '<' and s[i] == '>':\n                count += 1\n        else:\n            if s[i] == '>' and s[i+1] == '<':\n                count += 1\n    print(count)"
 ],
 "3831": [
  "n = int(input())\nroads = []\n\nfor i in range(n):\n    s, g = map(int, input().split())\n    roads.append((s, g))\n\nwidths = [roads[0][0]]\ntotal_lawn_width = 0\n\nfor i in range(1, n):\n    diff = roads[i][0] - roads[i-1][0]\n    if diff < 0:\n        print(-1)\n        break\n    else:\n        max_width = min(roads[i][1], diff)\n        total_lawn_width += roads[i][1] - max_width\n        widths.append(roads[i][0] + max_width)\nelse:\n    print(total_lawn_width)\n    print(*widths)"
 ],
 "3832": [
  "n = int(input())\na = list(map(int, input().split()))\ndp = [[float('inf')]*(n//2 + 1) for _ in range(n+1)]\ndp[0][0] = 0\n\nfor i in range(1, n+1):\n    for j in range(min(i//2+1, n//2+1)):\n        if i == 1:\n            dp[1][j] = 0\n        else:\n            dp[i][j] = min(dp[i-2][j-1] + max(0, a[i-2]-a[i-1]+1), dp[i-1][j])\nprint(*[dp[n][i] for i in range(n//2 + 1)])"
 ],
 "3833": [
  "s = input().strip()\nt = input().strip()\n\nn = len(s)\nm = len(t)\n\n# calculate frequency of 1's in s and t\nfreq_s = s.count('1')\nfreq_t = t.count('1')\n\nif freq_t > freq_s:\n    print(\"0\" * (n-freq_s) + t * freq_s)\nelse:\n    freq = s.count(t)\n    prefix = \"\"\n    while freq > 1:\n        prefix += t\n        freq -= 1\n    remainder = freq_s - (freq * m)\n    suffix = \"\"\n    while remainder > freq_t:\n        suffix += \"0\"\n        remainder -= 1\n    print(prefix + t * freq + suffix + \"0\" * remainder)"
 ],
 "3834": [
  "from collections import deque\n\nn, m, k = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\n\ndef is_valid(mask, x, y):\n    for i in range(n):\n        if (mask >> i) & 1 and a[i][y] != a[x][y]:\n            return False\n    for j in range(m):\n        if (mask >> (n+j)) & 1 and a[x][j] != a[x][y]:\n            return False\n    return True\n\ndef count_bits(mask):\n    cnt = 0\n    while mask:\n        cnt += mask & 1\n        mask >>= 1\n    return cnt\n\ndef solve():\n    res = float('inf')\n    num_bits = n + m\n    for mask in range(1 << num_bits):\n        if count_bits(mask) > k:\n            continue\n        valid = True\n        for i in range(n):\n            for j in range(m):\n                if ((mask >> i) & 1) and ((mask >> (n+j)) & 1) and a[i][j] != a[0][0]:\n                    valid = False\n        if not valid:\n            continue\n        dp = [[0] * (m+1) for _ in range(n+1)]\n        for i in range(n):\n            for j in range(m):\n                if is_valid(mask, i, j):\n                    dp[i+1][j+1] = dp[i+1][j] + dp[i][j+1] - dp[i][j] + 1\n                else:\n                    dp[i+1][j+1] = dp[i+1][j] + dp[i][j+1] - dp[i][j]\n        for i in range(n):\n            for j in range(m):\n                for x in range(i, n):\n                    for y in range(j, m):\n                        cnt = dp[x+1][y+1] - dp[x+1][j] - dp[i][y+1] + dp[i][j]\n                        if cnt <= k:\n                            res = min(res, k-count_bits(mask)+cnt)\n    if res == float('inf'):\n        print('-1')\n    else:\n        print(res)\n\nsolve()"
 ],
 "3835": [
  "n = int(input())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\n# Finding a1\na1 = int((matrix[0][1]*matrix[0][2]/matrix[1][2])**0.5)\n\na = [a1]\nfor i in range(1, n):\n    a.append(matrix[i][0]//a1)\n\nprint(*a)"
 ],
 "3836": [
  "n = int(input())\nlst_00, lst_01, lst_10, lst_11 = [], [], [], []\nA,B,total = 0,0,0\n\nfor i in range(n):\n    s_i, a_i = input().split()\n    a_i = int(a_i)\n    if s_i == '00':\n        total += a_i\n    elif s_i == '10':\n        lst_10.append(a_i)\n        A += 1\n        total += a_i\n    elif s_i == '01':\n        lst_01.append(a_i)\n        B += 1\n        total += a_i\n    elif s_i == '11':\n        lst_11.append(a_i)\n        A += 1\n        B += 1\n        total += a_i\n\nlst_01.sort(reverse=True)\nlst_10.sort(reverse=True)\n\nfor i in range(min(A, B)):\n    total += lst_10[i] + lst_01[i]\n\nif A > B:\n    total += sum(lst_11[:A-B])\nelif B > A:\n    total += sum(lst_11[:B-A])\n\nif A*2 <= n or B*2 <= n:\n    print(0)\nelse:\n    print(total)"
 ],
 "3837": [
  "from heapq import heappush, heappop\n\nn, m, s = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\nbugs = []\nfor i in range(m):\n    bugs.append((a[i], i))\nbugs.sort(reverse=True)\nstudents = []\nfor i in range(n):\n    students.append((b[i], c[i], i+1))\nstudents.sort(reverse=True)\npassed = day = i = ans = 0\nres = [-1 for i in range(m)]\nq = []\nwhile bugs:\n    while students and students[-1][0] >= bugs[-1][0]:\n        heappush(q, (-students[-1][1], students[-1][2]))\n        students.pop()\n    if not q:\n        print('NO')\n        exit(0)\n    passed -= q[0][0]\n    res[bugs[-1][1]] = q[0][1]\n    day = max(day, passed-bugs[-1][0])\n    bugs.pop()\n    if passed > s or passed-day > s:\n        print('NO')\n        exit(0)\nprint('YES')\nprint(*res)"
 ],
 "3838": [
  "n,k=map(int,input().split())\nq=list(map(int,input().split()))\ns=list(map(int,input().split()))\nb=[i==q[i-1] for i in range(1,n+1)]\nans=b==[0]*n\nfor i in range(k):\n    b1=[0]*n\n    for j in range(n):\n        b1[q[j]-1]=b[j]\n    b=b1.copy()\n    if b==[0]*n:\n        ans=True\n        break\n    if i==k-1 and b!=[0]*n:\n        ans=False\nif ans:\n    print('YES')\nelse:\n    print('NO')"
 ],
 "3839": [
  "n = int(input())\nk = max(5, n - 17)\nprint(0, 0)\nprint(1, 0)\nprint(2, 0)\nprint(0, 1)\nprint(1, 2)\n\n# Place first k knights in triangular pattern\nfor i in range(k):\n    print(i, i)\n\n# Place remaining knights in rectangular pattern\nfor i in range(k, n):\n    print(i-k+2, (i-k)//2 + 3 + (i-k) % 2)"
 ],
 "3840": [
  "n = int(input())\na = list(map(int, input().split()))\n\nmoves = 0\ni = 1\n\nwhile i < n:\n    if a[i-1] == 0:\n        i += 1\n        continue\n    x = min((a[i-1]-1)//2, (n-i)//2)\n    for j in range(i, i+2*x+1):\n        a[j-1] -= 1\n    if x == 0:\n        return -1\n    moves += 1\n    i = 1 if i == 2*x+1 else 2*x+1\n\nprint(moves)"
 ],
 "3841": [
  "p, k = map(int, input().split())\n\nif k == 2:\n    print(1)\n    print(p)\nelse:\n    res = []\n    while p:\n        res.append(p%k)\n        p = -(p//k)\n    if len(res) == 0:\n        print(1)\n        print(0)\n    else:\n        print(len(res))\n        print(*res)"
 ],
 "3842": [
  "import sys\nfrom math import inf\n\nn,p,q = map(int, input().split())\n\nprojects = []\n\nfor i in range(n):\n    a,b = map(int, input().split())\n    projects.append((a,b))\n\nans = inf\n\nfor i in range(n):\n    for j in range(i, n):\n\n        if projects[i][0] + projects[j][0] >= p and projects[i][1] + projects[j][1] >= q:\n            ans = min(ans, 1.0 * p / (projects[i][0] + projects[j][0]))\n\n        elif projects[i][0] >= p and projects[i][1] >= q:\n            ans = min(ans, 1.0 * p / projects[i][0])\n\n        elif projects[j][0] >= p and projects[j][1] >= q:\n            ans = min(ans, 1.0 * p / projects[j][0])\n\nprint(ans)"
 ],
 "3843": [
  "n, m = map(int, input().split()) # taking input values of n and m\nn_digits = len(base7(n-1)) # finding the number of digits required to represent numbers from 0 to n-1 in base 7\nm_digits = len(base7(m-1)) # finding the number of digits required to represent numbers from 0 to m-1 in base 7\nans = 0 # initializing the answer variable\nfor hour in range(n):\n    for minute in range(m):\n        hour_digits = len(base7(hour)) # finding the number of digits required to represent hour in base 7\n        minute_digits = len(base7(minute)) # finding the number of digits required to represent minute in base 7\n        digits = set() # initializing a set to keep track of digits seen so far\n        for digit in base7(hour) + base7(minute): # iterating over the digits of hour and minute\n            if digit in digits: # if the digit is already seen before, break the loop\n                break\n            digits.add(digit) # add the digit to the set\n        else: # if the loop completes without breaking, all digits are distinct, so increment the answer\n            ans += 1\nprint(ans) # printing the final answer"
 ],
 "3844": [
  "n = int(input())\ncards = list(map(int, input().split()))\nmax_card = max(cards)\n\nif cards.count(max_card) % 2 == 1:\n    print(\"Conan\")\nelse:\n    print(\"Agasa\")"
 ],
 "3845": [
  "A, B = map(int, input().split())\nprint(100, 100)\ngrid = [['#' for _ in range(50)] + ['.' for _ in range(50)] for _ in range(100)]\nA -= 1\nB -= 1\nfor i in range(0, 50, 2):\n    if A == 0 and B == 0:\n        break\n    for j in range(0, 100, 2):\n        if A > 0:\n            grid[i][j] = '.'\n            A -= 1\n        if B > 0:\n            grid[99 - i][j] = '#'\n            B -= 1\nfor row in grid:\n    print(''.join(row))"
 ],
 "3846": [
  "n, m = map(int, input().split())\npresent = set()\ncandidates = set(range(1, n+1))\n\nfor i in range(m):\n    command, id = input().split()\n    id = int(id)\n    if command == '+':\n        present.add(id)\n        if len(present) > 1:\n            candidates.discard(id)\n    else:\n        present.remove(id)\n        if len(present) == 0:\n            candidates.discard(id)\n\nprint(len(candidates))\nprint(*sorted(candidates))"
 ],
 "3847": [
  "n,m=map(int,input().split())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\nx=int(input())\np=[ [0]*(m+1) for i in range(n+1) ]\nfor i in range(n):\n    for j in range(m):\n        p[i+1][j+1]=a[i]*b[j]\nfor i in range(n):\n    for j in range(m):\n        p[i+1][j+1]+=p[i+1][j]+p[i][j+1]-p[i][j]\nans=0\nfor i in range(1,n+1):\n    for j in range(1,m+1):\n        l=1\n        r=min(n-i+1,m-j+1)\n        while l<r:\n            mid=(l+r+1)>>1\n            if p[i+mid-1][j+mid-1]-p[i-1][j+mid-1]-p[i+mid-1][j-1]+p[i-1][j-1]<=x:\n                l=mid\n            else:\n                r=mid-1\n        ans=max(ans,l*(j-i+1))\nprint(ans)"
 ],
 "3848": [
  "n, p = map(int, input().split())\ns = list(input().strip())\n\nif p == 1:\n    print(\"NO\")\n    exit()\n\nfor i in range(n-1, -1, -1):\n    c = ord(s[i]) - ord('a')\n    while c < p-1:\n        c += 1\n        if i > 0 and c == ord(s[i-1]) - ord('a'):\n            continue\n        if i > 1 and c == ord(s[i-2]) - ord('a'):\n            continue\n        s[i] = chr(c + ord('a'))\n        for j in range(i+1, n):\n            for d in range(p):\n                if j > 0 and d == ord(s[j-1]) - ord('a'):\n                    continue\n                if j > 1 and d == ord(s[j-2]) - ord('a'):\n                    continue\n                s[j] = chr(d + ord('a'))\n                break\n        print(\"\".join(s))\n        exit()\n\nprint(\"NO\")"
 ],
 "3849": [
  "n, k = map(int, input().split())\ncards = list(map(int, input()))\n\ndef can_win(start):\n    end = start + k - 1\n    if end >= n:\n        return False\n    if cards[start] == cards[end]:\n        return False\n    flipped_cards = cards[start:end+1][::-1]\n    if flipped_cards.count(cards[start]) > k // 2:\n        return True\n    return False\n\ntokitsukaze_wins = False\nquailty_wins = False\ndraw = False\n\nfor i in range(n):\n    if can_win(i):\n        if i % 2 == 0:\n            tokitsukaze_wins = True\n        else:\n            quailty_wins = True\n\nif tokitsukaze_wins and quailty_wins:\n    draw = True\n\nif draw:\n    print(\"once again\")\nelif tokitsukaze_wins:\n    print(\"tokitsukaze\")\nelse:\n    print(\"quailty\")"
 ],
 "3850": [
  "n, k, p = map(int, input().split())\na = sorted(list(map(int, input().split())))\nb = sorted(list(map(int, input().split())))\nbest = float(\"inf\")\nfor i in range(k-n+1):\n    t = 0\n    for j in range(n):\n        d = abs(a[j] - b[i + j]) + abs(b[i + j] - p)\n        t = max(t, d)\n    best = min(best, t)\nprint(best)"
 ],
 "3851": [
  "n, k = map(int, input().split())\na, b = map(int, input().split())\n\nd = n*k\n\nans_min = d\nfor i in range(1, n*k):\n    if i % k == a:\n        for j in range(1, n*k):\n            if (i+j) % k == b:\n                ans_min = min(ans_min, j)\n                break\n        break\n\nans_max = 1\nfor i in range(1, n*k):\n    if i % k == a:\n        for j in range(n*k, 0, -1):\n            if (i+j) % k == b:\n                ans_max = max(ans_max, (i+j)//k)\n                break\n        break\n\nprint(ans_min, ans_max)"
 ],
 "3852": [
  "n = int(input())\na = list(map(int, input().split()))\n\nops = []\nwhile True:\n    sorted_a = sorted(a)\n    if a == sorted_a:\n        break\n    i = a.index(max(a)) # find the index of the largest element in a\n    j = sorted_a.index(min(a)) # find the index of the smallest element in sorted_a\n    if i == j: # if the largest element is already in the correct position\n        j = (j+1)%n # move the smallest element to the next position\n    a[j] += a[i] # add the largest element to the smallest element\n    ops.append((i+1, j+1)) # record the operation\n\nprint(len(ops))\nfor op in ops:\n    print(op[0], op[1])"
 ],
 "3853": [
  "n = int(input())\nboxes = {}\nfor i in range(n):\n    k, a = map(int, input().split())\n    boxes[k] = boxes.get(k, 0) + a\n\nmax_k = max(boxes.keys())\nnum_boxes = boxes[max_k]\nfor k in range(max_k-1, -1, -1):\n    num_boxes = (num_boxes + 3) // 4 + boxes.get(k, 0)\n\np = 0\nwhile num_boxes > 1:\n    num_boxes = (num_boxes + 3) // 4\n    p += 1\n\nprint(p+max_k)"
 ],
 "3854": [
  "n, k = map(int, input().split())\ncoins = list(map(int, input().split()))\n\ndp = [[False] * (k+1) for i in range(n+1)]\ndp[0][0] = True\n\nfor i in range(1, n+1):\n    for j in range(k+1):\n        dp[i][j] = dp[i-1][j] or (j >= coins[i-1] and dp[i-1][j-coins[i-1]])\n\npossible_sums = []\nfor i in range(k+1):\n    if dp[n][i]:\n        possible_sums.append(i)\n\nresult = []\nfor x in possible_sums:\n    flag = False\n    for i in range(1, n+1):\n        for j in range(x+1, k+1):\n            if dp[i-1][j-x] and dp[n-i][k-j]:\n                flag = True\n                break\n        if flag:\n            break\n    if not flag:\n        result.append(x)\n\nprint(len(result))\nfor x in result:\n    print(x, end=' ')"
 ],
 "3855": [
  "n = int(input())\nans = 0\nwhile n:\n    x = (int(((8 * n + 1)**0.5) - 1) // 2)\n    n = n - (x * (x + 1)) // 2\n    ans += 1\nprint(ans)"
 ],
 "3856": [
  "n = int(input())\nfriends = []\nfor i in range(n):\n    w, h = map(int, input().split())\n    friends.append((w, h))\n\nfriends.sort(key=lambda x: x[0] - x[1], reverse=True)\nh_total = sum(h for _, h in friends)\nw_max = friends[0][0]\nans = h_total * w_max\n\nfor i in range(1, n // 2 + 1):\n    h_total += friends[i][1] - friends[i][0]\n    w_max = max(w_max, friends[i][0])\n    ans = min(ans, h_total * w_max)\n\nprint(ans)"
 ],
 "3857": [
  "n = int(input())\nx = list(map(int, input().split()))\n\nx.sort()\npiles = 1\ncurr_pile_height = 1\n\nfor i in range(n):\n    if x[i] >= curr_pile_height:\n        curr_pile_height += 1\n        if curr_pile_height > x[i]:\n            piles += 1\n            curr_pile_height = 1\n\nprint(piles)"
 ],
 "3858": [
  "MOD = 998244353\n\ndef get_score(points, S):\n    if len(S) < 3:\n        return 0\n\n    cross = 0\n    for i in range(len(S)):\n        x1, y1 = points[S[i]]\n        x2, y2 = points[S[(i+1)%len(S)]]\n        cross += (x2-x1)*(y2+y1)\n\n    if cross < 0:\n        return 0\n\n    mask = [0] * len(points)\n    for i in range(len(S)):\n        mask[S[i]] = 1\n\n    n = 0\n    for i in range(len(points)):\n        is_inside = True\n        for j in range(len(S)):\n            x1, y1 = points[S[j]]\n            x2, y2 = points[S[(j+1)%len(S)]]\n            cp = (x2-x1)*(points[i][1]-y1)-(y2-y1)*(points[i][0]-x1)\n            if cp < 0:\n                is_inside = False\n                break\n        if is_inside:\n            n += 1\n\n    return pow(2, n-len(S), MOD)\n\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\nans = 0\nfor s in range(1, 1<<n):\n    score = get_score(points, [i for i in range(n) if s & 1<<i])\n    ans = (ans+score) % MOD\nprint(ans)"
 ],
 "3859": [
  "n = int(input())\nwhite = []\nblack = []\nfor i in range(2*n):\n    c, a = input().split()\n    if c == \"W\":\n        white.append(int(a))\n    else:\n        black.append(int(a))\nw_map = [0] * (n+1)\nfor i in range(n):\n    w_map[white[i]] = i+1\nb_map = [0] * (n+1)\nfor i in range(n):\n    b_map[black[i]] = i+1\nans = 0\nfor i in range(1,n+1):\n    ans += abs(w_map[i]-b_map[i])\nprint(ans)"
 ],
 "3860": [
  "b = int(input())\ng = int(input())\nn = int(input())\n\ncount = 0\nfor i in range(n+1):\n    if i <= b and n-i <= g:\n        count += 1\n\nprint(count)"
 ],
 "3861": [
  "import math\n\nn = int(input())\narr = list(map(int, input().split()))\n\nmax_not_square = -1\n\nfor i in range(n):\n    sqrt = int(math.sqrt(arr[i]))\n    if(sqrt**2 != arr[i]):\n        if (arr[i] > max_not_square):\n            max_not_square = arr[i]\n\nprint(max_not_square)"
 ],
 "3862": [
  "n, k = map(int, input().split())\na = sorted(list(map(int, input().split())))\n\ndef get_min_vol(target, start_idx, volumes):\n    if start_idx == k:\n        if target == 0:\n            return sum(volumes)\n        else:\n            return float('inf')\n    min_vol = float('inf')\n    for i in range(start_idx, k):\n        if a[i] > target:\n            break\n        if i > start_idx and a[i] == a[i-1]:\n            continue\n        next_vol = get_min_vol(target-a[i], i+1, volumes+[1])\n        min_vol = min(min_vol, next_vol)\n    if target == 0:\n        return sum(volumes)\n    return min_vol\n\nif n not in a:\n    target = n\n    while target > 0:\n        target -= 1\n        if target in a:\n            min_vol = get_min_vol(n-target, 0, [1])\n            print(min_vol)\n            break\n    else:\n        print(-1)\nelse:\n    min_vol = get_min_vol(n, 0, [1])\n    print(min_vol)"
 ],
 "3863": [
  "n, k = map(int, input().split())\nMOD = 10**9 + 7\n\nif n == 1:\n    print(k)\nelif n == 2:\n    print(k*(k-1)%MOD)\nelse:\n    print(k*(k-1)*pow(k-2, n-2, MOD)%MOD)"
 ],
 "3864": [
  "MOD = 998244353\ninv2 = (MOD + 1) // 2\n\nn = int(input())\nans = [0] * n\n\ndef calc(k):\n    return (pow(2, k, MOD) - 1 + MOD) % MOD\n\nfor i in range(n):\n    ans[i] = (calc(i) + calc(n - 1 - i)) * inv2 % MOD\n\nfor i in ans:\n    print(i)"
 ],
 "3865": [
  "a = int(input())\nfound = False\nfor n in range(1, 10**6):\n    s = str(n * a)\n    if sum(int(d) for d in s) == int(s) // a:\n        print(n)\n        found = True\n        break\nif not found:\n    print(-1)"
 ],
 "3866": [
  "n = int(input())\nif n%2==0:\n    print(\"-1\")\nelse:\n    a = \" \".join(str(i) for i in range(n))\n    b = \" \".join(str((2*i)%n) for i in range(n))\n    c = \" \".join(str((2*i+1)%n) for i in range(n))\n    print(a)\n    print(b)\n    print(c)"
 ],
 "3867": [
  "from collections import deque\n\nn = int(input())\nadj_list = [[] for _ in range(n)]\nfor i in range(n-1):\n    x, y = map(int, input().split())\n    adj_list[x-1].append(y-1)\n    adj_list[y-1].append(x-1)\n    \nbfs_order = list(map(int, input().split()))\n    \nvisited = [False] * n\nif bfs_order[0] != 1:\n    print(\"No\")\nelse:\n    q = deque()\n    q.append(0)\n    visited[0] = True\n    idx = 1\n    while q:\n        u = q.popleft()\n        children = sorted(adj_list[u])\n        for v in children:\n            if not visited[v]:\n                if bfs_order[idx] != v+1:\n                    print(\"No\")\n                    exit()\n                visited[v] = True\n                q.append(v)\n                idx += 1\n    print(\"Yes\")"
 ],
 "3868": [
  "n, m, k = map(int, input().split())\n\n# Create two lists to store incoming and outgoing flights respectively\nincoming_flights = []\noutgoing_flights = []\n\nfor i in range(m):\n    d, f, t, c = map(int, input().split())\n    if t == 0:\n        incoming_flights.append((d, f, c))\n    else:\n        outgoing_flights.append((d, t, c))\n\n# Sort the lists by day of departure\nincoming_flights.sort()\noutgoing_flights.sort()\n\n# Check if it is possible to gather everyone in Metropolis for k days\nfor i in range(len(incoming_flights) - n + 1):\n    if incoming_flights[i + n - 1][0] - incoming_flights[i][0] + 1 <= k:\n        # Calculate the total cost of the flights\n        cost = sum(flight[2] for flight in incoming_flights[i:i+n])\n        for j in range(len(outgoing_flights)):\n            if outgoing_flights[j][0] < incoming_flights[i][0] + k:\n                continue\n            if outgoing_flights[j][1] == 0:\n                cost += outgoing_flights[j][2]\n            else:\n                for l in range(i, i+n):\n                    if outgoing_flights[j][1] == incoming_flights[l][1]:\n                        cost += outgoing_flights[j][2]\n                        break\n            if l == i+n-1:\n                print(cost)\n                exit()\n\n# If it is impossible to gather everyone in Metropolis for k days, print -1\nprint(-1)"
 ],
 "3869": [
  "import math\n\nw, h, alpha = map(int, input().split())\n\nif alpha > 90:\n    alpha = 180 - alpha\n    \nalpha = math.radians(alpha)\n\nif h > w:\n    h, w = w, h\n\nif h * (1 + math.cos(alpha)) <= w * math.sin(alpha):\n    res = h * h / math.sin(alpha)\nelse:\n    x = (h * (1 + math.cos(alpha)) - w * math.sin(alpha)) / (2 * math.sin(alpha) * math.cos(alpha))\n    res = h * x + (h * math.cos(alpha) - x * w) * math.sin(alpha)\n    \nprint(\"{:.9f}\".format(res))"
 ],
 "3870": [
  "n,m=map(int,input().split())\na=[]\nb=[]\nfor i in range(n):\n    x,y=input().split()\n    a.append((x,int(y)))\nfor i in range(m):\n    b.append(int(input()))\na.sort(key=lambda x:(x[0]=='ATK',x[1]),reverse=True)\nb.sort(reverse=True)\nans=0\npos=0\nfor i in range(m):\n    while pos<n and a[pos][1]>=b[i]:\n        if a[pos][0]=='DEF':\n            pos+=1\n        else:\n            ans+=b[i]-a[pos][1]\n            pos+=1\n            break\nprint(ans)                "
 ],
 "3871": [
  "n, m = map(int, input().split())\nl = list(map(int, input().split()))\ns = list(map(int, input().split()))\nc = list(map(int, input().split()))\n\ndp = [-10**18] * (n+m+1)\ndp[0] = 0\n\nfor i in range(n):\n    mx = -10**18\n    for j in range(l[i], -1, -1):\n        if dp[j] >= 0:\n            mx = max(mx, dp[j]+c[l[i]])\n    for j in range(l[i], m+1):\n        dp[j] = max(dp[j], mx-s[i]-c[j])\n\nans = max(dp)\nprint(ans)"
 ],
 "3872": [
  "a = input()\nb = input()\nif a == b:\n    print(\"YES\")\nelse:\n    a1 = sorted(a[:len(a)//2] + a[len(a)//2 + len(a)%2:])\n    b1 = sorted(b[:len(b)//2] + b[len(b)//2 + len(b)%2:])\n    a2 = sorted(a[:len(a)//2 + len(a)%2] + a[len(a)//2:])\n    b2 = sorted(b[:len(b)//2 + len(b)%2] + b[len(b)//2:])\n    if a1 == b1 and a2 == b2:\n        print(\"YES\")\n    elif a1 == b2 and a2 == b1:\n        print(\"YES\")\n    else:\n        print(\"NO\")"
 ],
 "3873": [
  "n = int(input())\nif n%4 > 1:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    if n%4 == 0:\n        for i in range(1,n+1,4):\n            print(i+1,i+3)\n            print(i,i+2)\n            print(i+1,i+2)\n    else:\n        print(\"1 2\")\n        print(\"2 3\")\n        print(\"3 4\")\n        for i in range(5,n+1,4):\n            print(i+1,i-1)\n            print(i,i-2)\n            print(i+1,i-2)"
 ],
 "3874": [
  "n, m = map(int, input().split())\nnames = []\nfor i in range(n):\n    names.append(input())\nindices = list(map(int, input().split()))\n\npattern = list(names[indices[0]-1])\n\nfor i in range(m):\n    current_name = names[indices[i]-1]\n    for j in range(len(current_name)):\n        if current_name[j] != pattern[j]:\n            pattern[j] = '?'\n\nfor name in names:\n    matched = True\n    for i in range(len(name)):\n        if name[i] != pattern[i] and pattern[i] != '?':\n            matched = False\n            break\n    if matched and name not in names[indices[0]-1:indices[-1]]:\n        print(\"No\")\n        exit()\n\nprint(\"Yes\")\nprint(\"\".join(pattern))"
 ],
 "3875": [
  "n = int(input())\na = list(map(int, input().split()))\n\nMOD = 10**9 + 7\n\ndp = []\nfor i in range(n):\n    l, r = 0, len(dp)\n    while l < r:\n        m = (l + r) // 2\n        if dp[m] >= a[i]:\n            r = m\n        else:\n            l = m + 1\n    if l == len(dp):\n        dp.append(a[i])\n    else:\n        dp[l] = a[i]\n\nP = sum(dp[i] < 10**18 for i in range(len(dp)))\nQ = 1\nfor i in range(1, n+1):\n    Q = Q * i % MOD\n\nfor i in range(P):\n    Q = Q * i % MOD\nfor i in range(n-P):\n    Q = Q * i % MOD\n\nprint((Q * pow(P, MOD-2, MOD)) % MOD)"
 ],
 "3876": [
  "MOD = 10**9 + 7\n\ndef dfs(u, p):\n    # for storing the number of ways to pair the vertices in the subtree of u\n    dp = [1]\n    for v in adj[u]:\n        if v == p:\n            continue\n        child_dp = dfs(v, u)\n        # combined the number of ways to pair the current subtree with the previous subtrees\n        # by multiplying them together\n        new_dp = [0] * (len(dp) + len(child_dp) - 1)\n        for i in range(len(dp)):\n            for j in range(len(child_dp)):\n                # count the number of ribbons that pass through the edge (u, v)\n                # by multiplying the ways to pair the subtrees rooted at u and v\n                # and then multiply k and n-2k, where k is the size of the subtree rooted at v\n                # this is equivalent to the number of ways to choose a pair that includes v\n                # times the number of ways to pair the remaining vertices\n                cnt = dp[i] * child_dp[j] % MOD\n                cnt = cnt * (n - 2 * sz[v][j]) % MOD\n                new_dp[i + j] += cnt\n                new_dp[i + j] %= MOD\n        dp = new_dp\n    return dp\n\nn = int(input())\nadj = [[] for _ in range(n + 1)]\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    adj[u].append(v)\n    adj[v].append(u)\nsz = [[0] * n for _ in range(n)]\nfor u in range(1, n + 1):\n    queue = [u]\n    visited = [False] * (n + 1)\n    while queue:\n        v = queue.pop()\n        visited[v] = True\n        sz[u - 1][v - 1] = 1\n        for w in adj[v]:\n            if visited[w]:\n                continue\n            sz[u - 1][v - 1] += sz[u - 1][w - 1]\n            queue.append(w)\nans = 0\nfor i in range(len(dfs(1, 0))):\n    if i % 2 == 0:\n        ans += dfs(1, 0)[i]\nans %= MOD\nprint(ans"
 ],
 "3877": [
  "n, l, r = map(int, input().split())\n\ndef count_ones(n, pos):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        # calculate the index of the last element in the left subtree\n        last_in_left = (1 << (pos - 2)) - 1\n        # if the element is in the left subtree, recurse on the left subtree\n        if n <= last_in_left + 1:\n            return count_ones(n - 1, pos - 1)\n        # if the element is the root of the right subtree, return all the ones in the left subtree\n        elif n == last_in_left + 2:\n            return (1 << (pos - 2))\n        # if the element is in the right subtree, recurse on the right subtree\n        else:\n            return ((1 << (pos - 2))\n                    + count_ones(n - last_in_left - 2, pos - 1)\n                    + count_ones(last_in_left + 1, pos - 1))\n\nprint(count_ones(r, 50) - count_ones(l - 1, 50))"
 ],
 "3878": [
  "n, m = map(int, input().split())\ngraph = [[False] * n for i in range(n)]\n\nfor i in range(m):\n    u, v = map(int, input().split())\n    u, v = u-1, v-1\n    graph[u][v] = graph[v][u] = True\n\n# Finding all pairs of guests that are not friends yet\nnot_friends = []\nfor i in range(n):\n    for j in range(i+1, n):\n        if not graph[i][j]:\n            not_friends.append((i, j))\n\n# Checking if all guests are already friends\nif not not_friends:\n    print(0)\n    exit()\n\n# Brute force approach to find minimum number of steps and guests selected at each step\nmin_steps = n+1\nfor mask in range(1, 1<<n):\n    guests = []\n    for i in range(n):\n        if (mask >> i) & 1:\n            guests.append(i)\n    new_graph = [[False] * len(guests) for i in range(len(guests))]\n    for i in range(len(guests)):\n        for j in range(i+1, len(guests)):\n            if graph[guests[i]][guests[j]]:\n                new_graph[i][j] = new_graph[j][i] = True\n    for u, v in not_friends:\n        u, v = guests.index(u), guests.index(v)\n        if not new_graph[u][v]:\n            break\n    else:\n        if len(guests) < min_steps:\n            min_steps = len(guests)\n            ans_guests = guests\n\nprint(min_steps)\nprint(*[x+1 for x in ans_guests])"
 ],
 "3879": [
  "n = int(input())\nbids = list(map(int, input().split()))\nwhile all(bid%2==0 for bid in bids):\n    bids = [bid//2 for bid in bids]\nwhile all(bid%3==0 for bid in bids):\n    bids = [bid//3 for bid in bids]\nif len(set(bids))==1:\n    print(\"Yes\")\nelse:\n    print(\"No\")"
 ],
 "3880": [
  "n = int(input())\narr = list(map(int, input().split()))\n\nneg_count = len([x for x in arr if x<0])\nif neg_count%2==0:\n    print(sum(map(abs, arr)))\nelse:\n    if len(arr)>2*n-2:\n        print(sum(map(abs, arr))-(2*min(map(abs, arr))))\n    else:\n        print(sum(map(abs, arr)))"
 ],
 "3881": [
  "n, q = map(int, input().split())\n\nops = {}\nfor i in range(q):\n    a, b = input().split()\n    ops[a] = b\n\ncount = 0\nstack = ['abcdef'[:n]]\nwhile stack:\n    cur = stack.pop()\n    if len(cur) == 1 and cur == 'a':\n        count += 1\n    else:\n        for a, b in ops.items():\n            if a in cur:\n                next_str = cur.replace(a, b, 1)\n                stack.append(next_str)\n\nprint(count)"
 ],
 "3882": [
  "n = int(input())\n\nMOD = 10 ** 9 + 7\n\nf = [0] * (n + 1)\ng = [0] * (n + 1)\n\nf[0] = g[0] = 1\n\nfor i in range(1, n + 1):\n    f[i] = g[i - 1]\n    g[i] = (f[i - 1] + (i - 1) * g[i - 1]) % MOD\n\nans = (g[n] - f[n] + MOD) % MOD\n\nprint(ans)"
 ],
 "3883": [
  "a, b = map(int, input().split())\n\nif a < b or (a - b) % 2 == 1: # no such x exists\n    print(-1)\nelse:\n    k = (a - b) // (2 * b)\n    x = (a - b) / (2 * k)\n    print(x)"
 ],
 "3884": [
  "import math\n\nn = int(input())\nm = int(input())\ntakeoff_coeff = list(map(int, input().split()))\nlanding_coeff = list(map(int, input().split()))\n\ndef check_if_possible(x):\n    fuel_mass = x\n    cargo_mass = m\n    for i in range(n):\n        takeoff_mass = cargo_mass + fuel_mass\n        fuel_to_burn = takeoff_mass/takeoff_coeff[i]\n        if fuel_mass - fuel_to_burn < 0:\n            return False\n        fuel_mass -= fuel_to_burn\n        cargo_mass += fuel_mass\n        fuel_mass = 0\n        landing_mass = cargo_mass + min(landing_coeff[i]*fuel_mass, cargo_mass)\n        cargo_mass -= landing_mass\n        fuel_to_burn = landing_mass/landing_coeff[i]\n        fuel_mass -= fuel_to_burn\n        if fuel_mass < 0:\n            return False\n    return cargo_mass >= 0\n\nEPS = 10**(-9)\nlow_bound = 0\nrecent_bound = m*n\nwhile recent_bound - low_bound > EPS*max(recent_bound, 1):\n    middle_bound = 0.5*(recent_bound + low_bound)\n    if check_if_possible(middle_bound):\n        recent_bound = middle_bound\n    else:\n        low_bound = middle_bound\nif recent_bound > m*n:\n    print(-1)\nelse:\n    print(recent_bound)"
 ],
 "3885": [
  "n = int(input())\nprint((n//2)*(n - n//2))"
 ],
 "3886": [
  "import sys\ninput = sys.stdin.readline\n\ndef solve(n, k):\n    if n == 0:\n        return f0[k-1] if k <= len(f0) else '.'\n    if k <= len(prefix[n-1]):\n        return prefix[n-1][k-1]\n    k -= len(prefix[n-1])\n    if k == 1:\n        return qm\n    k -= 1\n    if k <= len(suffix[n-1]):\n        return suffix[n-1][k-1]\n    return '.'\n\nq = int(input())\nf0 = \"What are you doing at the end of the world? Are you busy? Will you save us?\"\nprefix, suffix = [], []\nqm = '\"'\nfor i in range(int(1e5)):\n    if i == 0:\n        prefix.append(f0)\n    else:\n        prev = prefix[-1]\n        nxt = \"What are you doing while sending \"+qm+prev[:len(prev)-len(suffix[-1])]+qm+\"? Are you busy? Will you send \"+qm+suffix[-1]+qm+\"?\"\n        prefix.append(nxt)\n    suff = \"What are you doing at the end of the world? Are you busy? Will you save us?\" if i == 0 else suffix[-1]\n    for j in range(len(prefix[-1])):\n        ch = prefix[-1][~j]\n        suff = ch+suff\n        if ch == qm:\n            break\n    suffix.append(suff)\nfor _ in range(q):\n    n, k = map(int, input().split())\n    print(solve(n, k), end='')"
 ],
 "3887": [
  "from itertools import permutations\n\nrebus = input().split()\nn = int(rebus[-1])\nexpr = rebus[:-2]\n\noperators = []\nnums = []\n\nfor i in range(len(expr)):\n    if i % 2 == 0:\n        nums.append(None)\n        operators.append(expr[i])\n    else:\n        nums.append(expr[i])\n\nperms = permutations(range(1, n+1), len(nums))\n \nfor perm in perms:\n    temp_expr = nums.copy()\n    for i in range(len(perm)):\n        temp_expr[i] = perm[i]\n        \n    calc = temp_expr[0]\n    for i in range(len(operators)):\n        if operators[i] == '+':\n            calc += temp_expr[i+1]\n        else:\n            calc -= temp_expr[i+1]\n            \n    if calc == n:\n        print(\"Possible\")\n        for i in range(len(expr)):\n            if i % 2 == 0:\n                print(temp_expr[int(i/2)], end=\"\")\n            else:\n                print(expr[i], end=\"\")\n        print(temp_expr[-1])\n        break\nelse:\n    print(\"Impossible\")"
 ],
 "3888": [
  "N = int(input())\na = [list(map(int, input().split())) for _ in range(N)]\n\ncnt = [0]*3\n\nfor i in range(N):\n    for j in range(N):\n        if i == 0 or j == 0:\n            cnt[a[i][j]] += 1\n        else:\n            cnt[mex(a[i-1][j], a[i][j-1])] += 1\n\nprint(cnt[0], cnt[1], cnt[2])\n        \ndef mex(x, y):\n    if x != 0 and y != 0 and x == y:\n        return 0\n    if x != 1 and y != 1 and x == y:\n        return 1\n    if x != 2 and y != 2 and x == y:\n        return 2\n    for i in range(3):\n        if i != x and i != y:\n            return i"
 ],
 "3889": [
  "n = int(input())\ns = input()\nif len(set(s)) == 1:\n    print(\"Yes\")\nelif n == 2 and s[0] != s[1]:\n    print(\"No\")\nelse:\n    sorted_s = sorted(s)\n    first_color_count = sorted_s.count(sorted_s[0])\n    last_color_count = sorted_s.count(sorted_s[-1])\n    if first_color_count + last_color_count == n:\n        print(\"Yes\")\n    elif first_color_count == 1 or last_color_count == 1:\n        print(\"No\")\n    else:\n        if sorted_s[0] == sorted_s[1]:\n            min_color_count = first_color_count\n        else:\n            min_color_count = sorted_s.index(sorted_s[1])\n        if sorted_s[-1] == sorted_s[-2]:\n            max_color_count = last_color_count\n        else:\n            max_color_count = n - sorted_s.index(sorted_s[-2])\n        if max_color_count - min_color_count <= 1:\n            print(\"Yes\")\n        else:\n            print(\"No\")"
 ],
 "3890": [
  "MOD = 1_000_000_007\n\nn,k = map(int,input().split())\n\nans = 1\n\n# case when x = 1\nfor i in range(1,k+1):\n    ans *= n-k+i\n    ans %= MOD\n\n# case when x is not 1\nif k == 1:\n    for i in range(1,n):\n        ans *= i\n        ans %= MOD\nelse:\n    for i in range(1,n-k+1):\n        ans *= k-1+i\n        ans %= MOD\n\nprint(ans)"
 ],
 "3891": [
  "n, m = map(int, input().split())\nmatrix = [input() for i in range(n)]\nfor i in range(n):\n    for j in range(m):\n        if matrix[i][j] == 'B':\n            size = 1\n            while i+size<n and j+size<m and i-size>=0 and j-size>=0 \\\n            and matrix[i-size][j] == 'B' and matrix[i+size][j] == 'B' \\\n            and matrix[i][j-size] == 'B' and matrix[i][j+size] == 'B':\n                size += 1\n            print(i+size//2, j+size//2)\n            break"
 ],
 "3892": [
  "n, m = map(int, input().split())\n\ncandies_dest = {}\nfor i in range(m):\n    a, b = map(int, input().split())\n    candies_dest[a] = b\n\nans = []\nfor start in range(1, n + 1):\n    time = 0\n    for station in range(1, n + 1):\n        if station == start:\n            continue\n        if station in candies_dest:\n            time += min(\n                abs(station - start) + abs(candies_dest[station] - station),\n                abs(start - candies_dest[station]) + abs(start - station),\n            )\n        else:\n            time += abs(start - station)\n    ans.append(time)\nprint(*ans)"
 ],
 "3893": [
  "from math import inf\ndef dist(x1,y1,x2,y2,a,b,c):\n    if a*x1+b*y1+c>=0 and a*x2+b*y2+c>=0:\n        return 0\n    if a*x1+b*y1+c<=0 and a*x2+b*y2+c<=0:\n        return 0\n    if a==0:\n        if b*y1+c>=0 and b*y2+c>=0:\n            return abs(y2-y1)\n        if b*y1+c<=0 and b*y2+c<=0:\n            return abs(y2-y1)\n        if (b*y1+c)*(b*y2+c)>0:\n            return inf\n        if (b*y1+c)*(b*y2+c)<0:\n            return 1\n    if b==0:\n        if a*x1+c>=0 and a*x2+c>=0:\n            return abs(x2-x1)\n        if a*x1+c<=0 and a*x2+c<=0:\n            return abs(x2-x1)\n        if (a*x1+c)*(a*x2+c)>0:\n            return inf\n        if (a*x1+c)*(a*x2+c)<0:\n            return 1\n    b1 = -a/b\n    c1 = -c/b\n    b2 = -b/a\n    c2 = -c/a\n    if b1*y1+c1>x1:\n        if b1*y2+c1>x2:\n            return abs(b1*(y2-y1))\n        if b2*x2+c2<y2 or b2*x1+c2>y1:\n            return inf\n        p = (b1*y2+c1-x2*b1)/(b2-b1)\n        return abs(p-x2)\n    if b2*x2+c2<y2 or b2*x1+c2>y1:\n        return inf\n    if b1*y2+c1<x2:\n        if b1*y1+c1<x1:\n            return abs(b1*(y2-y1))\n        p = (b1*y1+c1-x1*b1)/(b2-b1)\n        return abs(p-x1)\n    return 1\ngx,gy = map(int,input().split())\nux,uy = map(int,input().split())\nn = int(input())\nroads = []\nfor i in range(n):\n    a,b,c = map(int,input().split())\n    roads.append((a,b,c))\nblocks = []\nfor road1 in roads:\n    for road2 in roads:\n        if road1==road2:\n            continue\n        [a1,b1,c1],[a2,b2,c2] = [road1]+list(road2)\n        if a1*b2==a2*b1:\n            continue\n        x = (c2*b1-c1*b2)/(a1*b2-a2*b1)\n        y = (-c1-a1*x)/b1\n        if len(blocks)==0:\n            blocks.append([(x,y)])\n            continue\n        min_dist = inf\n        nearest_block = None\n        for block in blocks:\n            for b_x,b_y in block:\n                d = (x-b_x)**2+(y-b_y)**2\n                if d<min_dist:\n                    min_dist = d\n                    nearest_block = block\n        can_attach = True\n        for b_x,b_y in nearest_block:\n            for road in roads:\n                if dist(b_x,b_y,x,y,*road)==0:\n                    can_attach = False\n                    break\n            if not can_attach:\n                break\n        if can_attach:\n            nearest_block.append((x,y))\n        else:\n            blocks.append([(x,y)])\nprint(sum(any(dist(gx,gy,ux,uy,*road) for road in roads)==0 for block in blocks for b_x,b_y in block)))"
 ],
 "3894": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Helper function to determine parity of number of odd-size piles\ndef parity(a):\n    return sum(x % 2 == 1 for x in a) % 2\n\n# If k = 1 or parity of odd-size piles is 0, Kevin wins\nif k == 1 or parity(a) == 0:\n    print(\"Kevin\")\n# If n is odd and k > 1 and there is only one odd-size pile, Nicky wins\nelif n % 2 == 1 and len([x for x in a if x % 2 == 1]) == 1:\n    print(\"Nicky\")\n# Otherwise, Kevin wins\nelse:\n    print(\"Kevin\")"
 ],
 "3895": [
  "n = int(input())\nf = list(map(int, input().split()))\n\nm = max(f)\nif m == n:\n    if f.count(m) != m:\n        print(-1)\n    else:\n        print(n)\n        print(*range(1, n+1))\n        print(*range(1, n+1))\nelse:\n    if f.count(m) > m:\n        print(-1)\n    else:\n        g = [0]*n\n        cur = 1\n        for i in range(n):\n            if f[i] == m:\n                g[i] = cur\n                cur += 1\n            else:\n                g[i] = g[f[i]-1]\n\n        print(m)\n        print(*g)\n\n        h = [0]*m\n        for i in range(n):\n            h[g[i]-1] = f[i]\n\n        print(*h)"
 ],
 "3896": [
  "MOD = 1000000007\nn = int(input())\nx = input().strip()\n\n# Pre-compute the number of ones in binary representation of x\nnum_ones = x.count(\"1\")\n\n# Compute the answer using combinatorics formula\nans = 0\nfor i in range(n):\n    if x[i] == \"1\":\n        ans = (ans + pow(2, i, MOD) * (pow(2, num_ones, MOD) - pow(2, n - num_ones, MOD))) % MOD\n    else:\n        ans = (ans + pow(2, i, MOD) * pow(2, num_ones, MOD)) % MOD\n        \nprint(ans)"
 ],
 "3897": [
  "MOD = 10**9 + 7\nn = int(input())\na = list(map(int, input().split()))\n\nprod = 1\nfor ai in a:\n    prod *= ai\n\nfactors = []\nfor i in range(2, int(prod**0.5)+1):\n    if prod % i == 0:\n        cnt = 0\n        while prod % i == 0:\n            cnt += 1\n            prod //= i\n        factors.append(cnt)\nif prod > 1:\n    factors.append(1)\n\ndp = [[0]*(n+1) for _ in range(len(factors)+1)]\ndp[0][0] = 1\n\nfor i in range(1, len(factors)+1):\n    for j in range(n+1):\n        dp[i][j] = dp[i-1][j]\n        for k in range(1, factors[i-1]+1):\n            if j-k >= 0:\n                dp[i][j] += dp[i-1][j-k]\n                dp[i][j] %= MOD\n\nans = 1\nfor cnt in dp[-1]:\n    ans *= cnt\n    ans %= MOD\n\nprint(ans)"
 ],
 "3898": [
  "n = int(input()) \na = list(map(int, input().split())) \nb = list(map(int, input().split())) \n\nempty_pos = a.index(0)  \nfor i in range(n): \n    if b[i] == a[(empty_pos + 1 + i) % n]:  \n        continue  \n    elif b[i] in a:  \n        print(\"NO\")  \n        break  \n    else:  \n        a[empty_pos] = b[i]  \n        empty_pos = a.index(0)  \nelse:  \n    print(\"YES\")"
 ],
 "3899": [
  "n = int(input())\npowers = list(map(int, input().split()))\nprocs = list(map(int, input().split()))\n\ntotal_procs = sum(procs)\nmax_power = sum(powers)\nmin_power = 0\n\nwhile min_power < max_power:\n    mid_power = (min_power + max_power + 1) // 2\n    compute_powers = []\n    \n    for i in range(1 << n):\n        used_procs = 0\n        power_consumed = 0\n        \n        for j in range(n):\n            if i & (1 << j):\n                used_procs += procs[j]\n                power_consumed += powers[j]\n                \n        if power_consumed <= mid_power:\n            compute_powers.append(power_consumed / used_procs)\n            \n    compute_powers.sort(reverse=True)\n    \n    if len(compute_powers) > total_procs / 2:\n        if sum(compute_powers[:total_procs // 2]) > mid_power:\n            min_power = mid_power\n        else:\n            max_power = mid_power - 1\n    else:\n        max_power = mid_power - 1\n        \nprint((min_power + 1) * 1000)"
 ],
 "3900": [
  "from collections import Counter\n\nn, p = list(map(int, input().split()))\npairs = [list(map(int, input().split())) for _ in range(n)]\ncount = Counter([coder[0] for coder in pairs]+[coder[1] for coder in pairs])\nans = 0\nfor i in count:\n    for j in count:\n        if i < j and count[i]+count[j]-sum([1 for coder in pairs if i in coder and j in coder]) >= p:\n            ans += 1\nprint(ans)"
 ],
 "3901": [
  "import math\n\nn = int(input())\na = list(map(int, input().split()))\n\nif 1 in a:\n    a.remove(1)\n\nif not a:\n    print(0)\n\nelse:\n    gcd_arr = a[0]\n    for i in range(1, len(a)):\n        gcd_arr = math.gcd(gcd_arr, a[i])\n\n    if gcd_arr != 1:\n        print(-1)\n\n    else:\n        count = 0\n        for num in a:\n            while num % 2 == 0:\n                count += 1\n                num //= 2\n\n        print(count+n-1)"
 ],
 "3902": [
  "s = input()\n\nif len(s) <= 4:\n    print(0)\nelse:\n    suffixes = set()\n    for i in range(4, len(s)):\n        if s[i-4:i] != s[i-2:i]:\n            suffixes.add(s[i-2:i])\n            if i >= 5 and s[i-5:i-2] == s[i-2:i]:\n                suffixes.discard(s[i-2:i])\n    print(len(suffixes))\n    for suffix in sorted(suffixes):\n        print(suffix)"
 ],
 "3903": [
  "n, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\n\nstates = [[] for _ in range(3)]\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == '1':\n            states[0].append((i,j))\n        elif grid[i][j] == '2':\n            states[1].append((i,j))\n        elif grid[i][j] == '3':\n            states[2].append((i,j))\n            \ndist = [[float('inf')]*3 for _ in range(3)]\nfor i in range(3):\n    dist[i][i] = 0\n    \nfor i in range(3):\n    for j in range(i+1, 3):\n        d = float('inf')\n        for r1, c1 in states[i]:\n            for r2, c2 in states[j]:\n                d = min(d, abs(r1-r2) + abs(c1-c2))\n        if d == float('inf'):\n            print(-1)\n            exit()\n        dist[i][j] = d\n        dist[j][i] = d\n        \nfor k in range(3):\n    for i in range(3):\n        for j in range(3):\n            dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n            \nans = float('inf')\nfor i in range(len(states[0])):\n    for j in range(len(states[1])):\n        for k in range(len(states[2])):\n            d = abs(states[0][i][0]-states[1][j][0]) + abs(states[0][i][1]-states[1][j][1])\n            d += abs(states[1][j][0]-states[2][k][0]) + abs(states[1][j][1]-states[2][k][1])\n            ans = min(ans, d+dist[0][1]+dist[1][2])\n            d = abs(states[0][i][0]-states[2][k][0]) + abs(states[0][i][1]-states[2][k][1])\n            d += abs(states[2][k][0]-states[1][j][0]) + abs(states[2][k][1]-states[1][j][1])\n            ans = min(ans, d+dist[0][2]+dist[2][1])\n            \nprint(ans)"
 ],
 "3904": [
  "n = int(input())\ns = input()\n\ndef solve():\n    bal = 0\n    seg = []\n    for i in range(n):\n        bal += 1 if s[i] == \"(\" else -1\n        if bal < 0:\n            seg.append(i)\n            bal = 0\n    if bal != 0:\n        return -1\n    ans = 0\n    for right in seg[::-1]:\n        cur = s[right+1:] + s[:right+1]\n        r = 0\n        bal = 0\n        for i in range(n):\n            bal += 1 if cur[i] == \"(\" else -1\n            if bal < 0:\n                r = i + 1\n                bal = 1\n        ans += r\n        cur = cur[r:] + cur[:r]\n    return ans\n\nprint(solve())"
 ],
 "3905": [
  "import sys\nsys.setrecursionlimit(100000)\n\nn, m, h = map(int, input().split())\nu = [0] + list(map(int, input().split()))\ng = [[] for i in range(n+1)]\nfor i in range(m):\n    c1, c2 = map(int, input().split())\n    if (u[c1] + 1)%h == u[c2]:\n        g[c1].append(c2)\n    if (u[c2] + 1)%h == u[c1]:\n        g[c2].append(c1)\n\ncc = [-1]*(n+1)\ncnum = 0\nst = []\n\ndef dfs(u):\n    global cnum\n    cc[u] = cnum\n    for v in g[u]:\n        if cc[v] == -1:\n            dfs(v)\n    st.append(u)\n\nfor i in range(1, n+1):\n    if cc[i] == -1:\n        dfs(i)\n        cnum += 1\n\noutg = [[] for i in range(cnum)]\ning = [[] for i in range(cnum)]\n\nfor u in range(1, n+1):\n    uid = cc[u]\n    for v in g[u]:\n        vid = cc[v]\n        if uid == vid:\n            continue\n        outg[uid].append(vid)\n        ing[vid].append(uid)\n\nmatched = [-1]*cnum\npm = [-1]*cnum\nused = [False]*cnum\n\ndef match(u, outg):\n    used[u] = True\n    for v in outg[u]:\n        if pm[v] == -1:\n            matched[u] = v\n            pm[v] = u\n            return True\n    for v in outg[u]:\n        if used[pm[v]]:\n            continue\n        if match(pm[v], outg):\n            matched[u] = v\n            pm[v] = u\n            return True\n    return False\n\nfor u in range(cnum):\n    while True:\n        used = [False]*cnum\n        if not match(u, outg):\n            break\n\nres = []\nfor i in range(cnum):\n    if matched[i] == -1:\n        res.append(i)\n\nans = 1e9\nfor i in range(len(res)):\n    r = res[i]\n    cnt = 0\n    for j in range(cnum):\n        if matched[j] == -1 and cc[j+1] == r:\n            cnt += 1\n    if cnt < ans:\n        ans = cnt\n        cidx = i\n\nr = res[cidx]\n\nrset = set()\nfor j in range(cnum):\n    if cc[j+1] == r:\n        rset.add(j+1)\n\nansv = []\nfor i in range(1, n+1):\n    if u[i] == (u[i+1]-1)%h and cc[i] in rset and cc[i+1] in rset:\n        ansv.append(i)\nprint(ans)\nprint(*ansv)"
 ],
 "3906": [
  "MOD = 10**9 + 7\n\nn, m = map(int, input().split())\n\nif n > m:\n    n, m = m, n\n\nif n == 1:\n    print(pow(2, m, MOD))\nelif n == 2:\n    print(pow(3, m-1, MOD)*2 % MOD)\nelse:\n    print(2*pow(3, n+m-2, MOD) % MOD)"
 ],
 "3907": [
  "n, m = map(int, input().split())\n\ndicts = {}\nfor i in range(m):\n  x, y = map(int, input().split())\n  dicts[x] = y\n  \nvals = sorted(dicts, key = lambda x: dicts[x])\n\ni = 1\nans = 0\n\nwhile(i <= n):\n  if(len(vals) == 0):\n    ans += dicts[max(dicts)]\n    \n  elif(dicts[vals[0]] <= dicts[max(dicts)]):\n    if(i != vals[0]):\n      ans += dicts[vals[0]]\n    else:\n      if(dicts[vals[0]] <= dicts[max(dicts)]):\n        vals.pop(0)\n      ans += dicts[max(dicts)]\n  else:\n    if(i != vals[0]):\n      ans += dicts[max(dicts)]\n    else:\n      if(dicts[max(dicts)] < 2*dicts[vals[0]]):\n        ans += dicts[max(dicts)]\n        vals.pop(0)\n      else:\n        ans += 2*dicts[vals[0]]\n        dicts[max(dicts)] -= dicts[vals[0]]\n        if(dicts[max(dicts)] == 0):\n          del dicts[max(dicts)]\n        vals.pop(0)\n        \n  i += 1\n\nprint(ans)"
 ],
 "3908": [
  "s = input()\nn = len(s)\n\n# creating dp table with index as ascii values of characters from a to z\ndp = [[0 for _ in range(n)] for _ in range(26)]\n\n# initializing last indexes of characters as -1\nlast = [-1] * 26\n\n# fill the dp table \nfor i in range(n):\n    # update last index of character s[i]\n    last[ord(s[i]) - ord('a')] = i\n    for j in range(26):\n        # if character j occurs before character i, add dp[j][k-1] to dp[i][k]\n        if last[j] != -1:\n            for k in range(last[j]):\n                if last[s[k]] > last[j]:\n                    dp[j][last[j]] += dp[s[k]][k]\n        # add dp[j][last[j]-1] to dp[j][last[j]]\n        dp[j][last[j]] += 1\n    \n# find the maximum value in dp table\nans = 0\nfor i in range(26):\n    ans = max(ans, max(dp[i]))\n    \n# print the maximum value\nprint(ans)"
 ],
 "3909": [
  "n = int(input())\n\ncount = 0\nwhile n > 0:\n    count += n % 3\n    n //= 3\n\nprint(count)"
 ],
 "3910": [
  "n = int(input())\npairs = []\nfor i in range(n):\n    a, b = map(int, input().split())\n    pairs.append((a, b))\n\nfood = [-1] * (2*n + 1)  # initialize all chairs with no food\n\nfor i in range(n):\n    boy_chair, girl_chair = pairs[i]\n    if food[boy_chair] == -1 and food[girl_chair] == -1:\n        food[boy_chair] = 1\n        food[girl_chair] = 2\n    elif food[boy_chair] == -1:\n        food[boy_chair] = 3 - food[girl_chair]\n    elif food[girl_chair] == -1:\n        food[girl_chair] = 3 - food[boy_chair]\n    else:\n        print(-1)\n        exit()\n\nfor i in range(n):\n    boy_chair, girl_chair = pairs[i]\n    boy_food = food[boy_chair]\n    girl_food = food[girl_chair]\n    print(boy_food, girl_food)"
 ],
 "3911": [
  "n = int(input())\nslimes = [1]\nfor i in range(2, n + 1):\n    if slimes[-1] != i % 2:\n        slimes.append(1)\n    else:\n        slimes[-1] += 1\nprint(*slimes)"
 ],
 "3912": [
  "n = int(input())\ns = input()\n\ndef is_palindrome(s):\n    return s == s[::-1]\n\nfor i in range(1,n+1):\n    if n % i == 0:\n        parts = [s[j:j+i] for j in range(0,n,i)]\n        if all(is_palindrome(p) for p in parts):\n            print(len(parts))\n            print(' '.join(parts))\n            break"
 ],
 "3913": [
  "n = int(input())\nrevealed = input()\nm = int(input())\nwords = [input() for _ in range(m)]\ncount = 0 # counter for possible letters to tell\nfor i in range(n):\n    if revealed[i] == '*': # if the letter is not revealed yet\n        candidates = set() # set of possible letters\n        for word in words:\n            candidates.add(word[i]) # add the letter at that position in every word to the set\n        if len(candidates) == 1: # if there is only one possible letter\n            if candidates.pop() not in revealed: # and that letter has not been revealed yet\n                count += 1 # increase the counter\nprint(count)"
 ],
 "3914": [
  "n, d, b = map(int, input().split())\na = list(map(int, input().split()))\n\ndef count_diff(x, y):\n    cnt1, cnt2 = 0, 0\n    for i in range(n):\n        if (i % 2 == 0 and a[i] - x > 0) or (i % 2 != 0 and a[i] - y > 0):\n            if i < n - 1 and abs(a[i+1]-x-y) > d*(i % 2 == 0) and i % 2 == 0:\n                cnt1 += 1\n                x = min(a[i], b + a[i+1] - x)\n            elif i > 0 and abs(a[i-1]-x-y) > d*(i % 2 != 0) and i % 2 != 0:\n                cnt2 += 1\n                y = min(a[i], b + a[i-1] - y)\n            elif i % 2 == 0:\n                x = min(a[i], b + x)\n            elif i % 2 != 0:\n                y = min(a[i], b + y)\n    return max(cnt1, cnt2)\n\nans = float('inf')\nfor x in range(b+1):\n    y = b - x\n    if x > a[0] or y > a[-1]:\n        continue\n    ans = min(ans, count_diff(x, y))\n\nprint(ans)"
 ],
 "3915": [
  "from math import sqrt\n\ndef is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(sqrt(n))+1):\n        if n % i == 0:\n            return False\n    return True\n\ndef is_palindrome(n):\n    return str(n) == str(n)[::-1] and str(n)[0] != '0'\n\ndef calculate_pi_n(n):\n    count = 0\n    for i in range(2, n+1):\n        if is_prime(i):\n            count += 1\n    return count\n\ndef calculate_rub_n(n):\n    count = 0\n    for i in range(1, n+1):\n        if is_palindrome(i):\n            count += 1\n    return count\n\np, q = map(int, input().split())\na = p/q\n\nfor n in range(1, 10**7):\n    pi_n = calculate_pi_n(n)\n    rub_n = calculate_rub_n(n)\n    if pi_n <= a * rub_n:\n        print(n)\n        break\nelse:\n    print(\"Palindromic tree is better than splay tree\")"
 ],
 "3916": [
  "import math\n\nn = int(input())\nfrags = sorted(list(map(int, input().split())))\nN = math.factorial(frags[-1])\n\nsieve = [True] * (N + 1)\nsieve[0] = sieve[1] = False\nprimes = []\nfor i in range(2, N + 1):\n    if sieve[i]:\n        primes.append(i)\n        for j in range(i * i, N + 1, i):\n            sieve[j] = False\n        if i > 50:\n            break\n\nfactors = [[] for _ in range(N + 1)]\nfor i in range(2, N + 1):\n    if sieve[i]:\n        continue\n    for j in range(1, N // i + 1):\n        factors[i * j].append(i)\n\ndistances = [[] for _ in range(N + 1)]\nfor i in range(N):\n    distances[frags[i]].append(0)\n    for factor in factors[frags[i]]:\n        if factor == 1:\n            continue\n        dist = distances[frags[i] // factor][-1] + 1\n        distances[frags[i]].append(dist)\n\ntotal_dist = float(\"inf\")\nfor p in primes:\n    dist = 0\n    for i in range(n):\n        dist += distances[p * frags[i]][-1]\n    total_dist = min(total_dist, dist)\n\nprint(total_dist)"
 ],
 "3917": [
  "n = int(input())\na = list(map(int, input().split()))\n\ndef g(i, j):\n    s = 0\n    for k in range(min(i, j) + 1, max(i, j) + 1):\n        s += a[k]\n    return s\n\nans = float('inf')\nfor i in range(1, n + 1):\n    for j in range(1, n + 1):\n        if i != j:\n            ans = min(ans, (i - j)**2 + g(i, j)**2)\n\nprint(ans)"
 ],
 "3918": [
  "n, k1, k2 = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\ndiff = [(abs(a[i] - b[i]), i) for i in range(n)]\ndiff.sort(reverse=True)\nfor i in range(min(k1 + k2, n)):\n    if a[diff[i][1]] >= b[diff[i][1]]:\n        if k1 > 0:\n            a[diff[i][1]] -= 1\n            k1 -= 1\n        else:\n            b[diff[i][1]] += 1\n            k2 -= 1\n    else:\n        if k2 > 0:\n            b[diff[i][1]] -= 1\n            k2 -= 1\n        else:\n            a[diff[i][1]] += 1\n            k1 -= 1\nprint(sum([(a[i] - b[i])**2 for i in range(n)]))"
 ],
 "3919": [
  "MOD = 10 ** 9 + 7\n\nn, m = map(int, input().split())\ns = input().strip()\ndp = [[0] * n for _ in range(n)]\n\nfor i in range(n):\n    for j in range(i + 1, n):\n        dp[i][j] = dp[i][j - 1]\n        if s[j - 1] == \"0\":\n            dp[i][j] += dp[i][j - 1] + 1\n\nfor i in range(m):\n    l, r = map(int, input().split())\n    l -= 1\n    r -= 1\n    for j in range(l):\n        for k in range(l, r + 1):\n            if s[j] == \"1\" and s[k] == \"0\":\n                dp[j][k] -= pow(2, k - l - dp[l][k] - dp[j][l], MOD)\n                dp[j][k] %= MOD\n    for j in range(l, r + 1):\n        for k in range(r, n):\n            if s[j] == \"0\" and s[k] == \"1\":\n                dp[j][k] += pow(2, k - r - dp[r][k] - dp[j][r], MOD)\n                dp[j][k] %= MOD\n\nans = pow(2, s.count(\"0\"), MOD)\nfor i in range(n):\n    for j in range(i, n):\n        if dp[i][j] == dp[0][n - 1]:\n            ans += pow(2, n - 1 - j, MOD)\n            ans %= MOD\n\nprint(ans)"
 ],
 "3920": [
  "a = list(map(int, input().split()))\nprint((a[0]+a[1]+a[2])**2-a[0]**2-a[2]**2-a[4]**2)"
 ],
 "3921": [
  "from math import gcd\n\nn = int(input())\na = list(map(int, input().split()))\n\ndp = [1] * n\nfor i in range(n):\n    for j in range(i):\n        if a[i] > a[j] and gcd(a[i], a[j]) > 1:\n            dp[i] = max(dp[i], dp[j]+1)\nprint(max(dp))"
 ],
 "3922": [
  "def solve(k, row1, row2):\n    row1 = [x if x != 'E' else None for x in row1]\n    row2 = [x if x != 'E' else None for x in row2]\n    correct_pos = {\n        row1[i]: (0, i) for i in range(2*k+1)\n    }\n    correct_pos.update({\n        row2[i]: (1, i) for i in range(2*k+1) if row2[i] is not None\n    })\n    empty_row = 0 if 'E' in row1 else 1\n    empty_col = row1.index('E') if 'E' in row1 else row2.index('E')\n\n    def move_empty_to_row(empty_row_dest):\n        nonlocal empty_row, empty_col\n        if empty_row_dest == empty_row:\n            return \"\"\n        if empty_row == 0 and empty_row_dest == 1:\n            empty_row = 1\n            diff = empty_col - k\n            if diff == 0:\n                return \"SrS\"\n            if diff < 0:\n                return \"S\" * -diff + \"rSr\" + \"S\" * (-diff)\n            return \"rS\" * diff + \"Sr\" + \"rS\" * diff\n        elif empty_row == 1 and empty_row_dest == 0:\n            empty_row = 0\n            diff = empty_col - k\n            if diff == 0:\n                return \"TrT\"\n            if diff < 0:\n                return \"T\" * -diff + \"rTr\" + \"T\" * (-diff)\n            return \"rT\" * diff + \"Tr\" + \"rT\" * diff\n        else:\n            assert False\n\n    def move_to_empty(entry):\n        nonlocal empty_row, empty_col\n        entry_row, entry_col = correct_pos[entry]\n        if entry_col == empty_col:\n            if entry_row == empty_row-1:\n                empty_row -= 1\n                return \"u\"\n            elif entry_row == empty_row+1:\n                empty_row += 1\n                return \"d\"\n        elif entry_row == empty_row and entry_col == empty_col-1:\n            empty_col -= 1\n            return \"l\"\n        elif entry_row == empty_row and entry_col == empty_col+1:\n            empty_col += 1\n            return \"r\"\n        return None\n\n    def find_move():\n        for i in range(4*k+1):\n            if row1[i] == 'E' or row2[i] == 'E':\n                continue\n            if move := move_to_empty(row1[i] if empty_row == 1 else row2[i]):\n                return move\n        return None\n\n    sequence = \"\"\n    while True:\n        if not any(None in row for row in (row1, row2)):\n            return \"SURGERY COMPLETE\", sequence\n        if move := find_move():\n            sequence += move\n        elif sequence:\n            print(\"INVALID SEQUENCE: \", sequence)\n            return \"SURGERY FAILED\",\n        else:\n            sequence += move_empty_to_row(1)\n            sequence += \"r\" * (2*k - empty_col)\n            sequence += \"d\" * (1 - empty_row)\n            sequence += \"l\" * (2*k - empty_col)\n            sequence += move_empty_to_row(0)\n\nfor _ in range(int(input())):\n    k = int(input())\n    row1 = input().split()\n    row2 = input().split()\n    result = solve(k, row1, row2)\n    for short, long in {'R': 'SrS', 'S': 'rr', 'T': 'lldll'}.items():\n        if short in result[1]:\n            print(short)\n            print(long)\n    print(\"DONE\")\n    print(*result)"
 ],
 "3923": [
  "n, a, b = map(int, input().split())\n\nif a == 1 and b == 1:\n    if n == 1:\n        print(1)\n    else:\n        print(-1)\nelif n < a + b - 1:\n    print(-1)\nelse:\n    perm = list(range(1, n+1))\n    for i in range(1, a+b-1):\n        if i < a:\n            perm[i-1] = i+1\n        else:\n            perm[i-1] = a+b-i\n    for i in range(a+b-1, n):\n        perm[i] = i+1\n    if b > 1:\n        perm[b-2] = a+1\n        perm[a+b-2] = b\n    print(' '.join(map(str, perm)))"
 ],
 "3924": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\nbag_count = 0\ncur_bag = 0\n\nfor i in range(n):\n    cur_bag += a[i]\n    if cur_bag > k:\n        bag_count += 1\n        cur_bag = a[i]\n    elif i == n - 1: # last day\n        bag_count += 1\n\nif cur_bag > 0:\n    bag_count += 1\n\nprint(bag_count)"
 ],
 "3925": [
  "s = input()\nn = len(s)\nmax_len = 1\ncurr_len = 1\nfor i in range(1, n):\n    if s[i] != s[i-1]:\n        curr_len += 1\n        max_len = max(max_len, curr_len)\n    else:\n        curr_len = 1\nprint(min(n, max_len+2))"
 ],
 "3926": [
  "from collections import deque\n\nn, m = map(int, input().split())\nr, c = map(int, input().split())\nx, y = map(int, input().split())\n\ngrid = []\nfor i in range(n):\n    row = input()\n    grid.append(row)\n\nmoves = [[-1, 0], [0, 1], [1, 0], [0, -1]]\n\nreachable = [[False for j in range(m)] for i in range(n)]\nqueue = deque([(r-1, c-1)])\nreachable[r-1][c-1] = True\n\nwhile queue:\n    r, c = queue.popleft()\n    for move in moves:\n        if abs(move[0]) <= x and abs(move[1]) <= y:\n            new_r, new_c = r + move[0], c + move[1]\n            if 0 <= new_r < n and 0 <= new_c < m and not reachable[new_r][new_c] and grid[new_r][new_c] == '.':\n                reachable[new_r][new_c] = True\n                queue.append((new_r, new_c))\n                \nprint(sum(sum(row) for row in reachable))"
 ],
 "3927": [
  "n = int(input())\nweights = list(map(int, input().split()))\n\ntotal_sum = sum(weights)\ndp = [[0] * (total_sum+1) for _ in range(n+1)]\ndp[0][0] = 1\n\nfor i in range(1,n+1):\n    for j in range(total_sum+1):\n        dp[i][j] = dp[i-1][j]\n        if j >= weights[i-1]:\n            dp[i][j] |= dp[i-1][j-weights[i-1]]\n\nmax_cnt = 0\nfor i in range(1, total_sum+1):\n    if dp[n][i]:\n        cnt = 0\n        sum_so_far = i\n        for j in range(n-1, -1, -1):\n            if sum_so_far >= weights[j] and dp[j][sum_so_far-weights[j]]:\n                cnt += 1\n                sum_so_far -= weights[j]\n        max_cnt = max(max_cnt, cnt)\n\nprint(max_cnt)"
 ],
 "3928": [
  "n, a, b = map(int, input().split())\ns = input()\n\ndp = [float(\"inf\")] * (n+1)\ndp[0] = 0\n\nfor i in range(1,n+1):\n    for j in range(1,i+1):\n        t = s[j-1:i]\n        if j==i:\n            dp[i] = min(dp[i], dp[j-1]+a)\n        elif t in s[:j-1]:\n            dp[i] = min(dp[i], dp[j-1]+b)\nprint(dp[n])"
 ],
 "3929": [
  "from math import comb\nMOD = 10**9 + 7\nN, K = map(int, input().split())\nans = 0\nfor i in range(K, N+1):\n    ans += comb(N, i) * comb(N-1, N-i-1)\nprint(ans % MOD)"
 ],
 "3930": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\nprefix_sum = [0]\nfor x in a:\n    prefix_sum.append(prefix_sum[-1] + x)\n\npowers = [1]\nwhile powers[-1] <= 10**18:  # limit to prevent overflow\n    powers.append(powers[-1] * abs(k))\n\ndef count_segment_with_sum(sum_value, prefix_sum):\n    count = 0\n    freq = {}\n    for x in prefix_sum:\n        if x in freq:\n            count += freq[x]\n        if x - sum_value in freq:\n            count += freq[x - sum_value]\n        freq[x] = freq.get(x, 0) + 1\n    return count\n\nans = 0\nfor i in range(n+1):\n    for power in powers:\n        ans += count_segment_with_sum(power*prefix_sum[i], prefix_sum[:i])\n\nprint(ans)"
 ],
 "3931": [
  "n, a, b, k, f = map(int, input().split())\nstops = [tuple(input().split()) for _ in range(n)]\n\nprice = 0\ntrips = {}\nfor s, f in stops:\n    cost = a\n    if (s, f) in trips:\n        cost = b\n        trips.pop((s, f))\n    else:\n        trips[(s, f)] = True\n    \n    price += cost\n    \ntrips = len(trips)\ncards_needed = (trips + 1) // 2\ncards_needed = min(cards_needed, k)\ncards_cost = cards_needed * f\n\nprint(price - cards_cost)"
 ],
 "3932": [
  "n = int(input())\nc = list(map(int,input().split()))\n\npossible = True\nfor i in range(2,n+1):\n    if c[i-1] >= i:\n        possible = False\n        break\n\nif possible:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "3933": [
  "n = int(input())\ntemps = list(map(int, input().split()))\n\nif temps[0] == temps[-1]: \n    print(temps[-1])\nelse:\n    diff = None\n    is_ap = True\n    for i in range(1, len(temps)):\n        if diff is None:\n            diff = temps[i] - temps[i-1]\n        elif temps[i] - temps[i-1] != diff:\n            is_ap = False\n            break\n\n    if is_ap:\n        print(temps[-1] + diff)\n    else:\n        print(temps[-1])"
 ],
 "3934": [
  "import sys\nsys.setrecursionlimit(10**7)\ndef dfs(i,p,l,e):\n    l[i] = 0\n    for j in e[i]:\n        if j!=p:\n            dfs(j,i,l,e)\n            l[i] = max(1+l[j],l[i])\n    return\ndef solve(i,p,l,e):\n    res = []\n    tin = 0\n    v = sorted(e[i],key=lambda x:-l[x])\n    for j in v:\n        if j!=p:\n            a,b = solve(j,i,l,e)\n            res.append(b+tin)\n            tin += 1+a\n    if len(res)<=1:\n        return 1,0\n    res.sort()\n    if res[-1]-res[0]<=1:\n        return res[-1]-res[0]+1,res[0]\n    else:\n        return res[-1]+1,tin+res[-2]+1+res[-1]-res[0]\ndef main():\n    n = int(input())\n    e = [[] for _ in range(n)]\n    for i in range(n-1):\n        a,b = map(int,input().split())\n        e[a-1].append(b-1)\n        e[b-1].append(a-1)\n    ans = True\n    l = [0]*n\n    dfs(0,-1,l,e)\n    for i in range(n):\n        if len(e[i])==1:\n            continue\n        a,b = solve(i,-1,l,e)\n        if a>2*l[i]:\n            ans = False\n            break\n    print('YES' if ans else 'NO')\nmain()"
 ],
 "3935": [
  "from collections import deque\n\nn = int(input())\nb = list(map(int, input().split()))\n\ngraph = [[] for _ in range(n)]\nfor i in range(n):\n    for j in range(i+1, n):\n        if abs(b[i]-b[j]) in b:\n            graph[i].append(j)\n            graph[j].append(i)\n\ncolor = [-1 for _ in range(n)]\nqueue = deque()\n\ndef bfs(start):\n    queue.append(start)\n    color[start] = 0\n    while queue:\n        u = queue.popleft()\n        for v in graph[u]:\n            if color[v] == -1:\n                color[v] = 1-color[u]\n                queue.append(v)\n            elif color[v] == color[u]:\n                return False\n    return True\n\nis_bipartite = True\nfor i in range(n):\n    if color[i] == -1:\n        is_bipartite &= bfs(i)\n\n\nif is_bipartite:\n    print(0)\nelse:\n    delete_set = set()\n    for i in range(n):\n        if color[i] == 0:\n            for j in range(i+1, n):\n                if color[j] == 0 and abs(b[i]-b[j]) in b:\n                    delete_set.add(max(b[i], b[j]))\n        elif color[i] == 1:\n            for j in range(i+1, n):\n                if color[j] == 1 and abs(b[i]-b[j]) in b:\n                    delete_set.add(min(b[i], b[j]))\n    print(len(delete_set))\n    print(*delete_set)"
 ],
 "3936": [
  "n=int(input())\ns1=input().rstrip()\ns2=input().rstrip()\n\nmod=10**9+7\n\nif s1[0]==s2[0]:\n    ans=3\n    i=1\nelse:\n    ans=6;\n    i=2;\n    \nwhile i<n:\n    if s1[i]==s2[i]:\n        if s1[i-1]==s2[i-1]:\n            ans=ans*2 % mod\n        i+=1\n    else:\n        if s1[i-1]==s2[i-1]:\n            ans=ans*2 % mod\n        else:\n            ans=ans*3 % mod\n        i+=2\nprint(ans)"
 ],
 "3937": [
  "def gcd(a, b):\n    return a if b == 0 else gcd(b, a % b)\n\nn, m, k = map(int, input().split())\na = list(map(int, input().split()))\n\ng = [0] * (m - k + 1)\nfor j in range(m - k + 1):\n    g[j] = gcd(j+1, j+k) == a[0]\n    for l in range(1, k):\n        if g[j] and gcd(j+l+1, j+k) != a[l]:\n            g[j] = False\n            break\n\nprint('YES' if any(g) else 'NO')"
 ],
 "3938": [
  "from collections import defaultdict\n\ndef build_graph(n, m, rectangles):\n    graph = defaultdict(list)\n    rects_in_col = [[] for _ in range(n+2)]\n    for x1, y1, x2, y2 in rectangles:\n        rects_in_col[x1].append((y1, y2))\n        rects_in_col[x2+1].append((-y1, -y2))\n    for i in range(1, n+1):\n        rects = rects_in_col[i]\n        rects.sort()\n        end_points = []\n        for y1, y2 in rects:\n            if y1 > 0:\n                for y in end_points:\n                    graph[y].append((y2, y2-y))\n            else:\n                for y in end_points:\n                    graph[y1-y].append((y, y-y1))\n            end_points.append(y1)\n            end_points.append(y2)\n        end_points.sort()\n        new_end_points = []\n        for y in end_points:\n            if y > 0:\n                new_end_points.append(y)\n            else:\n                new_end_points.remove(-y)\n        end_points = new_end_points\n    return graph\n\ndef dfs(v, visited, graph, match):\n    visited.add(v)\n    for u, w in graph[v]:\n        if u not in visited:\n            if dfs(u, visited, graph, match):\n                match[v] = (u, w)\n                return True\n        elif u not in match or u in visited:\n            match[v] = (u, w)\n            return True\n    return False\n\ndef max_matching(graph):\n    matching = {}\n    for v in graph:\n        dfs(v, set(), graph, matching)\n    return matching\n\ndef min_vertex_cover(graph, matching):\n    cover = set()\n    for v in graph:\n        if v not in matching:\n            cover.add(v)\n    visited = set()\n    for v in cover:\n        if v not in visited:\n            visited.add(v)\n            for u, w in graph[v]:\n                if u in matching:\n                    visited.add(u)\n    return cover | visited\n\n\nn, m = map(int, input().split())\nrectangles = []\nfor _ in range(m):\n    x1, y1, x2, y2 = map(int, input().split())\n    rectangles.append((x1, y1, x2, y2))\ngraph = build_graph(n, m, rectangles)\nmatching = max_matching(graph)\ncover = min_vertex_cover(graph, matching)\ncost = sum(min(v[1], matching[v][1]) for v in matching)\nfor v in cover:\n    for u, w in graph[v]:\n        if u in cover:\n            cost += min(v+w, u+w)\nprint(cost)"
 ],
 "3939": [
  "def medianIndex(l,r):\n    length = r-l+1\n    return (l+r)//2 if length%2==1 else (l+r)//2-1\n\ndef isPossible(n,k,a):\n    medianIndices = [0]\n    for i in range(1,n):\n        if a[i]!=a[i-1]:\n            medianIndices.append(i)\n    medianIndices.append(n)\n    if len(medianIndices)>3:\n        return False\n    elif len(medianIndices)==2:\n        return True\n    else:\n        leftMedianIndex = medianIndex(0,medianIndices[1]-1)\n        rightMedianIndex = medianIndex(medianIndices[1],n-1)\n\n        leftMedian = a[leftMedianIndex]\n        rightMedian = a[rightMedianIndex]\n\n        if leftMedian>=k and rightMedian>=k:\n            return False\n\n        changesNeeded = 0\n        \n        if leftMedian<k:\n            for i in range(medianIndices[0],medianIndices[1]):\n                if a[i]>leftMedian:\n                    changesNeeded+=1\n        if rightMedian<k:\n            for i in range(medianIndices[1],medianIndices[2]):\n                if a[i]>rightMedian:\n                    changesNeeded+=1\n\n        return changesNeeded<=len(a)//2\n\nt=int(input())\nfor _ in range(t):\n    n,k=map(int,input().split())\n    a=list(map(int,input().split()))\n    if isPossible(n,k,a):\n        print(\"yes\")\n    else:\n        print(\"no\")"
 ],
 "3940": [
  "n,m=map(int,input().split())\nl,r=[],[]\nfor i in range(m):\n    a,b=map(int,input().split())\n    l.append(a)\n    r.append(b)\na=[0]*n\nfor i in range(m):\n    if r[i]<n:\n        a[r[i]]=max(a[r[i]],a[r[i]]+1)\n    if l[i]>1:\n        a[l[i]-2]=max(a[l[i]-2],a[l[i]-1]-1)\nprint(max(a))\nfor i in range(n):\n    if i==0:\n        print(a[i],end='')\n    else:\n        print(' '+str(a[i]),end='')\nprint()"
 ],
 "3941": [
  "from collections import defaultdict\n\n# DFS function for checking if graph is strongly connected\ndef dfs(u, graph, visited, stack):\n    visited[u] = True\n    for v in graph[u]:\n        if not visited[v]:\n            dfs(v, graph, visited, stack)\n    stack.append(u)\n\n# Transpose the graph\ndef transpose(graph):\n    transposed_graph = defaultdict(list)\n    for u in graph:\n        for v in graph[u]:\n            transposed_graph[v].append(u)\n    return transposed_graph\n\n# DFS function for finding connected components of transposed graph\ndef dfs2(u, transposed_graph, visited, component):\n    visited[u] = True\n    component.append(u)\n    for v in transposed_graph[u]:\n        if not visited[v]:\n            dfs2(v, transposed_graph, visited, component)\n \n# Main function\ndef main():\n    n, m = map(int, input().split())\n    doors = list(map(int, input().split()))\n    switches = []\n    graph = defaultdict(list)\n    for i in range(m):\n        x, *rooms = map(int, input().split())\n        if doors[rooms[0]-1] != doors[rooms[1]-1]:\n            # If the two rooms controlled by the switch have different statuses,\n            # we add the switch to the graph\n            switches.append(i)\n            graph[i].append(~i)\n            graph[~i].append(i)\n            for room in rooms:\n                # We add edges from switch to room and from ~switch to ~room\n                graph[~i].append((room-1)+m)\n                graph[(room-1)+m].append(~i)\n        else:\n            # If the two rooms controlled by the switch have the same status,\n            # we remove the switch as it doesn't contribute to the solution\n            for room in rooms:\n                doors[room-1] = 1 - doors[room-1]\n    visited = [False]*(2*m)\n    stack = []\n    for i in range(2*m):\n        if not visited[i]:\n            dfs(i, graph, visited, stack)\n    transposed_graph = transpose(graph)\n    visited = [False]*(2*m)\n    answer = \"YES\"\n    while stack:\n        component = []\n        u = stack.pop()\n        if not visited[u]:\n            dfs2(u, transposed_graph, visited, component)\n            statuses = [doors[(room-m)-1] for room in component if room >= m]\n            if all(statuses):\n                # If all the rooms controlled by the switches in this strongly connected component\n                # can be unlocked at the same time, then the solution is possible\n                continue\n            else:\n                answer = \"NO\"\n                break\n    print(answer)\n\nif __name__ == \"__main__\":\n    main()"
 ],
 "3942": [
  "s = input()\nstack = []\ncount = 0\nfor i in range(len(s)):\n    if s[i] == '(':\n        stack.append('(')\n    elif s[i] == ')':\n        if not stack:\n            print(-1)\n            exit(0)\n        stack.pop()\n    else:\n        count += 1\n        if len(stack) < count:\n            print(-1)\n            exit(0)\n        print(count)\n        stack.append('(' * count)\nprint(-1 if stack else \"\", end=\"\")"
 ],
 "3943": [
  "a,b = map(int, input().split())\nif a == 0:\n    print(-b**2)\n    print('x'*b)\nelif b == 0:\n    print(a**2)\n    print('o'*a)\nelif a == 1 and b == 1:\n    print(0)\n    print('ox')\nelse:\n    if a > b:\n        print(a**2 - (a-1-b)**2)\n        print('o'*(a-(a-1-b))+'x'*(a-1-b)+'oo'*(b-(a-(a-1-b))))\n    elif a == b:\n        print(a**2-b**2)\n        print('ox'*a)\n    else:\n        print(b**2-(b-1-a)**2)\n        print('x'*(b-(b-1-a))+'o'*(b-1-a)+'xx'*(a-(b-(b-1-a))))"
 ],
 "3944": [
  "MOD = 10**9+7\n\nn, m, k = map(int, input().split())\n\ndef pow_mod(a, b):\n    if b == 0:\n        return 1\n    if b%2 == 0:\n        return pow_mod(a*a%MOD, b//2)%MOD\n    else:\n        return a*pow_mod(a, b-1)%MOD\n\nfac = [1]*(n+m+k+1)\nfor i in range(1, n+m+k+1):\n    fac[i] = i*fac[i-1]%MOD\n\ninv_fac = [1]*(n+m+k+1)\ninv_fac[n+m+k] = pow_mod(fac[n+m+k], MOD-2)\nfor i in range(n+m+k-1, -1, -1):\n    inv_fac[i] = (i+1)*inv_fac[i+1]%MOD\n\ndef nCr(n, r):\n    return fac[n]*inv_fac[n-r]%MOD*inv_fac[r]%MOD\n\nans = 0\nfor i in range(n+1):\n    x = nCr(n+m+k-i-1, m+k-i)*pow_mod(2, MOD-2*(n+m+k-i))%MOD\n    ans = (ans + nCr(n+m+k-1-i, n-i)*x)%MOD\n\nprint(ans)"
 ],
 "3945": [
  "n,m=map(int,input().split())\na=[list(map(int,input().split())) for i in range(n)]\nres=[]\nfor k in range(n+m-1):\n    b=[]\n    for i in range(n):\n        for j in range(m):\n            if i+j==k:\n                b.append(a[i][j])\n    b.sort()\n    j=0\n    dict={}\n    for i in range(len(b)):\n        if not dict:\n            dict[b[i]]=j\n            continue\n        while j<=dict[b[i]]:\n            j+=1\n        dict[b[i]]=j\n    res.append(dict)\nfor i in range(n):\n    for j in range(m):\n        print(res[i+j][a[i][j]], end=' ')\n    print(\"\")"
 ],
 "3946": [
  "n,m=map(int,input().split())\na=list(map(int,input().split()))\nw=list(map(int,input().split()))\ntotal_w=sum(w)\n\ndp=[[0]*(total_w+1) for _ in range(m+1)]\n\ndp[0][0]=1\nfor i in range(1,m+1):\n    for total_weight in range(total_w+1):\n        #keep the same\n        dp[i][total_weight]+=dp[i-1][total_weight]*(total_weight+m-i+1)\n        dp[i][total_weight]%=998244353\n        #add 1 to the weight\n        if total_weight-1+w[i-1]<=total_w:\n            dp[i][total_weight]+=dp[i-1][total_weight-1]*(w[i-1]-a[i-1])\n            dp[i][total_weight]%=998244353\n        #subtract 1 from the weight\n        if total_weight+1<=total_w:\n            dp[i][total_weight]+=dp[i-1][total_weight+1]*(a[i-1]+1)\n            dp[i][total_weight]%=998244353\n\nmod=998244353\nfor i in range(1,n+1):\n    ans=0\n    for total_weight in range(total_w+1):\n        ans+=(total_weight+mod)*dp[m][total_weight]%mod*pow(w[i-1]+total_w-mod,mod-2,mod)%mod\n        ans%=mod\n    print(ans)"
 ],
 "3947": [
  "n = int(input())\na = list(map(int, input().split()))\n\nans = 0\nfor i in range(1, n-1):\n    ans += min(a[i], min(a[i-1], a[i+1]))\n\nprint(ans)"
 ],
 "3948": [
  "from collections import deque\n\nn, k = map(int, input().split())\ndeg = [0] * (n+1)\nadj = [[] for _ in range(n+1)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    deg[u] += 1\n    deg[v] += 1\n    adj[u].append(v)\n    adj[v].append(u)\ncenter = deg.index(max(deg[1:])) # find the center of hedghog\nq = deque([center])\nfor _ in range(k):\n    nxt_q = deque()\n    while q:\n        u = q.popleft()\n        for v in adj[u]:\n            if deg[v] == 1:\n                nxt_q.append(v)\n                w = nxt_q[-1] # new center for subtree\n        adj[u].remove(w) # remove the joining edge and center\n        adj[w] = [u] # update w's adjacency list\n        adj.append([w]) # create a new hedgehog\n        for v in adj[u]: # connect newly created hedgehog to u's neighbors\n            adj[w].append(v)\n            adj[v].append(w)\n        deg[u] -= 1 # update degrees\n        deg[w] = 2\n    q = nxt_q\nif any(deg[i] != 2 for i in range(1, n+1)): # check if all vertices have degree 2\n    print(\"No\")\nelse:\n    print(\"Yes\")"
 ],
 "3949": [
  "n, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\nrows, cols = [set() for _ in range(n)], [set() for _ in range(m)]\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == '#':\n            rows[i].add(j)\n            cols[j].add(i)\n\nnorth = [False] * n\nfor i in range(n):\n    for j in rows[i]:\n        flag = False\n        for k in range(n):\n            if k != i and j in rows[k]:\n                flag = True\n                break\n        if not flag:\n            north[i] = True\n    if len(rows[i]) == 0:\n        print(-1)\n        exit()\n\nfor j in range(m):\n    flag = False\n    for i in cols[j]:\n        if not north[i]:\n            flag = True\n            break\n    if not flag and len(cols[j]) > 0:\n        print(-1)\n        exit()\n\nprint(sum(north))"
 ],
 "3950": [
  "n,q=map(int,input().split())\na=list(map(int,input().split()))\nans=[-1]*n\nseg=[0]*q\nlast=-1\nfor i in range(n):\n    if a[i]>0:\n        if seg[a[i]-1]>0:\n            if last>=seg[a[i]-1]:\n                print(\"NO\")\n                break\n        j=seg[a[i]-1]\n        while j<i:\n            ans[j]=a[i]\n            j+=1\n        seg[a[i]-1]=i+1\n        ans[i]=a[i]\n        last=i\nfor i in range(q):\n    if seg[i]==0:\n        print(\"NO\")\n        break\nelse:\n    j=n-1\n    for i in range(q):\n        k=seg[i]-2\n        val=i+1\n        while j>k:\n            if ans[j]==-1:\n                ans[j]=val\n            j-=1\n    print(\"YES\")\n    print(*ans)"
 ],
 "3951": [
  "from math import gcd\n\nn = int(input())\ntable = list(map(int, input().split()))\n\na = [0] * n\n\nfor i in range(n):\n    for j in range(n):\n        if i == j:\n            a[i] = table[i * n + j] // n\n        else:\n            g = gcd(table[i * n + j], table[i * n + i])\n            a[j] = g // a[i]\n\nprint(*a)"
 ],
 "3952": [
  "n = int(input())\npoints = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    points.append((x, y))\npoints.sort()\n\nans = 0\nleft_y = 0\nright_y = 0\nfor i in range(n):\n    x, y = points[i]\n    if y > left_y:\n        ans += 1\n        left_y = y\n        right_y = y\n    elif y > right_y:\n        ans += 1\n        right_y = y\nprint(ans)"
 ],
 "3953": [
  "n = int(input())\ngrid = []\nfor _ in range(n):\n    row = input().strip()\n    grid.append(row)\n\nrows_to_purify = set(range(n))\ncols_to_purify = set(range(n))\n\nfor i in range(n):\n    for j in range(n):\n        if grid[i][j] == 'E':\n            rows_to_purify.discard(i)\n            cols_to_purify.discard(j)\n\nif not rows_to_purify and not cols_to_purify:\n    print(-1)\nelse:\n    cells_to_purify = []\n    for i in rows_to_purify:\n        for j in range(n):\n            cells_to_purify.append((i+1, j+1))\n    for i in cols_to_purify:\n        for j in range(n):\n            if (j+1, i+1) not in cells_to_purify:\n                cells_to_purify.append((j+1, i+1))\n    for cell in cells_to_purify:\n        print(cell[0], cell[1])"
 ],
 "3954": [
  "def f(a, l, r):\n    return sum(a[l - 1:r])\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nresult = max(a)\nfor i in range(n):\n    for j in range(i+1, n):\n        subarray = a[:i] + a[i:j+1][::-1] + a[j+1:]\n        for swaps in range(1, k+1):\n            max_sum = float('-inf')\n            for x in range(n):\n                for y in range(x, n):\n                    max_sum = max(max_sum, f(subarray, x+1, y))\n            result = max(result, max_sum - swaps * (subarray[i] + subarray[j]))\n                \nprint(result)"
 ],
 "3955": [
  "n,k,x=map(int,input().split())\nnums=list(map(int,input().split()))\nfor i in range(k):\n    nums.sort()\n    nums[-1]=nums[-1]*x\nprint(max(nums))"
 ],
 "3956": [
  "mod = 998244353\nK, N = map(int, input().split())\n\ncomb = [[0] * (N*K + 1) for _ in range(N+1)]\nfor i in range(N+1):\n    comb[i][i] = comb[i][0] = 1\n    for j in range(1,i):\n        comb[i][j] = (comb[i-1][j-1] + comb[i-1][j]) % mod\n\ndp = [0]*((N*K) + 1)\ndp[0] = 1\nfor i in range(K):\n    ndp = [0]*((N*K)+1)\n    for j in range(i*N+1):\n        for l in range(1,K+1):\n            if j+l <= i*N+K:\n                ndp[j+l] = (ndp[j+l] + dp[j]*comb[N-1+i*N-j//l][N-1])%mod\n    dp = ndp\n\nans = [0]*(2*K-1)\nfor i in range(2,2*K):\n    for j in range(i//2+1):\n        if 1<=i-j<=K:\n            val = dp[(i-j)*N] * comb[K][j] % mod\n            if i-j-j > 0:\n                val = (val-val*2*comb[K-j][i-j-j]%mod+mod)%mod\n            ans[i-2] = (ans[i-2] + val)%mod\n\nprint(*ans, sep='\\n')"
 ],
 "3957": [
  "n, k = map(int, input().split())\nuniversities = set(map(int, input().split()))\ngraph = [[] for _ in range(n + 1)]\n\nfor _ in range(n-1):\n    u, v = map(int, input().split())\n    graph[u].append(v)\n    graph[v].append(u)\n\nans = 0\n\ndef dfs(node, parent=None):\n    global ans\n    size = 1\n    for neighbor in graph[node]:\n        if neighbor != parent:\n            subsize = dfs(neighbor, node)\n            size += subsize\n            ans += min(subsize, 2*k-subsize)\n    return size\n\ndfs(1)\nprint(ans)"
 ],
 "3958": [
  "from collections import deque\ns = input().strip()\nn = len(s)\n\n# find all the zebras\nzebras = deque()\ncurr_zebra = []\nfor i in range(n):\n    if s[i] == '0':\n        # bad day, start a new zebra\n        if len(curr_zebra) > 0:\n            zebras.append(curr_zebra)\n        curr_zebra = [i+1]\n    else:\n        # good day, add to current zebra\n        if len(curr_zebra) > 0 and s[curr_zebra[-1]-1] == '1':\n            curr_zebra.append(i+1)\n        else:\n            # cannot form zebra\n            print(-1)\n            exit()\n\n# add last zebra\nif len(curr_zebra) > 0:\n    zebras.append(curr_zebra)\n\n# print the answer\nprint(len(zebras))\nfor zebra in zebras:\n    print(len(zebra), ' '.join(map(str, zebra)))"
 ],
 "3959": [
  "n, m = map(int, input().split())\n\nMOD = 10**9 + 7\n\nfreq = [{} for i in range(m+1)]\nfor i in range(n):\n    gyms = list(map(int, input().split()))[1:]\n    for p in gyms:\n        if p in freq[i]:\n            freq[i][p] += 1\n        else:\n            freq[i][p] = 1\n\ntype_freq = {}\nfor i in range(n):\n    for t, f in freq[i].items():\n        if t in type_freq:\n            type_freq[t].append(f)\n        else:\n            type_freq[t] = [f]\n\nfor t in type_freq:\n    type_freq[t].sort()\ni = 1\nans = 1\nfor t in sorted(type_freq.keys()):\n    currans = 1\n    prev = type_freq[t][0]\n    for i in range(1, len(type_freq[t])):\n        if type_freq[t][i] != prev:\n            currans *= i\n            currans %= MOD\n            prev = type_freq[t][i]\n    currans *= i+1\n    currans %= MOD\n    ans *= currans\n    ans %= MOD\nprint(ans)"
 ],
 "3960": [
  "n = int(input())\na = list(map(int, input().split()))\n\ndp1 = [-1e18]*n\ndp2 = [-1e18]*n\n\nfor i in range(n-1):\n    if i % 2 == 0:\n        dp1[i] = abs(a[i] - a[i+1])\n    else:\n        dp1[i] = -abs(a[i] - a[i+1])\nfor i in range(n-1):\n    if i % 2 == 0:\n        dp2[i] = -abs(a[i] - a[i+1])\n    else:\n        dp2[i] = abs(a[i] - a[i+1])\n\nans = -1e18\ncurr_max = -1e18\n\nfor i in range(n):\n    curr_max = max(curr_max, dp1[i])\n    ans = max(ans, curr_max-dp2[i])\n\nprint(ans)"
 ],
 "3961": [
  "n = int(input())\np = list(map(int, input().split()))\n\ndp = [0] * (n+1)\ndp[1] = 2\n\nMOD = int(1e9) + 7\nfor i in range(2, n+1):\n    dp[i] = (2 * dp[i-1] - dp[p[i-2]-1] + 2) % MOD\n    \nprint(dp[n])"
 ],
 "3962": [
  "n = int(input())\nguests = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    guests.append((l, r))\n\nguests.sort(reverse=True)\nchairs = 0\nleft_space, right_space = 0, 0\n\nfor l, r in guests:\n    needed_space = max(l - right_space, 0) + max(r - left_space, 0)\n    chairs += needed_space\n    left_space += max(left_space - r, 0)\n    right_space += max(right_space - l, 0)\n\nchairs += max(left_space, right_space)\nprint(chairs)"
 ],
 "3963": [
  "MOD = 10**9 + 7\nN = int(input())\na = [0] + list(map(int, input().split()))\nb = [0] + list(map(int, input().split()))\nm_int = int(input())\ndp = [0] * (m_int + 1)\ndp[0] = 1\nfor i in range(1, N + 1):\n    for v in range(m_int, -1, -1):\n        ni = 0\n        value = v\n        while value > 0 and ni <= 20:\n            ni += 1\n            value //= a[i]\n        sum_dp = 0\n        for j in range(ni + 1):\n            new_value = v - j * (a[i]**j)\n            if new_value < 0:\n                break\n            sum_dp += dp[new_value] if new_value >= 0 else 0\n        dp[v] += sum_dp * b[i]\n        dp[v] %= MOD\nprint(dp[m_int])"
 ],
 "3964": [
  "n, m, b, mod = map(int, input().split())\na = list(map(int, input().split()))\ndp = [[0] * (b + 1) for _ in range(m + 1)]\ndp[0][0] = 1\nfor i in range(n):\n    for j in range(m, 0, -1):\n        for k in range(b + 1):\n            if k + a[i] <= b:\n                dp[j][k + a[i]] = (dp[j][k + a[i]] + dp[j - 1][k]) % mod\nans = 0\nfor i in range(b + 1):\n    ans = (ans + dp[m][i]) % mod\nprint(ans)"
 ],
 "3965": [
  "vowels = set(['a', 'e', 'i', 'o', 'u', 'y'])\nn = int(input())\npattern = list(map(int, input().split()))\n\nfor i in range(n):\n    line = input().strip().split()\n    syllables = 0\n    for word in line:\n        found_vowel = False\n        for char in word:\n            if char in vowels:\n                if not found_vowel:\n                    syllables += 1\n                    found_vowel = True\n            else:\n                found_vowel = False\n        if not found_vowel:\n            continue\n    if syllables != pattern[i]:\n        print('NO')\n        exit()\nprint('YES')"
 ],
 "3966": [
  "n=int(input())\na=sorted(map(int,input().split()))\ns=a[0]\nfor i in range(1,n):\n    s+=(i+1)*a[i]\nprint(s)"
 ],
 "3967": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort(reverse=True)\nans = a[0]\n\nfor d in range(1, n):\n    parts_to_cut = (a[d-1] - a[d]) * d\n    if parts_to_cut <= k:\n        k -= parts_to_cut\n        ans = a[d]\n    else:\n        ans += k // d\n        break\n\nprint(ans)"
 ],
 "3968": [
  "from heapq import heappop, heappush\n\nn, d = map(int, input().split())\nc, *infected = map(int, input().split())\ninfected_set = set(infected)\n\n# Build the timeline with events.\nevents = []\nfor i in range(1, n+1):\n    s, t = map(int, input().split())\n    events.append((s, i, 'enter'))\n    events.append((t, i, 'exit'))\nevents.sort()\n\n# A heap to store the people currently in the room.\nroom = []\n# A set to store infected people that are currently in the room.\ninfected_in_room = set(infected)\n\n# Simulate the virus spread.\nfor day in range(1, d+1):\n    # Get all the people that were infected on the previous day and are not currently infected.\n    newly_infected = []\n    for p in room:\n        if p not in infected_in_room and p not in infected_set:\n            newly_infected.append(p)\n    # Add all the people infected on the previous day to the infected set.\n    infected_set.update(newly_infected)\n    # Add all the infected people currently in the room to the infected in room set.\n    infected_in_room.update(p for p in room if p in infected_set)\n    # Remove people who left the room.\n    while room and events[0][0] == room[0][0]:\n        _, _, p_status = heappop(room)\n        if p_status == 'infected':\n            infected_in_room.remove(p)\n    # Add people who entered the room.\n    while events and events[0][0] == day:\n        _, p, action = events.pop(0)\n        if action == 'enter':\n            heappush(room, (day, p, 'infected' if p in infected_set else 'healthy'))\n\n# Report the people infected at the end of the simulation.\nprint(*sorted(infected_set))"
 ],
 "3969": [
  "import sys\n\nn, m = map(int, sys.stdin.readline().split())\n\n# Creating an array to store the position of each plant of a given species\npos = [[] for _ in range(m)]\nfor i in range(n):\n    s, x = map(float, sys.stdin.readline().split())\n    # subtracting 1 from species number to be able to use it as index in pos array\n    pos[int(s) - 1].append(x)\n\n# Initializing a 2D array to store the minimum number of replants needed for a certain number of blocks and species\n# min_replants[i][j] will store the minimum replants needed for j species divided into i blocks\nmin_replants = [[float('inf')] * m for _ in range(m + 1)]\nmin_replants[1] = [0] * m\n\n# Looping through all possible numbers of blocks, from 2 to m\nfor i in range(2, m + 1):\n    # Looping through all possible divisions of the species among the blocks\n    for j in range(1, m - i + 2):\n        # Finding the leftmost and rightmost plant of species j in the current block\n        leftmost = min(pos[j - 1])\n        rightmost = max(pos[j - 1][:i])\n        # Looping through all possible positions for the border between the current block and the next one\n        for k in range(1, i):\n            # Finding the position of the border\n            border_pos = leftmost + (rightmost - leftmost) * k / i\n            # Finding the number of replants needed to put all plants of species j in the correct block\n            replants = len(pos[j - 1][:k]) - sum(1 for x in pos[j - 1][:k] if x <= border_pos) + \\\n                       sum(1 for x in pos[j - 1][k:i] if x > border_pos)\n            # Updating the minimum number of replants needed for the current number of blocks and species\n            min_replants[i][j] = min(min_replants[i][j], replants + min_replants[k][j - 1])\n\n# The minimum number of replants needed will be the minimum value of min_replants[m][j] for all j\nprint(min(min_replants[m]))"
 ],
 "3970": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\na = sorted(a)\n\nans = 1\ncnt = [1] * n\nfor i in range(1, n):\n    for j in range(i):\n        if a[i] % (a[j] * k) == 0:\n            cnt[i] = max(cnt[i], cnt[j] + 1)\n            ans = max(ans, cnt[i])\n            break\n\nprint(ans)"
 ],
 "3971": [
  "n = int(input())\na = list(map(int, input().split()))\n \n# Creating a list to store the frequency of each number in the sequence\nfreq = [0] * (max(a) + 1)\nfor x in a:\n    freq[x] += 1\n \n# Applying dynamic programming to find the maximum points that can be earned\ndp = [0] * (max(a) + 1)\ndp[1] = freq[1]\nfor i in range(2, max(a) + 1):\n    dp[i] = max(dp[i-1], dp[i-2] + i*freq[i])\nprint(dp[max(a)])"
 ],
 "3972": [
  "Mod=10**9+7\nn=int(input())\ndp=[0]*(n+1)\ndp[0]=1\nfor i in range(1,n+1):\n    dp[i]=(dp[i-1]+dp[i-1]+dp[i-1])%Mod\n    if i>=2:\n        dp[i]+=dp[i-2]\nprint(dp[n]%Mod)"
 ],
 "3973": [
  "n, m = map(int, input().split())\na = list(map(int, input().split()))\n\ncnt = [0] * (m + 1)\nfor i in range(n-1):\n    if a[i] < a[i+1]:\n        cnt[a[i]] -= 1\n        cnt[a[i+1]] += 1\n    else:\n        cnt[a[i]] -= 1\n        cnt[1] += 1\n        cnt[a[i+1]] += 1\n\nans = n\ncur = 0\nfor k in range(1, m+1):\n    cur += cnt[k]\n    ans = min(ans, cur)\n\nprint(ans)"
 ],
 "3974": [
  "s = input()\ncount = 0\nans = 0\nfor c in s:\n    if c == \"+\":\n        count += 1\n    else:\n        count -= 1\n    if count < 0:\n        ans += 1\n        count += 1\nprint(ans + count//2)"
 ],
 "3975": [
  "from collections import defaultdict\n\ndef dfs(node, graph):\n    if node in graph:\n        operation = graph[node][0]\n        if operation == 'IN':\n            return graph[node][1]\n        elif operation == 'NOT':\n            return int(not dfs(graph[node][1], graph))\n        else:\n            input1 = dfs(graph[node][1], graph)\n            input2 = dfs(graph[node][2], graph)\n            if operation == 'AND':\n                return input1 & input2\n            elif operation == 'OR':\n                return input1 | input2\n            else:\n                return input1 ^ input2\n                \nn = int(input())\ngraph = defaultdict(list)\nfor i in range(1, n+1):\n    inputs = input().split()\n    if inputs[0] == 'IN':\n        graph[i].append(inputs[0])\n        graph[i].append(int(inputs[1]))\n    else:\n        graph[i].extend(inputs)\nprint(''.join(str(int(not dfs(i, graph)))) for i in range(1,n+1) if graph[i][0] == 'IN')"
 ],
 "3976": [
  "from collections import Counter\n\nn, m, p = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\ncount_b = Counter(b)\ncount_a = Counter(a[:m])\n\nq_vals = []\nfor i in range(n-m+1):\n    if i == 0:\n        if count_a == count_b:\n            q_vals.append(i+1)\n    else:\n        count_a[a[i-1]] -= 1\n        if count_a[a[i-1]] == 0:\n            del count_a[a[i-1]]\n        count_a[a[i+m-1]] += 1\n        if count_a == count_b:\n            q_vals.append(i+1)\n\nprint(len(q_vals))\nprint(*q_vals)"
 ],
 "3977": [
  "from collections import deque\n\nn, m, k = map(int, input().split())\ngovs = set(map(int, input().split()))\ng = {}\nfor i in range(1, n+1):\n    g[i] = set()\nfor i in range(m):\n    u, v = map(int, input().split())\n    g[u].add(v)\n    g[v].add(u)\n\nmax_edges = 0\nfor i in range(1, n+1):\n    if i not in govs:\n        curr_edges = 0\n        for node in g[i]:\n            if node not in govs:\n                curr_edges += 1\n        max_edges += curr_edges\n        for node in g[i]:\n            g[node].remove(i)\n        g[i] = set()\n\nwhile len(govs) > 1:\n    visited = set()\n    curr_gov = govs.pop()\n    q = deque([curr_gov])\n    while q:\n        node = q.popleft()\n        visited.add(node)\n        for neighbor in g[node]:\n            if neighbor not in visited:\n                q.append(neighbor)\n    govs.discard(curr_gov)\n    for gov in govs:\n        max_edges += len(g[curr_gov] & g[gov])\n    \nprint(max_edges)"
 ],
 "3978": [
  "n=int(input())\na=list(map(int,input().split()))\na.sort()\ncolors=[0]*n\nnum_colors=0\nfor i in range(n):\n    if colors[i]==0:\n        num_colors+=1\n        colors[i]=num_colors\n        for j in range(i+1,n):\n            if colors[j]==0 and a[j]%a[i]==0:\n                colors[j]=num_colors\nprint(num_colors)"
 ],
 "3979": [
  "import sys\n\nn, m = map(int, input().split())\n\n# create adjacency list\nadj_list = [[] for _ in range(2 * m + 1)]\nfor i in range(n):\n    w = input().split()[1:]\n    l = len(w)\n    for j in range(l - 1):\n        u, v = w[j], w[j + 1]\n        # case 1: u and v are not the same letter\n        if u != v:\n            # add edges to the graph\n            if u.endswith(\"'\") and not v.endswith(\"'\"):\n                adj_list[int(u[:-1]) + m].append(int(v))\n                adj_list[int(v) + m].append(int(u[:-1]))\n            elif v.endswith(\"'\") and not u.endswith(\"'\"):\n                adj_list[int(v[:-1])].append(int(u) + m)\n                adj_list[int(u) + m].append(int(v[:-1]))\n            elif u < v:\n                adj_list[int(u) + m].append(int(v))\n                adj_list[int(v) + m].append(int(u))\n            else:\n                adj_list[int(u)].append(int(v) + m)\n                adj_list[int(v)].append(int(u) + m)\n        # case 2: u and v are the same letter\n        else:\n            if u.endswith(\"'\"):\n                adj_list[int(u[:-1]) + m].append(int(u))\n                adj_list[int(v) + m].append(int(v[:-1]))\n            else:\n                adj_list[int(u) + m].append(int(u[:-1]))\n                adj_list[int(v) + m].append(int(v[:-1]) + m)\n\n# DFS function to find the strongly connected components (SCCs)\ndef dfs(v):\n    visited[v] = True\n    for u in adj_list[v]:\n        if not visited[u]:\n            dfs(u)\n    order.append(v)\n\n# reverse the edges in the graph\nreverse_adj_list = [[] for _ in range(2 * m + 1)]\nfor u in range(1, 2 * m + 1):\n    for v in adj_list[u]:\n        reverse_adj_list[v].append(u)\n\n# find the SCCs of the reversed graph in reverse topological order\nvisited = [False] * (2 * m + 1)\norder = []\nfor u in range(1, 2 * m + 1):\n    if not visited[u]:\n        dfs(u)\n\nsccs = [[] for _ in range(2 * m + 1)]\nleader = [0] * (2 * m + 1)\nfor u in order[::-1]:\n    if leader[u] == 0:\n        stack = [u]\n        while stack:\n            v = stack.pop()\n            sccs[u].append(v)\n            leader[v] = u\n            for w in reverse_adj_list[v]:\n                if leader[w] == 0:\n                    stack.append(w)\n\n# check if there is a letter that belongs to the same SCC as its complement\nfor i in range(1, m + 1):\n    if leader[i] == leader[i + m]:\n        print(\"No\")\n        sys.exit()\n\n# output the answer\nprint(\"Yes\")\nprint(len([i for i in range(1, m + 1) if leader[i] < leader[i + m]]))\nprint(*[i for i in range(1, m + 1) if leader[i] < leader[i + m]])"
 ],
 "3980": [
  "n = int(input())\np = list(range(n+1))\nfor i in range(n.bit_length()):\n    for j in range(2**i):\n        for k in range(2**i):\n            if j + k*2**i <= n:\n                p[j+k*2**i] |= 1<<i\nprint((n*(n+1))//2)\nprint(*p)"
 ],
 "3981": [
  "import sys\n\ndef get_hash(points):\n    n = len(points)\n    high = int(1e9+7)\n    module = int(1e9+9)\n    base = 31\n    hashed_points = [0] * n\n    p_pow = [1] * n\n    for i in range(n):\n        x, y = points[i]\n        hashed_points[i] = ((x+y) * base * base + x * base + y) % module\n        if i > 0:\n            p_pow[i] = (p_pow[i-1] * base) % module\n    hash_val = 0\n    for i in range(n):\n        hash_val = (hash_val + hashed_points[i] * p_pow[n-i-1]) % module\n    return hash_val\n\ndef check(points1, points2):\n    origin = (0, 0)\n    points = points1 + points2\n    n1 = len(points1)\n    n2 = len(points2)\n    count = 0\n    for i in range(n1+n2):\n        for j in range(i+1, n1+n2):\n            if points[i] == points[j]:\n                continue\n            mid_x = (points[i][0] + points[j][0]) / 2\n            mid_y = (points[i][1] + points[j][1]) / 2\n            d_x = mid_x - origin[0]\n            d_y = mid_y - origin[1]\n            k = 2\n            while k > 1e-8:\n                new_x = mid_x - k * d_y\n                new_y = mid_y + k * d_x\n                if (round(new_x, 8), round(new_y, 8)) not in points:\n                    break\n                new_x = mid_x + k * d_y\n                new_y = mid_y - k * d_x\n                if (round(new_x, 8), round(new_y, 8)) not in points:\n                    break\n                k /= 2\n            else:\n                count += 1\n    return count == n1 * n2\n\nn, m = map(int, input().split())\npoints1 = [tuple(map(int, input().split())) for _ in range(n)]\npoints2 = [tuple(map(int, input().split())) for _ in range(m)]\nif check(points1, points2) and check(points2, points1):\n    hash1 = get_hash(points1)\n    hash2 = get_hash(points2)\n    if hash1 == hash2:\n        print(\"YES\")\n        sys.exit()\nprint(\"NO\")"
 ],
 "3982": [
  "mod = 10**9 + 7\n\ndef countSeq(s, d):\n    if s in d:\n        return d[s]\n    n = len(s)\n    if n == 0:\n        return 1\n    if n == 1:\n        return 2\n    ans = countSeq(s[:-1], d)\n    c = s[-1]\n    if c == '0':\n        ans += countSeq(s[:-2], d)\n    else:\n        ans += countSeq(s[:-2], d) + countSeq(s[:-3], d)\n    ans %= mod\n    d[s] = ans\n    return ans\n\nd = {}\nfor i in range(26):\n    s = input().strip()\n    d[s] = chr(ord('A') + i)\n    \nn = int(input())\ns = ''\nans = []\nfor i in range(n):\n    s += input().strip()\n    cnt = 0\n    for j in range(len(s)):\n        for k in range(j + 1, len(s) + 1):\n            if s[j:k] in d:\n                cnt = (cnt + countSeq(s[:j], {})*pow(2, k - j - 1, mod)*countSeq(s[k:], {})) % mod\n    ans.append(cnt)\n    \nprint('\\n'.join(map(str, ans)))"
 ],
 "3983": [
  "t = int(input())\n\nfor _ in range(t):\n    n, m = map(int, input().split())\n    if m == 0:\n        print(\"Second\" if n % 2 == 0 else \"First\")\n    else:\n        graph = [set() for _ in range(n)]\n        for _ in range(m):\n            a, b = map(int, input().split())\n            graph[a-1].add(b-1)\n            graph[b-1].add(a-1)\n        visited = [False] * n\n        stack = [0]\n        visited[0] = True\n        while stack:\n            u = stack.pop()\n            for v in graph[u]:\n                if not visited[v]:\n                    visited[v] = True\n                    stack.append(v)\n        if visited[-1]:\n            num_components = sum(len(g) for g in graph) // 2  # Divide by 2 because of bidirectional edges\n            print(\"First\" if num_components % 2 == 0 else \"Second\")\n        else:\n            print(\"Second\")"
 ],
 "3984": [
  "s = input()\nn = len(s)\n\nleft_idx = [-1] * n\nright_idx = [-1] * n\nleft_idx[0] = right_idx[n-1] = 0\n\nfor i in range(1, n):\n    if s[i] < s[left_idx[i-1]]:\n        left_idx[i] = i\n    else:\n        left_idx[i] = left_idx[i-1]\n\nfor i in range(n-2, -1, -1):\n    if s[i] > s[right_idx[i+1]]:\n        right_idx[i] = i\n    else:\n        right_idx[i] = right_idx[i+1]\n\nfor i in range(n):\n    if i - left_idx[i] <= right_idx[i] - i:\n        print(\"Mike\")\n    else:\n        print(\"Ann\")"
 ],
 "3985": [
  "from collections import defaultdict\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\npairs = defaultdict(list)\n\nfor _ in range(m):\n    i, j = map(int, input().split())\n    pairs[i].append(j)\n    pairs[j].append(i)\n\nans = 0\nvis = [False] * (n + 1)\n\ndef dfs(u):\n    vis[u] = True\n    for v in pairs[u]:\n        if not vis[v]:\n            dfs(v)\n\nfor i in range(1, n + 1):\n    if not vis[i]:\n        dfs(i)\n        cnt = 0\n        for j in range(1, n + 1):\n            if vis[j] and a[j - 1] % 2 == 0:\n                cnt += 1\n        ans += cnt // 2\n\nprint(ans)"
 ],
 "3986": [
  "n, k = map(int, input().split())\nif k > n or (k == 1 and n > 1):\n    print(\"-1\")\nelse:\n    res = \"\"\n    for i in range(n-k+2):\n        if i % 2 == 0:\n            res += \"a\"\n        else:\n            res += \"b\"\n    for i in range(2, k+1):\n        res += chr(ord('a') + i)\n    print(res)"
 ],
 "3987": [
  "n = int(input())\na = list(map(int, input().split()))\n\ndp = [[0 for _ in range(n)] for _ in range(n)]\n\nfor i in range(n):\n    dp[i][i] = 1\n\nfor i in range(n):\n    for j in range(i+1, n):\n        dp[i][j] = dp[i][j-1] + (a[j] >= a[j-1]) * (i == j-1)\n        dp[j][i] = dp[j-1][i] + (a[j-1] <= a[j]) * (i == j-1)\n\nres = 1\nfor i in range(n):\n    for j in range(i, n):\n        res = max(res, dp[i][j] + (j-i+1-dp[i][j])-(a[i:j+1].count(1)))\n        res = max(res, dp[i][j] + (j-i+1-dp[i][j])-(a[i:j+1].count(2)))\nprint(res)"
 ],
 "3988": [
  ""
 ],
 "3989": [
  "from itertools import permutations\na = input()\nperms = list(permutations(a))\nfor x in perms:\n    y = int(''.join(x))\n    if y%7==0:\n        print(y)\n        break\nelse:\n    print(0)"
 ],
 "3990": [
  "import heapq\n\ndef dijkstra(graph, start):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    \n    heap = [(0, start)]\n    \n    while heap:\n        (current_dist, current_node) = heapq.heappop(heap)\n        \n        if current_dist > distances[current_node]:\n            continue\n        \n        for neighbor, weight in graph[current_node].items():\n            distance = current_dist + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(heap, (distance, neighbor))\n            \n    return distances\n\nn, m = map(int,input().split())\ngraph = {i: {} for i in range(1, n+1)}\n\nfor _ in range(m):\n    u, v = map(int, input().split())\n    graph[u][v] = 1\n    graph[v][u] = 1\n\ndist1 = dijkstra(graph, 1)\ndistn = dijkstra(graph, n)\n\nif dist1[n] == float('inf'):\n    print(-1)\nelse:\n    min_time = float('-inf')\n    for i in range(1,n+1):\n        for j in graph[i].keys():\n            if dist1[i]+1+distn[j] < dist1[n] and dist1[i] < distn[j]:\n                min_time = max(min_time, dist1[i]+1+distn[j])\n    print(dist1[n] if min_time == float('-inf') else min_time)"
 ],
 "3991": [
  "n=int(input())\na=list(map(int,input().split()))\nmod=10**9+7\nsum=0\nfor i in range(n):\n    left=i\n    right=n-i-1\n    sum+=a[i]*right\n    sum-=a[i]*left\n    sum%=mod\nsum=(sum+mod)%mod\nprint(sum)"
 ],
 "3992": [
  "n=int(input())\na=list(map(int,input().split()))\ngcd=0\nfor i in range(n):\n  gcd=__import__('math').gcd(gcd,a[i])\n  if gcd == 1:\n    break\nif gcd != 1:\n  print(0)\nelse:\n  mn=float('inf')\n  for i in range(n):\n    cnt,cur=0,0\n    while a[i]%gcd:\n      cnt+=1\n      a[i]+=1\n    for j in range(n):\n      cur+=abs(a[j]-(a[i]*j//n))\n    mn=min(mn,cur)\n  print(mn)"
 ],
 "3993": [
  "n, m, k = map(int, input().split())\np = list(map(int, input().split()))\n\npage = 1\nans = 0\ni = 0\n\nwhile i < m:\n    cnt = 0\n    while i < m and (p[i] - (page - 1) * k - cnt) > 0 and (p[i] - (page - 1) * k - cnt) <= k:\n        cnt += 1\n        i += 1\n    if cnt != 0:\n        ans += 1\n        page += 1\n    else:\n        nxt = ((p[i] - (page - 1) * k - 1) // k + 1) * k + (page - 1) * k\n        page += (nxt - (page - 1) * k) // k\nprint(ans)"
 ],
 "3994": [
  "n = int(input())\ninitial = list(map(int, input()))\nlamps = []\nfor i in range(n):\n    a, b = map(int, input().split())\n    lamps.append((a,b))\nmax_lights = 0\nfor i in range(1, 101):\n    count = 0\n    for j in range(n):\n        if (((i - lamps[j][1]) % lamps[j][0]) == 0 and initial[j] == 1) or ((i - lamps[j][1]) % lamps[j][0]) == 1 and initial[j] == 0:\n            count += 1\n    max_lights = max(max_lights, count)\nprint(max_lights)"
 ],
 "3995": [
  "n,k=map(int,input().split())\ns=\"0\"*(n-k)+\"\".join(str(i%2) for i in range(1,k))\nprint(s)"
 ],
 "3996": [
  "MOD = 10**9 + 7\n\ndef pow_mod(x, n):\n    if n == 0:\n        return 1\n    if n % 2 == 0:\n        return pow_mod(x*x%MOD, n//2)\n    else:\n        return x * pow_mod(x, n-1) % MOD\n\ndef inv_mod(x):\n    return pow_mod(x, MOD-2)\n\nk = int(input())\na = list(map(int, input().split()))\n\ncur_prob = 1\nfor ai in a:\n    cur_prob = cur_prob * 2 % MOD\n    cur_prob = cur_prob * inv_mod(ai) % MOD\n\np, q = 1, 1\nfor ai in a:\n    p = p * (ai-1) % MOD\n    q = q * ai % MOD\n    inv_q = inv_mod(q)\n    p = p * inv_q % MOD\n\np = (p * cur_prob // 2) % MOD\nq = inv_mod(3*q) % MOD\n\nans = (p * q) % MOD\nprint(\"{}/{}\".format(ans, q))"
 ],
 "3997": [
  "from collections import defaultdict\n\nn = int(input())\na = list(map(int, input().split()))\ngraph = defaultdict(list)\nfor i in range(n-1):\n    p, w = map(int, input().split())\n    graph[p].append((i+2, w))\n\nans = [0]*n\nsubtree_sum = [0]*n\n\ndef dfs(v, p):\n    global ans, subtree_sum, graph\n    ans[v-1] = 1\n    subtree_sum[v-1] = a[v-1]\n    for u, w in graph[v]:\n        if u == p:\n            continue\n        dfs(u, v)\n        ans[v-1] += ans[u-1]\n        subtree_sum[v-1] += subtree_sum[u-1] + w*ans[u-1]\n    for u, w in graph[v]:\n        if u == p:\n            continue\n        ans[v-1] += ans[u-1]*int(subtree_sum[v-1] - subtree_sum[u-1] - w*ans[u-1] <= a[v-1])\n\ndfs(1, -1)\nprint(*[ans[i]-1 for i in range(n)])"
 ],
 "3998": [
  "n = int(input())\nr = list(map(int, input().split()))\ntarget_rating = sum(r) // n\n\nlosses_required = [r[i] - target_rating for i in range(n)]\nmatch_results = []\nwhile sum(losses_required) > 0:\n    match = ['0']*n\n    for i in range(n):\n        if losses_required[i] > 0:\n            match[i] = '1'\n            losses_required[i] -= min(losses_required[i], 2)\n            if sum(match.count('1') for match in match_results) % 2 == 0:\n                break\n            if sum(match.count('1') for match in match_results) % 2 == 1:\n                if match.count('1') == 1 or match.count('1') == 3:\n                    break\n                else:\n                    match[i] = '0'\n                    losses_required[i] += min(losses_required[i] + 2)\n\n    match_results.append(''.join(match))\n    \nresulting_rating = target_rating - sum(losses_required) // n\nprint(resulting_rating)\nprint(len(match_results))\nfor match in match_results:\n    print(match)"
 ],
 "3999": [
  "from itertools import permutations\n\nN = int(input())\nC = []\n\nfor _ in range(N):\n    C.append(list(map(int, input().split())))\n\nperms = list(permutations(range(N), 6))\nans = 0\n\nfor perm in perms:\n    ok = True\n    for i in range(6):\n        for j in range(i+1, 6):\n            if perm[i]//4 == perm[j]//4:\n                if C[perm[i]//4][(perm[i]%4+0)%4] != C[perm[j]//4][(perm[j]%4+2)%4] or C[perm[i]//4][(perm[i]%4+1)%4] != C[perm[j]//4][(perm[j]%4+3)%4]:\n                    ok = False\n                    break\n            elif perm[i]//4 != perm[j]//4:\n                if C[perm[i]//4][(perm[i]%4+0)%4] == C[perm[i]//4][(perm[i]%4+1)%4] == C[perm[i]//4][(perm[i]%4+2)%4] or C[perm[j]//4][(perm[j]%4+0)%4] == C[perm[j]//4][(perm[j]%4+1)%4] == C[perm[j]//4][(perm[j]%4+2)%4]:\n                    ok = False\n                    break\n        if not ok:\n            break\n    if ok:\n        ans += 1\n\nprint(ans)"
 ]
}