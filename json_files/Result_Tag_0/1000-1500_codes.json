{
 "1000": [
  "n, v = map(int, input().split())\ncost = 0\nremaining = v\nfor i in range(1, n):\n    if remaining < n - i:\n        cost += remaining * i\n        remaining = 0\n    else:\n        cost += (n - i) * i\n        remaining -= n - i\nprint(cost)"
 ],
 "1001": [
  "import sys \n\nn = int(input())\na = list(map(int, input().split()))\n\nleft, right = [0] * n, [0] * n\nleft[1], right[n-2] = a[0], a[n-1]\n\nfor i in range(2, n):\n    left[i] = left[i-1] + a[i-1]\n    right[n-i-1] = right[n-1-i+1] + a[n-i]\n\ndp = [ [0] * (n+1) for _ in range(n+1) ]\n\nfor i in range(n):\n    dp[i][i] = a[i]\n\nfor l in range(2, n+1):\n    for i in range(n-l+1):\n        j = i + l - 1\n        s = right[i] - left[j]\n        dp[i][j] = s + max(a[i] - dp[i+1][j], a[j] - dp[i][j-1])\n\nprint(dp[0][n-1])"
 ],
 "1002": [
  "n, d = map(int, input().split())\nt = list(map(int, input().split()))\n\ndevu_time = sum(t) + 10 * (n - 1)\n\nif devu_time > d:\n    print(-1)\nelse:\n    jokes = (n - 1) * (d - devu_time) // 5\n    print(jokes)"
 ],
 "1003": [
  "n, m = map(int, input().split())\ndays = n\nwhile n >= m:\n    k = n//m\n    days += k\n    n = k + n % m\nprint(days)"
 ],
 "1004": [
  "n = int(input())\nevents = list(map(int, input().split()))\nenter_times = {}\nexit_times = {}\nfor i, event in enumerate(events):\n    if event > 0:  # enter event\n        if event in enter_times or event in exit_times:\n            print(-1)\n            exit()\n        enter_times[event] = i\n    else:  # exit event\n        event = abs(event)\n        if event not in enter_times or event in exit_times:\n            print(-1)\n            exit()\n        exit_times[event] = i\n\ndays = []\nwhile exit_times:\n    start_event = min(enter_times.keys() | exit_times.keys())\n    start_index = min(enter_times.get(start_event, n), exit_times[start_event])\n    if start_event in exit_times:\n        del exit_times[start_event]\n    day = [start_event]\n    while True:\n        i = day[-1]\n        if i in enter_times and i != start_event:\n            j = enter_times[i]\n            if any(events[k] == -i for k in range(start_index, j)):\n                print(-1)\n                exit()\n            start_index = j\n        if i in exit_times:\n            del exit_times[i]\n        if not exit_times:\n            break\n        i = abs(events[start_index:end + 1][-1])\n        if i in enter_times:\n            day.append(i)\n        else:\n            break\n\n    if day[-1] in enter_times:\n        day.pop()\n    days.append(day)\n\nprint(len(days))\nprint(*(len(day) for day in days))"
 ],
 "1005": [
  "t = int(input()) \nfor _ in range(t):\n    n,k,d = map(int, input().split())\n    a = list(map(int, input().split()))\n    sub_count = [0] * k\n    for i in range(d):\n        sub_count[a[i]-1] += 1\n    ans = cur_ans = sum([1 for i in sub_count if i > 0])\n    for j in range(d, n):\n        sub_count[a[j-d]-1] -= 1\n        sub_count[a[j]-1] += 1\n        cur_ans = sum([1 for i in sub_count if i > 0])\n        ans = min(ans, cur_ans)\n    print(ans)"
 ],
 "1006": [
  "def can_draw_crosses(n, board):\n    count = 0\n    for i in range(1, n-1):\n        for j in range(1, n-1):\n            if board[i][j] == '#' and board[i-1][j] == '#' and board[i+1][j] == '#' and board[i][j-1] == '#' and board[i][j+1] == '#':\n                count += 1\n                # mark adjacent cells as visited\n                board[i][j] = board[i-1][j] = board[i+1][j] = board[i][j-1] = board[i][j+1] = '.'\n    if any('#' in row for row in board):\n        return 'NO'\n    return 'YES'\n\nn = int(input())\nboard = []\nfor i in range(n):\n    row = input().strip()\n    board.append(row)\nprint(can_draw_crosses(n, board))"
 ],
 "1007": [
  "k, p = map(int, input().split())\ns = 0\nfor i in range(1, k+1):\n    num = str(i)+str(i)[::-1]\n    s += int(num)%p\nprint(s % p)"
 ],
 "1008": [
  "python\ns = input()\nk = int(input())\nif len(s)%k!=0:\n    print(\"NO\")\nelse:\n    n = len(s)//k\n    palindromes = [s[i*n:(i+1)*n] for i in range(k)]\n    for p in palindromes:\n        if p!=p[::-1]:\n            print(\"NO\")\n            break\n    else:\n        print(\"YES\")"
 ],
 "1009": [
  "# read input\nn, k = map(int, input().split())\ncowbells = list(map(int, input().split()))\n\n# binary search for the minimum possible value of s\nleft = 1\nright = cowbells[-1] * 2\nwhile left < right:\n    mid = (left + right) // 2\n    count = 0\n    i = 0\n    j = n - 1\n    while i <= j:\n        if cowbells[j] <= mid - cowbells[i]:\n            count += 1\n            i += 1\n            j -= 1\n        else:\n            count += 1\n            j -= 1\n    if count <= k:\n        right = mid\n    else:\n        left = mid + 1\n\n# output the result\nprint(left)"
 ],
 "1010": [
  "n = int(input())\npieces = input().split()\npieces = list(map(int, pieces))\nnum_nuts = sum(pieces)\nif num_nuts == 0:\n    print(0)\nelse:\n    break_count = 0\n    for i in range(n-1):\n        if pieces[i] == 1 and pieces[i+1] == 0:\n            break_count += 1\n    if num_nuts == 1:\n        print(break_count+1)\n    else:\n        print(break_count*(break_count+1)//2)"
 ],
 "1011": [
  "n = int(input())\na = sorted(list(map(int, input().split())))\nm = int(input())\nb = sorted(list(map(int, input().split())))\nmax_score = 0\nmax_a = 0\nfor i in range(n+1):\n    throws_worth2 = i\n    throws_worth3 = n - i\n    j = bisect_right(b, a[i-1])\n    throws_worth2 += j\n    throws_worth3 += m - j\n    score = 2*throws_worth2 + 3*throws_worth3\n    if score > max_score:\n        max_score = score\n        max_a = throws_worth2\nprint('{}:{}'.format(max_score, max_score - max_a))"
 ],
 "1012": [
  "for _ in range(int(input())):\n    s = input()\n    counts = [s.count(c) for c in set(s)]\n    odd_count = sum(count % 2 for count in counts)\n    if odd_count > 1:\n        print(\"-1\")\n    else:\n        ans = \"\"\n        for c, count in sorted(zip(set(s), counts), key=lambda x: x[1], reverse=True):\n            ans += c * (count // 2)\n        if odd_count == 1:\n            ans += [c for c in set(s) if s.count(c) % 2 == 1][0]\n        ans += ans[::-1]\n        print(ans)"
 ],
 "1013": [
  "n, m = map(int, input().split())\n\ngrid = [list(map(int, input().split())) for _ in range(n)]\n\ngood_cells = list((i, j) for i in range(n) for j in range(m) if grid[i][j])\n\ncorners = [(1, 1), (1, m), (n, 1), (n, m)]\n\nans = 0\n\nfor corner in corners:\n    closest_good_cell = min(good_cells, key=lambda x: abs(x[0]-corner[0])+abs(x[1]-corner[1]))\n    ans += abs(closest_good_cell[0]-corner[0]) + abs(closest_good_cell[1]-corner[1])\nprint(ans)"
 ],
 "1014": [
  "n = int(input())\nif n % 2 == 0:\n    print('white')\n    print('1 2')\nelse:\n    print('black')"
 ],
 "1015": [
  "n=int(input())\na=list(map(int,input().split()))\nres=[]\nfor k in range(n*(n-1)//2+1):\n    dp=[[0]*(n+1) for i in range(n+1)]\n    for L in range(1,n+1):\n        for l in range(n-L+2):\n            r=l+L-1\n            if L==1 and a[l]==1:\n                dp[l][r]=-10000\n            elif L==1:\n                dp[l][r]=0\n            else:\n                dp[l][r]=max(dp[l+1][r],dp[l][r-1])\n                if a[l]==0 and a[r]==0:\n                    if k>0:\n                        dp[l][r]=max(dp[l][r],dp[l+1][r-1]+1)\n                        dp[l][r]=max(dp[l][r],dp[l+1][r-1])\n                        dp[l][r]=max(dp[l][r],dp[l][r-1]+1)\n                        k-=1\n    res.append(dp[0][n])\nprint(*res)"
 ],
 "1016": [
  "n, m = map(int, input().split())\ngraph = [[] for _ in range(n)]\nfor _ in range(m):\n    u, v = map(int, input().split())\n    graph[u-1].append(v-1)\n    graph[v-1].append(u-1)\n\ndef dfs(u, visited):\n    visited[u] = True\n    danger = 1\n    for v in graph[u]:\n        if not visited[v]:\n            res, multiply = dfs(v, visited)\n            danger *= multiply\n            danger += res\n    return danger, 2 if danger > 1 else 1\n\nans = 0\nvisited = [False] * n\nfor i in range(n):\n    if not visited[i]:\n        res, multiply = dfs(i, visited)\n        ans += res\n        ans += (multiply - 1)\nprint(ans)"
 ],
 "1017": [
  "n = int(input())\nfibonacci = [1, 1]\ncount = 1\nwhile fibonacci[-1] <= n:\n    fibonacci.append(fibonacci[-1]+fibonacci[-2])\n    count += 1\nif fibonacci[-2] == n:\n    print(count-1)\nelse:\n    print(count)"
 ],
 "1018": [
  "n = int(input())\na = list(map(int, input().split()))\n\nl, r = 0, n-1\nwhile l < r:\n    mid = (l+r)//2\n\n    day = mid+2\n    total_ink = sum(a[:mid+1])\n    remaining_days = n - mid - 1\n    remaining_ink = total_ink - remaining_days\n\n    if remaining_ink >= day:\n        l = mid + 1\n    else:\n        r = mid\n\nprint(l+1)"
 ],
 "1019": [
  "def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\nn = int(input())\n\nfor b in range(n-1, 1, -1):\n    a = n - b\n    if gcd(a, b) == 1:\n        print(a, b)\n        break"
 ],
 "1020": [
  "w, h, k = map(int, input().split())\ntotal_cells = 2 * (w + h) - 4\nfor i in range(1, k + 1):\n    cells_per_ring = 2 * (w - 4 * (i - 1) + h - 4 * (i - 1)) - 4\n    total_cells += cells_per_ring\nprint(total_cells)"
 ],
 "1021": [
  "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nfor i in range(1,n-1):\n    da = a[i+1] + a[i-1] - a[i]\n    db = b[i+1] + b[i-1] - b[i]\n    if da != db:\n        break\nelse:\n    if a[0] == b[0] and a[-1] == b[-1]:\n        print(\"Yes\")\n        exit()\n\nprint(\"No\")"
 ],
 "1022": [
  "n = int(input())\nl = list(map(int, input().split()))\nr = list(map(int, input().split()))\n\na = [0] * n\nfor i in range(n):\n    a[i] = n - l[i] - r[i] - 1\n\nfor i in range(n):\n    for j in range(i):\n        if a[j] > a[i]:\n            l[i] -= 1\n        if l[i] < 0:\n            print(\"NO\")\n            exit()\n    for j in range(i+1, n):\n        if a[j] > a[i]:\n            r[i] -= 1\n        if r[i] < 0:\n            print(\"NO\")\n            exit()\n\nif sum(l) + sum(r) == sum(a) * 2:\n    print(\"YES\")\n    print(*a)\nelse:\n    print(\"NO\")"
 ],
 "1023": [
  "n, m, ta, tb, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nif k >= n or k >= m:\n    print(-1)\nelse:\n    ans = 0\n    for i in range(k+1):\n        left = bisect.bisect(b, a[i])\n        if left + (k-i) >= m:\n            print(-1)\n            exit()\n        ans = max(ans, b[left + k - i] + tb)\n    print(ans)"
 ],
 "1024": [
  "n = int(input())\na = list(map(int, input().split()))\n\ninv = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        if a[i] > a[j]:\n            inv += 1\n\nans = 0\nfor k in range(1, n + 1):\n    for l in range(n - k + 1):\n        r = l + k - 1\n        num_inv = inv\n        for i in range(l, r + 1):\n            for j in range(i + 1, r + 1):\n                if a[i] > a[j]:\n                    num_inv -= 1\n                elif a[i] < a[j]:\n                    num_inv += 1\n        ans += num_inv / (n * (n + 1) // 2) / math.factorial(k)\n\nprint(ans)"
 ],
 "1025": [
  "n = int(input())\npoints = [list(map(int, input().split())) for i in range(n)]\ncount = 0\nfor i in range(n):\n    for j in range(i+1, n):\n        for k in range(j+1, n):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            x3, y3 = points[k]\n            if (x2-x1)*(y3-y1) != (x3-x1)*(y2-y1):\n                count += 1\nprint(count)"
 ],
 "1026": [
  "n = int(input())\nb = list(map(int, input().split()))\ndp = b.copy()\nfor i in range(n):\n    for j in range(i):\n        if b[i] - b[j] == i - j:\n            dp[i] = max(dp[i], dp[j] + b[i])\nprint(max(dp))"
 ],
 "1027": [
  "stones = list(map(int, input().split()))\n\nmax_score = 0\n\nfor i in range(14):\n    if stones[i] == 0:\n        continue\n    new_stones = stones[:]\n    stones_to_redistribute = new_stones[i]\n    new_stones[i] = 0\n    for j in range(stones_to_redistribute):\n        new_stones[(i+j+1)%14] += 1\n    score = sum(new_stones[k] for k in range(14) if new_stones[k]%2 == 0)\n    max_score = max(max_score, score)\n    \nprint(max_score)"
 ],
 "1028": [
  "n, m = map(int, input().split())\nmax_pairs = (n - m + 1) * (n - m) // 2 + (m - 1) * (n // m) * (n // m + 1) // 2\nif n % m == 0:\n    min_pairs = (n // m) * (n // m - 1) // 2 * m\nelse:\n    # minimum number of pairs when each team has participants floor(n/m)\n    min_pairs = (n // m) * (n // m - 1) // 2 * (m - n % m) + (n // m + 1) * (n // m) // 2 * n % m\nprint(min_pairs, max_pairs)"
 ],
 "1029": [
  "p = input()\nn = len(p)\n\ncount = 0\nfor i in range(1,n):\n    for j in range(i,n):\n        if int(p[i-1:j]) % 3 == 0 or int(p[i-1:j]) % 7 == 0 or int(p[i-1:j]) % 13 == 0:\n            count += 1\n\nif n == 1:\n    print(1)\nelse:\n    print(count+1)"
 ],
 "1030": [
  "n, p, k = map(int, input().split())\n\nif p-k > 1:\n    print(\"<<\", end=\" \")\nfor i in range(max(1, p-k), p):\n    print(i, end=\" \")\nprint(f\"({p})\", end=\" \")\nfor i in range(p+1, min(n+1, p+k)):\n    print(i, end=\" \")\nif p+k < n:\n    print(\">>\", end=\" \")"
 ],
 "1031": [
  "n = int(input())\na = list(map(int, input().split()))\n\nx, y = 0, 0\nQ = [(0, 0)]\nfor i in range(n):\n    if i % 2 == 0:\n        y -= a[i]\n    else:\n        y += a[i]\n    x += a[i]\n    Q.append((x, y))\n\nmaxdiff = max(y for x, y in Q) - min(y for x, y in Q)\nans = []\nfor i in range(maxdiff, 0, -1):\n    row = [\" \"] * x\n    for j in range(1, n + 1):\n        x1, y1 = Q[j - 1]\n        x2, y2 = Q[j]\n        if y1 <= i <= y2 or y2 <= i <= y1:\n            k = (x - x1) - (x2 - x1) * (y1 - i) // (y2 - y1)\n            if row[k] == \" \":\n                if y1 < y2:\n                    row[k] = \"/\"\n                else:\n                    row[k] = \"\\\\\"\n            else:\n                if row[k] == \"/\" and y1 < y2:\n                    row[k] = \"X\"\n                elif row[k] == \"\\\\\" and y1 > y2:\n                    row[k] = \"X\"\n    ans.append(\"\".join(row))\n\nprint(\"\\n\".join(ans))"
 ],
 "1032": [
  "from math import factorial\n\nn, p = map(int, input().split())\na = list(map(int, input().split()))\n\na = [i % p for i in a]\nzero_count = a.count(0)\nnonzero_a = [ai for ai in a if ai != 0]\n\nif not nonzero_a:\n    if zero_count > 0:\n        print(factorial(n-1))\n        print(*range(1, n))\n    else:\n        print(0)\nelse:\n    f = [1] * (n+1)\n    for i in nonzero_a:\n        f[i+1:] = [fi * (i+1) % p for fi in f[i+1:]]\n\n    ans = 0\n    for k in range(p):\n        num_k = f.count(k)\n        ans += pow(p-1, zero_count) * (factorial(n-zero_count)//factorial(n-zero_count-num_k)//factorial(num_k))\n    print(ans)\n    for i in range(1, n+1):\n        if f[i] % p != 0:\n            print(i, end=' ')\n    print()"
 ],
 "1033": [
  "n, H = map(int, input().split())\n\ndef check(mid):\n    if mid > H:\n        return (mid+H)*(mid-H+1)//2 <= n\n    else:\n        b = mid + mid-H\n        return (mid+b)*(b-mid+1)//2 + mid <= n\n\nl, r = 1, n\nans = n\nwhile l <= r:\n    mid = (l+r)//2\n    if check(mid):\n        ans = mid\n        r = mid-1\n    else:\n        l = mid+1\n\nprint(ans)"
 ],
 "1034": [
  "from heapq import heappush, heappop\nX, Y, Z, K = map(int, input().split())\nA = sorted(map(int, input().split()), reverse=True)\nB = sorted(map(int, input().split()), reverse=True)\nC = sorted(map(int, input().split()), reverse=True)\nh = []\nfor i in range(X):\n    for j in range(Y):\n        for k in range(Z):\n            if (i+1)*(j+1)*(k+1) > K:\n                break\n            heappush(h, -(A[i]+B[j]+C[k]))\nans = []\nfor i in range(K):\n    ans.append(-heappop(h))\nfor a in ans:\n    print(a)"
 ],
 "1035": [
  "a, b = map(int, input().split())\n\nfrom math import gcd\n\nans = 1\nfor i in range(2, int(gcd(a,b)**0.5)+1):\n    if gcd(a,b) % i == 0:\n        ans += 1\n        while gcd(a,b) % i == 0:\n            gcd(a,b) //= i\n\nif gcd(a,b) > 1:\n    ans += 1\n\nprint(ans)"
 ],
 "1036": [
  "n, k = map(int, input().split())\ns = input()\nt = [\"\"]*n\nfor i in range(n):\n    if s[i] == \"R\":\n        t[i] = \"P\"\n    elif s[i] == \"P\":\n        t[i] = \"S\"\n    else:\n        t[i] = \"R\"\nwhile len(t) < 2**k:\n    x = len(t)\n    for i in range(x):\n        t.append(t[i])\n        t.append(s[i])\nans = \"\"\nx = t[0]\nfor i in range(1, 2**k):\n    y = t[i]\n    if x <= y:\n        ans = x\n    else:\n        ans = y\n    x = ans\nprint(ans)"
 ],
 "1037": [
  "n = int(input())\na = list(map(int, input().split()))\na.sort()\nans = 0\nfor i in range(n):\n    ans += a[i] * (2 * i - n + 1)\nprint(ans)"
 ],
 "1038": [
  "A, B = map(int, input().split())\ndef xor_range(A,B):\n    def xor_1_to_n(n):    # XOR from 1 to n\n        m = n % 4\n        if m == 0:\n            return n\n        elif m == 1:\n            return 1\n        elif m == 2:\n            return n + 1\n        else:\n            return 0\n    return xor_1_to_n(A-1) ^ xor_1_to_n(B)\nprint(xor_range(A, B))"
 ],
 "1039": [
  "from collections import deque\n\nn = int(input())\n# Build the graph\ngraph = [[] for i in range(n+1)]\nfor i in range(n-1):\n  a, b, c = map(int, input().split())\n  graph[a].append((b, c))\n  graph[b].append((a, c))\n\nq, k = map(int, input().split())\n\n# Find the shortest distance from vertex k to all other vertices\ndist = [float('inf') for i in range(n+1)]\ndist[k] = 0\nqueue = deque([k])\nwhile queue:\n  node = queue.popleft()\n  for neighbor, edge_weight in graph[node]:\n    if dist[neighbor] == float('inf'):\n      dist[neighbor] = dist[node] + edge_weight\n      queue.append(neighbor)\n\n# Answer the queries\nfor i in range(q):\n  x, y = map(int, input().split())\n  print(dist[x] + dist[y])"
 ],
 "1040": [
  "n = int(input())\ns = input()\nwhile 'fox' in s:\n    s = s.replace('fox', '')\nprint(len(s))"
 ],
 "1041": [
  "from math import gcd\nn = int(input())\nnums = [int(x) for x in input()]\ngcd_num = nums[0]\nfor i in range(n):\n    gcd_num = gcd(gcd_num, nums[i])\nif gcd_num > 1:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "1042": [
  "MOD = 10**9 + 7\n\ndef gcd(a,b):\n    if b == 0:\n        return a\n    return gcd(b, a%b)\n\nx,y = map(int, input().split())\n\nif y % x != 0:\n    print(0)\nelse:\n    cnt = 0\n    y //= x\n    for i in range(1, int(y**(0.5))+1):\n        if y % i == 0:\n            if gcd(i, y//i) == 1:\n                cnt += 2 if i != y // i else 1\n    f = [1]*(y+1)\n    for i in range(2, y+1):\n        f[i] = f[i-1]*i % MOD\n    invf = [0]*(y+1)\n    invf[y] = pow(f[y], MOD-2, MOD)\n    for i in range(y-1, 0, -1):\n        invf[i] = invf[i+1]*(i+1) % MOD\n    ans = 1\n    for i in range(cnt):\n        ans = ans*f[y] % MOD\n    for i in range(cnt//2):\n        ans = ans*invf[2] % MOD\n    print(ans)"
 ],
 "1043": [
  "n=int(input())\na=[int(x) for x in input().split()]\nb=bribe=[]\nfor i in range(n):\n    if a[i]==-1:\n        b.append(i)\n    else:\n        bribe.append(a[i])\nb,ans=min(b),0\nwhile len(bribe)>1:\n    bribe=[max(bribe[i],bribe[i+1]) for i in range(0,len(bribe),2)]\n    ans+=sum(bribe)\n    if b<len(bribe):\n        bribe[b]=0\n    b//=2\nprint(ans)"
 ],
 "1044": [
  "n = int(input())\ncycles = []\nfor i in input().split():\n    cycle_size = int(i)\n    if cycle_size % 2 == 0:\n        cycles.append(2)\n    else:\n        cycles.append(1)\n\nfor i in cycles:\n    if i == 1:\n        print(\"2\")\n    else:\n        print(\"1\")"
 ],
 "1045": [
  "n = int(input())\nheight = 0\nwhile n >= height*(height+1)//2:\n    height += 1\nprint(height-1)"
 ],
 "1046": [
  "n = int(input())\ncalls = list(map(int, input().split()))\n\nunique_calls = list(set(filter(lambda x: x != 0, calls)))\n\nif len(unique_calls) == 0:\n    print(0)\nelse:\n    pairs = 0\n    for call in unique_calls:\n        if calls.count(call) > 1:\n            pairs += calls.count(call) * (calls.count(call) - 1) // 2\n\n    if pairs == 0:\n        print(-1)\n    else:\n        print(pairs)"
 ],
 "1047": [
  "n = int(input())\ndigits = set(str(n))\nmax_digit = max(digits)\nans = [\"\"] * (int(max_digit) + 1)\n\nwhile n > 0:\n    n_str = str(n)\n    max_digit = max(n_str)\n    for i in range(int(max_digit)+1):\n        if i in digits:\n            ans[i] += \"1\"\n            n -= int(\"1\" + \"0\"*len(n_str[1:]))\n    digits = set(str(n))\n\nprint(len(ans))\nprint(\" \".join(ans))"
 ],
 "1048": [
  "n = int(input())\ncommands = input()\n\nx, y = 0, 0\ncount = 0\n\nfor c in commands:\n    if c == 'U':\n        y += 1\n    elif c == 'D':\n        y -= 1\n    elif c == 'L':\n        x -= 1\n    elif c == 'R':\n        x += 1\n    \n    if x == 0 and y == 0:\n        count += 1\n        x, y = 0, 0\n\nprint(count)"
 ],
 "1049": [
  "n, d = map(int, input().split())\nconsec_wins = 0\ncurr_consec = 0\n\nfor i in range(d):\n    opponents_present = input()\n    if '0' in opponents_present:\n        curr_consec = 0\n    else:\n        curr_consec += 1\n        consec_wins = max(consec_wins, curr_consec)\n        \nprint(consec_wins)"
 ],
 "1050": [
  "n, m, k = map(int, input().split())\nif m >= n and k >= n:\n    print(\"Yes\")\nelse:\n    print(\"No\")"
 ],
 "1051": [
  "k = int(input())\nranks = list(map(int, input().split()))\nranks.sort()\ncount = 0\nfor i in range(1, 26-k):\n    if i not in ranks:\n        count += 1\nprint(count)"
 ],
 "1052": [
  "n, k = map(int, input().split())\n\ndp = [[0 for _ in range(n+1)] for _ in range(n+1)]\ndp[0][0] = 1\n\nfor i in range(1, n+1):\n    dp[i][0] = 1\n    for j in range(1, i+1):\n        dp[i][j] = dp[i-1][j] + (j * dp[i-1][j-1])\n\nans = 0\nfor i in range(k+1):\n    ans += dp[n][i]\nprint(ans)"
 ],
 "1053": [
  "n = int(input())\nans = 0\nfor i in range(1, n):\n    ans += i ^ (i-1)\nprint(ans)"
 ],
 "1054": [
  "n = int(input())\nmin_x = float(\"inf\")\nmax_x = float(\"-inf\")\nmin_y = float(\"inf\")\nmax_y = float(\"-inf\")\n\nfor i in range(n):\n    x, y = map(int, input().split())\n    min_x = min(min_x, x)\n    max_x = max(max_x, x)\n    min_y = min(min_y, y)\n    max_y = max(max_y, y)\n\nlength = max(max_x - min_x, max_y - min_y)\nprint(length ** 2)"
 ],
 "1055": [
  "n=int(input())\na=list(map(int,input().split()))\ndef ThanosSort(a):\n    if sorted(a)==a: \n        return len(a)\n    else:\n        return(max(ThanosSort(a[:len(a)//2]),ThanosSort(a[len(a)//2:])))\nprint(ThanosSort(a))"
 ],
 "1056": [
  "from collections import deque\nfrom heapq import heappop, heappush\n\n# Function to find the shortest path in the given graph\ndef shortest_path(graph, start, end):\n    # Create a dictionary to store the distance of each node from the start node\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    \n    # Create a dictionary to store the previous node in the shortest path\n    previous = {node: None for node in graph}\n    \n    # Create a priority queue to store the nodes to be visited in order of distance from start\n    queue = [(distances[start], start)]\n    \n    while queue:\n        current_distance, current_node = heappop(queue)\n        \n        # If we have reached the end node, we are done - return the shortest path\n        if current_node == end:\n            path = []\n            while current_node is not None:\n                path.append(current_node)\n                current_node = previous[current_node]\n            path.reverse()\n            return path\n        \n        # Visit each neighbour of the current node\n        for neighbour in graph[current_node]:\n            distance = current_distance + 1 # Assuming all edges have unit weight\n            if distance < distances[neighbour]:\n                distances[neighbour] = distance\n                previous[neighbour] = current_node\n                heappush(queue, (distance, neighbour))\n    \n    # If we reach here, it means there is no path from start to end\n    return None\n\n# Function to calculate the minimum expected number of turns to reach the goal\ndef min_turns(h):\n    graph = {}\n    for i in range(10):\n        for j in range(10):\n            node = i * 10 + j\n            graph[node] = []\n            for k in range(1, 7):\n                if i % 2 == 0:\n                    # Even rows - right to left\n                    if j - k >= 0:\n                        graph[node].append(node - k)\n                    else:\n                        graph[node].append((i - 1) * 10)\n                else:\n                    # Odd rows - left to right\n                    if j + k < 10:\n                        graph[node].append(node + k)\n                    else:\n                        graph[node].append((i - 1) * 10 + 9)\n            if h[i][j] > 0:\n                # Connect the node to the ladder top\n                ladder_top = (i - h[i][j]) * 10 + j\n                graph[node].append(ladder_top)\n    \n    # Find the shortest path to the goal\n    path = shortest_path(graph, 0, 90)\n    \n    # Create a dictionary to store the expected number of turns to reach each node\n    expected_turns = {node: float('inf') for node in graph}\n    expected_turns[0] = 0\n    \n    queue = deque([0])\n    while queue:\n        current_node = queue.popleft()\n        for neighbour in graph[current_node]:\n            if neighbour == current_node:\n                continue\n            if neighbour in path:\n                # If the neighbour is on the path to the goal, the expected\n                # number of turns is the minimum of rolling the dice and \n                # climbing the ladder\n                expected_turns[neighbour] = expected_turns[current_node] + min(1, expected_turns[current_node] + 1)\n            else:\n                # If the neighbour is not on the path, we have to keep rolling\n                expected_turns[neighbour] = expected_turns[current_node] + 1\n            \n            # If we have not visited the neighbour before, add it to the queue\n            if neighbour not in queue:\n                queue.append(neighbour)\n    \n    return expected_turns[90]\n\n# Read the input\nh = []\nfor i in range(10):\n    h.append(list(map(int, input().split())))\n\n# Calculate the minimum expected number of turns\nresult = min_turns(h)\n\n# Print the result with 10 decimal places of precision\nprint('{:.10f}'.format(result))"
 ],
 "1057": [
  "n=int(input())\ns=input()\nd,j=1,0\nmod=998244353\nfor i in range(1,n):\n    if s[i]==s[j]:\n        d=d+1\n    else:\n        j=i\nans=pow(2,d,mod)-2\nif ans<0:\n    ans+=mod\nprint(ans)"
 ],
 "1058": [
  "n = int(input())\nblocks = [] \n\nfor i in range(n):\n    color1, value, color2 = map(int, input().split())\n    blocks.append((color1, value, color2))\n    \ndp = [[0] * n for _ in range(n)]\n\nfor i in range(n):\n    for j in range(n):\n        if blocks[i][2] == blocks[j][0] or blocks[i][2] == blocks[j][2]:\n            dp[i][j] = blocks[j][1]\n            \nans = 0\n\nfor mask in range(1, 1<<n):\n    valid = True \n    cur_value = 0 \n    for i in range(n):\n        if (1<<i) & mask:\n            for j in range(n):\n                if (1<<j) & mask:\n                    cur_value += dp[i][j]\n            for j in range(n):\n                if not ((1<<j) & mask):\n                    if dp[i][j]:\n                        valid = False \n                        break \n            if not valid:\n                break \n    if valid:\n        ans = max(ans, cur_value)\n        \nprint(ans)"
 ],
 "1059": [
  "k = int(input())\nif k < 25:\n    print(\"-1\")\nelse:\n    n, m = 5, k//5\n    while n*m != k:\n        n += 1\n        m = k//n\n        if m < 5:\n            print(\"-1\")\n            break\n    else:\n        vowel = ['a', 'e', 'i', 'o', 'u']\n        word = [['x']*m for i in range(n)]\n        for i in range(n):\n            for j in range(m):\n                word[i][j] = vowel[(i+j)%5]\n        for j in range(m):\n            if (j % 5) == 0:\n                word[0][j], word[1][j] = word[1][j], word[0][j]\n            if (j % 5) == 1 or (j % 5) == 2:\n                word[2][j], word[1][j] = word[1][j], word[2][j]\n            if (j % 5) == 4:\n                word[3][j], word[1][j] = word[1][j], word[3][j]\n            if (j // ((k-1)//5)) > 0:\n                word[4][j], word[3][j] = word[3][j], word[4][j]\n        for i in range(n):\n            print(\"\".join(word[i]), end=\"\")"
 ],
 "1060": [
  "n = int(input())\na = list(map(int, input().split()))\n\ndp = [0] * (10**6 + 1)\nfor i in range(n):\n    dp[a[i]] = 1\n    for j in range(2*a[i], 10**6+1, a[i]):\n        dp[j] = max(dp[j], dp[a[i]] + dp[j//a[i]])\nprint(max(dp))"
 ],
 "1061": [
  "matrix = []\nfor i in range(5):\n    matrix.append(list(map(int, input().split())))\n\nrow_index, col_index = None, None\nfor i in range(5):\n    if 1 in matrix[i]:\n        row_index, col_index = i, matrix[i].index(1)\n        break\n\nmoves = abs(row_index - 2) + abs(col_index - 2)\nprint(moves)"
 ],
 "1062": [
  "n = int(input())\nS = input()\nT = input()\ndiff = []\nfor i in range(n):\n    if S[i] != T[i]:\n        diff.append(i)\nif len(diff) == 0:\n    print(0, \"-1 -1\")\nelif len(diff) == 2 and S[diff[0]] == T[diff[1]] and S[diff[1]] == T[diff[0]]:\n    print(2, diff[0]+1, diff[1]+1)\nelse:\n    found = False\n    for i in range(n):\n        for j in range(i+1, n):\n            S_list = list(S)\n            S_list[i], S_list[j] = S_list[j], S_list[i]\n            new_S = \"\".join(S_list)\n            new_diff = 0\n            for k in range(n):\n                if new_S[k] != T[k]:\n                    new_diff += 1\n            if new_diff == 0:\n                print(0, \"-1 -1\")\n                found = True\n                break\n            elif new_diff == 1:\n                print(1, i+1, j+1)\n                found = True\n                break\n        if found:\n            break\n    if not found:\n        print(2, diff[0]+1, diff[1]+1)"
 ],
 "1063": [
  "from collections import defaultdict\n\ndef solve(n, seq):\n    res = [0] * n\n    for i in range(n):\n        if seq[i].count('?') > 1:\n            return \"NO\"\n        if '?' in seq[i]:\n            for j in range(10):\n                num = str(j)\n                if num not in seq[i]:\n                    break\n            seq[i] = seq[i].replace('?', num)\n        res[i] = int(seq[i])\n    for i in range(1, n):\n        if res[i] <= res[i-1]:\n            return \"NO\"\n    return \"YES\\n\" + '\\n'.join(str(x) for x in res)\n\nn = int(input())\nseq = [input() for _ in range(n)]\nprint(solve(n, seq))"
 ],
 "1064": [
  "n, m, k = map(int, input().split())\nblocked = set(map(int, input().split()))\ncost = list(map(int, input().split()))\n\nmin_cost = float('inf')\nfor l in range(1, k+1):\n    # check if we can illuminate the entire segment using lamps of power l\n    if l >= n or any(i not in blocked for i in range(n-l+1)):\n        curr_cost = cost[l-1]\n        for j in range(2*l, k+1, l):\n            curr_cost += cost[j-1]\n        min_cost = min(min_cost, curr_cost)\n\nif min_cost == float('inf'):\n    print(-1)\nelse:\n    print(min_cost)"
 ],
 "1065": [
  "n, k, m, d = map(int, input().split())\n\nmax_candies = 0\n\nfor i in range(1, m+1):\n    if i > n:\n        break\n    cycles = (n - i) // i // k\n    if cycles >= d:\n        candies = (i + i*cycles*d)*(cycles+1)*k//2\n        if candies > max_candies:\n            max_candies = candies\n\nprint(max_candies)"
 ],
 "1066": [
  "n, k = input().split()\nn = int(n)\nk = int(k)\n\nif k <= (n+1)//2:\n    print((2*k)-1)\nelse:\n    print(2*(k-((n+1)//2)))"
 ],
 "1067": [
  "n = int(input())\na = list(map(int, input().split()))\n\nnegatives = sum(1 for x in a if x < 0)\npos = 0\nneg = 0\nzeros = 0\nans = 0\n\nfor num in a:\n    if num > 0:\n        pos += 1\n        ans += num - 1\n    elif num < 0:\n        neg += 1\n        ans += abs(num) - 1\n    else:\n        zeros += 1\n\n# Case 1: All numbers are positive\nif neg == 0:\n    if zeros > 0:\n        print(ans + zeros)\n    else:\n        print(ans)\n\n# Case 2: All numbers are negative\nelif pos == 0:\n    if zeros > 0:\n        if negatives % 2 == 0:\n            print(ans + zeros)\n        else:\n            print(ans + 2)\n    else:\n        if negatives % 2 == 0:\n            print(ans)\n        else:\n            print(ans + 2)\n\n# Case 3: Both positive and negative numbers are present\nelse:\n    if zeros > 0:\n        print(ans + zeros)\n    else:\n        print(ans + 2 * min(pos, neg))"
 ],
 "1068": [
  "s = input().strip()\nfor i in range(1, len(s)):\n    for j in range(i+1, len(s)):\n        a, b, c = int(s[:i]), int(s[i:j]), int(s[j:])\n        if str(a)+str(b) == str(c):\n            print(str(a)+\"+\"+str(b)+\"=\"+str(c))\n            exit()"
 ],
 "1069": [
  "n = int(input())\nprint((1 + 2 ** (n % 4) + 3 ** (n % 4) + 4 ** (n % 2)) % 5)"
 ],
 "1070": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\nmax_len = 1\ncurr_len = 1\nfor i in range(1,n):\n    if a[i] != a[i-1]:\n        curr_len += 1\n    else:\n        max_len = max(max_len, curr_len)\n        curr_len = 1\nmax_len = max(max_len, curr_len)\n\nprint(max_len)"
 ],
 "1071": [
  "a1,a2,a3=map(int,input().split())\nb1,b2,b3=map(int,input().split())\nn=int(input())\nif (a1+a2+a3)//5+((a1%5+a2%5+a3%5+9)//10)+(b1+b2+b3)//10+((b1%10+b2%10+b3%10+9)//10)<=n:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "1072": [
  "n,m=map(int,input().split())\ntable=[input() for i in range(n)]\ncount=0\nfor j in range(m):\n    good=True\n    for i in range(1,n):\n        if table[i][j]<table[i-1][j]:\n            good=False\n            break\n    if not good:\n        count+=1\nprint(count)"
 ],
 "1073": [
  "n = int(input())\ncode = input()\n\ncount = 0\n\nfor i in range(n):\n    for j in range(i+1, n+1):\n        x = code[i:j]\n        # check if x returns to starting square\n        if x.count('U') == x.count('D') and x.count('L') == x.count('R'):\n            count += 1\n            \nprint(count)"
 ],
 "1074": [
  "print(int(\"1\"))"
 ],
 "1075": [
  "n = int(input())\n\nif n % 2 == 1:\n    print(-1)\n    \nelse:\n    ans = list(range(n))\n    for i in range(0, n - 1, 2):\n        ans[i], ans[i + 1] = ans[i + 1], ans[i]\n        ans[(2 * i) % (n - 1) + 1], ans[i + 1] = ans[i + 1], ans[(2 * i) % (n - 1) + 1]\n        \n    print(*ans, 0)"
 ],
 "1076": [
  "MOD = 998244353\n\nn, m = map(int, input().split())\n\nq = [1]  # q[i] = (m/n)^i % mod\nfor i in range(1, n + m + 1):\n    q.append(q[-1] * (m * pow(n, MOD - 2, MOD)) % MOD)\n\nfac = [1]  # fac[i] = i! % mod\nfor i in range(1, n + m + 1):\n    fac.append(fac[-1] * i % MOD)\n\nifac = [1]  # ifac[i] = i!^(-1) % mod\nfor i in range(1, n + m + 1):\n    ifac.append(ifac[-1] * pow(i, MOD - 2, MOD) % MOD)\n\nans = 0\nfor i in range(1, n + 1):\n    add = fac[n + m - i] * ifac[n - i] % MOD * q[i] % MOD * (n - i) % MOD\n    if (n - i) & 1:\n        ans = (ans - add) % MOD\n    else:\n        ans = (ans + add) % MOD\n\nprint(ans * ifac[n] % MOD)"
 ],
 "1077": [
  "n, m = map(int, input().split())\na = list(map(int, input().split()))\n\ncounters = [0] * m\n\nfor i in a:\n    if i <= m:\n        counters[i-1] += 1\n\nchanges = 0\nmax_songs = 0\n\nfor i in range(m):\n    temp_counters = counters.copy()\n    temp_songs = temp_counters[i]\n\n    for j in range(n):\n        if a[j] > m or temp_songs >= max_songs:\n            break\n\n        if temp_counters[a[j]-1] > temp_songs:\n            temp_songs += 1\n            temp_counters[a[j]-1] -= 1\n\n    if temp_songs > max_songs:\n        max_songs = temp_songs\n        changes = sum(temp_counters)\n        for j in range(n):\n            if temp_counters[a[j]-1] > temp_songs:\n                a[j] = i+1\n                temp_counters[a[j]-1] -= 1\n\nprint(max_songs, changes)\nprint(*a)"
 ],
 "1078": [
  "n = int(input())\na = [int(input()) for i in range(n)]\nb = [None] * n\n\nfor i in range(n):\n    if a[i] % 2 == 0:\n        b[i] = a[i] // 2\n    elif sum(1 for j in range(n) if a[j] % 2 == 1) == 1:\n        b[i] = a[i] // 2\n    else:\n        b[i] = a[i] // 2 + ((a[i] > 0) - (a[i] < 0))\n\nprint(*b)"
 ],
 "1079": [
  "s = input().strip()\nn = int(s, 2)\nif n == 0:\n    print(0)\nelse:\n    bits = len(s)\n    dp = [float('inf')] * (bits + 1)\n    dp[0] = 0\n    for i in range(1, bits + 1):\n        cur_sum = 0\n        cur_pow = 1\n        j = i\n        while j > 0 and i - j < 64:\n            cur_sum += int(s[j - 1]) * cur_pow\n            cur_pow *= 2\n            if cur_sum != 0 and abs(n % cur_sum) == 0:\n                dp[i] = min(dp[i], dp[j - 1] + 1)\n            j -= 1\n    print(dp[bits])"
 ],
 "1080": [
  "n=int(input())\na=list(map(int,input().split()))\ns=sum(a)\nm=max(a)\nif s%2==m%2 and s>=2*m:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "1081": [
  "a = int(input())\nif a in [2, 3, 4, 5, 12, 30, 31, 35, 43, 46, 52, 64, 86]:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "1082": [
  "n=int(input())\na=list(map(int,input().split()))\n\nMOD=10**9+7\nN=72\ndp=[[0]*N for i in range(1<<20)] \np=[-1]*N\n\nfor i in range(n):\n    x=a[i]\n    pi=-1\n    while x>1:\n        if pi==-1 or p[pi]!=x%pi:\n            pi+=1\n            p[pi]=x%pi\n        x//=pi\n    st=0\n    mask=0\n    for j in range(pi,-1,-1):\n        if p[j]==-1:\n            continue\n        cnt=p[j]\n        while cnt:\n            if cnt&1:\n                mask^=1<<st\n            st+=1\n            cnt>>=1\n    dp[mask][0]+=1\nfor i in range(20):\n    for mask in range(1<<20):\n        if not mask&(1<<i):\n            dp[mask][i+1]+=dp[mask][i]\n        else:\n            dp[mask^(1<<i)][i+1]+=dp[mask][i]\n            dp[mask][i+1]+=dp[mask][i]\nans=0\nfor i in range(1,N):\n    if i*(i-1)//2%2:\n        for j in range(1<<20):\n            dp[j][i]-=dp[j][i-1]\n    else:\n        for j in range(1<<20):\n            dp[j][i]+=dp[j][i-1]\n    for j in range(1<<20):\n        if dp[j][i]:\n            ans+=pow(2,N-i-1,MOD)*dp[j][i]\n            ans%=MOD\nprint(ans)"
 ],
 "1083": [
  "n = int(input())\nsum_n = (n*(n+1))//2\n\nif sum_n % 2:\n    print(1)\n    print(n//2, *list(range(1, n//2+1)))\nelse:\n    print(0)\n    s1 = []\n    s2 = []\n    for i in range(n, 0, -1):\n        if sum(s1) > sum(s2):\n            s2.append(i)\n        else:\n            s1.append(i)\n    print(len(s1), *s1)"
 ],
 "1084": [
  "n, m = map(int, input().strip().split())\ngrid = [list(input().strip()) for _ in range(n)]\n\nrow_ops = [set() for _ in range(n)]\ncol_ops = [set() for _ in range(m)]\n\n# check each cell in the grid\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == \"#\":\n            row_ops[i].add(j)\n            col_ops[j].add(i)\n\n# check if the constraints are satisfied\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == \"#\" and len(row_ops[i].intersection(col_ops[j])) == 0:\n            continue\n        else:\n            print(\"No\")\n            exit()\n\nprint(\"Yes\")"
 ],
 "1085": [
  "n = int(input())\ncount = 0\nfor k in range(2,n+1):\n    x = n\n    while x>=k:\n        if x%k == 0:\n            x //= k\n        else:\n            x -= k\n    if x == 1:\n        count += 1\nprint(count)"
 ],
 "1086": [
  "import numpy as np\n\nh, w = map(int, input().split())\na = np.array([input().split() for _ in range(h)], dtype=int)\nb = np.array([input().split() for _ in range(h)], dtype=int)\n\ndp = np.zeros((h, w, 16010), dtype=bool)\ndp[0][0][abs(a[0][0] - b[0][0])] = True\n\nfor i in range(h):\n    for j in range(w):\n        for k in range(16000):\n            if i > 0:\n                dp[i][j][k] |= dp[i-1][j][k-abs(a[i][j]-b[i][j])]\n            if j > 0:\n                dp[i][j][k] |= dp[i][j-1][k-abs(a[i][j]-b[i][j])]\n\nfor k in range(16000):\n    if dp[h-1][w-1][k]:\n        print(k)\n        break"
 ],
 "1087": [
  "n,k=map(int,input().split())\na=list(map(int,input().split()))\nans=0\nfor i in range(41,-1,-1):\n    cnt=0\n    for j in range(n):\n        if a[j]&(1<<i):\n            cnt+=1\n    if k&(1<<i):\n        if n-cnt>=cnt:\n            ans+=k^(1<<i)\n        else:\n            ans+=1<<i\n    else:\n        ans+=cnt<<i\nprint(ans)"
 ],
 "1088": [
  "from itertools import permutations\nMOD = 998244353\n\nn, k = map(int, input().split())\ngrid = [list(map(int, input().split())) for _ in range(n)]\n\ndef count_score_order():\n    score_order = [0] * (n * n + 1)\n    for i in range(n):\n        for j in range(n):\n            score_order[grid[i][j]] = i * n + j + 1\n    return score_order\n\nscore_order = count_score_order()\n\ndef check_swap_columns(x, y):\n    for i in range(n):\n        if grid[i][x] + grid[i][y] > k:\n            return False\n    return True\n\ndef check_swap_rows(x, y):\n    for i in range(n):\n        if grid[x][i] + grid[y][i] > k:\n            return False\n    return True\n\ninv3 = pow(3, -1, MOD)\ndef calc_pow3(x):\n    res = 1\n    while x > 0:\n        if x & 1:\n            res = res * 3 % MOD\n        x >>= 1\n    return res\n\ndef count_patterns_horizontal():\n    patterns = [[False] * n for _ in range(n)]\n    res = 1\n    for num, pos in enumerate(score_order[1:], start=1):\n        i, j = (pos - 1) // n, (pos - 1) % n\n        col_swaps = [ptn[j] for ptn in patterns]\n        row_swaps = [ptn[i] for ptn in patterns[i+1:]]\n        res *= col_swaps.count(True) + row_swaps.count(True) + 1\n        res %= MOD\n        # update patterns\n        for k in range(i):\n            if check_swap_columns(j, k):\n                patterns[i][k] = not patterns[i][k]\n        for k in range(i+1, n):\n            if check_swap_rows(i, k):\n                patterns[k][j] = not patterns[k][j]\n    return res\n\ndef count_patterns_vertical():\n    res = 1\n    for num, pos in enumerate(score_order[1:], start=1):\n        i, j = (pos - 1) // n, (pos - 1) % n\n        swaps = [grid[i][x] + grid[j][y] for x, y in permutations(range(n), r=2) if x < y]\n        num_swaps = sum(s <= k for s in swaps)\n        res *= (num_swaps + 1) * inv3 % MOD  # choose swaps\n        res %= MOD\n    return res\n\nres_h = count_patterns_horizontal()\nres_v = count_patterns_vertical()\nans = res_h * res_v % MOD\nprint(ans)"
 ],
 "1089": [
  "MOD = 1000000007\n\nn, m, k = map(int, input().split())\n\nans = 0\n\nfor i in range(1, n + 1):\n    for j in range(1, m + 1):\n        # calculate contribution of each cell to answer\n        ways = ((n - i + 1) * (m - j + 1)) % MOD\n        ans = (ans + ways * (i + j - 2) % MOD) % MOD\n\n# calculate answer\nfor i in range(2, n + m + 1):\n    num_ways = (i - 2) * (i - 1) // 2\n    # calculate contribution of each sum to answer\n    ans = (ans - (num_ways * ((k * (k - 1) // 2) % MOD) % MOD) + MOD) % MOD\n\nprint(ans)"
 ],
 "1090": [
  "n, k = map(int, input().split())\ns = input()\n\nans = 0\nfor i in range(n-1):\n    if s[i] == s[i+1]:\n        ans += 1\n\nmax_ans = ans + 2 * k\nif max_ans > n - 1:\n    max_ans = n - 1\n\nprint(max_ans)"
 ],
 "1091": [
  "n = int(input())\nprices = list(map(int, input().split()))\n\nwinner_index = prices.index(max(prices))\nsecond_max_price = max(price for i, price in enumerate(prices) if i!=winner_index)\n\nprint(winner_index+1, second_max_price)"
 ],
 "1092": [
  "lst = list(map(int, input().strip().split()))\nlsts = list(map(int, input().strip().split()))\n\nfrom functools import lru_cache\n\n@lru_cache()\ndef dp(i, last):\n    if i == len(lsts):\n        return 1\n\n    res = 0\n    if lsts[i] - 1 <= last:\n        res += dp(i + 1, last)\n    if lsts[i] + 1 >= last:\n        if i == len(lsts) - 1:\n            res += dp(i + 1, lsts[i] + 1)\n        else:\n            res += dp(i + 1, last)\n    return res % mod\n\nmod = 10**9 + 7\nres = 0\n\nif lsts[0] - 1 > 0:\n    res += dp(0, lsts[0] - 1)\n\nres += dp(0, lsts[0])\n\nprint(res % mod)"
 ],
 "1093": [
  "n, m = map(int, input().split())\nmountain = [input() for i in range(n)]\n\nmax_up = 0\nmax_down = 0\nfor i in range(1, m):\n    up = 0\n    down = 0\n    for j in range(n):\n        if mountain[j][i] == '*':\n            if mountain[j][i-1] == '*':\n                up = max(up, j)\n            else:\n                down = max(down, j)\n    max_up = max(max_up, down - up)\n    max_down = max(max_down, up - down)\nprint(max_up, max_down)"
 ],
 "1094": [
  "n = int(input())\nchats = []\nfor i in range(n):\n    friend = input()\n    if friend in chats:  # if friend already exists, remove from old position and add to the top\n        chats.remove(friend)\n        chats.insert(0, friend)\n    else:  # if friend is new, add to the top\n        chats.insert(0, friend)\nprint(*chats, sep='\\n')  # print the final list with each friend on a new line"
 ],
 "1095": [
  "n,y1 = map(int,input().split())\na = list(map(int,input().split()))\nm,y2 = map(int,input().split())\nb = list(map(int,input().split()))\n\ninf = int(1e9)+7\n\ndef bisect(t,coord,dir):\n    l, r = 0, len(coord)-1\n    while l < r:\n        mid = (l+r+dir)//2\n        if coord[mid] < t:\n            l = mid+1\n        else:\n            r = mid-dir\n    if l == len(coord) or coord[l] != t:\n        return inf\n    return l\n\nans = 0\nfor i in range(n):\n    x1 = a[i]\n    l = bisect(x1,b,-1)\n    r = bisect(x1,b,1)\n    if l == inf or r == inf:\n        continue\n    x2l, x2r = b[l], b[r]\n    # left path\n    x2 = x2l\n    cnt = 0\n    for j in range(i-1,-1,-1):\n        if a[j] < x1 and bisect(a[j],b,-1) < l:\n            cnt += 1\n            x1, x2 = a[j], 2*a[i] - x2l\n    for j in range(l):\n        if b[j] < x2:\n            cnt += 1\n            x1, x2 = 2*x1 - x1, 2*b[j] - x2\n    ans = max(ans,cnt)\n    # right path\n    x2 = x2r\n    cnt = 0\n    for j in range(i+1,n):\n        if a[j] > x1 and bisect(a[j],b,1) > r:\n            cnt += 1\n            x1, x2 = a[j], 2*a[i] - x2r\n    for j in range(r+1,m):\n        if b[j] > x2:\n            cnt += 1\n            x1, x2 = 2*x1 - x1, 2*b[j] - x2\n    ans = max(ans,cnt)\n\nprint(ans)"
 ],
 "1096": [
  "pos = input().strip()\ncol = ord(pos[0]) - ord('a')\nrow = int(pos[1]) - 1\nmoves = 0\n\nif col > 0:\n    moves += 1\nif col < 7:\n    moves += 1\nif row > 0:\n    moves += 1\nif row < 7:\n    moves += 1\nif col > 0 and row > 0:\n    moves += 1\nif col < 7 and row > 0:\n    moves += 1\nif col > 0 and row < 7:\n    moves += 1\nif col < 7 and row < 7:\n    moves += 1\n\nprint(moves)"
 ],
 "1097": [
  "n, t, k = map(int, input().split())\na = list(map(int, input().split()))\n\nif a[0] != 1:\n    print(-1)\n    exit()\n\ndeg = [0] * n\nmax_dist = 0\nfor i in range(1, t):\n    for j in range(a[i]):\n        u = sum(a[:i]) + j + 1\n        max_dist = max(max_dist, i)\n        for p in range(a[i-1]):\n            v = sum(a[:i-1]) + p + 1\n            deg[u-1] += 1\n            deg[v-1] += 1\n            if deg[u-1] > 1 or deg[v-1] > 1:\n                print(-1)\n                exit()\n\nres = []\nq = [(0, 1)]\nwhile q:\n    dist, u = q.pop()\n    if deg[u-1] == 1:\n        k -= 1\n    for v in range(n):\n        if deg[v] == 1 and u != v:\n            deg[u-1] -= 1\n            deg[v-1] -= 1\n            q.append((dist+1, v+1))\n            res.append((u, v+1))\n\nif k < 0 or any(deg[i] > 1 for i in range(n)):\n    print(-1)\nelse:\n    print(n)\n    for u, v in res:\n        print(u, v)"
 ],
 "1098": [
  "n = int(input())\n# read the alarm times and convert them to time in minutes\nalarm_times = []\nfor i in range(n):\n    hh, mm = map(int, input().split(\":\"))\n    alarm_times.append(hh * 60 + mm)\n\n# sort the alarm times in ascending order\nalarm_times.sort()\n\n# check the time between each adjacent alarm, \n# and find the longest time segment with no alarms\nmax_sleep = alarm_times[0] + (24 * 60 - alarm_times[-1] - 1)\nfor i in range(1, n):\n    sleep_time = alarm_times[i] - alarm_times[i-1] - 1\n    if sleep_time > max_sleep:\n        max_sleep = sleep_time\n\n# convert the time in minutes to hh:mm format\nhh = max_sleep // 60\nmm = max_sleep % 60\nprint(\"{:02d}:{:02d}\".format(hh, mm))"
 ],
 "1099": [
  "from collections import deque\n \nn = int(input())\nadj = [[] for _ in range(n+1)]\ndegree = [0] * (n+1)\n \nfor i in range(n-1):\n    x, y = map(int, input().split())\n    adj[x].append(y)\n    adj[y].append(x)\n    degree[x] += 1\n    degree[y] += 1\n \nq = deque([i for i in range(1, n+1) if degree[i] == 1])\n \nwhile n > 1:\n    sz = len(q)\n    for _ in range(sz):\n        u = q.popleft()\n        n -= 1\n        for v in adj[u]:\n            if degree[v] > 1:\n                degree[v] -= 1\n                if degree[v] == 1:\n                    q.append(v)\n                    break\n \nprint(len(q))"
 ],
 "1100": [
  "import math\nn = int(input())\nprint((n-2)*(n-2) if n <= 4 else (n-2)*(n-2) + int((n*(n-4)*(n-2)*math.tan(math.pi/n))/4))"
 ],
 "1101": [
  "n, k = map(int, input().split())\nrooms = input()\n\nzeros = []\nfor i in range(n):\n    if rooms[i] == '0':\n        zeros.append(i)\n\nlow, high = 0, zeros[k]\nresult = high\n\nwhile high < len(zeros) - 1:\n    low += 1\n    high += 1\n    mid = (zeros[low] + zeros[high]) // 2\n    left = mid - zeros[low]\n    right = zeros[high] - mid\n    result = min(result, max(left, right))\n\nprint(result)"
 ],
 "1102": [
  "n, a = map(int, input().split())\nt = list(map(int, input().split()))\n\ncatch = 0\nfor i in range(n):\n    if t[i] == 0:\n        continue\n    diff = abs(i+1-a)\n    if i+1 < a:\n        if t[a-diff-1] == 1:\n            catch += 2\n    elif i+1 > a:\n        if t[a+diff-1] == 1:\n            catch += 2\n    else:\n        catch += 1\n\nprint(catch)"
 ],
 "1103": [
  "n = int(input())\nseq = list(map(int, input().split()))\ncounts = [seq.count(i) for i in range(1, 9)]\ndp = [[0] * 9 for _ in range(n + 1)]\nfor i in range(1, n + 1):\n    for j in range(1, 9):\n        if seq[i - 1] == j:\n            dp[i][j] = dp[i - 1][j - 1] + 1\n            if j < 8:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j + 1] + 1)\n        else:\n            dp[i][j] = dp[i - 1][j]\nres = 0\nfor i in range(1, n + 1):\n    for j in range(1, i + 1):\n        cur_counts = [dp[i][k] - dp[j - 1][k] for k in range(1, 9)]\n        if all(abs(cur_counts[k] - counts[k]) <= 1 for k in range(8)):\n            res = max(res, i - j + 1)\nprint(res)"
 ],
 "1104": [
  "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nt = [0 for i in range(n)]\nt[0] = a[0]\n\nfor i in range(1, n-1):\n    if (a[i] == 3 and b[i] == 0):\n        t[i] = 3\n    elif (a[i] == 2 and b[i] == 0):\n        t[i] = 2\n    elif (a[i] == 1 and b[i] == 0):\n        t[i] = 2\n    elif (a[i] == 0 and b[i] == 0):\n        t[i] = 1\n    elif (a[i] == 3 and b[i] == 3):\n        t[i] = 3\n    elif (a[i] == 3 and b[i] == 2):\n        t[i] = 2\n    elif (a[i] == 2 and b[i] == 3):\n        t[i] = 2\n    elif (a[i] == 2 and b[i] == 2):\n        t[i] = 1\n    elif (a[i] == 1 and b[i] == 3):\n        t[i] = 2\n    elif (a[i] == 1 and b[i] == 2):\n        t[i] = 1\n    elif (a[i] == 1 and b[i] == 1):\n        print(\"NO\")\n        exit()\n    elif (a[i] == 0 and b[i] == 3):\n        t[i] = 1\n    elif (a[i] == 0 and b[i] == 2):\n        t[i] = 0\n    elif (a[i] == 0 and b[i] == 1):\n        print(\"NO\")\n        exit()\n    elif (a[i] == 0 and b[i] == 0):\n        t[i] = 0\n\nif (a[0] & t[1] == b[0] and t[n-2] | a[n-2] == b[n-2]):\n    t[n-1] = a[n-2] | t[n-2]\n\n    for i in range(n-2, 0, -1):\n        t[i] = a[i-1] | t[i-1]\n    \n    print(\"YES\")\n    for i in range(n):\n        print(t[i], end=\" \")\nelse:\n    print(\"NO\")"
 ],
 "1105": [
  "n = int(input())\nlast = [0] * n\nfor i in range(n):\n    x, k = map(int, input().split())\n    if x == 0:\n        last[k-1] = i\n    else:\n        if last[k-1] > x-1:\n            print(\"NO\")\n            break\n        else:\n            last[k-1] = i\nelse:\n    print(\"YES\")"
 ],
 "1106": [
  "n = int(input())\na = list(map(int, input().split()))\n\ndef dfs(v, lvl):\n    s[v] = a[v]\n    h[v] = lvl    \n    for u in [2*v, 2*v+1]:\n        if u in G[v]:\n            dfs(u, lvl+1)\n            s[v] += s[u]   \n    return\n\ndef paint(v, w):\n    ans[0] += abs(w - s[v]) \n    for u in [2*v, 2*v+1]:\n        if u in G[v]:\n            paint(u, s[v]//2)   \n    return\n\nG = {}\nfor i in range(1, 2**n):\n    G[i] = [i//2]\n\ns = [0] * (2**n)\nh = [0] * (2**n)\ndfs(1, 0)\n\nans = [0]\npaint(1, sum(s) // (2**n))\nprint(ans[0])"
 ],
 "1107": [
  "n = int(input())\ns = input()\nans = 0\n\nfor i in range(n):\n    cnt = 0\n    last_move = [' ', ' ', ' ']\n    for j in range(i, n + i):\n        if s[j % n] != last_move[cnt % 3] and cnt >= 3:\n            ans = max(ans, cnt - 1)\n        cnt += 1\n        last_move[cnt%3] = 'b' if s[j % n] == 'a' else 'a'\n\nprint(ans)"
 ],
 "1108": [
  "n = int(input())\ncount = 0\nfor i in range(n):\n    p, q = map(int, input().split())\n    if q - p >= 2:\n        count += 1\nprint(count)"
 ],
 "1109": [
  "n,k=map(int,input().split())\na=list(map(int,input().split()))\nchanges = 0\nfor i in range(k):\n    freq1,freq2 = 0,0\n    for j in range(i,n,k):\n        if a[j]==1:\n            freq1+=1\n        else:\n            freq2+=1\n    changes += min(freq1,freq2)\nprint(changes)"
 ],
 "1110": [
  "n = int(input())\nprint((n*(n-1)//2)+n)"
 ],
 "1111": [
  "n,k=map(int,input().split())\nMOD=10**9+7\nw=list(map(int,input().split()))\nfact=[1]\nfor i in range(1,n+1):fact.append((fact[i-1]*i)%MOD)\ninv=[1]*(n+1)\nfor i in range(2,n+1):inv[i]=(MOD-MOD//i)*inv[MOD%i]%MOD\nfor i in range(1,n+1):inv[i]=inv[i]*inv[i-1]%MOD\nwk=[1]\nfor i in range(1,k):wk.append((wk[-1]*(k-i))%MOD)\nans=0\nfor i in range(k):\n    a=fact[n];a=a*inv[i]%MOD;a=a*inv[n-k+i]%MOD;a=a*wk[i]%MOD\n    if i%2==1:ans-=a\n    else:ans+=a\nfor i in range(n):\n    if k>n-i:break\n    a=fact[n-i-1];a=a*inv[k-1]%MOD;a=a*inv[n-i-k]%MOD;a=a*w[i]%MOD;a=a*fact[k]%MOD;a=a*fact[n-i-k-1]%MOD\n    if (n-k-i)%2==1:ans-=a\n    else:ans+=a\nprint((ans%MOD+MOD)%MOD)"
 ],
 "1112": [
  "from itertools import combinations\n\n# Read Elephant's notes\nrows = [list(map(int, input().split())) for _ in range(3)]\n\n# Find the indices of missing diagonal elements\nmissing_indices = [(i, i) for i in range(3) if rows[i][i] == 0]\n\n# Generate all possible combinations of integers that can fill in the missing elements\npossible_values = combinations(range(1, 10), len(missing_indices))\n\n# Iterate over each combination\nfor values in possible_values:\n    # Create a copy of the original square\n    square = [row[:] for row in rows]\n    # Fill in the missing diagonal elements with the current combination\n    for i, value in zip(missing_indices, values):\n        square[i[0]][i[1]] = value\n    # Calculate the sums of each row, column and diagonal\n    sums = [sum(row) for row in square] + [sum(square[i][j] for i in range(3)) for j in range(3)] + [sum(square[i][i] for i in range(3))), sum(square[i][2-i] for i in range(3))]\n    # Check if all sums are equal\n    if len(set(sums)) == 1:\n        # If they are, we have found a valid magic square, so print it and exit the loop\n        for row in square:\n            print(*row)\n        break"
 ],
 "1113": [
  "n = int(input())\na = list(map(int, input().split()))\n\ns = set()\nmex = 0\nfor i in range(n):\n    s.add(a[i])\n    while mex in s:\n        mex += 1\n    if mex != a[i+1] and i+1 < n:\n        print(i+1)\n        break\nelse:\n    print(-1)"
 ],
 "1114": [
  "n, m = map(int, input().split())\nf = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nindices = [[] for i in range(n+1)] # indices[i] will store all the indices where we have f[j] == i\nfor i in range(1, n+1):\n    for j in range(m):\n        if f[i-1] == b[j]:\n            indices[i].append(j+1)\n\n# If there are no conflicts, then there must exist exactly 1 index for each element of f.\n# For any index k of b, if there are multiple corresponding values of f_i (say i and j), then a unique sequence does not exist.\n# Otherwise, we can construct the original sequence using the indices.\npositions = [0]*(m+1)\nfor i in range(1, n+1):\n    if len(indices[i]) == 1:\n        positions[indices[i][0]] = str(i)\n    elif len(indices[i]) > 1:\n        print(\"Ambiguity\")\n        exit()\n    else:\n        print(\"Impossible\")\n        exit()\nprint(\"Possible\")\nprint(\" \".join(positions[1:]))"
 ],
 "1115": [
  "# Reading inputs\nn = int(input())\ntimes = list(map(int, input().split()))\nm = int(input())\nperiods = []\nfor i in range(m):\n    l, r = map(int, input().split())\n    periods.append((l, r))\n\n# Initializing necessary variables\ni = 0  # current problem being solved\nend_time = 0  # the earliest time all problems can be submitted\n\n# Iterating over each period of time when the website is working\nfor l, r in periods:\n    # Checking if we have enough time to solve and submit all problems during this period\n    while i < n and end_time + times[i] <= r:\n        end_time += times[i]\n        i += 1\n    # If we have solved and submitted all problems, we can return the end time\n    if i == n:\n        print(end_time)\n        exit()\n    # If we haven't solved and submitted all problems, but we can still solve them during this period,\n    # we update the start time to the end of this period\n    if end_time < l:\n        end_time = l\n# If we have gone through all periods and still haven't solved and submitted all problems, it's impossible\nprint(-1)"
 ],
 "1116": [
  "t = int(input())\nfor i in range(t):\n    r, b, k = map(int, input().split())\n    if r > b:\n        r, b = b, r\n    gcd = math.gcd(r, b)\n    lcm = r*b // gcd\n    n = (lcm - 1) // b\n    if n >= k-1:\n        print(\"OBEY\")\n    else:\n        print(\"REBEL\")"
 ],
 "1117": [
  "n=int(input())\na=[]\nfor i in range(n):\n    w,h=map(int,input().split())\n    a.append([w,h])\nflag=True\ncurr_h=0\nfor i in range(n):\n    w,h=a[i]\n    if w<=curr_h or h<=curr_h:\n        curr_h=max(w,h)\n    elif w>curr_h and h>curr_h:\n        if w>h:\n            w,h=h,w\n        if w<=curr_h:\n            curr_h=h\n        else:\n            flag=False\n            break\nif flag:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "1118": [
  "n = int(input())\nc = list(map(int, input().split()))\n\ndp = [[0]*n for _ in range(n)]\n\nfor l in range(n):\n    for i in range(n-l):\n        j = i+l\n        if l == 0:\n            dp[i][j] = 1\n        else:\n            if c[i] == c[j]:\n                dp[i][j] = dp[i+1][j-1] + (l == 1)\n            else:\n                dp[i][j] = n\n                for k in range(i,j):\n                    dp[i][j] = min(dp[i][j], dp[i][k]+dp[k+1][j])\n                    \nprint(dp[0][n-1])"
 ],
 "1119": [
  "MOD = 10**9 + 7\n\n# Function to calculate modular inverse using Fermat's Little Theorem\ndef modinv(x):\n    return pow(x, MOD-2, MOD)\n\nk, pa, pb = map(int, input().split())\n\n# Probability that 'a' is added at each second\npa = pa * modinv(pa + pb) % MOD\n\n# dp[i][j] represents the expected number of subsequences 'ab'\n# we will get after adding j characters with i valid 'ab' subsequences so far\ndp = [[0] * (k+1) for _ in range(k+1)]\n\n# Base case: If we have 0 valid subsequences so far, \n# we need to start with 'b' to contribute to a new valid subsequence\ndp[0][1] = pb\n\nfor i in range(k):\n    for j in range(k+1):\n        # If we already have k valid subsequences, the probability of getting another is 0\n        if j == k:\n            dp[i+1][j] += dp[i][j]\n            continue\n        # Probability of adding 'a' and preserving the current number of valid subsequences\n        dp[i][j] = (dp[i][j] + dp[i][j] * pa) % MOD\n        # Probability of adding 'b' and increasing the number of valid subsequences by 1\n        dp[i+1][j+1] = (dp[i+1][j+1] + dp[i][j] * pb) % MOD\n\n# Sum up the expected number of valid subsequences across all the states where we have k valid subsequences so far\nans = 0\nfor j in range(1, k+1):\n    ans = (ans + j * dp[-1][j]) % MOD\n\nprint(ans)"
 ],
 "1120": [
  "n = int(input())\ndigits = set(str(n))\ndp = {str(i):0 for i in range(1, 10)}\nfor d in digits:\n    dp[d] = 1\n\nfor i in range(2, len(str(n))+1):\n    for j in digits:\n        new_num = str(int(j)*i)\n        if new_num in dp:\n            dp[new_num] = min(dp[new_num], i)\n        for k in dp.keys():\n            if k != '0' and k in new_num:\n                dp[k] = min(dp[k], dp[new_num]+i)\n\nprint(dp[str(n)])"
 ],
 "1121": [
  "n, m = map(int, input().split())\nfor i in range(n):\n    row = ''\n    for j in range(m):\n        if (i+j) % 2 == 0:\n            row += 'A'\n        else:\n            row += 'B'\n    print(row)"
 ],
 "1122": [
  "n, m = map(int, input().split())\nfor i in range(m):\n    print(i+1, m-i if i % 2 == 0 else m-i+2)"
 ],
 "1123": [
  "from math import gcd\nn, k = map(int, input().split())\nmod = 10**9+7\nans = 0\nfor i in range(1, k+1):\n    cnt = pow(k//i, n, mod)\n    ans += i*cnt\n    ans %= mod\nprint(ans)"
 ],
 "1124": [
  "n=int(input())\ncards=list(map(int, input().split()))\nwhile max(cards)!=min(cards):\n    max_val=max(cards)\n    min_val=min(cards)\n    for i in range(n):\n        if cards[i]==max_val:\n            cards[i]=max_val-min_val\nprint(cards[0])"
 ],
 "1125": [
  "n = int(input())\na = list(map(int,input().split()))\ntotal_sum = sum(a)\nprefix_sum = [a[0]]\nfor i in range(1,n):\n    prefix_sum.append(prefix_sum[i-1]+a[i])\nans = -1\nfor i in range(1,n):\n    if prefix_sum[i-1] <= (total_sum-prefix_sum[i-1]) <= prefix_sum[i]:\n        ans = total_sum - 2*(total_sum-prefix_sum[i-1])\n        break\nprint(ans)"
 ],
 "1126": [
  "n, x, m = map(int, input().split())\nans, cnt = 0, 0\nmp = [-1] * m\nlst = [x]\nwhile cnt < n:\n    y = lst[-1] ** 2 % m\n    if mp[y] != -1:\n        len_cycle = cnt - mp[y]\n        num_cycle = (n - cnt) // len_cycle\n        ans += sum(lst[mp[y]:]) + num_cycle * (sum(lst[mp[y]:]) - ans)\n        cnt += num_cycle * len_cycle\n    else:\n        mp[y] = cnt\n        ans += lst[-1]\n        lst.append(y)\n        cnt += 1\nprint(ans)"
 ],
 "1127": [
  "for _ in range(int(input())):\n    n = int(input())\n    s = input()\n    if n % 2 == 1 and int(s[-1]) % 2 == 1:\n        print(1)\n    else:\n        print(2)"
 ],
 "1128": [
  "a,m=map(int,input().split())\nrem=[0]*m\nwhile a%m not in rem:\n    rem[a%m]=1\n    a+=a%m\nprint(\"Yes\" if a>=m else \"No\")"
 ],
 "1129": [
  "n = int(input())\nxi = sorted(list(map(int, input().split())))\nx = xi[n//2] if n%2==1 else xi[n//2-1]\nprint(x)"
 ],
 "1130": [
  "n, m, k = map(int, input().split())\n\ntimetable = []\nfor i in range(n):\n    timetable.append(list(map(int, input())))\n\ndp = [[[float('inf') for _ in range(k+1)] for _ in range(m)] for _ in range(n)]\n\nfor i in range(m):\n    dp[0][i][0] = (not timetable[0][i])\n    \nfor i in range(n):\n    for j in range(k+1):\n        dp[i][0][j] = (not timetable[i][0])\n        \nfor i in range(1, n):\n    for j in range(1, m):\n        if timetable[i][j]:\n            for x in range(k+1):\n                dp[i][j][x] = min(dp[i][j-1][x-1]+1, dp[i-1][j][x-1]+1)\n        else:\n            for x in range(k+1):\n                dp[i][j][x] = min(dp[i][j-1][x], dp[i-1][j][x])\n\nprint(min(dp[n-1][m-1]))"
 ],
 "1131": [
  "a, b, w, x, c = map(int, input().split())\ntime = 0\nwhile c > a:\n    c -= 1\n    if b >= x:\n        b -= x\n    else:\n        a -= 1\n        b = w - (x - b)\n    time += 1\nprint(time)"
 ],
 "1132": [
  "n, m = map(int, input().split())\ngraph = {node: set() for node in range(1, n+1)}\n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    graph[a].add(b)\n    graph[b].add(a)\n\ndegree_counts = [len(graph[node]) for node in range(1, n+1)]\n\nnum_degrees = degree_counts.count(1)\nnum_degrees_2 = degree_counts.count(2)\nnum_degrees_n_1 = degree_counts.count(n-1)\n\nif num_degrees == n-2 and num_degrees_n_1 == 2:\n    print(\"bus topology\")\nelif num_degrees == n-2 and num_degrees_2 == 2:\n    print(\"ring topology\")\nelif num_degrees == n-1 and num_degrees_n_1 == 1:\n    print(\"star topology\")\nelse:\n    print(\"unknown topology\")"
 ],
 "1133": [
  "n = int(input())\nwords = [input() for i in range(n)]\nmax_length = 0\nfor i in range(n):\n    for j in range(i+1, n):\n        letters_set = set(words[i]) | set(words[j])\n        if len(letters_set) <= 2:\n            length = len(words[i]) + len(words[j])\n            for word in words[j+1:] + words[:i]:\n                if set(word) == letters_set:\n                    length += len(word)\n            max_length = max(max_length, length)\nprint(max_length)"
 ],
 "1134": [
  "n = int(input())\nm = list(map(int, input().split()))\n\nmarks = [0] * n \nd_sum = 0\n\nfor i in range(n):\n    if m[i] == 0:\n        marks[i] = 1\n    elif i - m[i] > 0 and marks[i - m[i] - 1] > marks[i - 1]:\n        marks[i] = marks[i - m[i] - 1] + 1\n    else:\n        marks[i] = marks[i - 1]\n\n    d_sum += i + 1 - marks[i]\n\nprint(d_sum)"
 ],
 "1135": [
  "n = int(input())\ns = input()\ndecoded = \"\"\nif n % 2 == 0:\n    decoded += s[n//2-1]\n    decoded += s[n//2]\n    for i in range(n//2-1):\n        decoded += s[(n//2)+i+1]\n        decoded += s[(n//2)-i-2]\nelse:\n    decoded += s[n//2]\n    for i in range(n//2):\n        decoded += s[(n//2)+i+1]\n        decoded += s[(n//2)-i-1]\nprint(decoded)"
 ],
 "1136": [
  "n, m = map(int, input().split())\n\nMOD = 10**9 + 7\n\nans = 0\n\nfor i in range(1, min(n+1, m+1)):\n    ans += n % i\n    ans %= MOD\n\nprint(ans)"
 ],
 "1137": [
  "n, m, k = map(int, input().split())\ns = input()\nt = input()\n\ndp = [[0] * (m + 1) for _ in range(k + 1)]\n\nfor i in range(1, k + 1):\n    for j in range(1, m + 1):\n        max_val = dp[i][j - 1]\n        for x in range(n, 0, -1):\n            if s[x - 1] == t[j - 1]:\n                max_val = max(max_val, dp[i - 1][j - x - 1] + x)\n            dp[i][j] = max(dp[i][j], max_val)\n\nprint(dp[k][m])"
 ],
 "1138": [
  "s = input()\nl_count = s.count('L')\nr_count = s.count('R')\nu_count = s.count('U')\nd_count = s.count('D')\nh_moves = abs(r_count-l_count)\nv_moves = abs(u_count-d_count)\nif (h_moves + v_moves) % 2 == 1:\n    print(-1)\nelse:\n    print((h_moves + v_moves) // 2)"
 ],
 "1139": [
  "n, m = map(int, input().split())\nintervals = []\nfor i in range(n):\n    k = int(input())\n    row = [0] * m\n    for j in range(k):\n        l, r = map(int, input().split())\n        for x in range(l-1, r):\n            row[x] = 1\n    intervals.append(row)\n \nans = 0\nfor c in range(m):\n    col_sum = sum(intervals[i][c] for i in range(n))\n    ans += col_sum ** 2\n \n    # Greedy approach: change one 0 to 1 in the interval with the smallest contribution to col_sum\n    choices = []\n    for i in range(n):\n        if intervals[i][c] == 0:\n            contrib = sum(intervals[i][j] for j in range(m)) - col_sum\n            choices.append((contrib, i))\n    if choices:\n        _, best_row = max(choices)\n        intervals[best_row][c] = 1\n        col_sum += 1\n        ans += (col_sum * 2 - 1)  # Update ans\n \nprint(ans)"
 ],
 "1140": [
  "n = int(input())\nbeauty = list(map(int, input().split()))\n\nmax_beauty = max(beauty)\nmin_beauty = min(beauty)\ndiff = max_beauty - min_beauty\nmax_count = beauty.count(max_beauty)\nmin_count = beauty.count(min_beauty)\n\nif max_beauty == min_beauty:\n    print(diff, int(n*(n-1)/2))\nelse:\n    print(diff, max_count*min_count)"
 ],
 "1141": [
  "n, m = map(int, input().split())\ns = list(input())\n\nfor i in range(m):\n    l, r, c1, c2 = input().split()\n    l, r = int(l), int(r)\n    for j in range(l-1, r):\n        if s[j] == c1:\n            s[j] = c2\n            \nprint(''.join(s))"
 ],
 "1142": [
  "n, k = map(int, input().split())\nwaves = []\nfor i in range(n):\n    l, r, a = map(int, input().split())\n    waves.append((l, r, a))\n\ndp = [float('inf')] * (n+1)\ndp[0] = 0\nfor i in range(n):\n    rem = k\n    for j in range(i, n):\n        a = waves[j][2]\n        rem -= a\n        if rem < 0:\n            break\n        dp[j+1] = min(dp[j+1], dp[i] + max(0, waves[j][1]-waves[j][0])*k + a)\n\nif dp[-1] == float('inf'):\n    print(-1)\nelse:\n    print(dp[-1])"
 ],
 "1143": [
  "from datetime import datetime, timedelta\n\nn = int(input())\nolympiads = []\nfor i in range(n):\n    m, d, p, t = map(int, input().split())\n    date = datetime(2013, m, d)\n    olympiads.append((date-timedelta(days=t), date, p))\n\nolympiads.sort()\nbusy_days = set()\nneeded_jury_size = 0\n\nfor start_date, end_date, num_jury in olympiads:\n    busy_days = set(day for day in busy_days if day >= end_date)\n    free_days = [day for day in (end_date-timedelta(days=i) for i in range(1, t+1)) if day not in busy_days]\n    if len(free_days) < t:\n        needed_jury_size += t-len(free_days)\n        busy_days.update(end_date-timedelta(days=i) for i in range(1, t+1))\n\nprint(needed_jury_size)"
 ],
 "1144": [
  "n = int(input())\ns = input()\nm = int(input())\nt = 'ab' * (m//2) + 'a' * (m%2)\n\n# Count the number of '?' in each m-length substring of s\nq_counts = [0] * (n-m+1)\nfor i in range(n-m+1):\n    q_counts[i] = s[i:i+m].count('?')\n\n# Calculate the minimum number of replacements needed for each starting position of t in s\nmin_replacements = float('inf')\nfor i in range(m):\n    replacements = sum([q_counts[j+i] for j in range(len(q_counts)) if (j+i) % m % 2 == t[j] == 'a']) + sum([q_counts[j+i] for j in range(len(q_counts)) if (j+i) % m % 2 != t[j] == 'b'])\n    if replacements < min_replacements:\n        min_replacements = replacements\n\nprint(min_replacements)"
 ],
 "1145": [
  "n = int(input())\nbadges = list(map(int, input().split()))\n\ncoins = 0\nfor i in range(n):\n    for j in range(i+1, n):\n        if badges[i] == badges[j]:\n            coins += 1\n            badges[j] += 1\n\nprint(coins)"
 ],
 "1146": [
  "n, m = map(int, input().split())\n\nbulbs = set(range(1, m+1))\nbuttons = []\nfor i in range(n):\n    s = set(map(int, input().split()[1:]))\n    buttons.append(s)\n    bulbs -= s\n\nfor b in buttons:\n    if not bulbs.isdisjoint(b):\n        bulbs -= b\n\nif not bulbs:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "1147": [
  "n, x, k = map(int, input().split())\na = sorted(map(int, input().split()))\n\ncount = 0\ni = 0\n\nwhile i < n:\n    j = i\n    while j < n and a[j] % x == a[i] % x:\n        j += 1\n    prefer_start_after = (a[i] - 1) // x + 1 + k\n    prefer_end_before = (a[i] - 1) // x + 1 + 2 * k\n    start = max(prefer_start_after, (a[i] - 1) // x + 1)\n    end = min(prefer_end_before, (a[j - 1] - 1) // x)\n    if start <= end:\n        count += max(0, end - start + 1)\n    i = j\n\nprint(count)"
 ],
 "1148": [
  "n = int(input())\na = list(map(int, input().split()))\n\nmax_color = max(a)\nindex = a.index(max_color)\n\npaintable_squares = max_color\nnext_color = (index + 1) % n\n\nwhile a[next_color] == max_color and next_color != index:\n    paintable_squares += max_color\n    next_color = (next_color + 1) % n\n\nif next_color != index:\n    paintable_squares += a[next_color]\n\nprint(paintable_squares)"
 ],
 "1149": [
  "n = int(input())\nx_levels = list(map(int, input().split()))[1:]\ny_levels = list(map(int, input().split()))[1:]\nall_levels = set(range(1, n+1))\npassed_levels = set(x_levels + y_levels)\nif all_levels == passed_levels:\n    print(\"I become the guy.\")\nelse:\n    print(\"Oh, my keyboard!\")"
 ],
 "1150": [
  "from itertools import permutations\nfrom math import dist\n\n# Helper function to check if the four moles form a square\ndef is_square(points):\n    d = [dist(points[i], points[j]) for i, j in [(0, 1), (1, 3), (3, 2), (2, 0), (0, 3), (1, 2)]]\n    return all(x == d[0] for x in d)\n\n# Read input\nn = int(input())\nmole_data = [list(map(int, input().split())) for _ in range(4*n)]\n\n# Iterate over each regiment\nfor i in range(n):\n    moves_needed = float('inf')\n    moles = mole_data[i*4:(i+1)*4]  # Extract the four moles for this regiment\n    for p in permutations(range(4)):  # Check all possible permutations of moles\n        permuted_moles = [moles[j] for j in p]\n        if is_square(permuted_moles):\n            # Calculate the number of moves needed to make this permutation compact\n            moves = sum(abs(p[0]-p[j]) for j in range(1, 4))\n            moves_needed = min(moves, moves_needed)\n    if moves_needed == float('inf'):\n        print(\"-1\")\n    else:\n        print(moves_needed)"
 ],
 "1151": [
  "import bisect\nn, u = map(int, input().split())\nE = list(map(int, input().split()))\nans = -1\nfor i in range(n-2):\n    j = bisect.bisect_right(E, E[i]+u) - 1\n    if j <= i + 1:\n        continue\n    ans = max(ans, (E[j] - E[i+1])/(E[j] - E[i]))\nprint(ans)"
 ],
 "1152": [
  "n,m = map(int,input().split())\n\nA = []\nB = []\n\nfor i in range(n):\n    A.append(list(map(int,input().split())))\n\nfor i in range(n):\n    B.append(list(map(int,input().split())))\n\ndef invert(a,r1,c1,r2,c2):\n    for i in range(r1,r2+1):\n        for j in range(c1,c2+1):\n            a[i][j] = 1 - a[i][j]\n\nfor i in range(n-1):\n    for j in range(m-1):\n        if A[i][j] != B[i][j]:\n            invert(A,i,j,i+1,j+1)\nif A == B:\n    print(\"Yes\")\nelse:\n    print(\"No\")"
 ],
 "1153": [
  "n, m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\ni = 0\nj = 0\nsuma = 0\nsumb = 0\ncount = 0\n\nwhile i < n and j < m:\n    if suma == sumb:\n        count += 1\n        suma += a[i]\n        sumb += b[j]\n        i += 1\n        j += 1\n\n    elif suma < sumb:\n        suma += a[i]\n        i += 1\n\n    else:  # suma >  sumb\n        sumb += b[j]\n        j += 1\n\nif suma == sumb:  # left over case\n    count += 1\n\nprint(count)"
 ],
 "1154": [
  "n, h, k = map(int, input().split())\na = list(map(int, input().split()))\n\ntime = i = 0\ncurr_height = 0\n\nwhile i < n or curr_height != 0:\n    while i < n and curr_height + a[i] <= h:\n        curr_height += a[i]\n        i += 1\n    if curr_height < k:\n        curr_time = 1\n        curr_height = 0\n    else:\n        curr_time = curr_height // k\n        curr_height %= k\n    time += curr_time\n\ntime += curr_height // k + (1 if curr_height % k != 0 else 0)\n\nprint(time)"
 ],
 "1155": [
  "n, m = map(int, input().split())\nmin_cost = float('inf')\nfor i in range(n):\n    a, b = map(int, input().split())\n    cost = a/b * m\n    min_cost = min(min_cost, cost)\nprint(\"{0:.8f}\".format(min_cost))"
 ],
 "1156": [
  "n=int(input())\na=list(map(int,input().split()))\nb=input().strip()\n\n# initialize left and right boundaries\nleft=-10**9\nright=10**9\n\n# perform binary search\nwhile left<right:\n    mid=(left+right)//2\n    # set initial values of b\n    bb=[0]*n\n    bb[:5]=[0]*5\n    # apply algorithm to update bb\n    for i in range(5,n):\n        if a[i]<=mid and all(a[i]-j<=mid for j in range(1,5)):\n            bb[i]=1\n        if a[i]>=mid+1 and all(a[i]-j>=mid+1 for j in range(1,5)):\n            bb[i]=1\n    # compare bb with b\n    if ''.join(map(str,bb))==b:\n        # solution found\n        right=mid\n    else:\n        # solution not found\n        left=mid+1\n\nprint(left,right)"
 ],
 "1157": [
  "n = int(input())\na = list(map(int, input().split()))\n\npos, neg = [0] * (n + 1), [0] * (n + 1)\n\nfor i in range(1, n + 1):\n    if a[i - 1] > 0:\n        pos[i] = pos[i - 1] + 1\n        neg[i] = neg[i - 1]\n    else:\n        pos[i] = neg[i - 1]\n        neg[i] = pos[i - 1] + 1\n        \nans_pos, ans_neg = 0, 0\n        \nfor i in range(1, n + 1):\n    if a[i - 1] > 0:\n        ans_pos += pos[i]\n        ans_neg += neg[i]\n    else:\n        ans_pos += neg[i]\n        ans_neg += pos[i]\n        \nprint(ans_neg, ans_pos)"
 ],
 "1158": [
  "n, k = map(int, input().split())\nutensils = list(map(int, input().split()))\n\ntypes = set(utensils)\nmin_stolen = n\n\nfor t in types:\n    count = utensils.count(t)\n    sets_needed = (count+k-1) // k\n    stolen = sets_needed * k - count\n    min_stolen = min(min_stolen, stolen)\n    \nprint(min_stolen)"
 ],
 "1159": [
  "n=int(input())\nprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 293, 307, 311, 313, 317, 331, 337, 347, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541]\nres=[]\nfor i in range(n-1):\n    res.append((i+1,i+2))\nres.append((n,1))\nsolve=False\nfor i in range(len(primes)):\n    if primes[i]<n:\n        continue\n    else:\n        m=primes[i]\n        solve=True\n        break\nif not solve:\n    print(-1)\nelse:\n    print (m)\n    cnt=0\n    for i in range(n-1):\n        for j in range(i+2,n+1):\n            print (i+1,j)\n            cnt+=1\n            if cnt==m:\n                break\n        if cnt==m:\n            break"
 ],
 "1160": [
  "from collections import defaultdict\nsizes = input().split()\ntshirts = {size: int(num) for size, num in zip(['S', 'M', 'L', 'XL', 'XXL', 'XXXL'], sizes)}\nn = int(input())\n\nparticipants = [input().split(',') for _ in range(n)]\ngraph = defaultdict(list)\n\nfor participant in participants:\n    if len(participant) == 1:\n        graph[participant[0]].append(str(id(participant)))\n        graph[str(id(participant))].append(participant[0])\n    else:\n        graph[participant[0]].append(str(id(participant)))\n        graph[str(id(participant))].append(participant[0])\n        graph[participant[1]].append(str(id(participant)))\n        graph[str(id(participant))].append(participant[1])\n        \nassigned = {}\nfor size in ['S', 'M', 'L', 'XL', 'XXL', 'XXXL']:\n    if not graph[size]:\n        continue\n    available_tshirts = tshirts[size]\n    for participant in graph[size]:\n        if available_tshirts == 0:\n            break\n        assigned[participant] = size\n        tshirts[size] -= 1\n        available_tshirts -= 1\n\nif len(assigned) != n:\n    print('NO')\nelse:\n    print('YES')\n    for participant in participants:\n        print(assigned.get(participant[0] if len(participant) == 1 else participant[1]))"
 ],
 "1161": [
  "opening = {\"[\": \"]\", \"{\": \"}\", \"(\": \")\", \"<\": \">\"}\nstack = []\ncount = 0\ns = input().strip()\n\nfor ch in s:\n    if ch in opening:\n        stack.append(ch)\n    else:\n        if len(stack) == 0:\n            print(\"Impossible\")\n            exit(0)\n        top = stack.pop()\n        if opening[top] != ch:\n            count += 1\n\nif len(stack) > 0:\n    print(\"Impossible\")\nelse:\n    print(count)"
 ],
 "1162": [
  "p, s, r = map(int, input().split())\n\nMOD = 998244353\n\nfact = [1]*(s+1)\nfor i in range(1, s+1):\n    fact[i] = (fact[i-1]*i)%MOD\n\ndef inv(n):\n    return pow(n, MOD-2, MOD)\n\ndef ncr(n, r):\n    if r > n or n < 0 or r < 0:\n        return 0\n    return (fact[n]*inv(fact[r])*inv(fact[n-r]))%MOD\n\n# Probability of not winning\nnot_winning_prob = 0\nfor i in range(r, s):\n    not_winning_prob += ncr(s-i+p-2, p-2)*ncr(i-1, r-1)\n    not_winning_prob %= MOD\n\n# Total possible ways\ntotal_ways = ncr(s-1, p-1)\n\n# Probability of winning\nwinning_prob = (total_ways - not_winning_prob)%MOD\n\n# Final probability as a fraction\nP = winning_prob\nQ = total_ways\nans = (P*inv(Q))%MOD\nprint(ans)"
 ],
 "1163": [
  "n, m = map(int, input().split())\n\nif n <= m:\n    print((\"GB\" * n) + \"G\" * (m - n))\nelse:\n    print((\"BG\" * m) + \"B\" * (n - m))"
 ],
 "1164": [
  "s = input()\ntotal_price = 0\nfor i in range(len(s)):\n    if s[i].isdigit():\n        j = i\n        while j < len(s) and (s[j].isdigit() or s[j] == '.'):\n            j += 1\n        price = float(s[i:j])\n        total_price += price\n        i = j # skip to the end of the price\nprint('{:.2f}'.format(total_price))"
 ],
 "1165": [
  "n, m = map(int, input().split())\na = list(map(int, input().split()))\nfor i in range(m):\n    l, r, x = map(int, input().split())\n    for j in range(l-1, r):\n        if a[j] != x:\n            print(j+1)\n            break\n    else:\n        print(-1)"
 ],
 "1166": [
  "n = int(input())\na = list(map(int, input().split()))\n\n# recursive function to check the winner starting from index i\ndef winner(i):\n\n    # check if we have already calculated the result of this index\n    if dp[i] != -1:\n        return dp[i]\n\n    # initialize the winning player as the opposite of the current player\n    res = 'B' if player=='A' else 'A'\n\n    # check all the possible moves\n    for j in range(i+a[i], n, a[i]):\n\n        # if Alice makes a move and loses, set the result as 'A'\n        if player=='A' and winner(j)=='B':\n            res = 'A'\n            break\n\n        # if Bob makes a move and Alice wins, set the result as 'A'\n        if player=='B' and winner(j)=='A':\n            res = 'A'\n            break\n\n    # memoize the result\n    dp[i] = res\n    return res\n\n# initialize the dp array to -1\ndp = [-1]*n\n\n# initialize the starting player\nplayer = 'A'\n\n# calculate the winner starting from each index\nfor i in range(n):\n    winner(i)\n\n# convert the dp array to the required string output\nprint(\"\".join(dp))"
 ],
 "1167": [
  "t = int(input())\nfor _ in range(t):\n    a,b,c,d,k = map(int,input().split())\n    x = (a+c-1)//c\n    y= (b+d-1)//d\n    if x+y <= k:\n        print(x,y)\n    else:\n        print(-1)"
 ],
 "1168": [
  "n = int(input())\nmountains = list(map(int, input().split()))\n\nstack = []\npair_count = 0\n\nfor i in range(n):\n    mountain = mountains[i]\n    while stack:\n        height = mountains[stack[-1]]\n        if height <= mountain:\n            stack.pop()\n        else:\n            break\n    if stack:\n        l = stack[-1] + 1\n    else:\n        l = 0\n    r = i\n    mask = mountain\n    while True:\n        if l == r:\n            if mountans[r] > mountain:\n                mask |= mountains[r]\n            break\n        mid = (l + r) // 2\n        mid_height = mountains[mid]\n        if mid_height <= mountain:\n            l = mid + 1\n        else:\n            r = mid\n            if mid_height > mountain:\n                mask |= mid_height\n    pair_count += i - r + 1\n    stack.append(i)\n\nprint(pair_count)"
 ],
 "1169": [
  "n, m = map(int, input().split())\nmax_isolated = n - 2*(m - n)//3 - (m - n)%3\nmax_isolated = max(0, max_isolated)\nmin_isolated = n - m\nmin_isolated = max(0, min_isolated)\nprint(min_isolated, max_isolated)"
 ],
 "1170": [
  "t = int(input())\nfor i in range(t):\n    x = int(input())\n    if x == 0:\n        print(1, 1)\n    elif x == 1:\n        print(2, 1)\n    else:\n        l, r = 1, int(x**0.5)+1\n        while l <= r:\n            mid = (l+r)//2\n            if (mid-1)**2 < x <= mid**2-1:\n                print(mid, x//(mid-1)+1)\n                break\n            elif (mid-2)**2 < x <= (mid-1)**2-1:\n                print(mid-1, x//(mid-2)+1)\n                break\n            elif x < (mid-2)**2:\n                r = mid-1\n            else:\n                l = mid+1\n        else:\n            print(-1)"
 ],
 "1171": [
  "n, k = map(int, input().split())\njewels = list(map(int, input().split()))\n\nmax_sum = 0\n\nfor i in range(min(n, k)+1):\n    for j in range(min(n, k)-i+1):\n        hand = jewels[:i] + jewels[n-j:]\n        hand.sort()\n        hand_sum = sum(hand)\n        for h in hand:\n            if h < 0 and k-(i+j) > 0:\n                hand_sum -= h\n                k -= 1\n            else:\n                break\n        max_sum = max(max_sum, hand_sum)\n\nprint(max_sum)"
 ],
 "1172": [
  "MOD = 10 ** 9 + 7\n\ndef solve(S):\n    dp = [0] * 4 # dp[i] represents number of valid triplets ending with character i (A, B, C)\n    q_count = S.count(\"?\")\n    for c in S:\n        if c == \"A\":\n            dp[0] += 1\n        elif c == \"B\":\n            dp[1] += dp[0]\n        elif c == \"C\":\n            dp[2] += dp[1]\n        else: # c == \"?\"\n            dp[2] = 3 * dp[2] + dp[1]\n            dp[1] = 3 * dp[1] + dp[0]\n            dp[0] = 3 * dp[0] + 1\n    return dp[2] % MOD\n\nS = input().strip()\nprint(solve(S))"
 ],
 "1173": [
  "from collections import deque\n\nn = int(input().strip())\ngraph = [[a-1 for a in input().split()] for i in range(n)]\n\nans = 0\nfor start in range(n):\n    q = deque([start])\n    days = [-1]*n\n    days[start] = 0\n    while q:\n        cur = q.popleft()\n        for nxt in [graph[cur][i] for i in range(len(graph[cur])) if days[graph[cur][i]] == -1]:\n            days[nxt] = days[cur] + 1\n            q.append(nxt)\n    if -1 in days:\n        print(-1)\n        exit()\n    ans = max(ans, max(days))\n\nprint(ans+1)"
 ],
 "1174": [
  "n, m = map(int, input().split())\na = sorted(list(map(int, input().split())), reverse=True)\nfor i in range(m):\n    if not a:\n        break\n    x = a.pop() // 2\n    bisect.insort_left(a, x)\n\nprint(sum(a))"
 ],
 "1175": [
  "L, R = map(int, input().split())\nmod = 10**9 + 7\n\ndef calc(x, y):\n    if y < x:\n        return 0\n    m = y ^ x\n    p = 1\n    while p <= m:\n        p <<= 1\n    p >>= 1\n    return (2 * calc(x, p-1) + calc(x^p, y^p) + (y >= p) * (p - x)) % mod\n\nprint(calc(L, R))"
 ],
 "1176": [
  "n = int(input())\na = list(map(int, input().split()))\nneg_count = sum(1 for i in a if i < 0)\nif neg_count % 2 == 0:\n    print(sum(map(abs, a)))\nelse:\n    print(sum(map(abs, a))-2*abs(min(a, key=abs)))"
 ],
 "1177": [
  "mod = 998244353\n\nN, S = map(int, input().split())\nA = list(map(int, input().split()))\n\ndp = [[0] * (S + 1) for _ in range(N + 1)]\ndp[0][0] = 1\n\nfor i in range(1, N + 1):\n    for j in range(S + 1):\n        dp[i][j] = dp[i - 1][j] * 2\n        if j >= A[i - 1]:\n            dp[i][j] += dp[i - 1][j - A[i - 1]]\n        dp[i][j] %= mod\n\nans = 0\nfor i in range(N):\n    for j in range(i + 1, N + 1):\n        ans += dp[j - i][S] % mod\n        ans %= mod\n\nprint(ans)"
 ],
 "1178": [
  "n, k = map(int, input().split())\nh = list(map(int, input().split()))\n\ndp = [float('inf')] * n\ndp[0] = 0\n\nfor i in range(1, n):\n    for j in range(max(i-k, 0), i):\n        dp[i] = min(dp[i], dp[j] + abs(h[j] - h[i]))\n\nprint(dp[n-1])"
 ],
 "1179": [
  "n,k = map(int,input().split())\nids = list(map(int,input().split()))\n\nleft = 1\nright = k\n\nwhile left<right:\n    mid = (left+right)//2\n    check = mid*(mid+1)//2\n    if check>=k:\n        right = mid\n    else:\n        left = mid+1\n\nidx = left-1\nans = ids[idx]\n\nwhile k>1:\n    k -= 1\n    if idx>0:\n        idx -= 1\n        ans = ids[idx]\n    else:\n        idx = left+(k-1)\n        ans = ids[idx]\n        break\n\nprint(ans)"
 ],
 "1180": [
  "MOD = 10**9 + 7\n\nn, k = map(int, input().split())\ndigits = input().strip()\n\n# calculate the coefficients\ncoeff = [1] * (n+k)\nfor i in range(1, n+k):\n    coeff[i] = i * coeff[i-1] % MOD\ninv_coeff = [pow(coeff[i], MOD-2, MOD) for i in range(n+k)]\n\n# calculate the sum of expressions\nans = 0\nfor i in range(k+1):\n    ans += int(digits[0]) * coeff[n-1-i] % MOD * inv_coeff[i] % MOD\n    ans %= MOD\n    if i < k:\n        ans += int(digits[i+1]) * coeff[n-2-i] % MOD * inv_coeff[i] % MOD\n        ans %= MOD\n\nprint(ans)"
 ],
 "1181": [
  "n, m = map(int, input().split())\na = list(map(int, input().split()))\n\ntotal_turns = 0\nfor i in range(1, m):\n    total_turns += abs(a[i] - a[i-1])\n\nmax_turns_saved = 0\nfor i in range(1, m-1):\n    x, y, z = a[i-1], a[i], a[i+1]\n    turns_saved = abs(x-y) + abs(y-z) - abs(x-z)\n    max_turns_saved = max(max_turns_saved, turns_saved)\n\nprint(total_turns - max_turns_saved)"
 ],
 "1182": [
  "from itertools import product\n\nr, c, n, k = map(int, input().split())\nviolas = set(tuple(map(int, input().split())) for _ in range(n))\n\ncount = 0\nfor i, j in product(range(1, r+1), range(1, c+1)):\n    for ii, jj in product(range(i, r+1), range(j, c+1)):\n        rect = set(product(range(i, ii+1), range(j, jj+1)))\n        if len(rect & violas) >= k:\n            count += 1\n            \nprint(count)"
 ],
 "1183": [
  "t = int(input())\nfor _ in range(t):\n    n, x = map(int, input().split())\n    a = set(map(int, input().split()))\n    v = 0\n    for i in range(1, 101):\n        if i not in a:\n            if x == 0:\n                break\n            else:\n                x -= 1\n        v += 1\n    v += x\n    print(v-1)"
 ],
 "1184": [
  "python\nstring = input() # take input as string\nstring = string[1:-1] # remove first and last character, i.e., opening and closing brackets\nif len(string) > 0: \n    string = string.split(\", \") # create a list of letters\n    letter_set = set(string) # convert list to set to get distinct letters\n    print(len(letter_set)) # print the number of distinct letters\nelse:\n    print(0) # if the string is empty print 0"
 ],
 "1185": [
  "n, m, k = map(int, input().split())\np = list(map(int, input().split()))\ndp = [[0] * (k + 1) for _ in range(n + 1)]\nfor i in range(1, n + 1):\n    for j in range(1, k + 1):\n        for l in range(max(0, i - m), i):\n            dp[i][j] = max(dp[i][j], dp[l][j - 1] + sum(p[l:i]))\nprint(dp[n][k])"
 ],
 "1186": [
  "n = int(input())\n\nif n == 1:\n    print(\"NO\\nNO\")\nelif n == 2:\n    print(\"NO\\nNO\")\nelse:\n    # Permutation p\n    print(\"YES\")\n    p = [i for i in range(2, n+1)] + [1]\n    print(*p)\n    \n    # Permutation q\n    print(\"YES\")\n    q = [i for i in range(1, n)]\n    q[-1] = n-1 if (n-1)&(n-2) == 0 else n-2\n    q.append(n)\n    print(*q)"
 ],
 "1187": [
  "import sys\nsys.setrecursionlimit(10**7)\n \nn, m = map(int, input().split())\ngraph = [[] for _ in range(n)]\nfor i in range(m):\n    u, v = map(int, input().split())\n    graph[u-1].append((v-1, i))\n \nvisited = [False] * n\nstack = []\ncolor = [-1] * m\n \ndef dfs(v):\n    if visited[v]:\n        while stack[-1] != v:\n            nv, ei = stack.pop()\n            color[ei] = cycle_color\n        nv, ei = stack.pop()\n        color[ei] = cycle_color\n        return True\n    visited[v] = True\n    stack.append((v, -1))\n    for nv, ei in graph[v]:\n        stack[-1] = (v, ei)\n        if dfs(nv):\n            return True\n    stack.pop()\n    return False\n \nfor cycle_color in range(n):\n    for v in range(n):\n        if visited[v]:\n            continue\n        if dfs(v):\n            break\n    else:\n        break\n \nprint(cycle_color + 1)\nprint(*[max(1, c) for c in color]"
 ],
 "1188": [
  "from bisect import bisect_left\n\nn = int(input())\na = list(map(int, input().split()))\n\ndef prairie_partition(x):\n    k = (x.bit_length()-1)\n    r = x - (2**k)\n    return [1]*(k+1-r) + [2]*r\n\nb = []\nfor x in a:\n    b.extend(prairie_partition(x))\nb.sort()\n\nm = []\nfor i in range(len(b)):\n    index = bisect_left(b, b[i]+1)\n    if index - i > 1:\n        m.append(index-i)\n\nif len(m) == 0:\n    print(-1)\nelse:\n    print(*m)"
 ],
 "1189": [
  "n, c = map(int, input().split())\nMOD = 1000003\n\nfac = [1]*(n+c+1)\nfor i in range(1, n+c+1):\n    fac[i] = (fac[i-1]*i) % MOD\n\ninv_fac = [1]*(n+c+1)\ninv_fac[n+c] = pow(fac[n+c], MOD-2, MOD)\nfor i in range(n+c-1, -1, -1):\n    inv_fac[i] = (inv_fac[i+1]*(i+1)) % MOD\n\ndef nCr(n, r):\n    if n<r or n<0 or r<0:\n        return 0\n    return (fac[n]*inv_fac[r]*inv_fac[n-r]) % MOD\n\n\ndp = [0]*(n+1)\ndp[0] = 1\nfor i in range(1, n+1):\n    dp[i] = (sum(dp[j]*nCr(c+i-j-1, i-j-1) for j in range(i))) % MOD\n\nprint(dp[n])"
 ],
 "1190": [
  "w1, h1, w2, h2 = map(int, input().split())\nprint((w1 + 2) * (h1 + h2 + 1) - w2 * h2 - 1)"
 ],
 "1191": [
  "n, k = map(int, input().split())\np = list(map(int, input().split()))\nc = list(map(int, input().split()))\n\nkp = sorted(range(n), key=lambda i: p[i])\nans = [-10 ** 18] * n\nfor i in range(n):\n    j = kp[i]\n    csum = [c[j]]\n    for l in range(max(i - k, 0), i):\n        csum.append(c[kp[l]] + csum[-1])\n    for l in range(len(csum)):\n        ans[kp[i]] = max(ans[kp[i]], csum[l] + (csum[-1] * (l+1)) + (ans[kp[max(0, i-k-1)]] if i - k > 0 else 0))\nfor i in ans: \n  print(i, end=' ')"
 ],
 "1192": [
  "from itertools import combinations\nfrom math import comb\n\nn, k = map(int, input().split())\np = list(map(int, input().split()))\n\ninv_count = 0\nfor i in range(n):\n    for j in range(i + 1, n):\n        if p[i] > p[j]:\n            inv_count += 1\n\nprob = 0\nfor l in range(n):\n    for r in range(l + 1, n + 1):\n        interval_len = r - l\n        reverse_count = comb(interval_len, 2)\n        for num_reverse in range(k + 1):\n            if num_reverse > interval_len // 2:\n                break\n            if (k - num_reverse) % 2 == 1:\n                continue\n            prob_reverse = comb(reverse_count, num_reverse) * comb(comb(n, interval_len), k - num_reverse)\n            prob += ((-1) ** num_reverse) * prob_reverse\n\nprint(inv_count * prob / comb(n, 2))"
 ],
 "1193": [
  "n, k = map(int, input().split())\nspeeds = list(map(int, input().split()))\n\nspeeds.sort()\n\nprint(speeds[-k])"
 ],
 "1194": [
  "n = int(input())\np = list(map(int, input().split()))\nq = list(map(int, input().split()))\n\ninv_p = [0] * n\ninv_q = [0] * n\nfor i in range(n):\n    inv_p[p[i]] = i\n    inv_q[q[i]] = i\n\nans = [0] * n\ncarry = 0\nfor i in range(n):\n    p_val = inv_p[i]\n    q_val = inv_q[i]\n    temp_sum = p_val + q_val + carry\n    ans[i] = temp_sum % n\n    carry = temp_sum // n\n\nans_perm = [0] * n\nfor i in range(n):\n    current_val = ans[i]\n    current_perm = 0\n    for j in range(n - 1, -1, -1):\n        if (current_perm >> j) & 1:\n            continue\n        if current_val == 0:\n            current_perm |= 1 << j\n        else:\n            current_val -= 1\n    ans_perm[i] = current_perm\n\nprint(*ans_perm)"
 ],
 "1195": [
  "n = int(input())\na = list(map(int, input().split()))\na.sort()\nprint(a[-2])"
 ],
 "1196": [
  "n, m = map(int,input().split())\nt = []\nfor i in input().split():\n    l, c = i.split(\"-\")\n    t.extend([c]*int(l))\ns = []\nfor i in input().split():\n    l, c = i.split(\"-\")\n    s.extend([c]*int(l))\n    \ndef hash(s):\n    h = 0\n    for c in s:\n        h = 27*h + ord(c) - 96\n    return h\n\nh_s = hash(s)\nh_t = hash(t[:len(s)])\n\ncount = 0\nif h_s == h_t:\n    count += 1\n\nfor i in range(len(s), len(t)):\n    h_t = 27*(h_t - ord(t[i-len(s)])*27**(len(s)-1)) + ord(t[i]) - 96\n    if h_s == h_t:\n        count += 1\n\nprint(count)"
 ],
 "1197": [
  "MOD = 10**9 + 7\ns = input()\nn = len(s)\n\ndp0 = dp1 = dp2 = dpq = 1\n\nfor i in range(n):\n    if s[i] == '0':\n        dp2 = dp2\n        dpq = 0\n        dp1 = dp0\n        dp0 = 0\n    elif s[i] == '1':\n        dp2 = (dp2 + dp1) % MOD\n        dpq = 0\n        dp1 = dp0\n        dp0 = 0\n    elif s[i] == '2':\n        dp2 = dp1\n        dpq = 0\n        dp1 = dp0\n        dp0 = 0\n    elif s[i] == '*':\n        dp0, dp1, dp2 = dp1, dp2, (dp1 + dp2) % MOD\n    else:\n        dps = dp0 + dp1 + dp2\n        dp2 = (dp2 + dp1) % MOD\n        dp1 = dp0\n        dp0 = dps % MOD\n\nprint(dpq * (dp0 + dp1 + dp2) % MOD)"
 ],
 "1198": [
  "import heapq\n\nn, c = map(int, input().split())\na = list(map(int, input().split()))\n\nprefix_sum = [0] * (n + 1)\nfor i in range(n):\n    prefix_sum[i+1] = prefix_sum[i] + a[i]\n\nmin_heap = []\nheapq.heappush(min_heap, (0, -1, 0))\ndp = []\nfor i in range(n):\n    min_val, idx, b_idx = min_heap[0]\n    cur_val = prefix_sum[i+1] - prefix_sum[b_idx] - min_val\n    dp.append(cur_val)\n    if i//c > idx:\n        heapq.heappop(min_heap)\n        min_val, idx, b_idx = min_heap[0]\n    heapq.heappush(min_heap, (prefix_sum[i+1]-prefix_sum[b_idx]-dp[b_idx], i//c, i+1))\n\nprint(dp[-1])"
 ],
 "1199": [
  "n, m = map(int, input().split())\ncolors = list(map(int, input().split()))\npairs = [0]*m\nleft, right = [], []\n\nfor i in range(n):\n    if len(left) < len(right):\n        if pairs[colors[i] - 1]:\n            left.append(pairs[colors[i] - 1])\n            right.append(i+1)\n            pairs[colors[i] - 1] = 0\n        else:\n            pairs[colors[i] - 1] = i+1\n    else:\n        if pairs[colors[i] - 1]:\n            left.append(i+1)\n            right.append(pairs[colors[i] - 1])\n            pairs[colors[i] - 1] = 0\n        else:\n            pairs[colors[i] - 1] = i+1\n\nprint(len(left))\nfor i in range(len(left)):\n    print(left[i], right[i])"
 ],
 "1200": [
  "n = int(input())\nx = list(map(int, input().split()))\ndistances = [x[i+1] - x[i] for i in range(n-1)]\ngcd = distances[0]\nfor i in range(1, n-1):\n    gcd = math.gcd(gcd, distances[i])\nm = sum([(distances[i] // gcd) - 1 for i in range(n-1)])\nprint(m)"
 ],
 "1201": [
  "n = int(input())\nitems = []\nfor i in range(n):\n    ti, di, pi = map(int, input().split())\n    items.append((ti, di, pi, i+1))\n\n# sort items by their burning time in ascending order\nitems = sorted(items, key=lambda x: x[1])\n\n# dp[i][j] represents the maximum value that can be saved using the items up to i, with j seconds left\ndp = [[0 for _ in range(2001)] for _ in range(n+1)]\n\n# choice[i][j] represents whether we choose to save item i or not, when there are j seconds left\nchoice = [[-1 for _ in range(2001)] for _ in range(n+1)]\n\nfor i in range(1, n+1):\n    for j in range(1, 2001):\n        ti, di, pi, _ = items[i-1]\n        # if we can't save the item, just take the value from the previous item\n        if ti >= di:\n            dp[i][j] = dp[i-1][j]\n        else:\n            # if we don't have enough time to save the item, take the value from the previous item\n            if ti > j:\n                dp[i][j] = dp[i-1][j]\n            else:\n                # else, decide whether to take the item or not\n                val_with_item = dp[i-1][j-ti] + pi\n                val_without_item = dp[i-1][j]\n                if val_with_item > val_without_item:\n                    dp[i][j] = val_with_item\n                    choice[i][j] = 1\n                else:\n                    dp[i][j] = val_without_item\n\n# find the items that were saved\nsaved_items = []\nj = 2000\nfor i in range(n, 0, -1):\n    if choice[i][j] == 1:\n        saved_items.append(items[i-1][3])\n        j -= items[i-1][0]\n\nprint(dp[n][2000])\nprint(len(saved_items))\nprint(*saved_items[::-1])"
 ],
 "1202": [
  "n = int(input())\na = [tuple(map(int, input().split())) for _ in range(n)]\nb = [tuple(map(int, input().split())) for _ in range(n)]\n\nfinalists_a = [0]*n\nfinalists_b = [0]*n\n\nfor k in range(n+1):\n    for i in range(k):\n        finalists_a[i] = 1\n        finalists_b[i] = 1\n    for i in range(n-2*k):\n        if a[k+i][1] < b[k+i][1]:\n            finalists_a[k+i] = 1\n        else:\n            finalists_b[k+i] = 1\n    \nprint(\"\".join(map(str, finalists_a)))\nprint(\"\".join(map(str, finalists_b)))"
 ],
 "1203": [
  "h, l = map(int, input().split())\nprint(((l**2) - (h**2)) / (2*h))"
 ],
 "1204": [
  "n, k = map(int, input().split())\nfighters = []\nfor i in range(n):\n    p, e = map(int, input().split())\n    fighters.append((p, e))\n\n# Sort fighters in descending order of tournament points\nfighters.sort(reverse=True)\nscore_needed = fighters[k-1][0]  # Score needed to be at least k-th\n\n# Check if Manao can achieve the required score\nif score_needed < fighters[0][0]:\n    print(-1)\nelse:\n    # Try all possible combinations of fights\n    min_effort = float('inf')\n    for i in range(2**n):\n        fights_won = []\n        effort = 0\n        for j in range(n):\n            if i & (1 << j):\n                effort += fighters[j][1]\n                fights_won.append(j)\n        if len(fights_won) < k - 1:\n            continue\n        scores = [fighters[j][0] + (1 if j in fights_won else 0) for j in range(n)]\n        scores.sort(reverse=True)\n        if scores.index(score_needed) < k:  # Manao can achieve the required rank\n            min_effort = min(min_effort, effort)\n    if min_effort == float('inf'):\n        print(-1)\n    else:\n        print(min_effort)"
 ],
 "1205": [
  "from collections import defaultdict\nfrom fractions import Fraction\n\nn = int(input())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\ncount = 0\nfor i in range(n):\n    slopes = defaultdict(int)\n    for j in range(n):\n        if i == j:\n            continue\n        dx, dy = points[j][0] - points[i][0], points[j][1] - points[i][1]\n        if dx == 0:\n            slope = float(\"inf\")\n        else:\n            slope = Fraction(dy, dx)\n        slopes[slope] += 1\n\n    for slope, multiplicity in slopes.items():\n        symmetric_multiplicity = slopes[Fraction(-slope.denominator, slope.numerator)]\n        if symmetric_multiplicity == multiplicty:\n            count += 1\n\nans = count // 2\nif ans == 0:\n    print(\"-1\")\nelse:\n    print(ans)"
 ],
 "1206": [
  "n = int(input())\n\nbids = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    bids.append((l, r))\n\ndef expected_value(bids):\n    total_prob = 1.0\n    total_value = 0.0\n    max_bid = float('-inf')\n    for i, (l, r) in enumerate(bids):\n        total_prob *= 1.0 / (r - l + 1)  # probability of choosing the bid for the i-th company\n        max_bid = max(max_bid, l)  # initialize max_bid as the lower bound of the i-th company's bid range\n        for j, (tl, tr) in enumerate(bids):\n            if i == j:  # don't compare with itself\n                continue\n            # update max_bid to the highest bid that's not from the i-th company\n            max_bid = max(max_bid, tl if l > tr else (tr if r < tl else max(l, tl)))\n        total_value += max_bid * total_prob  # add the expected value of the i-th company's winning to the total\n    return total_value\n\nprint(f'{expected_value(bids):.10f}')"
 ],
 "1207": [
  "from collections import deque\n\nn, m = map(int, input().split())\n\nin_degree = [0] * n\ngraph = [[] for _ in range(n)]\n\nfor _ in range(m):\n    u, v = map(int, input().split())\n    graph[u-1].append(v-1)\n    in_degree[v-1] += 1\n\nqueue = deque()\nfor i in range(n):\n    if in_degree[i] == 0:\n        queue.append(i)\n\nsorted_order = []\nwhile queue:\n    if len(queue) > 1:  # there are multiple ways to sort the robots\n        print(-1)\n        break\n    node = queue.popleft()\n    sorted_order.append(node)\n    for neighbor in graph[node]:\n        in_degree[neighbor] -= 1\n        if in_degree[neighbor] == 0:\n            queue.append(neighbor)\nelse:  # all robots can be sorted uniquely\n    print(len(sorted_order))"
 ],
 "1208": [
  "n = int(input())\ns = set()\nans = 0\ncur = 0\nfor i in range(n):\n    a, x = input().split()\n    x = int(x)\n    if a == '+':\n        s.add(x)\n        cur += 1\n        ans = max(ans, cur)\n    else:\n        if x not in s:\n            ans += 1\n        else:\n            s.remove(x)\n        cur -= 1\nprint(ans)"
 ],
 "1209": [
  "n = int(input())\na = [float(input()) for i in range(n)]\nb = [int(i) for i in a]\nfor i in range(n):\n    if sum(b) == 0:\n        break\n    if b[i] == a[i] or abs(b[i] - a[i]) > 0.5:\n        if a[i] > 0:\n            b[i] = int(a[i])\n        else:\n            b[i] = int(a[i] + 1)\nprint('\\n'.join(map(str,b)))"
 ],
 "1210": [
  "from itertools import product\nfrom math import comb\n\nn, p = map(int, input().split())\nranges = [tuple(map(int, input().split())) for _ in range(n)]\n\ntotal_combinations = comb(n, 2) + n\ntotal_money = 0\ntotal_prob = 0\n\nfor combo in product(*[range(l, r+1) for l, r in ranges]):\n    j = combo[-1]\n    for i in range(n):\n        if i == 0:\n            i = n-1\n        else:\n            i -= 1\n        if combo[i] * j % p == 0:\n            total_money += 1000\n            break\n    total_prob += 1\n\nprint(total_money / total_prob)"
 ],
 "1211": [
  "n, k = map(int, input().split())\nboxes = list(map(int, input().split()))\n\nmax_hamsters = 0\nmax_box_type = 0\nfor i in range(k):\n    if n % boxes[i] > max_hamsters:\n        max_hamsters = n % boxes[i]\n        max_box_type = i\n\nprint(max_box_type+1, n//boxes[max_box_type])"
 ],
 "1212": [
  "n, k = map(int, input().split())\nheights = list(map(int, input().split()))\n\nmin_sum = float('inf')\nmin_idx = 0\n\nfor i in range(n-k+1):\n    sum_heights = sum(heights[i:i+k])\n    if sum_heights < min_sum:\n        min_sum = sum_heights\n        min_idx = i + 1\n\nprint(min_idx)"
 ],
 "1213": [
  "n, k = map(int, input().split())\nslogan = input()\n\nif k <= n//2:\n    for i in range(k-1):\n        print(\"LEFT\")\n    for i in range(n):\n        print(\"PRINT\", slogan[i])\n        if i != n-1:\n            print(\"RIGHT\")\nelse:\n    for i in range(n-k):\n        print(\"RIGHT\")\n    for i in range(n-1, -1, -1):\n        print(\"PRINT\", slogan[i])\n        if i != 0:\n            print(\"LEFT\")"
 ],
 "1214": [
  "from math import isqrt\nn = int(input())\nx = list(map(int, input().split()))\n\ncum_sum = [0] * (n // 2)\ncum_sum[0] = x[0]\nfor i in range(1, n // 2):\n    cum_sum[i] = cum_sum[i-1] + x[i]\n\nresult = [0] * n\nresult[1] = x[0]\n\nfor i in range(1, n // 2):\n    prev = result[2*i-2]\n    idx = 2*i\n    res = cum_sum[i-1] + prev\n    next_perfect_square = isqrt(res + x[i])\n    if next_perfect_square**2 != res + x[i]:\n        next_perfect_square += 1\n    result[idx-1] = next_perfect_square**2 - res\n    result[idx] = x[i]\n\nif all(result):\n    print(\"Yes\")\n    print(*result)\nelse:\n    print(\"No\")"
 ],
 "1215": [
  "n = int(input())\ndp = [0] * (n + 1)\ndp[0] = 1\nfor i in range(2, n + 1, 2):\n    dp[i] = dp[i - 2] * 3\n    for j in range(4, i + 1, 2):\n        dp[i] += 2 * dp[i - j]\nprint(dp[n])"
 ],
 "1216": [
  "n = int(input())\ns = input()\nvowels = set(['a', 'e', 'i', 'o', 'u', 'y'])\n\ni = 0\nans = []\nwhile i < n:\n    curr_char = s[i]\n    ans.append(curr_char)\n\n    if curr_char in vowels:\n        # Check if next characters are consecutive vowels\n        count = 1\n        for j in range(i+1, n):\n            if s[j] != curr_char:\n                break\n            count += 1\n\n        if curr_char in ['e', 'o'] and count == 2:\n            # Do not transform consecutive 'e' or 'o' that appear twice\n            pass\n        else:\n            # Combine consecutive vowels to a single vowel\n            ans[-1] = curr_char\n    i += 1\n\nprint(\"\".join(ans))"
 ],
 "1217": [
  "n, m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\na.sort()\n\nfor j in b:\n    l = 0\n    r = n - 1\n    while l <= r:\n        mid = (l+r)//2\n        if a[mid] > j:\n            r = mid - 1\n        else:\n            l = mid + 1\n    print(l, end=\" \")"
 ],
 "1218": [
  "n, k = map(int, input().split())\n\nleft = 1\nright = k\n\nwhile left <= right:\n    mid = (left+right) // 2\n    pipes = 1\n    for i in range(mid):\n        pipes *= 2\n        if pipes > n:\n            break\n    pipes -= 1\n    if pipes < n:\n        left = mid + 1\n    elif pipes >= n:\n        right = mid - 1\n\nif right == 0:\n    print(-1)\nelse:\n    print(right)"
 ],
 "1219": [
  "n = int(input())\na = list(map(int, input().split()))\n\nfor i in range(n-1):\n    a[i+1] += a[i]\n    a[i] = -a[i]\n\nprint(max(a))"
 ],
 "1220": [
  "from collections import defaultdict\n\nn, m = map(int, input().split())\n\ngraph = defaultdict(set)\n\nfor i in range(m):\n    x, y = map(int, input().split())\n    graph[x].add(y)\n    graph[y].add(x)\n\nvisited = set()\n\ncomponents = []\n\ndef dfs(node, component):\n    visited.add(node)\n    component.add(node)\n    for neighbor in graph[node]:\n        if neighbor not in visited:\n            dfs(neighbor, component)\n\nfor i in range(1, n+1):\n    if i not in visited:\n        component = set()\n        dfs(i, component)\n        components.append(len(component))\n\nprint(len(components))\nprint(*sorted(components))"
 ],
 "1221": [
  "n, m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\na.sort()  # Why sorting?\nb.sort()  # Why sorting?\n\nans1 = min(a[:-1]) * max(b)\nans2 = max(a) * max(b[1:])\nprint(max(ans1, ans2))"
 ],
 "1222": [
  "k = int(input())\nq = list(range(1, 10))\n\nfor _ in range(k-1):\n    num = q.pop(0)\n    last_digit = num % 10\n    if last_digit > 0:\n        q.append(num*10 + last_digit - 1)\n    q.append(num*10 + last_digit)\n    if last_digit < 9:\n        q.append(num*10 + last_digit + 1)\n\nprint(q[0])"
 ],
 "1223": [
  "n = int(input())\np = list(map(int, input().split()))\n\nmax1 = max2 = -1\nfor i in range(n):\n    if p[i] > max1:\n        max2 = max1\n        max1 = p[i]\n    elif p[i] > max2:\n        max2 = p[i]\n\nsecond_largest = [-1] * n\nfor i in range(n-1):\n    if p[i] == max1:\n        second_largest[i] = max2\n    else:\n        second_largest[i] = max1\n\n    for j in range(i+1, n-1):\n        if p[j] > second_largest[j-1]:\n            second_largest[j-1] = p[j]\n\nans = 0\nfor i in range(n-1):\n    for j in range(i+1, n):\n        ans += second_largest[i] if j == i+1 else max(second_largest[i], p[j-2])\n\nprint(ans)"
 ],
 "1224": [
  "n = int(input())\n\nfound = False\nfor i in range(60):\n    for j in range(60):\n        if 3**i + 5**j == n:\n            print(i, j)\n            found = True\n            break\n    if found:\n        break\nelse:\n    print(-1)"
 ],
 "1225": [
  "h = int(input())\n\ncount = 0\nwhile h>0:\n    count +=1\n    h //=2\n\nprint(2**count - 1)"
 ],
 "1226": [
  "n, a, b = map(int, input().split())\n\nMOD = 10**9 + 7\n\ndef nCk(n, k, MOD):\n    if k > n-k:\n        k = n-k\n    numerator = 1\n    denominator = 1\n    for i in range(1, k+1):\n        numerator = (numerator * (n-i+1)) % MOD\n        denominator = (denominator * i) % MOD\n    return numerator * pow(denominator, MOD-2, MOD) % MOD\n\nans = pow(2, n, MOD) - 1\nans -= nCk(n, a, MOD) + nCk(n, b, MOD)\n\nprint(ans % MOD)"
 ],
 "1227": [
  "N = input()\nK = int(input())\n\ncount = 0\n\nif K == 1:\n    count = len(N.replace('0', ''))\n    \nelif K == 2:\n    for i in range(1,10):\n        for j in range(1,10):\n            count += N.count(str(i) + str(j))\n    \nelse:\n    for i in range(1,10):\n        for j in range(1,10):\n            for k in range(1,10):\n                digits = str(i) + str(j) + str(k)\n                count += N.count(digits)\n                \nprint(count)"
 ],
 "1228": [
  "x = int(input())\nif x%4 == 3:\n    print(0, 'A')\nelif x%4 == 1:\n    print(0, 'B')\nelif x%4 == 2:\n    print(1, 'A')\nelse:\n    print(1, 'B')"
 ],
 "1229": [
  "n,m = map(int,input().split())\nstrings = []\nfor i in range(n):\n    s = input()\n    strings.append(s)\n \ncosts = []\nfor i in range(n):\n    c = list(map(int,input().split()))\n    costs.append(c)\n    \nINF = 1 << 30\nans = INF\n\nfor mask in range(1<<(n*m)):\n    ok = True\n    for col in range(m):\n        for row in range(n):\n            if not (mask & (1<<(row*m + col))):\n                continue\n            for r in range(n):\n                if r == row:\n                    continue\n                if strings[r][col] == strings[row][col]:\n                    ok = False\n            cost = 0\n            for r in range(n):\n                if strings[r][col] == strings[row][col]:\n                    if not(mask & (1<<(r*m + col))):\n                        cost += costs[r][col]\n            if cost > 0:\n                ans = min(ans, cost)\n    if ok:\n        cost = 0\n        for i in range(n):\n            for j in range(m):\n                if not (mask & (1<<(i*m + j))):\n                    continue\n                cost += costs[i][j]\n        ans = min(ans, cost)\n \nprint(ans)"
 ],
 "1230": [
  "n = int(input())\na = list(map(int, input().split()))\n\nlow = max(0, n-sum(a))\nhigh = n-len([i for i in a if i==n-1])\n\nif low > high:\n    print(-1)\nelse:\n    ans = []\n    for i in range(low, high+1):\n        if i <= n-1-a.count(0):\n            ans.append(i)\n    print(*ans)"
 ],
 "1231": [
  "a, b = map(int, input().split())\nif abs(a-b) <= 1 and max(a,b)%2 == 1:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "1232": [
  "nA, nB = map(int, input().split())\nk, m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nif a[k-1]<b[-m]:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "1233": [
  "n = int(input())\narr = list(map(int, input().split()))\nswaps = []\nfor i in range(n-1):\n    if arr[i] > arr[i+1]:\n        swaps.append((i, i+1))\n\ncount = len(swaps)\nfor i, j in swaps:\n    arr[i], arr[j] = arr[j], arr[i]\n    new_swaps = []\n    for k in range(n-1):\n        if arr[k] > arr[k+1]:\n            new_swaps.append((k, k+1))\n    if len(new_swaps) > count:\n        count = len(new_swaps)\n        ans = 1\n    elif len(new_swaps) == count:\n        ans += 1\n    arr[i], arr[j] = arr[j], arr[i]\nprint(count, ans)"
 ],
 "1234": [
  "n, m, k = map(int, input().split())\na = list(map(int, input().split()))\n\nprefix_sum = [0] * (n+1)\nfor i in range(1, n+1):\n    prefix_sum[i] = prefix_sum[i-1] + a[i-1]\n\npair_list = []\nfor i in range(m-1, n):\n    pair_list.append((prefix_sum[i+1] - prefix_sum[i-m+1], i+1-m+1))\n\npair_list.sort(reverse=True)\n\nsubarray_indices = []\nfor i in range(k-1):\n    subarray_indices.append(pair_list[i][1])\n\nsubarray_indices.sort()\n\nsubarray_indices.insert(0, 0)\nsubarray_indices.append(n)\n\nbeauty_sum = 0\nfor i in range(1, k+1):\n    beauty_sum += prefix_sum[subarray_indices[i]] - prefix_sum[subarray_indices[i-1]]\n    subarray_indices[i] += 1\n\nprint(beauty_sum)\nprint(*subarray_indices[1:-1])"
 ],
 "1235": [
  "n = int(input())\na = sorted(list(set(map(int, input().split()))))\nm = int(input())\nb = sorted(list(set(map(int, input().split()))))\nfor ai in a:\n    for bi in b:\n        if ai+bi+1 not in a and ai+bi+1 not in b:\n            print(ai,bi)\n            exit()"
 ],
 "1236": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\nodd = evn = 0\nfor i in range(n):\n    if a[i]%2 == 1:\n        odd += 1\n    else:\n        evn += 1\nif k == n:\n    if odd%2 == 0:\n        print(\"Daenerys\")\n    else:\n        print(\"Stannis\")\nelse:\n    if k%2 == 0:\n        if odd <= k // 2 and evn >= (n - k + 1) // 2:\n            print(\"Daenerys\")\n        else:\n            print(\"Stannis\")\n    else:\n        if odd <= k // 2 or (odd - (k // 2 + 1)) % 2 == 0 and evn >= (n - k + 1) // 2:\n            print(\"Daenerys\")\n        else:\n            print(\"Stannis\")"
 ],
 "1237": [
  "n,s = map(int,input().split())\n\narr = []\n\nfor i in range(n):\n    f,t = map(int,input().split())\n    arr.append([f,t])\n    \narr = sorted(arr,key=lambda x: (-x[0],-x[1]))\n\ntime = s\n\nfor i in arr:\n    time += (i[0]-time) + i[1]\n    \nprint(time)"
 ],
 "1238": [
  "n = int(input())\na = list(map(int, input().split()))\na.sort()\ncount = 0\nfor i in range(n-1):\n    if a[i] != a[i+1]-1:\n        count += a[i+1]-a[i]-1\nprint(count)"
 ],
 "1239": [
  "n = int(input())\na = list(map(int, input().split()))\na.sort()\nmini_diff = a[n-1] - a[0]\nans = 0\nfor i in range(1, n):\n    diff = a[i] - a[i-1]\n    if diff < mini_diff:\n        mini_diff = diff\n        ans = 1\n    elif diff == mini_diff:\n        ans += 1\n\nprint(mini_diff, ans)"
 ],
 "1240": [
  "n = int(input())\nlegs = []\nL = R = 0\nfor i in range(n):\n    l, r = map(int, input().split())\n    legs.append((l, r, i+1))\n    L += l\n    R += r\nmax_beauty = abs(L - R)\nmax_index = 0\nfor i in range(n):\n    l, r, index = legs[i]\n    beauty = abs((L - l + r) - (R - r + l))\n    if beauty > max_beauty:\n        max_beauty = beauty\n        max_index = index\nprint(max_index)"
 ],
 "1241": [
  "# Reading input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Performing binary search\nl, r = 0, n\nwhile l < r:\n    mid = (l + r + 1) // 2\n    cnt = 0\n    mx_len = 0\n    for i in range(n):\n        if a[i] == 0:\n            cnt += 1\n            if cnt > k:\n                j = i - mx_len\n                if a[j] == 0:\n                    cnt -= 1\n                while j < i and a[j] == 1:\n                    j += 1\n                    mx_len -= 1\n                j += 1\n                mx_len = max(mx_len, i - j + 1)\n        else:\n            mx_len += 1\n    if cnt <= k:\n        l = mid\n    else:\n        r = mid - 1\n\n# Printing output\nprint(l)\ncnt = 0\nfor i in range(n):\n    if a[i] == 0 and cnt < k and (i == 0 or a[i-1] == 1) and (i == n-1 or a[i+1] == 1):\n        print(1, end=' ')\n        cnt += 1\n    else:\n        print(a[i], end=' ')\nprint()"
 ],
 "1242": [
  "python\ns = input()\nn = len(s)\nres = [0] * n\nfor i in range(1, n):\n    if s[i] != s[i-1]:\n        res[i-1] = 1\n        res[i] = 1\nprint(*res)"
 ],
 "1243": [
  "n = int(input())\nmatches = list(map(int, input().split()))\n\navg = sum(matches) // n\nmoves = 0\n\nfor i in range(n-1):\n    diff = matches[i] - avg\n    matches[i+1] += diff\n    moves += abs(diff)\n\nprint(moves)"
 ],
 "1244": [
  "n = int(input())\na = list(map(int, input().split()))\ndistinct_elements = set(a)\nmax_frequency = max(a.count(x) for x in distinct_elements)\nif max_frequency <= (n + 1) // 2:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "1245": [
  "n = int(input())\nseg = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    seg.append((l, r))\n\nseg.sort()\n\ndp = [[False] * (n + 1) for _ in range(n + 1)]\ndp[0][0] = True\n\nfor i in range(n):\n    for j in range(n + 1):\n        if dp[i][j]:\n            if j + 1 <= n:\n                l, r = seg[i]\n                if l <= j + 1 <= r:\n                    dp[i + 1][j + 1] = True\n            if j > 0:\n                if dp[i][j - 1]:\n                    dp[i + 1][j - 1] = True\n\nif not dp[n][0]:\n    print(\"IMPOSSIBLE\")\nelse:\n    ans = [0] * (2 * n)\n    j = 0\n    for i in range(n):\n        l, r = seg[i]\n        if j + 1 <= n and dp[i + 1][j + 1]:\n            ans[j] = \"(\"\n            ans[j + l + r] = \")\"\n            j += 1\n        else:\n            ans[j] = \")\"\n            ans[j + l + r] = \"(\"\n            j -= 1\n    print(\"\".join(ans))"
 ],
 "1246": [
  "import heapq\n\ndef solve(n, operations):\n    ans = []\n    heap = []\n    for op in operations:\n        op = op.split()\n        if op[0] == \"insert\":\n            ans.append(op)\n            heapq.heappush(heap, int(op[1]))\n        elif op[0] == \"getMin\":\n            val = int(op[1])\n            while heap and heap[0] < val:\n                ans.append([\"removeMin\"])\n                heapq.heappop(heap)\n            if not heap or heap[0] != val:\n                ans.append([\"insert\", str(val)])\n                heapq.heappush(heap, val)\n            ans.append(op)\n        else:\n            if not heap:\n                ans.append([\"insert\", \"1\"])\n                ans.append(op)\n                continue\n            ans.append(op)\n            heapq.heappop(heap)\n    return ans\n\nn = int(input())\nops = [input() for _ in range(n)]\nans = solve(n, ops)\nprint(len(ans))\nfor op in ans:\n    print(\" \".join(op))"
 ],
 "1247": [
  "s = input()\nfreq = [0]*26\nfor i in s:\n    freq[ord(i) - ord('a')] += 1\nodd_freq_count = 0\nfor f in freq:\n    if f % 2 != 0:\n        odd_freq_count += 1\nif odd_freq_count == 0 or odd_freq_count % 2 != 0:\n    print(\"First\")\nelse:\n    print(\"Second\")"
 ],
 "1248": [
  "d1, d2, d3 = map(int, input().split())\n\nprint(min(d1+d2+d3, 2*d1+2*d2, 2*d1+2*d3, 2*d2+2*d3))"
 ],
 "1249": [
  "m, k, n, s = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nb_freq = {x:0 for x in b}\nfor x in a[:k*n]:\n    if x in b:\n        b_freq[x] += 1\n\ntarget_freq = {x:b_freq[x]-a[:k*n].count(x) for x in b if b_freq[x]-a[:k*n].count(x)>0}\nif len(target_freq) == 0:\n    print(0)\n    exit()\n\nremove = []\nok = False\nfor i in range(n-1):\n    for j in range(k-1,-1,-1):\n        pos = i*k+j\n        if a[pos] in target_freq and target_freq[a[pos]] > 0:\n            target_freq[a[pos]] -= 1\n            remove.append(pos)\n            ok = True\n            break\n    if ok:\n        ok = False\n    else:\n        print(-1)\n        exit()\n\nprint(len(remove))\nprint(' '.join(map(str, [x+1 for x in remove])))"
 ],
 "1250": [
  "n = int(input())\nif n <= 2:\n    print(-1)\nelse:\n    counter_example = [i for i in range(n, 0, -1)]\n    print(*counter_example)"
 ],
 "1251": [
  "n = int(input())\nheights = list(map(int, input().split()))\n\ns = []\nans = 0\nfor i in range(n):\n    while s and s[-1] > heights[i]:\n        s.pop()\n        ans += 1\n    if s and s[-1] != heights[i]:\n        ans += 1\n    s.append(heights[i])\nans += len(set(heights))\nprint(ans)"
 ],
 "1252": [
  "from collections import deque\n\nn, m, T = map(int, input().split())\n\ng = [set() for _ in range(n)]\nfor _ in range(m):\n    u, v, w = map(int, input().split())\n    g[u - 1].add((v - 1, w))\n\n# bfs\nq = deque([(0, 0)])\nd = [-1] * n\nd[0] = 0\np = [-1] * n\n\nwhile q:\n    v, w = q.popleft()\n    for to, cost in g[v]:\n        if d[to] == -1 or d[to] > d[v] + cost:\n            d[to] = d[v] + cost\n            p[to] = v\n            q.append((to, d[to]))\n\n# restore path\npath = []\nv = n - 1\nwhile v != -1:\n    path.append(v + 1)\n    v = p[v]\n\npath.reverse()\n\n# output\nk = len(path)\nprint(k)\n\nprint(*path)\n"
 ],
 "1253": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\nneg = sum(1 for i in a if i < 0)\nfor i in range(min(neg, k)):\n    a[i] = -a[i]\nk -= neg\nif k % 2:\n    a[a.index(min(a))] = -a[a.index(min(a))]\nprint(sum(a))"
 ],
 "1254": [
  "n, m = map(int, input().split())\nsubj = [[] for _ in range(m)]\nfor i in range(n):\n    s, r = map(int, input().split())\n    subj[s-1].append(r)\nfor i in range(m):\n    subj[i].sort(reverse=True)\nmin_num = n\nans = 0\nwhile min_num > 0:\n    sum_skill = 0\n    for i in range(m):\n        if len(subj[i]) < min_num:\n            min_num = len(subj[i])\n        for j in range(min_num):\n            sum_skill += subj[i][j]\n    ans = max(ans, sum_skill)\nprint(ans)"
 ],
 "1255": [
  "n = int(input())\ncustomers = []\nfor _ in range(n):\n    h, m = map(int, input().split())\n    customers.append((h, m))\n\ncash_count = 1\nmax_cash_count = 1\nfor i in range(1, n):\n    if customers[i] == customers[i-1]:\n        cash_count += 1\n    else:\n        max_cash_count = max(max_cash_count, cash_count)\n        cash_count = 1\n\nmax_cash_count = max(max_cash_count, cash_count)\n\nprint(max_cash_count)"
 ],
 "1256": [
  "s = input().split(\"+\")\ns.sort()\nprint(\"+\".join(s))"
 ],
 "1257": [
  "n, k = map(int, input().split())\n\ntable = [[0] * n for i in range(n)]\n\ncur_num = 1\n\nfor j in range(n):\n  if j == k-1:\n    cur_sum = 0\n    for i in range(n):\n      table[i][j] = n*n - (n-1)*i\n      cur_sum += table[i][j]\n    print(cur_sum)\n  else:\n    for i in range(n):\n      table[i][j] = cur_num\n      cur_num += 1\n      \nfor row in table:\n  print(\" \".join(str(num) for num in row))"
 ],
 "1258": [
  "from collections import defaultdict\n\nn = int(input())\nq = [tuple(map(int, input().split())) for _ in range(n-2)]\n\n# Build adjacency list\nadj_list = defaultdict(list)\nfor x,y,z in q:\n    adj_list[x].append(y)\n    adj_list[x].append(z)\n    adj_list[y].append(x)\n    adj_list[y].append(z)\n    adj_list[z].append(x)\n    adj_list[z].append(y)\n\n# Find the endpoints of the permutation\nendpoints = []\nfor node in adj_list:\n    if len(adj_list[node]) == 2:\n        endpoints.append(node)\n\n# Build the permutation\np = [endpoints[0]]\nwhile len(p) < n:\n    for nxt in adj_list[p[-1]]:\n        if nxt not in p:\n            p.append(nxt)\n            break\n\nprint(*p)"
 ],
 "1259": [
  "from math import ceil, sqrt\nfrom collections import deque\n\nn, m = map(int, input().split())\n\nadj = [[] for _ in range(n+1)]\nfor _ in range(m):\n    u, v = map(int, input().split())\n    adj[u].append(v)\n    adj[v].append(u)\n\nif ceil(sqrt(n)) ** 2 - n < ceil(sqrt(n)):\n    # Find independent set\n    ans = [0]*(ceil(sqrt(n)))\n    visited = [0]*(n+1)\n    count = 0\n    for i in range(1, n+1):\n        if not visited[i]:\n            visited[i] = 1\n            count += 1\n            ans[min(count-1, ceil(sqrt(n))-1)] = i\n            for j in adj[i]:\n                visited[j] = 1\n    print(1)\n    for vertex in ans:\n        if vertex == 0:\n            break\n        print(vertex, end=' ')\nelse:\n    # Find cycle\n    visited = [0]*(n+1)\n    parent = [0]*(n+1)\n    cycle_start = 0\n    for start in range(1, n+1):\n        if visited[start]:\n            continue\n        parent[start] = -1\n        path = deque()\n        path.append(start)\n\n        while path:\n            curr = path.popleft()\n            visited[curr] = 1\n            for next in adj[curr]:\n                if visited[next] and next != parent[curr]:\n                    cycle_start = next\n                    cycle_end = curr\n                    break\n                elif not visited[next]:\n                    parent[next] = curr\n                    path.append(next)\n            if cycle_start != 0:\n                break\n        if cycle_start != 0:\n            break\n\n    if cycle_start == 0:\n        exit()\n\n    cycle = deque()\n    while cycle_end != cycle_start:\n        cycle.appendleft(cycle_end)\n        cycle_end = parent[cycle_end]\n    cycle.appendleft(cycle_end)\n    cycle.append(cycle[0])\n\n    cycle_length = len(cycle)-1\n\n    print(2)\n    print(cycle_length)\n    print(*cycle)"
 ],
 "1260": [
  "n = int(input())\na = list(map(int, input().split()))\n\nmax1 = max(a)\nmax2 = max(a[:a.index(max1)] + a[a.index(max1)+1:])\nidx1 = a.index(max1)\nidx2 = a.index(max2)\n\nif max1 < 0:\n    print(f'2 {idx1+1}')\n    a.pop(idx1)\n    idx1 = idx2\nelif max2 < 0:\n    a.pop(idx1)\n    print(f'1 {idx1+1} {idx2+1}')\n    idx1 = idx2\n    max1 = max2\nelse:\n    a.pop(idx2)\n    print(f'1 {idx1+1} {idx2+1}')\n\nfor i in range(n-2):\n    idx = a.index(max(a))\n    if max1*max(a) > max(a[idx1])*max(a):\n        print(f'1 {idx1+1} {idx+1}')\n        max2 = max1\n        max1 = a[idx]\n        idx1 = idx\n    else:\n        print(f'1 {idx2+1} {idx+1}')\n        max2 = max(a[idx2:idx]+a[idx+1:])        \n        idx2 = idx\n    a[idx] = max(a) + 1\n\nprint(f'1 {idx1+1} {idx2+1}') "
 ],
 "1261": [
  "from math import gcd\nn = int(input())\nans = []\nm = n\nwhile m > 1:\n    for i in range(1, m+1):\n        if gcd(i, m) == 1:\n            ans.append(m)\n            m = i\n            break\n    else:\n        break\nans.append(1)\nprint(*ans[::-1])"
 ],
 "1262": [
  "import sys\n\ndef find(parent, i):\n    if parent[i] == i:\n        return i\n    return find(parent, parent[i])\n\ndef union(parent, rank, x, y):\n    xroot = find(parent, x)\n    yroot = find(parent, y)\n\n    if rank[xroot] < rank[yroot]:\n        parent[xroot] = yroot\n    elif rank[xroot] > rank[yroot]:\n        parent[yroot] = xroot\n\n    else:\n        parent[yroot] = xroot\n        rank[xroot] += 1\n\ndef KruskalMST(edges, indices, V):\n    result = [] \n    i = 0 \n    e = 0 \n    edges = sorted(edges,key=lambda item: item[2])\n    parent = [] ; rank = []\n    for node in range(V):\n        parent.append(node)\n        rank.append(0)\n    while e < V - 1:\n        if i>=len(edges): break\n        u, v, w = edges[i]\n        i = i + 1\n        x = find(parent, u)\n        y = find(parent ,v)\n        if x != y:\n            e = e + 1    \n            result.append([u,v,w])\n            union(parent, rank, x, y)         \n\n    cost = 0\n    for u, v, weight in result:\n        cost += weight\n        \n    flag = [0 for i in range(V)]\n    for i in range(V):\n        if parent[i] == i:\n            flag[i] = 1\n    count = sum(flag)\n    print(cost)\n    print(count)\n    for i in range(V):\n        if parent[i] == i:\n            print(i+1, end=\" \")\n    print()\n    print(V-count)\n    for edge in result:\n        u,v,w = edge\n        \n        u = indices[u]; v = indices[v];\n        if u == v: continue;\n        if (u > v): u,v = v,u;\n        print(u,v)\n    \ninput = sys.stdin.readline\n\nn = int(input())\ncoordX = []\ncoordY = []\nedges = []\nfor i in range(n):\n    x, y = list(map(int, input().split()))\n    coordX.append((x, i))\n    coordY.append((y, i))\n    \ncost = list(map(int, input().split()))\nk = list(map(int, input().split()))\n    \ncoordX = sorted(coordX)\ncoordY = sorted(coordY)\n\nindexX = [-1 for i in range(n)]\nindexY = [-1 for i in range(n)]\n\nfor i in range(n):\n    indexX[coordX[i][1]] = i\n    indexY[coordY[i][1]] = i\n\n\nfor i in range(n):\n    edges.append((i, indexX[i], cost[i]))\n    edges.append((i, indexY[i], cost[i]))\nfor i in range(n):\n    for j in range(i):\n        dist = abs(coordX[i][0] - coordX[j][0]) + abs(coordY[i][0]-coordY[j][0])\n        costi = k[i] + k[j]\n        edges.append((i,j,dist*costi))\n\nKruskalMST(edges, indexX, n)\n"
 ],
 "1263": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\ndp = [[-1 for _ in range(10001)] for _ in range(n+1)]\ndp[0][0] = 0\nfor i in range(1, n+1):\n    for j in range(10001):\n        dp[i][j] = dp[i-1][j]\n        if j >= b[i-1] and dp[i-1][j-b[i-1]] != -1:\n            dp[i][j] = max(dp[i][j], dp[i-1][j-b[i-1]]+a[i-1])\n\nans = -1\nfor i in range(1, 10001):\n    if dp[n][i] != -1 and i/k <= dp[n][i]:\n        ans = max(ans, dp[n][i])\n\nprint(ans)"
 ],
 "1264": [
  "n = int(input())\na = list(map(int, input().split()))\nmax_count = 0\nfor i in range(n):\n    for j in range(i, n):\n        new_a = a[:i] + [1-x for x in a[i:j+1]] + a[j+1:]\n        count = sum(new_a)\n        max_count = max(max_count, count)\nprint(max_count)"
 ],
 "1265": [
  "a = input()\nb = input()\n\nif len(a) != len(b):\n    print(\"NO\") \nelif a == b: \n    print(\"YES\")\nelse: \n    if \"1\" in a and \"1\" in b:\n        print(\"YES\")\n    else: \n        print(\"NO\")"
 ],
 "1266": [
  "n = int(input())\nx0, y0 = map(int, input().split())\npieces = []\nfor i in range(n):\n    piece, x, y = input().split()\n    x, y = int(x), int(y)\n    pieces.append((piece,x,y))\n    \n# Check for rooks and queens on the same row or column\nfor p in pieces:\n    if p[0] == \"R\" or p[0] == \"Q\":\n        if p[1] == x0 or p[2] == y0:\n            print(\"YES\")\n            exit()\n\n# Check for bishops and queens on the same diagonal\nfor p in pieces:\n    if p[0] == \"B\" or p[0] == \"Q\":\n        if abs(p[1] - x0) == abs(p[2] - y0):\n            print(\"YES\")\n            exit()\n            \nprint(\"NO\")"
 ],
 "1267": [
  "n = int(input())\nscores = list(map(int, input().split()))\nscores = sorted(list(set(scores))) # remove duplicates and sort in increasing order\n\ncount = 0\nfor i in range(len(scores)-1, -1, -1): # loop from highest to lowest score\n    if scores[i] != 0: # check if score is non-zero\n        count += 1\n    else:\n        break # stop loop if we reach participants with score 0\n\nprint(count)"
 ],
 "1268": [
  "n=int(input())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\ns=sorted([(a[i],b[i]) for i in range(n)])\nif s[-1][1]+s[-2][1]>=sum(a):\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "1269": [
  "MOD = 998244353\n\nn, m = map(int, input().split())\nc = list(map(int, input().split()))\n\ndp = [[0] * (n + 1) for _ in range(n + 1)]\nfor i in range(m - 1):\n    if c[i] != c[i + 1]:\n        dp[c[i]][c[i + 1]] += 1\n        dp[c[i + 1]][c[i]] += 1\n\nfor k in range(1, n + 1):\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            dp[i][j] += dp[i][k] * dp[k][j]\n            dp[i][j] %= MOD\n\nans = 1\nfor i in range(1, n + 1):\n    for j in range(i + 1, n + 1):\n        ans *= dp[i][j]\n        ans %= MOD\nprint(ans)"
 ],
 "1270": [
  "n = int(input())\nif n % 2 == 0:\n    k = n//2\n    print(k)\n    print(\"2 \"*k)\nelse:\n    k = n//2\n    print(k)\n    print(\"2 \"*(k-1) + \"3\")"
 ],
 "1271": [
  "import sys\nsys.stdin.readline\nMAXN=55\nMAXK=2005\nf=[[[sys.maxsize for i in range(MAXK)] for j in range(MAXN)] for k in range(MAXN)]\nn,s,k=map(int,input().split())\nr=list(map(int,input().split()))\nr=['']+r\nc=['']+list(input().strip())\nans=sys.maxsize\nfor i in range(1,n+1):\n    f[i][i][r[i]]=0\nfor len in range(2,n+1):\n    for l in range(1,n-len+2):\n        r=l+len-1\n        for last in range(1,n+1):\n            for now in range(1,n+1):\n                if last!=now and r[now]>r[last] and c[now]!=c[last]:\n                    for j in range(r[now],k+1):\n                        f[l][r][j]=min(f[l][r][j],f[l][now][j-r[now]]+1)\n        if r[s]-l+1>=k:\n            tmp=0\n            for j in range(l,s):\n                if c[j]!=c[s]:\n                    tmp+=r[j]\n            for j in range(k,r[s]+1):\n                ans=min(ans,f[l][s][j]+tmp)\nprint(-1 if ans==sys.maxsize else ans)"
 ],
 "1272": [
  "# Reading input\nn, m = map(int, input().split())\nbridges = [list(map(int, input().split())) for _ in range(m)]\n\n# Initializing sets for each island\nislands = [set([i]) for i in range(n)]\n\n# Initializing inconvenience as 0\ninconvenience = 0\n\n# Storing inconvenience after each bridge collapse in a list\ninconveniences = []\n\n#Iterating through each bridge\nfor i in range(m):\n    a, b = bridges[i]\n    \n    #Finding the sets to which the two islands belong to\n    set_a = set_b = None\n    for j in range(len(islands)):\n        if a in islands[j]:\n            set_a = islands[j]\n            index_a = j\n        if b in islands[j]:\n            set_b = islands[j]\n            index_b = j\n    \n    #If the two islands are already connected, the inconvenience remains the same\n    if set_a == set_b:\n        inconveniences.append(inconvenience)\n    \n    #If the two islands are not connected, we merge the two sets and update the inconvenience\n    else:\n        inconvenience -= len(set_a)*(len(set_a)-1)//2 + len(set_b)*(len(set_b)-1)//2 #Removes inconvenience due to previous sets\n        new_set = set_a.union(set_b)\n        islands.pop(max(index_a, index_b))\n        islands.pop(min(index_a, index_b))\n        islands.append(new_set)\n        inconvenience += len(new_set)*(len(new_set)-1)//2 #Adds inconvenience due to new set\n        inconveniences.append(inconvenience)\n\n#Printing the inconveniences after each bridge collapse\nfor incon in inconveniences:\n    print(incon)"
 ],
 "1273": [
  "import sys\nsys.setrecursionlimit(10**6+7)\n\nn = int(input())\nadj = [[] for _ in range(n+1)]\ncolours = [0] * (n+1)\n\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    adj[u].append(v)\n    adj[v].append(u)\n\ndef dfs(node, parent, usedColours):\n    availableColours = set([1, 2, 3, 4])\n    for child in adj[node]:\n        if child == parent:\n            continue\n        if colours[child] != 0:\n            availableColours.discard(colours[child])\n    for child in adj[node]:\n        if child == parent:\n            continue\n        if colours[child] == 0:\n            colours[child] = availableColours.pop()\n            dfs(child, node, usedColours)\n\ncolours[1] = 1\ndfs(1, 0, set([colours[1]]))\n\nprint(max(colours))\nfor u, v in zip(range(1, n), range(2, n+1)):\n    print(colours[v])"
 ],
 "1274": [
  "n, m = map(int, input().split())\njobs = []\nfor i in range(n):\n    a, b = map(int, input().split())\n    jobs.append((a, b))\n\njobs = sorted(jobs)  # sort the jobs based on the time it takes to complete them\nans = 0\nq = []\nfor i in range(m):  # loop through each day\n    while jobs and jobs[0][0] <= i+1:  # add all the jobs which can be completed today to a priority queue\n        a, b = jobs.pop(0)\n        heapq.heappush(q, -b)\n    if q:  # if there are any pending jobs, complete the one with highest reward today\n        ans -= heapq.heappop(q)\nprint(ans)  # print the total reward earne"
 ],
 "1275": [
  "N, K = map(int, input().split())\nans = 0\nfor i in range(2, 2*N+1):\n    if i-K >= 2 and i-K <= 2*N:\n        ans += min(i-1, 2*N)-max(i-N-1, 1)\nprint(ans)"
 ],
 "1276": [
  "n=int(input())\ns=input()\nprint(sum(s[i]!=s[j]!=s[k]!=s[i] and j-i!=k-j for i in range(n) for j in range(i+1,n) for k in range(j+1,n)))"
 ],
 "1277": [
  "import sys\nfrom collections import deque\n\nsys.setrecursionlimit(10 ** 7)\n\ndef dfs(v, p=-1):\n    for u in tree[v]:\n        if u == p:\n            continue\n        depth[u] = depth[v] + 1\n        dfs(u, v)\n\nn, u, v = map(int, input().split())\nu, v = u - 1, v - 1\n\ntree = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    a, b = a - 1, b - 1\n    tree[a].append(b)\n    tree[b].append(a)\n\ndepth = [-1] * n\ndepth[u] = 0\ndfs(u)\n\n# Takahashi can reach a point only less than depth than him\n# hence Aoki will try to reach that point which is less than or equal to depth of u.\nq = deque([v])\ndist = [-1] * n\ndist[v] = 0\n\nwhile q:\n    v = q.pop()\n    for nv in tree[v]:\n        if dist[nv] != -1:\n            continue\n        dist[nv] = dist[v] + 1\n        q.append(nv)\n\nans = 0\nfor x, y in zip(depth, dist):\n    if x < y:\n        ans = max(ans, y - 1)\n\nprint(ans)"
 ],
 "1278": [
  "n, x, y = map(int, input().split())\na = list(map(int, input().split()))\n\nfor i in range(n):\n    if all(a[i] < a[j] for j in range(max(0, i-x), i)) and all(a[i] < a[j] for j in range(i+1, min(n, i+1+y))):\n        print(i+1)\n        break"
 ],
 "1279": [
  "n, m = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\ncount = 0\nfor i in range(n):\n    for j in range(m):\n        if (a[i] + b[j]) % 2 == 1:\n            count += 1\n            b[j] = -1  # Mark this key as used.\n            break  # Move on to the next chest.\nprint(count)"
 ],
 "1280": [
  "s = input()\ngood = input()\nk = int(input())\n\nn = len(s)\ncnt = 0\n\nfor i in range(n):\n    curbad = 0\n    for j in range(i, n):\n        if good[ord(s[j]) - ord('a')] == '0':\n            curbad += 1\n        if curbad > k:\n            break\n        cnt += 1\n\nprint(cnt)"
 ],
 "1281": [
  "n,k = map(int,input().split())\na = list(map(int,input().split()))\nans = 0\nxori = 0\nc = [0]*n\nfor j in range(k-1,-1,-1):\n    mask = 1 << j\n    xorsum = 0\n    cnt = 0\n    for i in range(n):\n        if a[i] & mask:\n            xorsum ^= a[i]\n            cnt += 1\n            c[i] = 1\n        else:\n            c[i] = 0\n    for i in range(n):\n        if c[i]:\n            xori ^= a[i]\n        if c[i] == 0 and xorsum ^ (a[i] & (mask-1)) == xori:\n            cnt += 1\n    ans += cnt*(cnt-1)//2\nprint(n*(n+1)//2-ans)"
 ],
 "1282": [
  "s = input()\n\nn = len(s)\n\nboys = [0]*n\ngirls = [0]*n\n\nfor i in range(n):\n    if s[i] == 'M':\n        boys[i] = 1\n    else:\n        girls[i] = 1\n\nfor i in range(1, n):\n    girls[i] += girls[i-1]\n\nfor i in range(n-2, -1, -1):\n    boys[i] += boys[i+1]\n\nans = n\n\nfor i in range(n):\n    if s[i] == 'F':\n        ans = min(ans, boys[i])\n    else:\n        ans = min(ans, girls[i])\n\nprint(ans)"
 ],
 "1283": [
  "n, k = map(int, input().split())\n\nfield = [input() for _ in range(n)]\n\nmax_count, max_pos = 0, (0, 0)\n\nfor i in range(n):\n    for j in range(n):\n        if field[i][j] == '#':\n            continue\n        # Check horizontal placements\n        ship_count = 0\n        for l in range(k):\n            if j+l >= n or field[i][j+l] == '#':\n                break\n            ship_count += 1\n        if ship_count == k:\n            max_count, max_pos = n, (i, j)\n        \n        # Check vertical placements\n        ship_count = 0\n        for l in range(k):\n            if i+l >= n or field[i+l][j] == '#':\n                break\n            ship_count += 1\n        if ship_count == k:\n            max_count, max_pos = n, (i, j)\n\nprint(max_pos[0]+1, max_pos[1]+1)"
 ],
 "1284": [
  "n = int(input())\na = list(map(int, input().split()))\ncum_sum = [0] + a\nfor i in range(1, n+1):\n    cum_sum[i] += cum_sum[i-1]\ndp = [[0]*n for _ in range(n)]\nfor l in range(n-1, -1, -1): # Length of Sub-interval\n    for i in range(n):\n        j = i+l\n        if j >= n:\n            break\n        if l == 0:\n            dp[i][j] = a[i]\n        elif l == 1:\n            dp[i][j] = max(a[i], a[j])\n        else:\n            total_sum = cum_sum[j+1] - cum_sum[i]\n            dp[i][j] = total_sum - min(dp[i][j-1], dp[i+1][j])\nprint(dp[0][n-1])"
 ],
 "1285": [
  "n = int(input())\nA = [input() for _ in range(n//4)]\n\nfor x in range(n, 0, -1):\n    if n % x != 0: \n        continue\n    B = [[0] * (n//x) for _ in range(n//x)]\n    ok = True\n    for i in range(n):\n        for j in range(n):\n            if A[i//4][j//4] & (1 << (3 - j % 4)):\n                B[i//x][j//x] |= (1 << (3 - (j % x)))\n            elif B[i//x][j//x] & (1 << (3 - (j % x))):\n                ok = False\n                break\n        if not ok: \n            break\n    if ok: \n        print(x)\n        break"
 ],
 "1286": [
  "MOD = 10**9+7\n\ndef power(x, y):\n    res = 1\n    while y > 0:\n        if y & 1:\n            res = res*x % MOD\n        x = x*x % MOD\n        y >>= 1\n    return res\n\nk = int(input())\na = list(map(int, input().split()))\n\n# Find the total number of turns, which is the product of all elements in the array\nn = 1\nfor ai in a:\n    n = n*ai % (MOD-1)\n\n# Calculate the probability\n# Probability of guessing correctly is always 1/3\n# Therefore, the probability of guessing incorrectly is 2/3\n# We need to calculate (2/3)^n\nnumerator = power(2, n)\ndenominator = power(3, n)\ndenominator_inv = power(denominator, MOD-2)  # Using Fermat's Little Theorem to calculate the inverse\nprobability = numerator*denominator_inv % MOD\n\n# Output the result as a fraction\nprint(\"{}/{}\".format(probability, 1))"
 ],
 "1287": [
  "n = int(input())\np = [list(map(float, input().split())) for _ in range(n)]\n\ndp = [[0 for _ in range(1<<n)] for _ in range(n)]\ndp[0][1] = 1\n\nfor mask in range(1<<n):\n    count = bin(mask).count('1') # count number of set bits which represents number of participating siths\n    for i in range(n):\n        if mask & (1<<i) and i!=0:\n            for j in range(n):\n                if mask & (1<<j) and j!=i:\n                    dp[i][mask] += dp[j][mask^(1<<i)]*p[j][i]\n\nprint(dp[0][(1<<n)-1])"
 ],
 "1288": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\ndef is_possible(mid):\n    j = 0\n    for i in range(n):\n        if a[i] <= mid and (i + 1) % 2 == 0:\n            j += 1\n        if j == k // 2:\n            break\n    if j < k // 2:\n        return False\n\n    j = 0\n    for i in range(n):\n        if a[i] <= mid and (i + 1) % 2 == 1:\n            j += 1\n        if j == k // 2 + k % 2:\n            break\n    if j < k // 2 + k % 2:\n        return False\n\n    return True\n\nl, r = 1, 10 ** 9\nwhile l < r:\n    mid = (l+r) // 2\n    if is_possible(mid):\n        r = mid\n    else:\n        l = mid + 1\nprint(l)"
 ],
 "1289": [
  "n = int(input()) \na = list(map(int, input().split())) \nm = int(input()) \nb = list(map(int, input().split())) \n\nindices = {}\nfor i in range(n):\n    indices[a[i]] = i\n\ndistances = []\nfor i in range(m - 1):\n    if indices[b[i]] > indices[b[i + 1]]:\n        b[i], b[i + 1] = b[i + 1], b[i]\n    distances.append(indices[b[i + 1]] - indices[b[i]])\n\nif len(set(b)) != m:\n    print(-1)\nelse:\n    print(sum(distances))"
 ],
 "1290": [
  "n, m = map(int, input().split())\ncols = [0] * n\npoints = 0\n\nfor i in range(m):\n    c = int(input()) - 1  # 0-based index for cols list\n    cols[c] += 1\n    if all(x > 0 for x in cols):\n        cols = [x - 1 for x in cols]\n        points += 1\n\nprint(points)"
 ],
 "1291": [
  "import math\n\ndef in_circle(x, y, a, b, r):\n    return (x-a)**2 + (y-b)**2 < r**2\n\ndef can_build_fence(n, m, mishas, sashas):\n    # find the center of the circle that separates the points\n    x, y = sum(x for x, _ in mishas+sashas), sum(y for _, y in mishas+sashas)\n    x /= n+m\n    y /= n+m\n\n    # find the radius of the circle that separates the points\n    r = max(math.sqrt((x-a)**2 + (y-b)**2) for a, b in mishas)\n    r2 = max(math.sqrt((x-a)**2 + (y-b)**2) for a, b in sashas)\n    r += r2\n\n    # check if all mishas are inside and all sashas are outside the circle\n    for a, b in mishas:\n        if not in_circle(a, b, x, y, r):\n            return \"NO\"\n    for a, b in sashas:\n        if in_circle(a, b, x, y, r):\n            return \"NO\"\n    return \"YES\"\n\nn, m = map(int, input().split())\nmishas = [tuple(map(int, input().split())) for _ in range(n)]\nsashas = [tuple(map(int, input().split())) for _ in range(m)]\n\nprint(can_build_fence(n, m, mishas, sashas))"
 ],
 "1292": [
  "from collections import deque\n\nn, m, p = map(int, input().split())\nspeeds = list(map(int, input().split()))\n\ngrid = [input() for _ in range(n)]\ncastle_positions = [[] for _ in range(p+1)]\n\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == '#':\n            continue\n        elif grid[i][j] == '.':\n            castle_positions[0].append((i, j))\n        else:\n            player = int(grid[i][j])\n            castle_positions[player].append((i, j))\n\ntotal_cells_controlled = [len(castle_positions[i]) for i in range(p+1)]\nfinished = False\n\nwhile not finished:\n    finished = True\n    for player in range(1, p+1):\n        queue = deque(castle_positions[player])\n        visited = set(queue)\n        distance = 0\n        next_positions = set()\n        \n        while queue:\n            distance += 1\n            for _ in range(len(queue)):\n                x, y = queue.popleft()\n                \n                for dx, dy in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                    nx, ny = x+dx, y+dy\n                    \n                    if nx < 0 or nx >= n or ny < 0 or ny >= m:\n                        continue\n                        \n                    if (nx, ny) in visited or grid[nx][ny] == '#':\n                        continue\n                    \n                    visited.add((nx, ny))\n                    if grid[nx][ny] == '.':\n                        next_positions.add((nx, ny))\n                    else:\n                        player_on_cell = int(grid[nx][ny])\n                        if player_on_cell == player:\n                            queue.append((nx, ny))\n                            visited.add((nx, ny))\n                        else:\n                            next_positions.add((nx, ny))\n                            \n        if next_positions:\n            total_cells_controlled[player] += len(next_positions)\n            castle_positions[player] = list(next_positions)\n            finished = False\n            \nprint(*total_cells_controlled[1:]) "
 ],
 "1293": [
  "n = int(input())\nb = list(map(int, input().split()))\n\nans = 0\nfor i in range(1, n):\n    ans += abs(b[i] - b[i-1])\n\nprint(ans)"
 ],
 "1294": [
  "t = int(input())\nfor _ in range(t):\n    s = input().strip()\n    freq = {}\n    for i in range(len(s)):\n        if i == 0 or s[i] != s[i-1]:\n            if s[i] in freq:\n                freq[s[i]] = -1\n            else:\n                freq[s[i]] = 1 if i == 0 or s[i] != s[i-1] else 0\n        elif s[i] == s[i-1]:\n            freq[s[i]] *= -2\n    res = [k for k, v in freq.items() if v > 0]\n    res.sort()\n    print(\"\".join(res))"
 ],
 "1295": [
  "n, m = map(int, input().split())\ncities = list(map(int, input().split()))\ntowers = list(map(int, input().split()))\n\nlow, high = 0, 10**9\n\nwhile low < high:\n    mid = (low + high) // 2\n    i, j = 0, 0\n    while i < n and j < m:\n        if abs(cities[i] - towers[j]) <= mid:\n            i += 1\n        else:\n            j += 1\n    if i == n:\n        high = mid\n    else:\n        low = mid + 1\n\nprint(low)"
 ],
 "1296": [
  "n, S = map(int, input().split())\na = list(map(int, input().split()))\n\nl, r = 0, n\nwhile l + 1 < r:\n    mid = (l + r) // 2\n    b = [(a[i]+(i+1)*mid) for i in range(n)]\n    b.sort()\n    if sum(b[:mid]) <= S:\n        l = mid\n    else:\n        r = mid\n\nk = l\nb = [(a[i]+(i+1)*k) for i in range(n)]\nb.sort()\nprint(k, sum(b[:k]))"
 ],
 "1297": [
  "s = input()\nprev = None\ncount = 0\ninsertions = 0\nfor char in s:\n    if char == prev:\n        count += 1\n        if count % 2 == 0:\n            insertions += 1\n            count = 1\n    else:\n        prev = char\n        count = 1\nprint(insertions)"
 ],
 "1298": [
  "n=int(input())\ns=input()\n\nwhile('10' in s or '01' in s):\n    s=s.replace('10','',1)\n    s=s.replace('01','',1)\n\nprint(len(s))"
 ],
 "1299": [
  "n, k = map(int, input().split())\nx = list(map(int, input().split()))\n\nprefix_sum = [0] * (n+1)\nfor i in range(n):\n    prefix_sum[i+1] = prefix_sum[i] + x[i]\n\nmax_sum = -1\nmax_a = -1\nmax_b = -1\n\nfor a in range(1, n-2*k+3):\n    l1, r1 = a, a+k-1\n    l2, r2 = n-k+1, n\n    if l1 <= l2 <= r1 or l1 <= r2 <= r1:\n        continue\n    s1 = prefix_sum[r1] - prefix_sum[l1-1]\n    s2 = prefix_sum[r2] - prefix_sum[l2-1]\n    if s1 + s2 > max_sum:\n        max_sum = s1 + s2\n        max_a = a\n        max_b = l2\n\nfor b in range(n-k, 2*k-2, -1):\n    l1, r1 = 1, k\n    l2, r2 = b, b+k-1\n    if l1 <= l2 <= r1 or l1 <= r2 <= r1:\n        continue\n    s1 = prefix_sum[r1] - prefix_sum[l1-1]\n    s2 = prefix_sum[r2] - prefix_sum[l2-1]\n    if s1 + s2 > max_sum:\n        max_sum = s1 + s2\n        max_a = l1\n        max_b = b\n\nprint(max_a, max_b)"
 ],
 "1300": [
  "n, c = map(int, input().split())\na = list(map(int, input().split()))\n\n# Count the initial occurrence of c in the array a\ninitial_count = a.count(c)\n\n# Initialize variables\nmax_count = initial_count\nmax_diff = 0\ncount_diff = 0\n\n# Calculate the difference between each element and c,\n# and find the maximum difference\nfor i in range(n):\n    diff = a[i] - c\n    count_diff += diff\n    max_diff = max(max_diff, count_diff)\n    \n    # Take the difference into account if the segment sum equals c\n    if count_diff == max_diff:\n        max_count = max(max_count, initial_count + max_diff)\n    else:\n        max_count = max(max_count, initial_count + count_diff - max_diff)\n\nprint(max_count)"
 ],
 "1301": [
  "n = int(input())\npattern = input().strip()\n\npokemons = [\"vaporeon\", \"jolteon\", \"flareon\", \"espeon\", \"umbreon\", \"leafeon\", \"glaceon\", \"sylveon\"]\n\nfor pokemon in pokemons:\n    if len(pokemon) == n:\n        match = True\n        for i in range(n):\n            if pattern[i] != '.' and pattern[i] != pokemon[i]:\n                match = False\n                break\n        if match:\n            print(pokemon)\n            break"
 ],
 "1302": [
  "n, k = map(int, input().split())\nif k > n//2:\n    print(-1)\nelse:\n    permutation = [i + 1 for i in range(n)]\n    for i in range(1, n, 2):\n        if k == 0:\n            break\n        permutation[i], permutation[i-1] = permutation[i-1], permutation[i]\n        k -= 1\n    print(\" \".join(map(str, permutation))) "
 ],
 "1303": [
  "p, q, l, r = map(int, input().split())\na = [0]*p\nb = [0]*p\nc = [0]*q\nd = [0]*q\nfor i in range(p):\n    a[i], b[i] = map(int, input().split())\nfor i in range(q):\n    c[i], d[i] = map(int, input().split())\n\ncount = 0\nfor i in range(l, r+1):\n    flag = 0\n    for j in range(q):\n        d1, c1 = d[j]+i, c[j]+i\n        for k in range(p):\n            if c1 <= b[k] and d1 >= a[k]:\n                count += 1\n                flag = 1\n                break\n        if flag:\n            break\nprint(count)"
 ],
 "1304": [
  "# Reading the input\nfield = []\nfor i in range(11):\n    if i % 4 == 3:\n        continue\n    line = input().split()\n    for j in range(9):\n        field.append(line[j])\nlast_x, last_y = map(int, input().split())\n\n# Determining the index of the last move\nlast_ind = (last_x - 1) * 9 + last_y - 1\n\n# Finding the available moves\nmoves = []\nif field[last_ind] == '.':\n    # Current player can move anywhere\n    for i in range(81):\n        if field[i] == '.':\n            moves.append(i)\nelse:\n    # Current player can only move in the small field specified by last move\n    start_row = (last_x - 1) // 3 * 3\n    start_col = (last_y - 1) // 3 * 3\n    for i in range(start_row, start_row + 3):\n        for j in range(start_col, start_col + 3):\n            ind = i * 9 + j\n            if field[ind] == '.':\n                moves.append(ind)\n\n# Updating the field to show available moves\nfor ind in moves:\n    field[ind] = '!'\n\n# Printing the output\nfor i in range(0, 81, 9):\n    print(' '.join(field[i:i+3]) + '  ' + ' '.join(field[i+3:i+6]) + '  ' + ' '.join(field[i+6:i+9]))\n    if i == 18 or i == 45:\n        print()"
 ],
 "1305": [
  "n = int(input())\nbills = list(map(int, input().split()))\n\nchange_25 = change_50 = 0\n\nfor bill in bills:\n    if bill == 25:\n        change_25 += 1\n    elif bill == 50:\n        change_25 -= 1\n        change_50 += 1\n    elif bill == 100:\n        if change_50 > 0:\n            change_50 -= 1\n            change_25 -= 1\n        else:\n            change_25 -= 3\n    if change_25 < 0 or change_50 < 0:\n        print(\"NO\")\n        break\nelse:\n    print(\"YES\")"
 ],
 "1306": [
  "MOD = 10**9 + 7\n\nn, h = map(int, input().split())\na = list(map(int, input().split()))\n\ndp = [[0] * (n + 1) for _ in range(n + 1)]\ndp[0][0] = 1\n\nfor i in range(n):\n    for j in range(i + 1):\n        if a[i] + j < h:\n            dp[i + 1][j] = (dp[i + 1][j] + dp[i][j] * (h - a[i] - j)) % MOD\n            dp[i + 1][j + 1] = (dp[i + 1][j + 1] + dp[i][j] * (a[i] + j + 1)) % MOD\n        else:\n            dp[i + 1][a[i] + j - h + 1] = (dp[i + 1][a[i] + j - h + 1] + dp[i][j]) % MOD\n            dp[i + 1][j] = (dp[i + 1][j] + dp[i][j] * (n - i - j)) % MOD\n\nprint(sum(dp[-1]) % MOD)"
 ],
 "1307": [
  "n = int(input())\nif n%2==0:\n    print(\"Mahmoud\")\nelse:\n    print(\"Ehab\")"
 ],
 "1308": [
  "n, m = map(int, input().split())\ns = input()\n\nfor _ in range(m):\n    x, y, length = map(int, input().split())\n    s1, s2 = s[x-1:x+length], s[y-1:y+length]\n    if len(s1) != len(s2):\n        print(\"NO\")\n    else:\n        d1, d2 = {}, {}\n        iso = True\n        for i in range(len(s1)):\n            if s1[i] not in d1 and s2[i] not in d2:\n                d1[s1[i]], d2[s2[i]] = s2[i], s1[i]\n            elif (s1[i] in d1 and d1[s1[i]] != s2[i]) or (s2[i] in d2 and d2[s2[i]] != s1[i]):\n                iso = False\n                break\n        if iso:\n            print(\"YES\")\n        else:\n            print(\"NO\")"
 ],
 "1309": [
  "n = int(input())\nweights = list(map(int, input().split()))\nweights.sort()\n\nmin_instability = float('inf')\n\nfor i in range(2*n-1):\n    for j in range(i+1, 2*n):\n        tandem = []\n        for k in range(2*n):\n            if k != i and k != j:\n                tandem.append(weights[k])\n        instability = 0\n        for k in range(0, len(tandem), 2):\n            instability += abs(tandem[k] - tandem[k+1])\n        min_instability = min(min_instability, instability)\n\nprint(min_instability)"
 ],
 "1310": [
  "n = int(input())\narr = list(map(int, input().split()))\nmax_xor = 0\nfor i in range(n):\n    xor = 0\n    for j in range(i, n):\n        xor ^= arr[j]\n        max_xor = max(max_xor, xor)\nprint(max_xor)"
 ],
 "1311": [
  "from bisect import bisect_left\n\nn = int(input())\n\npoints = []\nfor i in range(n):\n    x, w = map(int, input().split())\n    points.append((x, w))\n\npoints.sort()\ndp = [0] * n  # dynamic programming array to store the maximum clique ending at i-th vertex\n\nfor i in range(n):\n    dp[i] = 1  # every vertex is itself a clique with size 1\n    for j in range(i):\n        if abs(points[i][0] - points[j][0]) >= points[j][1] + points[i][1]:  # check if edge can be formed\n            dp[i] = max(dp[i], dp[j] + 1)\n\nprint(max(dp))  # size of maximum clique is the maximum value in dp array"
 ],
 "1312": [
  "n, m = map(int, input().split())\na = n // m\nb = n % m\nprint((str(a+1) + \" \"*b)*max(0, a+1 > b) + (str(a) + \" \"*(m-b))*max(0, a+1 <= b))"
 ],
 "1313": [
  "n1, n2, k1, k2 = map(int,input().split())\nif n1 > n2:\n    print(\"First\")\nelse:\n    print(\"Second\")"
 ],
 "1314": [
  "n = int(input())\nx = []\ny = []\na = []\nb = []\n\nfor i in range(n):\n    xi, yi = map(int, input().split())\n    x.append(xi)\n    y.append(yi)\n\nfor i in range(n):\n    ai, bi = map(int, input().split())\n    a.append(ai)\n    b.append(bi)\n\nfor p1 in range(n):\n    for p2 in range(n):\n        can_be_answer = True\n        tx = x[p1] + a[0] - a[p1]\n        ty = y[p2] + b[0] - b[p2]\n        for i in range(n):\n            if x[p1] + a[i] - a[p1] != tx or y[p2] + b[i] - b[p2] != ty:\n                can_be_answer = False\n                break\n        if can_be_answer:\n            print(tx, ty)\n            exit()"
 ],
 "1315": [
  "n = int(input())\na = list(map(int, input().split()))\nb = [(a[i], i) for i in range(n)]\nb.sort()\n\nans = [0] * n\nans[b[0][1]] = 0\nfor i in range(1, n):\n    if b[i][0] == b[i-1][0]:\n        ans[b[i][1]] = ans[b[i-1][1]]\n    else:\n        ans[b[i][1]] = i\n        \nfor i in range(1, n):\n    if ans[i] < ans[i-1]:\n        print(\":(\")\n        exit()\n        \nnew_a = [0] * n\nfor i in range(n):\n    new_a[n-1-ans[i]] = str(a[i] - i)\n    \nprint(' '.join(new_a))"
 ],
 "1316": [
  "n, k = map(int, input().split())\ns = input()\nx = 0\nfor c in set(s):\n    cnt = 0\n    i = 0\n    while i < n-k+1:\n        if s[i:i+k] == c*k:\n            cnt += 1\n            i += k\n        else:\n            i += 1\n    x = max(x, cnt)\nprint(x)"
 ],
 "1317": [
  "n,m = map(int,input().split())\nfrom math import gcd #in math library\nans = 0\nfor i in range(1,n+1):\n    for j in range(1,n+1):\n        x = i*i + j*j\n        if gcd(x,m) == 1:\n            continue\n        t = m // gcd(x,m)\n        ans += 1\nprint(ans)"
 ],
 "1318": [
  "n = int(input())\nrequests = []\nfor i in range(n):\n    requests.append(list(map(int, input().split())))\n\nk = int(input())\ntables = list(map(int, input().split()))\n\nseats = [[i+1, tables[i]] for i in range(k)]\nseats.sort(key=lambda x: -x[1])\n\naccepted = []\ntotal_money = 0\n\nfor r in requests:\n    sat = False\n    for i in range(len(seats)):\n        if seats[i][1] >= r[0]:\n            accepted.append([requests.index(r)+1, seats[i][0]])\n            total_money += r[1]\n            sat = True\n            seats[i][1] = 0\n            break\n    if not sat:\n        continue\n\nprint(len(accepted), total_money)\nfor a in accepted:\n    print(a[0], a[1])"
 ],
 "1319": [
  "MOD = int(1e9) + 7\nm = int(input())\nprimes = list(map(int, input().split()))\n\nprod = 1\nfor p in primes:\n    e = 1\n    while pow(p, e+1) <= primes[-1]:\n        e += 1\n    num_divs = (e+1) * m\n    prod = (prod * pow(p, (num_divs-1), MOD)) % MOD\n\nprint(prod)"
 ],
 "1320": [
  "n = int(input())\ncake = [input() for _ in range(n)]\nhappiness = 0 \n\nfor i in range(n):\n    chocolate_in_row = 0\n    chocolate_in_col = 0\n    for j in range(n):\n        if cake[i][j] == 'C':\n            chocolate_in_row += 1\n        if cake[j][i] == 'C':\n            chocolate_in_col += 1\n    happiness += chocolate_in_row * (chocolate_in_row - 1) // 2 + chocolate_in_col * (chocolate_in_col - 1) // 2\n\nprint(happiness)"
 ],
 "1321": [
  "n = int(input())\nfriends = []\nfor i in range(n):\n    w, h = map(int, input().split())\n    friends.append((w, h))\n    \ntotal_width = sum([friend[0] for friend in friends])\nmax_height = max([friend[1] for friend in friends])\nfor i in range(n):\n    width_without_i = total_width - friends[i][0]\n    if friends[i][1] != max_height:\n        size_without_i = width_without_i * max_height\n    else:\n        size_without_i = max([(width_without_i + friend[0]) * friend[1] for friend in friends if friend != friends[i]])\n    print(size_without_i, end=' ')"
 ],
 "1322": [
  "n = int(input())\nMOD = 10**9 + 7\n\n# Calculate the number of possible states using dynamic programming\n# dp[i] represents the number of possible states after the i-th move\ndp = [0] * (n+1)\ndp[0] = 1  # there is only one possible state at the beginning\n\nfor i in range(1, n+1):\n    # each move creates two new states, except for the last move\n    dp[i] = (dp[i-1] * 2) % MOD\n    if i == n:\n        dp[i] -= 1  # last move does not create a new state, so subtract 1\n\n# total number of states is the sum of all possible states\ntotal_states = sum(dp) % MOD\n  \nprint(total_states)"
 ],
 "1323": [
  "m, n = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\na_sum = sum(a)\nb_sum = sum(b)\n\na.sort()\nb.sort()\n\ni = 0\nj = 0\nops = 0\n\nwhile i < m and j < n:\n    if a_sum <= b_sum:\n        a_sum -= a[i]\n        i += 1\n    else:\n        b_sum -= b[j]\n        j += 1\n    ops += a_sum + b_sum\n\nprint(ops)"
 ],
 "1324": [
  "a = list(map(int, input().split()))\ns = input()\n\ncalories = 0\nfor char in s:\n    calories += a[int(char) - 1]\nprint(calories)"
 ],
 "1325": [
  "n, p = map(int, input().split())\ns = input()\n\nif p > n // 2:\n    p = n + 1 - p\ncount = 0\nfor i in range(n // 2):\n    left_char = s[i]\n    right_char = s[n-i-1]\n    diff = abs(ord(right_char) - ord(left_char))\n    if diff > 13:\n        diff = 26 - diff\n    count += diff\n    if i+1 == p:\n        p = n - p + 1\n\nprint(count)"
 ],
 "1326": [
  "n = int(input())\nans = 0\nfor i in range(1, n+1):\n    ans += i * ((n // i) * ((n // i) + 1)) // 2\nprint(ans)"
 ],
 "1327": [
  "n, m = map(int, input().split())\ncakes = []\nfor i in range(n):\n    x, y, z = map(int, input().split())\n    cakes.append((x, y, z))\nans = 0\nfor bit in range(1<<3):\n    sign = [1]*3\n    for i in range(3):\n        if (bit>>i)&1:\n            sign[i] = -1\n    scores = []\n    for cake in cakes:\n        score = sum([cake[i]*sign[i] for i in range(3)])\n        scores.append(score)\n    scores.sort(reverse= True)\n    total = sum(scores[:m])\n    ans = max(ans, abs(total))\nprint(ans)"
 ],
 "1328": [
  "import sys\n\ninput = sys.stdin.readline\n\n# Function to find the greatest common divisor\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\n# Read input values\nn, ma, mb = map(int, input().split())\nabc = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Find the maximum weight that can be achieved\nmax_weight = 10 * max(ma, mb) * n\n\n# Initialize the dp table\ndp = [[float('inf')] * (max_weight + 1) for _ in range(max_weight + 1)]\ndp[0][0] = 0\n\n# Fill the dp table\nfor a, b, c in abc:\n    for i in range(max_weight, a-1, -1):\n        for j in range(max_weight, b-1, -1):\n            dp[i][j] = min(dp[i][j], dp[i-a][j-b] + c)\n\n# Find the minimum cost for achieving desired ratio\nans = float('inf')\nfor i in range(1, max_weight+1):\n    if i * ma > max_weight or i * mb > max_weight:\n        break\n    ans = min(ans, dp[i*ma][i*mb])\n\nprint(ans if ans != float('inf') else -1)"
 ],
 "1329": [
  "n = int(input())\nfactors = [0] * (n+1)\nfor i in range(2, n+1):\n    num = i\n    for j in range(2, i+1):\n        while (num % j == 0):\n            factors[j] += 1\n            num //= j\n \nexponents = [0] * 101\nfor i in range(2, n+1):\n    exponents[factors[i]] += 1\n \nans = 0\nans += sum(1 for i in range(1,100) if exponents[i] >= 74)\nans += sum(1 for i in range(1,100) for j in range(1,100) if i != j and exponents[i] >= 2 and exponents[j] >= 24)\nans += sum(1 for i in range(1,100) for j in range(1,100) if i != j and exponents[i] >= 4 and exponents[j] >= 14)\nans += sum(1 for i in range(1,100) for j in range(1,100) for k in range(1,100) \n           if i != j and j != k and i != k and exponents[i] >= 2 and exponents[j] >= 4 and exponents[k] >= 4)\nans += sum(1 for i in range(1,100) for j in range(1,100) if i != j and exponents[i] >= 2 and exponents[j] >= 2 and j>i and exponents[1] >= 74)\nprint(ans)"
 ],
 "1330": [
  "from collections import defaultdict\nfrom heapq import heappush, heappop\n\nINF = 10 ** 18\nn, m = map(int, input().split())\np = list(map(int, input().split()))\nc = list(map(int, input().split()))\nd = int(input())\ncl = [[] for i in range(m)]\nfor i in range(n):\n    cl[c[i] - 1].append(p[i])\nans = []\nq = []\nfor i in range(m):\n    if len(cl[i]) == 0:\n        continue\n    cl[i].sort()\n    heappush(q, (-cl[i][-1], i))\nfor i in range(d):\n    k = int(input()) - 1\n    cl[c[k] - 1].remove(p[k])\n    c[k] = -1\n    heappush(q, (-0, -1))\n    for j in range(m):\n        if len(cl[j]) == 0:\n            continue\n        while cl[j] and c[k] == -1 and cl[j][-1] == 0:\n            cl[j].pop()\n        if len(cl[j]) == 0:\n            continue\n        heappush(q, (-cl[j][-1], j))\n    vis = [False] * m\n    par = [-1] * m\n    now = []\n    for j in range(int(len(q) / 2)):\n        x = heappop(q)\n        y = heappop(q)\n        x = -x[0]\n        y = -y[0]\n        if x == 0 or y == 0:\n            continue\n        now.append((x + y, x, y))\n    heap = []\n    for j in range(len(now)):\n        heappush(heap, (-now[j][0], -j))\n    if len(heap) == 0:\n        ans.append(0)\n        continue\n    j = -heappop(heap)[1]\n    ans.append(now[j][0])\n    while j != -1:\n        vis[now[j][1]] = True\n        vis[now[j][2]] = True\n        j = par[j]\n        if j == -1:\n            break\n        j = -j - 1\n    for j in range(len(now)):\n        if vis[j]:\n            continue\n        x = now[j][1]\n        y = now[j][2]\n        if x > y:\n            x, y = y, x\n        heappush(q, (-now[j][x == now[j][1] * 1 + now[j][2] * (-1)], x))\n        heappush(q, (-now[j][x == now[j][1] * (-1) + now[j][2] * 1], y))\n        par.append(-j - 1)\n    for j in range(len(heap)):\n        j = -heap[j][1]\n        if vis[j]:\n            par[j] = -1\n        else:\n            par[j] = -par[j] - 1\nprint('\\n'.join(map(str, ans))) "
 ],
 "1331": [
  "n, m, k = map(int, input().split())\nalarms = list(map(int, input().split()))\n\nalarms.sort()\noff_count = 0\ncurr_consecutive = 0\nlast_ring = -m - 1\n\nfor alarm in alarms:\n    if alarm - last_ring > m:\n        curr_consecutive = 1\n    else:\n        curr_consecutive += 1\n\n    if curr_consecutive > k:\n        off_count += 1\n        curr_consecutive = 1\n\n    last_ring = alarm\n\nprint(off_count)"
 ],
 "1332": [
  "c = list(map(int,input().split()))\ntotal = sum(c)\nif total % 5 == 0 and total != 0:\n    b = total // 5\n    if b in c:\n        print(b)\n    else:\n        print(-1)\nelse:\n    print(-1)"
 ],
 "1333": [
  "n, m = map(int, input().split())\n\nfor i in range(n):\n    if i % 2 == 0:\n        print(\"#\" * m)\n    elif (i // 2) % 2 == 0:\n        print(\".\" * (m - 1) + \"#\")\n    else:\n        print(\"#\" + \".\" * (m - 1))"
 ],
 "1334": [
  "n, k = map(int, input().split())\ns = input()\n\nunique_chars = sorted(set(s))\n\nt = ''\nfor i in range(k):\n    for char in unique_chars:\n        new_t = t + char\n        if new_t <= s[:i+1]:\n            t = new_t\n            break\n\nprint(t + unique_chars[0] * (k - len(t)))"
 ],
 "1335": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\ntests = [0] * k\nm, result = 0, 0\nfor i in range(n):\n    j, t = 0, float('inf')\n    for p in range(k):\n        if tests[p] < t:\n            j, t = p, tests[p]\n    tests[j] += a[i]\n    m += (tests[j] <= sum(a)) # in case an already tested solution becomes interesting again\n    if (a[i] * 100) % tests[j] == 0 and (a[i] * 100) // tests[j] <= m * 100 // n:\n        result += 1\nprint(result)"
 ],
 "1336": [
  "MOD = 10**9 + 7\nn = int(input())\nstack, rv, diff, min_d, degree, in_deg, out_deg, vals = [], [], [], float('inf'), [0] * n, [0] * n, [0] * n, [0] * n\nfor i in range(n):\n  out_i, in_i = map(int,input().split())\n  diff_i = in_i - out_i\n  diff.append(diff_i)\n  vals.append((diff_i, i))\n  out_deg[i], in_deg[i] = out_i, in_i\nvals = sorted(vals)\nfor _, idx in vals:\n  if not stack:\n    stack.append(idx)\n  else:\n    while diff[stack[-1]] < diff[idx] and in_deg[stack[-1]] >= out_deg[idx]:\n      degree[stack[-1]] += 1\n      rv[unit.pop()] = idx\n      if not stack:\n        break\n    stack.append(idx)\n  min_d = min(min_d, diff[idx])\ni = 0\nans = 1\nwhile i < n:\n  if degree[i] == 0 and diff[i] == min_d and diff[i] != float('inf'):\n    cnt = 0\n    nxt = i\n    while nxt != -1:\n      cnt += 1\n      nxt = rv[nxt]\n    ans = (ans * cnt) % MOD\n  i += 1\nprint(ans)"
 ],
 "1337": [
  "n = int(input())\na = list(map(int, input().split()))\nm = int(input())\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\n\nmovies = list(zip(range(m), b, c))\nmovies.sort(key=lambda x: (-a.count(x[1]), -a.count(x[2]), x[0]))\nprint(movies[0][0]+1)"
 ],
 "1338": [
  "n, m = map(int, input().split())\n\ndef f(p):\n    s = 0\n    for i in range(n):\n        for j in range(i, n):\n            s += min(p[i:j+1])\n    return s\n\nmax_f = n * (n+1) // 2    # maximum value of f(p)\n\ndef lexicographically_mth_permutation(n, m, max_f):\n    curr_perm = list(range(1, n+1))\n    count = 1\n    while count < m:\n        next_perm = curr_perm[:]\n        for i in range(n-2, -1, -1):\n            if curr_perm[i] < curr_perm[i+1]:\n                suffix = curr_perm[i+1:]\n                smallest_larger = min(filter(lambda x: x > curr_perm[i], suffix))\n                suffix.remove(smallest_larger)\n                prefix = curr_perm[:i]\n                next_perm = prefix + [smallest_larger] + sorted(suffix)\n                break\n        curr_perm = next_perm[:]\n        count += 1 if f(curr_perm) == max_f else 0\n    return curr_perm\n\nans = lexicographically_mth_permutation(n, m, max_f)\nprint(*ans)"
 ],
 "1339": [
  "n = int(input())\nsegments = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    segments.append((l,r,i+1))\n\nsegments.sort()\nmax_r = -1\nresult = -1\nfor i in range(n):\n    l, r, num = segments[i]\n    if r <= max_r:\n        result = num\n        break\n    max_r = r\nprint(result)"
 ],
 "1340": [
  "n = int(input())\na = list(map(int, input().split()))\n\nlast = [0] * 21\nfor i in range(1, 21):\n    last[i] = n\n\ndp = [[0] * 21 for _ in range(n+1)]\nfor i in range(n-1, -1, -1):\n    for j in range(1, 21):\n        if a[i] != j:\n            dp[i][j] = dp[last[j]][j]\n        else:\n            dp[i][j] = dp[last[j]][j] + (last[j] - i - 1)\n            last[j] = i\n\nans = n * 20\nfor i in range(1, 21):\n    ans = min(ans, dp[last[i]][i])\n\nprint(ans) "
 ],
 "1341": [
  "s = input()\nt = input()\npos = 1\nfor c in t:\n    if s[pos-1] == c:\n        pos += 1\nprint(pos)"
 ],
 "1342": [
  "n = int(input())\na = list(map(int, input().split()))\n\nmax_a = max(a)\nmin_a = min(a)\n\nresult = max_a\n\nlow = 1\nhigh = max_a\n\nwhile low <= high:\n    mid = (low + high) // 2\n    \n    can_divide = True\n    remaining = 0\n    \n    for i in range(n):\n        if a[i] > mid:\n            can_divide = False\n            break\n            \n        if a[i] >= remaining:\n            taken = min(a[i], mid)\n            remaining = mid - taken\n            \n        else:\n            remaining -= a[i]\n            \n    if can_divide and remaining <= max(mid - min_a, 0):\n        result = mid\n        high = mid-1\n    else:\n        low = mid+1\n        \nprint(result)"
 ],
 "1343": [
  "from heapq import heappush, heappop\nINF = float('inf')\n\nn, m, k = map(int, input().split())\n\n# Graph initialization\ngraph = [[] for _ in range(n+1)]\nfor i in range(m):\n    u, v, w = map(int, input().split())\n    graph[u].append((v, w))\n    graph[v].append((u, w))\n\n# Finding locations of storages\nstorages = set()\nif k > 0:\n    storages = set(map(int, input().split()))\n\n# Dijkstra's Algorithm\ndef dijkstra(start):\n    dist = [INF] * (n+1)\n    heap = [(0, start)]\n    visited = set()\n    while heap:\n        (d, u) = heappop(heap)\n        if u in visited:\n            continue\n        visited.add(u)\n        dist[u] = d\n        for v, w in graph[u]:\n            if (v not in visited) and (v not in storages):\n                heappush(heap, (d+w, v))\n    return dist\n\n# Find minimum amount of rubles to pay\nmin_rubles = INF\nfor i in range(1, n+1):\n    if i not in storages:\n        dist = dijkstra(i)\n        for storage in storages:\n            min_rubles = min(min_rubles, dist[storage] + dijkstra(storage)[i])\nif min_rubles == INF:\n    print(-1)\nelse:\n    print(min_rubles)"
 ],
 "1344": [
  "n = int(input())\na = list(map(int, input().split()))\n\ndp = [1] * n\n\nfor i in range(1, n):\n    if a[i] > a[i-1]:\n        dp[i] = dp[i-1] + 1\n\nprint(max(dp))"
 ],
 "1345": [
  "n = int(input())\na = list(map(int, input().split()))\n\nresult = [\"+\"] * n\ns = sum(a)\ncur = a[0]\nfor i in range(1, n):\n    if cur * 2 >= s:\n        result[i - 1] = \"-\"\n    cur += a[i] * (-1 if result[i - 1] == \"-\" else 1)\n\nprint(\"\".join(result))"
 ],
 "1346": [
  "from random import randint\n \nn, m, p = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n \ndef middle(left, right):\n    return (left + right) // 2\n \ndef fast_powering(base, exponent, module):\n    \"\"\"\n    \u0424\u0443\u043a\u043d\u0446\u0438\u044f \u0432\u043e\u0437\u0432\u0435\u0434\u0435\u043d\u0438\u044f \u0432 \u0441\u0442\u0435\u043f\u0435\u043d\u044c \u0437\u0430 \u043b\u043e\u0433\u0430\u0440\u0438\u0444\u043c\u0438\u0447\u0435\u0441\u043a\u043e\u0435 \u0432\u0440\u0435\u043c\u044f\n    \"\"\"\n    result = 1\n    while exponent != 0:\n        if exponent % 2 == 1:\n            result = (result * base) % module\n        exponent = exponent // 2\n        base = (base ** 2) % module\n    return result\n \ndef evaluate_polynomial(coeffs, x, p):\n    \"\"\"\n    \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043f\u043e\u043b\u0438\u043d\u043e\u043c\u0430 \u0432 \u0442\u043e\u0447\u043a\u0435 \u043f\u043e \u043c\u043e\u0434\u0443\u043b\u044e p\n    \"\"\"\n    result = coeffs[0]\n    power_of_x = 1\n    for i in range(1, len(coeffs)):\n        power_of_x = (power_of_x * x) % p\n        result = (result + coeffs[i] * power_of_x) % p\n    return result\n \n# \u0413\u0435\u043d\u0435\u0440\u0438\u0440\u0443\u0435\u043c \u043f\u0440\u043e\u0441\u0442\u044b\u0435 \u0447\u0438\u0441\u043b\u0430 \u0434\u043b\u044f \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c\u0430 \u0420\u0430\u0431\u0438\u043d\u0430-\u041a\u0430\u0440\u043f\u0430\nprime1 = 1\nwhile prime1 == 1:\n    prime1 = randint(1, p - 1)\n \nprime2 = 1\nwhile prime2 == 1:\n    prime2 = randint(1, p - 1)\n    \n    \n# \u0412\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043f\u043e\u043b\u0438\u043d\u043e\u043c\u043e\u0432 \u0432 \u0442\u043e\u0447\u043a\u0435 prime1 \u0438 prime2\nf_prime1_rem = evaluate_polynomial(a, prime1, p)\nf_prime2_rem = evaluate_polynomial(a, prime2, p)\n \ng_prime1_rem = evaluate_polynomial(b, prime1, p)\ng_prime2_rem = evaluate_polynomial(b, prime2, p)\n \n# \u0412\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0438\u0437\u0432\u0435\u0434\u0435\u043d\u0438\u044f \u043f\u043e\u043b\u0438\u043d\u043e\u0432\u043e\u0432 \u0432 \u0442\u043e\u0447\u043a\u0435 prime1 \u0438 prime2\nh_prime1, h_prime2 = f_prime1_rem * g_prime1_rem, f_prime2_rem * g_prime2_rem\n \n# \u0415\u0441\u043b\u0438 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043f\u0440\u043e\u0438\u0437\u0432\u0435\u0434\u0435\u043d\u0438\u044f \u043f\u043e\u043b\u0438\u043d\u043e\u0432\u043e\u0432 \u0432 \u0442\u043e\u0447\u043a\u0435 prime1 \u0438 prime2 \u043d\u0435 \u0440\u0430\u0432\u043d\u044b, \u0442\u043e \u043e\u0442\u0432\u0435\u0442 \u043d\u0430\u0439\u0434\u0435\u043d\nif h_prime1 % p != h_prime2 % p:\n    print(1)\nelse:\n    # \u0418\u043d\u0430\u0447\u0435 \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u043c \u043b\u043e\u043a\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044e \u043a\u043e\u0440\u043d\u044f \u0438 \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043f\u0440\u043e\u0438\u0437\u0432\u0435\u0434\u0435\u043d\u0438\u0435 \u043f\u043e\u043b\u0438\u043d\u043e\u043c\u043e\u0432 \u0432 \u043d\u043e\u0432\u043e\u0439 \u0442\u043e\u0447\u043a\u0435\n    left, right = 0, n + m - 2\n     \n    # \u041f\u043e\u043a\u0430 \u043c\u044b \u043d\u0435 \u043d\u0430\u0448\u043b\u0438 \u0442\u043e\u0447\u043a\u0443, \u0433\u0434\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043f\u0440\u043e\u0438\u0437\u0432\u0435\u0434\u0435\u043d\u0438\u044f \u043f\u043e\u043b\u0438\u043d\u043e\u043c\u043e\u0432 \u043f\u043e \u043c\u043e\u0434\u0443\u043b\u044e p \u043d\u0435 \u0434\u0435\u043b\u0438\u0442\u0441\u044f \u043d\u0430 p\n    while True:   \n        mid = middle(left, right)\n         \n        # \u0412\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043c\u043d\u043e\u0433\u043e\u0447\u043b\u0435\u043d\u0430 non-modulo\n        non_modulo_polynomial = [0] * (n + m - 1)\n        for i in range(n):\n            for j in range(m):\n                non_modulo_polynomial[i + j] += a[i] * b[j]\n         \n        to_check = fast_powering(prime1, mid, p)\n        remainder = evaluate_polynomial(non_modulo_polynomial, to_check, p)\n         \n        if remainder % p != 0 or left == right:\n            print(mid + 1)\n            break\n        else:\n            if h_prime1 % p == evaluate_polynomial(a, prime1, p) * evaluate_polynomial(b, prime1, p):\n                right = mid\n            else:\n                left = mi"
 ],
 "1347": [
  "from collections import defaultdict\n\ndef dfs(word, synonyms, visited, r_count):\n    global min_r, min_len\n    visited.add(word)\n    r_count += word.lower().count('r')\n    if r_count < min_r:\n        min_r = r_count\n        min_len = sum(len(w) for w in new_essay)\n    elif r_count == min_r:\n        curr_len = sum(len(w) for w in new_essay)\n        if curr_len < min_len:\n            min_len = curr_len\n    for syn in synonyms[word]:\n        if syn not in visited:\n            new_essay.append(syn)\n            dfs(syn, synonyms, visited, r_count)\n            new_essay.pop()\n\nm = int(input())\nessay = input().lower().split()\nn = int(input())\nsynonyms = defaultdict(set)\nfor i in range(n):\n    x, y = input().split()\n    synonyms[x.lower()].add(y.lower())\n\nmin_r, min_len = float('inf'), float('inf')\nfor word in essay:\n    new_essay = [word]\n    visited = set()\n    dfs(word.lower(), synonyms, visited, 0)\n\nprint(min_r, min_len)"
 ],
 "1348": [
  "from collections import deque\nn, k = map(int, input().split())\nd = list(map(int, input().split()))\nadj = [[] for _ in range(n)]\nfreq = [0]*n\nfor i in range(n):\n    l, r = max(0, i-d[i]), min(n-1, i+d[i])\n    for j in range(l, r+1):\n        if i != j and d[j] + j >= i - d[i]:\n            adj[i].append(j)\n            freq[i] += 1\n            if freq[i] > k:\n                print(-1)\n                exit()\nans = []\nvisited = [False]*n\nfor i in range(n):\n    if not visited[i]:\n        queue = deque([i])\n        visited[i] = True\n        while queue:\n            v = queue.popleft()\n            for u in adj[v]:\n                if not visited[u]:\n                    visited[u] = True\n                    queue.append(u)\n                    ans.append((v+1, u+1))\nprint(len(ans))\nfor a, b in ans:\n    print(a, b)"
 ],
 "1349": [
  "t = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    tap_locs = list(map(int, input().split()))\n    max_distance = max(tap_locs[0]-1, n-tap_locs[-1])\n    for i in range(k-1):\n        max_distance = max(max_distance, (tap_locs[i+1]-tap_locs[i])//2)\n    print(max_distance+1)"
 ],
 "1350": [
  "n, k = map(int, input().split())\ns = input()\n\ncnt = [0] * k\nfor c in s:\n    cnt[ord(c) - ord('A')] += 1\n\nans = min(cnt) * k\nprint(ans)"
 ],
 "1351": [
  "l, r = map(int, input().split())\nfor i in range(l, r+1):  \n    if len(set(str(i))) == len(str(i)):\n        print(i)\n        break\nelse:\n    print(-1)"
 ],
 "1352": [
  "from bisect import bisect_left\n\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\ncnt = 0\n\nfor l in range(1, x + 1):\n    r = bisect_left(a, l) - 1\n    if r == -1:\n        continue\n    sorted_so_far = []\n    for i in range(n):\n        if a[i] > r:\n            continue\n        if not sorted_so_far or a[i] >= sorted_so_far[-1]:\n            sorted_so_far.append(a[i])\n    if len(sorted_so_far) == r - l + 1:\n        cnt += 1\n        \nprint(cnt)"
 ],
 "1353": [
  "n, m, a, b = map(int, input().split())\nif m * a <= b:\n    print(n * a)\nelse:\n    print((n // m) * b + min((n % m) * a, b))"
 ],
 "1354": [
  "n, k, a = map(int, input().split())\nm = int(input())\nshots = sorted(list(map(int, input().split())))\n\nif n % a != 0:\n    gaps = [shots[i + 1] - shots[i] - 1 for i in range(m - 1)]\n    for i in range(a):\n        total_gap = sum(gaps[i::a])\n        ships = (n - k * a - total_gap) // a\n        if ships < 0:\n            print(shots[i] + (n - k * a - total_gap))\n            break\n    else:\n        print(\"-1\")\n\nelse:\n    for i in range(a):\n        total_gap = shots[i + 1] - shots[i] - a\n        ships = (n - k * a - total_gap) // a\n        if ships < 0:\n            print(shots[i] + a + (n - k * a - total_gap))\n            break\n    else:\n        print(\"-1\")"
 ],
 "1355": [
  "from math import sqrt\n\nn, m = map(int, input().split())\n\npolygon = []\nfor i in range(n):\n    x, y = map(float, input().split())\n    polygon.append((x, y))\n\nlines = []\nfor i in range(m):\n    x1, y1, x2, y2 = map(float, input().split())\n    lines.append((x1, y1, x2, y2))\n\nfor line in lines:\n    x1, y1, x2, y2 = line\n    length = 0\n    for i in range(n):\n        x3, y3 = polygon[i]\n        x4, y4 = polygon[(i+1)%n]\n        a1 = y2 - y1\n        b1 = x1 - x2\n        c1 = -a1*x1 - b1*y1\n        a2 = y4 - y3\n        b2 = x3 - x4\n        c2 = -a2*x3 - b2*y3\n        det = a1*b2 - a2*b1\n        if det == 0:\n            continue\n        inter_x = (b1*c2 - b2*c1) / det\n        inter_y = (a2*c1 - a1*c2) / det\n        if min(x1, x2) <= inter_x <= max(x1, x2) and min(y1, y2) <= inter_y <= max(y1, y2) and min(x3, x4) <= inter_x <= max(x3, x4) and min(y3, y4) <= inter_y <= max(y3, y4):\n            length += sqrt((inter_x-x1)**2 + (inter_y-y1)**2)\n            x1, y1 = inter_x, inter_y\n    print(\"{:.10f}\".format(length))"
 ],
 "1356": [
  "s = input().strip()\na_count = s.count('a')\n\nif a_count > len(s)//2:\n    print(len(s))\nelse:\n    print(2*a_count-1)"
 ],
 "1357": [
  "n, m = map(int, input().split())\na = list(map(int, input().split()))\ntime = a[0] - 1\nfor i in range(1, m):\n    if a[i] >= a[i-1]:\n        time = time + a[i] - a[i-1]\n    else:\n        time = time + n - a[i-1] + a[i]\nprint(time)"
 ],
 "1358": [
  "from collections import defaultdict\n\nk, n = map(int, input().split())\n\n# Divide the strings into two groups, according to if they are palindromes or not\npalindrome_beauties = defaultdict(int)\nnon_palindrome_beauties = defaultdict(int)\n\nfor i in range(k):\n    s, beauty = input().split()\n    beauty = int(beauty)\n    if s == s[::-1]:\n        palindrome_beauties[s] += beauty\n    else:\n        non_palindrome_beauties[s] += beauty\n\n# Calculate the total beauty of palindromes\ntotal_palindrome_beauty = sum(palindrome_beauties.values())\n\n# Calculate the max beauty of pairs of non-palindromes with the same reversed string\nmax_non_palindrome_pair_beauty = 0\nnon_palindrome_set = set(non_palindrome_beauties.keys())  # convert to set for faster membership check\nfor s in list(non_palindrome_set):\n    reverse_s = s[::-1]\n    if reverse_s in non_palindrome_set:\n        max_non_palindrome_pair_beauty = max(max_non_palindrome_pair_beauty,\n                                             non_palindrome_beauties[s] + non_palindrome_beauties[reverse_s])\n        non_palindrome_set.remove(s)  # remove to avoid checking the reverse pair twice\n\n# Add the max beauty of non-palindrome pairs to the total palindrome beauty\nprint(total_palindrome_beauty + max_non_palindrome_pair_beauty)"
 ],
 "1359": [
  "n, m = map(int, input().split())\ngraph = [[] for _ in range(n)]\n\nfor _ in range(m):\n    a, b = map(int, input().split())\n    graph[a-1].append(b-1)\n\ncount = 0\nfor i in range(n):\n    for j in graph[i]:\n        for k in graph[j]:\n            if i != k and k in graph[i]:\n                count += 1\nprint(count//2)"
 ],
 "1360": [
  "n = int(input())\nexams = []\nfor i in range(n):\n    a, b = map(int, input().split())\n    exams.append((a, b))\n\nexams.sort()\n\nmin_day = exams[0][0]\n\nfor i in range(1, n):\n    if exams[i][1] >= min_day:\n        min_day = exams[i][1]\n    else:\n        min_day = exams[i][0]\n\nprint(min_day)"
 ],
 "1361": [
  "n = int(input())\na = list(map(int, input().split()))\n\nmin_difficulty = float('inf')\nfor i in range(1, n - 1):\n    # remove the i-th hold\n    current_difficulty = max(a[j + 1] - a[j] for j in range(n) if j != i and j != i - 1)\n    min_difficulty = min(min_difficulty, current_difficulty)\n\nprint(min_difficulty)"
 ],
 "1362": [
  "n, p, m = map(int, input().split())\ntopup = {}\nfor i in range(n):\n    d, t = map(int, input().split())\n    topup[d] = t\nbalance = 0\nans = 0\nfor i in range(1, m+1):\n    balance -= p\n    if i in topup:\n        balance += topup[i]\n    if balance < 0:\n        ans += 1\n        balance += p\nprint(ans)"
 ],
 "1363": [
  "from itertools import combinations\n\ng, d, f = map(int, input().split())\ngoalies = set(map(int, input().split()))\ndefenders = set(map(int, input().split()))\noffence = set(map(int, input().split()))\n\nvalid_team_count = 0\n\nfor goalie in goalies:\n    for defender_1, defender_2 in combinations(defenders, 2):\n        for forward_1, forward_2, forward_3 in combinations(offence, 3):\n            team = {goalie, defender_1, defender_2, forward_1, forward_2, forward_3}\n            max_num = max(team)\n            min_num = min(team)\n            if (max_num <= min_num * 2 and (max_num - min_num) <= max_num // 2):\n                valid_team_count += 1\n\nprint(valid_team_count)"
 ],
 "1364": [
  "n = int(input())\nsushi = list(map(int, input().split()))\ntuna_count = sum([1 for x in sushi if x == 1])\neel_count = sum([1 for x in sushi if x == 2])\n\nif tuna_count != eel_count:\n    print(0)\nelse:\n    ans = 0\n    for i in range(n):\n        curr_tuna = 0\n        curr_eel = 0\n        for j in range(i, n):\n            if sushi[j] == 1:\n                curr_tuna += 1\n            else:\n                curr_eel += 1\n            if curr_tuna == curr_eel:\n                ans = max(ans, j-i+1)\n    print(ans)"
 ],
 "1365": [
  "MOD = 10**9 + 7\n\ndef dfs(v, p):\n    dp[v][0] = 1\n    for u in adj[v]:\n        if u != p:\n            dfs(u, v)\n            new_dp = [0] * (k+2)\n            for i in range(k+1):\n                for j in range(k+1):\n                    if i+j+2 <= k+1:\n                        new_dp[max(i+1,j)] = (new_dp[max(i+1,j)] + dp[v][i] * dp[u][j]) % MOD\n            for i in range(k+2):\n                dp[v][i] = new_dp[i]\n                \nn, k = map(int, input().split())\nadj = [[] for _ in range(n+1)]\nfor _ in range(n-1):\n    u, v = map(int, input().split())\n    adj[u].append(v)\n    adj[v].append(u)\n    \ndp = [[0] * (k+2) for _ in range(n+1)]\ndfs(1, 0)\nprint(sum(dp[1]) % MOD)"
 ],
 "1366": [
  "n = int(input())\n\nremainder = 0\nfor i in range(n):\n    a, b = map(int, input().split())\n    remainder += b - a\n\nif remainder < 0:\n    print(-1)\nelse:\n    print(remainder)"
 ],
 "1367": [
  "n = int(input())\nwatched = set(map(int, input().split()))\n\nfor i in range(1, n+1):\n    if i not in watched:\n        print(i)\n        break"
 ],
 "1368": [
  "from itertools import combinations\nfrom statistics import mean\n\nn, a, b = map(int, input().split())\nv = sorted(list(map(int, input().split())), reverse=True)\n\nmax_mean = mean(v[:a])\ncount = 0\n\nfor c in combinations(v, a):\n    if mean(c) == max_mean:\n        count += 1\n\nprint(max_mean)\nprint(count)"
 ],
 "1369": [
  "import math\n\ndef dist(x1, y1, x2, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calc_radius(x, y):\n    if len(x) == 1:\n        return 0\n    radius = dist(x[0], y[0], x[1], y[1]) / 2\n    for i in range(len(x)):\n        for j in range(i + 1, len(x)):\n            if dist(x[i], y[i], x[j], y[j]) / 2 > radius:\n                radius = dist(x[i], y[i], x[j], y[j]) / 2\n                for k in range(j + 1):\n                    for l in range(j + 1, len(x)):\n                        if dist(x[k], y[k], x[l], y[l]) / 2 > radius:\n                            cx = (x[k] + x[l]) / 2\n                            cy = (y[k] + y[l]) / 2\n                            radius = dist(x[k], y[k], cx, cy)\n    return radius\n\nn = int(input())\nx, y = [], []\nfor _ in range(n):\n    xi, yi = map(int, input().split())\n    x.append(xi)\n    y.append(yi)\nprint('{:.10f}'.format(calc_radius(x, y)))"
 ],
 "1370": [
  "H, W, K = map(int, input().split())\nS = [list(map(int, input())) for _ in range(H)]\n\nans = float('inf')\n\nfor bit in range(1 << (H-1)):\n    cnt = 0  # Number of cuts made\n    white = [0] * H  # Number of white squares in each block\n    prev = 0  # Row index of the start of the current block\n    for i in range(H):\n        for j in range(W):\n            white[prev] += S[i][j]\n            # If white squares exceed K, a cut is needed\n            if white[prev] > K:\n                cnt += 1  \n                white = [0] * H\n                prev = i\n                # If we need more cuts than previously found, stop searching\n                if cnt > ans:\n                    break\n        # If we need more cuts than previously found, stop searching\n        if cnt > ans:\n            break\n        # If we have a new block, update the row index of the start of the next block\n        if bit & (1 << i):\n            cnt += 1\n            white = [0] * H\n            prev = i\n    # If every block has K or less white squares, update the answer\n    if max(white) <= K and cnt < ans:\n        ans = cnt\n\nprint(ans)"
 ],
 "1371": [
  "python\nMOD = 10**9+7\nS = int(input())\ndp = [0] * (S+1)\ndp[0] = 1\nfor i in range(3, S+1):\n    for j in range(i, S+1):\n        dp[j] += dp[j-i]\n        dp[j] %= MOD\nprint(dp[S])"
 ],
 "1372": [
  "h, n = map(int, input().split())\n\n# initialize the dp table with a high value\ndp = [float('inf')] * (h+1)\ndp[0] = 0\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    for j in range(a, h+1):\n        dp[j] = min(dp[j], dp[j-a] + b)\n\nprint(dp[h])"
 ],
 "1373": [
  "MOD = 10**9 + 7\nn, k = map(int, input().split())\n\nans = 0\nfor i in range(k, n + 2):\n    # minimum\n    min_sum = (i * (i-1)) // 2 \n    # maximum\n    max_sum = (i * (2 * n - i + 1)) // 2\n\n    ans += (max_sum - min_sum + 1) % MOD\n\nprint(ans % MOD)"
 ],
 "1374": [
  "n = int(input())\na = list(map(int, input().split()))\nm = []\nfor i in range(n):\n    b = []\n    for j in range(i, n):\n        b.append(a[j])\n        b.sort()\n        m.append(b[len(b)//2])\nm.sort()\nprint(m[len(m)//2])"
 ],
 "1375": [
  "n = int(input())\narr = list(map(int, input().split()))\n\nprefix_sum = [0] * n\nprefix_sum[0] = arr[0]\n\nfor i in range(1, n):\n    prefix_sum[i] = prefix_sum[i-1] + arr[i]\n\nif prefix_sum[-1] % 3 != 0:\n    print(0)\nelse:\n    target_sum = prefix_sum[-1] // 3\n    first = []\n    second = []\n\n    for i in range(n-2):\n        if prefix_sum[i] == target_sum:\n            first.append(i)\n        if prefix_sum[i] == 2 * target_sum:\n            second.append(i)\n    ans = 0\n\n    for i in first:\n        ans += len(second) - bisect.bisect_right(second, i)\n    print(ans)"
 ],
 "1376": [
  "n = int(input())\na = list(map(int, input().split()))\n\npos = [[] for i in range(n)]\nfor i in range(2 * n):\n    pos[a[i] - 1].append(i)\n\nsasha = 0\ndima = 0\nans = 0\nfor i in range(n):\n    ans += abs(pos[i][0] - sasha) + abs(pos[i][1] - dima)\n    sasha = pos[i][0]\n    dima = pos[i][1]\n\nprint(ans)"
 ],
 "1377": [
  "n = int(input())\nradii = list(map(int, input().split()))\n\nmin_radius = min(radii)\nmax_radius = max(radii)\n\nmin_radius_count = radii.count(min_radius)\nmax_radius_count = radii.count(max_radius)\n\nif min_radius_count == 1:\n    if max_radius_count == 1:\n        min_index = radii.index(min_radius) \n        max_index = radii.index(max_radius)         \n        if abs(min_index - max_index) == 1:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n    else:\n        print(\"NO\")\nelse:\n    if max_radius_count == 1:\n        print(\"NO\")\n    else:\n        print(\"YES\")"
 ],
 "1378": [
  "n = int(input())\n\ncourt_points = list(map(int, input().split()))\n\nbill_points = [0] * n\n\nfor i in range(n):\n    if i % 2 == 0:\n        bill_points[i] = court_points[i//2]\n\nused_points = set(bill_points)\n\navailable_points = sorted(set(range(n)) - used_points)\n\nfor i in range(n):\n    if i % 2 == 1:\n        bill_points[i] = available_points[-1]\n        available_points.pop()\n\nprint(*bill_points)"
 ],
 "1379": [
  "n, m, d = map(int, input().split())\na = list(map(int, input().split()))\n \npos = {a[i]:i for i in range(n)}\na.sort()\n \nst = []\nans = [0]*n\nused = set()\nfor i in range(n):\n  if a[i] in used:\n    continue\n  ans[pos[a[i]]] = len(st) + 1\n  st.append(a[i])\n  used.add(a[i])\n  j = i+1\n  while j < n and a[j] - a[i] < d:\n    ans[pos[a[j]]] = len(st)\n    used.add(a[j])\n    j += 1\n \nprint(len(st))\nprint(*ans)"
 ],
 "1380": [
  "n, k = map(int, input().split())\nheights = list(map(int, input().split()))\n\nactions = []\nfor i in range(n-1):\n    diff = k - (heights[i+1] - heights[i])\n    if diff > 0:\n        actions.append((\"+\", i+1, diff))\n        heights[i+1] += diff\n    elif diff < 0:\n        actions.append((\"-\", i+1, abs(diff)))\n        heights[i+1] -= abs(diff)\n        \nprint(len(actions))\nfor a in actions:\n    print(\"{} {} {}\".format(a[0], a[1], a[2]))"
 ],
 "1381": [
  "import math\n\nk, n, s, p = map(int, input().split())\n\nsheets_needed = math.ceil(k * n / s)\n\npacks_needed = math.ceil(sheets_needed / p)\n\nprint(packs_needed)"
 ],
 "1382": [
  "from collections import defaultdict\n\n\nn, m = map(int, input().split())\ngraph = defaultdict(list)\nfor _ in range(m):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\nCOLOR_UNKNOWN = 0\nCOLOR_WHITE = 1\nCOLOR_BLACK = 2\ncolor = [COLOR_UNKNOWN] * (n + 1)\ncounts = [0, 0]\n\ndef dfs(u, c):\n    global counts\n    color[u] = c\n    for v in graph[u]:\n        if color[v] == COLOR_UNKNOWN:\n            dfs(v, 3 - c)\n        elif color[v] == c:\n            counts[0] += 1\n            return\n\nfor u in range(1, n + 1):\n    if color[u] == COLOR_UNKNOWN:\n        counts[1] += 1\n        dfs(u, COLOR_WHITE)\n\nif counts[0] == 0:\n    if counts[1] >= 2:\n        print(\"1 {}\".format(counts[1] * (counts[1] - 1) // 2))\n    else:\n        print(\"3 {}\".format(n * (n - 1) // 2))\nelse:\n    print(counts[0], 0)"
 ],
 "1383": [
  "n,m=map(int,input().split())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\n\na.sort()\nb.sort()\nc=[]\nfor i in range(n):\n    c.append((b[i]-a[i])%m)\n\nif len(set(c))==1:\n    print(c[0])\nelse:\n    print(m-a[-1]+b[0])"
 ],
 "1384": [
  "n = int(input())\ngames = list(map(int, input().split()))\n\ndp = [1] * n\nfor i in range(1, n):\n    if games[i] == 0 and games[i-1] == 1:\n        dp[i] = dp[i-1]\n    elif games[i] == 0:\n        dp[i] = dp[i-1]\n    elif games[i] == 1 and games[i-1] == 0:\n        dp[i] = dp[i-1] + 1\n    else:\n        dp[i] = dp[i-1] + 1\n\nprint(dp[-1])"
 ],
 "1385": [
  "s = input().strip()\nidx = 0\nn = len(s)\nwhile idx < n:\n    if s[idx] == \" \":\n        idx += 1\n        continue\n    elif s[idx] == '\"':\n        idx += 1\n        while s[idx] != '\"':\n            print(s[idx], end=\"\")\n            idx += 1\n        print(\"<>\", end=\"\")\n        idx += 1\n    else:\n        while idx < n and s[idx] != \" \":\n            print(s[idx], end=\"\")\n            idx += 1\n        print(\"<>\", end=\"\")\n    print()"
 ],
 "1386": [
  "MOD = 998244353\n\ndef power(x, y):\n    ret = 1\n    while y > 0:\n        if y & 1:\n            ret = ret * x % MOD\n        x = x * x % MOD\n        y >>= 1\n    return ret\n\nw, h = map(int, input().split())\n\nans = power(2, w+h) * power(3, w*h) % MOD\nprint(ans)"
 ],
 "1387": [
  "n, t = map(int, input().split())\na = list(map(int, input().split()))\n\ncur_cell = 1\nwhile cur_cell < t:\n    cur_cell += a[cur_cell - 1]\n    if cur_cell == t:\n        print(\"YES\")\n        break\nelse:\n    print(\"NO\")"
 ],
 "1388": [
  "from collections import deque\nfrom sys import setrecursionlimit\n\nsetrecursionlimit(10**6)\n\nn = int(input())\na = [0] * n\nb = [0] * n\nc = [0] * n\nfor i in range(n):\n    a[i], b[i], c[i] = map(int, input().split())\ng = [[] for _ in range(n)]\nfor i in range(n - 1):\n    u, v = map(int, input().split())\n    g[u - 1].append(v - 1)\n    g[v - 1].append(u - 1)\n\nsz = [1] * n\nanc = [[0] * 20 for _ in range(n)]\nlogn = 20\ndp = [[float(\"inf\")] * 2 for _ in range(n)]\n\ndef dfs(u, par):\n    for v in g[u]:\n        if v != par:\n            sz[u] += dfs(v, u)\n\n    for bit in range(logn):\n        if bit == 0:\n            anc[u][bit] = par\n        else:\n            p = anc[u][bit - 1]\n            anc[u][bit] = anc[p][bit - 1]\n\n    if b[u] != c[u]:\n        dp[u][c[u]] = a[u]\n\n    for bit in range(logn):\n        if c[anc[u][bit]] == c[u]:\n            x = anc[u][bit]\n            dp[u][c[u]] = min(dp[u][c[u]], dp[x][c[u]] + (sz[u] - sz[x]) * a[u])\n\n    ans = float(\"inf\")\n    for bit in range(logn):\n        if b[anc[u][bit]] == c[u]:\n            x = anc[u][bit]\n            ans = min(ans, dp[x][c[u]] + (n - sz[x]) * a[u])\n\n    dp[u][b[u]] = ans\n    return sz[u]\n\ndfs(0, -1)\nif dp[0][b[0]] == float(\"inf\"):\n    print(-1)\nelse:\n    print(dp[0][b[0]])"
 ],
 "1389": [
  "n, m = map(int, input().split())\nfeature = []\nfor i in range(n):\n    feature.append(input())\n\nops = 0\nfor i in range(n):\n    for j in range(m):\n        if feature[i][j] != 'W':\n            continue\n        ops += int(i==0 or feature[i-1][j] != 'W')\n        ops += int(j==0 or feature[i][j-1] != 'W')\n        ops += int(i==n-1 or feature[i+1][j] != 'B')\n        ops += int(j==m-1 or feature[i][j+1] != 'B')\n        \nprint(ops)"
 ],
 "1390": [
  "n, m = map(int, input().split())\npuzzles = list(map(int, input().split()))\n\npuzzles.sort()\nmin_diff = float('inf')\n\nfor i in range(n-1, m):\n    diff = puzzles[i] - puzzles[i-n+1]\n    min_diff = min(min_diff, diff)\n\nprint(min_diff)"
 ],
 "1391": [
  "n, m, a = map(int, input().split())\nb = list(map(int, input().split()))\np = list(map(int, input().split()))\n\np.sort()\nans = count = money = 0\nsum_b = sum(b)\n\nif sum(p) + max(b) > a:\n    for i in range(m):\n        if p[i] > a:\n            break\n        count += 1\n        money += p[i]\n        if sum_b + money >= a:\n            break\n    for i in range(n):\n        if b[i] >= p[0] and count < m and sum_b < a:\n            count += 1\n            money += p[count - 1]\n            sum_b += b[i]\n        elif sum_b >= a:\n            break\n        else:\n            break\n    ans = min(n, count)\n    if ans == 0:\n        money = 0\n    else:\n        money += max(0, a - sum_b - sum(p[:count]))\nprint(ans, money)"
 ],
 "1392": [
  "n, k = map(int, input().split())\na = set(str(i) for i in range(k+1))\nans = 0\nfor i in range(n):\n    s = set(input().strip())\n    if a.issubset(s):\n        count = min(s.count(str(j)) for j in range(1, k+1))\n        ans += count\nprint(ans)"
 ],
 "1393": [
  "s = input()\nt = input()\n\nyay = 0\nwhoops = 0\n\nfor letter in s:\n    if letter in t:\n        yay += 1\n        t = t.replace(letter, '', 1)\n    elif letter.lower() in t:\n        whoops += 1\n        t = t.replace(letter.lower(), '', 1)\n        \nprint(yay, whoops)"
 ],
 "1394": [
  "t = input().strip()\n\nif 'a' not in t:\n    print(t[:len(t)//2])\nelse:\n    idx = t.find('a')\n    if t[idx+1:].count('a') <= idx:\n        print(t[:idx+t[idx+1:].index('a')+1])\n    else:\n        print(\":(\")"
 ],
 "1395": [
  "s = input().strip()\nm = int(input())\n\nn = len(s)\ns += s\ngood_shifts = []\nfor i in range(n):\n    shift = int(s[i:i+n])\n    if shift >= 10**(n-1) and shift <= 10**n-1:\n        good_shifts.append(shift%m)\n\nprint(min(good_shifts))"
 ],
 "1396": [
  "n, k, x = map(int, input().split())\nballs = list(map(int, input().split()))\n\ncount = 0\ni = 0\n\nwhile i < n:\n    if balls[i] == x:\n        j = i + 1\n        while j < n and balls[j] == x:\n            j += 1\n        if j - i >= 3:\n            count += j - i\n            if i > 0 and j < n and balls[i-1] == balls[j]:\n                count += 1\n            i = j\n        else:\n            i += 1\n    else:\n        i += 1\n\nprint(count)"
 ],
 "1397": [
  "from itertools import combinations\n\nn, m = map(int, input().split())\n\n# creating the set of banned cities\nbanned_cities = set()\nfor _ in range(m):\n    a, b = map(int, input().split())\n    banned_cities.add((a,b))\n    banned_cities.add((b,a))\n\n# creating the set of all possible roads\nall_roads = set(combinations(range(1, n+1), 2))\n\n# creating the set of valid roads\nvalid_roads = all_roads - banned_cities\n\n# constructing the graph using valid roads\ngraph = {i: set() for i in range(1, n+1)}\nfor road in valid_roads:\n    u, v = road\n    graph[u].add(v)\n    graph[v].add(u)\n\n# finding the minimum number of additional roads to be constructed\nadditional_roads = set()\nvisited = set()\nfor city in range(1, n+1):\n    if city not in visited:\n        visited.add(city)\n        queue = [city]\n        while queue:\n            current = queue.pop(0)\n            for neighbor in graph[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n                    if (current, neighbor) not in valid_roads and (neighbor, current) not in valid_roads:\n                        additional_roads.add((current, neighbor))\n\n# outputting the answer\nprint(len(valid_roads) + len(additional_roads))\nfor road in valid_roads:\n    print(road[0], road[1])\nfor road in additional_roads:\n    print(road[0], road[1])"
 ],
 "1398": [
  "n = int(input())\nmeasurements = list(map(int, input().split()))\n\nmeasurements.sort()\n\nleft = 0\nright = n-1\n\nwhile left < right:\n    if measurements[right] <= 2*measurements[left]:\n        break\n    else:\n        left += 1\n        right -= 1\n\nprint(n - (right - left + 1))"
 ],
 "1399": [
  "from collections import defaultdict\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef get_integer_points(x1, y1, x2, y2):\n    if y1 == y2:\n        return [(i, y1) for i in range(min(x1, x2), max(x1, x2) + 1)]\n    elif x1 == x2:\n        return [(x1, i) for i in range(min(y1, y2), max(y1, y2) + 1)]\n    else:\n        if x1 > x2:\n            x1, y1, x2, y2 = x2, y2, x1, y1\n        dx = x2 - x1\n        dy = y2 - y1\n        sign = 1 if dy > 0 else -1\n        g = gcd(abs(dx), abs(dy))\n        xstep = dx // g\n        ystep = sign * abs(dy) // g\n        res = []\n        x, y = x1, y1\n        for i in range(g):\n            res.append((x, y))\n            x += xstep\n            y += ystep\n        res.append((x2, y2))\n        return res\n\nn = int(input())\npoints = set()\nfor i in range(n):\n    x1, y1, x2, y2 = map(int, input().split())\n    integer_points = get_integer_points(x1, y1, x2, y2)\n    for point in integer_points:\n        points.add(point)\nprint(len(points))"
 ],
 "1400": [
  "MOD = 10**9 + 7\n\nn, T = map(int, input().split())\nt = list(map(int, input().split()))\n\np = [1] + [0] * n\ntsum = 0\nres = 0\n\nfor i in range(n):\n    tsum += t[i]\n    for j in range(min(i+1, n+1))[::-1]:\n        p[j] = (p[j] * (1 - 0.5**i) % MOD + p[j-1] * 0.5**i % MOD) % MOD\n\n    s = sum(p[j] for j in range(n+1) if tsum + j <= T)\n    res = (res + s * (i+1)) % MOD\n\nprint(res)"
 ],
 "1401": [
  "n = int(input())\na = list(map(int,input().split()))\nadj = [[] for i in range(n)]\nfor i in range(n-1):\n    p,c = map(int,input().split())\n    adj[p-1].append([i+1,c])\nans = 0\ndef dfs(u):\n    global ans\n    sad = False\n    biggest = 0\n    for v,c in adj[u]:\n        child = dfs(v)\n        if child + c > a[v-1]:\n            sad = True\n        else:\n            biggest = max(biggest, child + c)\n    if sad:\n        ans += 1\n        return 0\n    else:\n        return biggest\ndfs(0)\nprint(ans)"
 ],
 "1402": [
  "MOD = 10**9+7\n\nn = int(input())\ns1 = input().strip()\ns2 = input().strip()\n\ngreater = [0]*n\nless = [0]*n\nunknown = [0]*n\n\nfor i in range(n):\n    if s1[i] == '?' and s2[i] == '?':\n        unknown[i] = 2\n    elif s1[i] == '?':\n        unknown[i] = 1\n        less[i] = int(s2[i])\n        greater[i] = int(s2[i])-1\n    elif s2[i] == '?':\n        unknown[i] = 1\n        greater[i] = int(s1[i])\n        less[i] = int(s1[i])+1\n    elif s1[i] > s2[i]:\n        greater[i] = int(s1[i])\n        less[i] = int(s2[i])+1\n    elif s1[i] < s2[i]:\n        greater[i] = int(s2[i])\n        less[i] = int(s1[i])+1\n    \ndp = [[0]*3 for _ in range(n)]  # 0: =, 1: <, 2: >\n\ndp[0][0] = unknown[0]+1\ndp[0][1] = 1 if less[0] else 0\ndp[0][2] = 1 if greater[0] else 0\n\nfor i in range(1, n):\n    # equal case\n    if unknown[i] == 2:\n        # case when previous state is equal\n        dp[i][0] = (dp[i-1][0]*10)%MOD\n        # case when previous state is less\n        dp[i][0] = (dp[i][0]+dp[i-1][1])%MOD\n        # case when previous state is greater\n        dp[i][0] = (dp[i][0]+dp[i-1][2])%MOD\n        \n    if unknown[i] == 1:\n        # case when previous state is equal\n        dp[i][0] = (dp[i-1][0]*1)%MOD\n        # case when previous state is less\n        dp[i][0] = (dp[i][0]+dp[i-1][1]*1)%MOD\n        # case when previous state is greater\n        dp[i][0] = (dp[i][0]+dp[i-1][2]*1)%MOD\n        \n        # case when previous state is less\n        if less[i]:\n            dp[i][1] = (dp[i-1][1]*1)%MOD\n            dp[i][1] = (dp[i][1]+dp[i-1][0]*less[i])%MOD\n            dp[i][1] = (dp[i][1]+dp[i-1][2]*less[i])%MOD\n        \n        # case when previous state is greater\n        if greater[i]:\n            dp[i][2] = (dp[i-1][2]*1)%MOD\n            dp[i][2] = (dp[i][2]+dp[i-1][0]*greater[i])%MOD\n            dp[i][2] = (dp[i][2]+dp[i-1][1]*greater[i])%MOD\n            \n    if unknown[i] == 0:\n        # case when previous state is equal\n        if s1[i] == s2[i]:\n            dp[i][0] = dp[i-1][0]\n            \n        # case when previous state is less\n        if less[i]:\n            if s1[i] == '?':\n                dp[i][1] = (dp[i-1][1]*1)%MOD\n                dp[i][1] = (dp[i][1]+dp[i-1][0]*less[i])%MOD\n            elif s1[i] < s2[i]:\n                dp[i][1] = dp[i-1][1]\n                \n        # case when previous state is greater\n        if greater[i]:\n            if s1[i] == '?':\n                dp[i][2] = (dp[i-1][2]*1)%MOD\n                dp[i][2] = (dp[i][2]+dp[i-1][0]*greater[i])%MOD\n            elif s1[i] > s2[i]:\n                dp[i][2] = dp[i-1][2]\n\nways = (dp[n-1][0]+dp[n-1][1]+dp[n-1][2])%MOD\nprint(ways)"
 ],
 "1403": [
  "n, k = map(int, input().split())\nbacteria = sorted(list(map(int, input().split())))\n\ni = 0\nj = 1\nwhile j < n:\n    while j < n and bacteria[j] <= bacteria[i] + k:\n        j += 1\n    if j == n:\n        break\n    i = j\n    j += 1\n\nprint(n - (j - i))"
 ],
 "1404": [
  "MOD = 998244353\n\nn = int(input())\na = [int(x) for x in input().split()]\n\ndp = [[0] * 201 for _ in range(n + 1)]\n\nfor i in range(1, n + 1):\n    if a[i-1] != -1:\n        dp[i][a[i-1]] = 1\n    else:\n        for j in range(1, 201):\n            for k in range(max(1, j-1), min(201, j+2)):\n                dp[i][j] += dp[i-1][k]\n                dp[i][j] %= MOD\n\nprint(sum(dp[n]) % MOD)"
 ],
 "1405": [
  "n = int(input())\narr = list(map(int,input().split()))\nfreq = {}\nfor val in arr:\n    freq[val] = freq.get(val,0) + 1 \narr.sort(reverse = True)\nmaxlen = 0 \nfor i in range(n-1):\n    for j in range(i+1,n):\n        fib = [arr[i], arr[j]]\n        cnt = 2 \n        while True:\n            nxt = fib[-1] + fib[-2]\n            if nxt in freq and freq[nxt] > 0:\n                freq[nxt] -= 1 \n                cnt += 1 \n                fib.append(nxt)\n            else:\n                break \n        for f in fib[2:]:\n            freq[f] += 1 \n        if cnt > 2:\n            maxlen = max(maxlen,cnt)\nprint(maxlen)"
 ],
 "1406": [
  "n, k, d = map(int, input().split())\nif k**d < n:\n    print(-1)\nelse:\n    bus_arrangement = [[0 for j in range(d)] for i in range(n)]\n    for i in range(n):\n        x = i\n        for j in range(d):\n            bus_arrangement[i][j] = (x % k) + 1\n            x //= k\n    for i in range(d):\n        for j in range(n):\n            print(bus_arrangement[j][i], end=\" \")\n        print()"
 ],
 "1407": [
  "from math import sqrt\n\n\ndef is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\n\nn, m = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\nrow_primes = set()  # set of all column indices that have a prime number\ncol_primes = set()  # set of all row indices that have a prime number\n\nfor i in range(n):\n    for j in range(m):\n        if is_prime(matrix[i][j]):\n            row_primes.add(i)\n            col_primes.add(j)\n\nmin_moves = float('inf')\n\nfor i in row_primes:\n    row_moves = sum([not is_prime(matrix[i][j]) for j in range(m)])\n    min_moves = min(min_moves, row_moves)\n\nfor j in col_primes:\n    col_moves = sum([not is_prime(matrix[i][j]) for i in range(n)])\n    min_moves = min(min_moves, col_moves)\n\nprint(min_moves)"
 ],
 "1408": [
  "n = int(input())\nbooks = []\nfor i in range(n):\n  t, w = map(int, input().split())\n  books.append((t, w))\nbooks.sort(key=lambda x: x[1]) # sort by width\n\ndp = [float('inf')] * (n+1)\ndp[0] = 0\nfor i in range(n):\n  t, w = books[i]\n  for j in range(n, 0, -1):\n    if j >= t:\n      dp[j] = min(dp[j], dp[j-t] + w)\n\nans = float('inf')\nfor i in range(n+1):\n  if dp[i] != float('inf'):\n    horizontal = sum([b[1] for b in books if b[0] == 2 and b[1] <= i])\n    ans = min(ans, max(horizontal, dp[i]))\n\nprint(ans)"
 ],
 "1409": [
  "python\nn, k = map(int, input().split())\nparticipations = list(map(int, input().split()))\nparticipations.sort(reverse=True)\n\ncount = 0\nfor i in range(0, n-2, 3):\n    if participations[i] >= k and participations[i+1] >= k and participations[i+2] >= k:\n        count += 1\n\nprint(count)"
 ],
 "1410": [
  "import sys\ninput = sys.stdin.readline\n\nn = int(input())\nc = [list(map(int, input().split())) for i in range(3)]\nadj = [[] for i in range(n)]\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    adj[u-1].append(v-1)\n    adj[v-1].append(u-1)\n\ndeg = [0] * n\nfor i in range(n):\n    deg[i] = len(adj[i])\n\nroot = 0\nfor i in range(n):\n    if deg[i] > 2:\n        print(-1)\n        exit(0)\n    if deg[i] == 1:\n        root = i\n\ndp = [[0]*3 for i in range(n)]\npar = [[-1]*3 for i in range(n)]\ndef dfs(u, p):\n    for i in range(3):\n        dp[u][i] = c[i][u]\n    par[u][0] = p\n    for v in adj[u]:\n        if v == p: continue\n        dfs(v, u)\n        for i in range(3):\n            for j in range(3):\n                if i != j and dp[v][j] + c[i][u] < dp[u][i]:\n                    dp[u][i] = dp[v][j] + c[i][u]\n                    par[u][i] = j\n\ndfs(root, -1)\nids = [None] * n\ndef color(u, p, col):\n    ids[u] = col\n    for i in range(3):\n        if i != col and i != par[u][col]:\n            color_child = i\n    for v in adj[u]:\n        if v == p: continue\n        color(v, u, color_child)\n\ncol = dp[root].index(min(dp[root]))\nres = dp[root][col]\ncolor(root, -1, col)\nprint(res)\nprint(*[ids[i]+1 for i in range(n)])"
 ],
 "1411": [
  "n, s = map(int, input().split())\ncustomers = []\nfor i in range(n):\n    si, ai, bi = map(int, input().split())\n    customers.append((si, ai, bi))\n\ndef get_happiness(pizzas):\n    total_happiness = 0\n    for si, ai, bi in customers:\n        type1_slices = min(si, pizzas[0])\n        type2_slices = min(si - type1_slices, pizzas[1])\n        total_happiness += type1_slices * ai + type2_slices * bi\n    return total_happiness\n\nlo = 1\nhi = 10**18\nwhile lo < hi:\n    mid = (lo + hi) // 2\n    pizzas = [mid, (mid + s - 1) // s]\n    if get_happiness(pizzas) >= get_happiness([p + 1 for p in pizzas]):\n        hi = mid\n    else:\n        lo = mid + 1\n\nprint(get_happiness([lo, (lo + s - 1) // s]))"
 ],
 "1412": [
  "from bisect import bisect_left, bisect_right\n\nn, k = map(int, input().split())\n\ncoupons = []\nfor i in range(n):\n    l, r = map(int, input().split())\n    coupons.append((l, r))\n    \ncoupons.sort()\n\nprefix_max = [coupons[0][1]]\nfor i in range(1, n):\n    prefix_max.append(max(prefix_max[-1], coupons[i][1]))\n    \nans = 0\nchosen_coupons = []\nfor i in range(n-k+1):\n    total_range = (coupons[i+k-1][0], prefix_max[i+k-2])\n    left_idx = bisect_left(coupons, total_range)\n    right_idx = bisect_right(coupons, total_range)\n    cnt = right_idx - left_idx\n    if cnt > ans:\n        ans = cnt\n        chosen_coupons = [j+1 for j in range(i, i+k)]\n        \nprint(ans)\nprint(*chosen_coupons)"
 ],
 "1413": [
  "n = int(input())\ns = input()\n\ncount = 0\nfor i in range(n):\n    for j in range(i, n):\n        if int(s[i:j+1]) % 2 == 0:\n            count += 1\n\nprint(count)"
 ],
 "1414": [
  "n,m=map(int,input().split())\n\ngrid=[]\nfor i in range(n):\n    a=list(input().strip())\n    grid.append(a)\n\ndef dfs(x,y,letter,dima):\n    if letter==3:\n        if grid[x][y]=='A':\n            dima[0]=dima[0]+1\n        return\n    if letter==0:\n        if grid[x][y]=='D':\n            dfs(x,y+1,letter+1,dima)\n            dfs(x,y-1,letter+1,dima)\n            dfs(x-1,y,letter+1,dima)\n            dfs(x+1,y,letter+1,dima)\n        return\n    if letter==1:\n        if grid[x][y]=='I':\n            dfs(x,y+1,letter+1,dima)\n            dfs(x,y-1,letter+1,dima)\n            dfs(x-1,y,letter+1,dima)\n            dfs(x+1,y,letter+1,dima)\n        return\n    if letter==2:\n        if grid[x][y]=='M':\n            dfs(x,y+1,letter+1,dima)\n            dfs(x,y-1,letter+1,dima)\n            dfs(x-1,y,letter+1,dima)\n            dfs(x+1,y,letter+1,dima)\n        return\n    if letter==3:\n        if grid[x][y]=='A':\n            dfs(x,y+1,0,dima)\n            dfs(x,y-1,0,dima)\n            dfs(x-1,y,0,dima)\n            dfs(x+1,y,0,dima)\n        return\n\nflag = False\ncount=0\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 'D':\n            dima = [0]\n            dfs(i,j,0,dima)\n            if dima[0] > 0:\n                if dima[0] > 1:\n                    flag = True\n                count = max(count,dima[0])\n\nif flag: \n    print(\"Poor Inna!\")\nelif count==0:\n    print(\"Poor Dima!\")\nelse:\n    print(count)"
 ],
 "1415": [
  "x, y, x0, y0 = map(int, input().split())\ns = input()\n\nvisited = [[False] * y for _ in range(x)] # Grid to store if a cell has been visited or not\nvisited[x0-1][y0-1] = True # Starting cell is already visited\n\ncount = [0] * (len(s)+1) # List to store the count of tests for each k from 0 to len(s)\n\nfor i in range(len(s)):\n    if s[i] == 'L':\n        if y0 > 1: # Move to left\n            y0 -= 1\n    elif s[i] == 'R':\n        if y0 < y: # Move to right\n            y0 += 1\n    elif s[i] == 'U':\n        if x0 > 1: # Move up\n            x0 -= 1\n    elif s[i] == 'D':\n        if x0 < x: # Move down\n            x0 += 1\n            \n    if visited[x0-1][y0-1]: # If the cell is already visited i.e. robot is in a loop\n        continue\n        \n    visited[x0-1][y0-1] = True # Marking the cell as visited\n    empty_cells = sum([row.count(False) for row in visited]) # Counting the empty cells which haven't been visited yet\n    count[i+1] = empty_cells # Setting the count for k=i+1\n    \nprint(*count) # Printing the counts for all values of k"
 ],
 "1416": [
  "n, w = map(int, input().split())\na = sorted(list(map(int, input().split())))\nx = min(a[0], a[n]/2, w/(3*n))\nprint(3*n*x)"
 ],
 "1417": [
  "from functools import reduce\nfrom sys import stdin\n\nMOD = 998244353\n\nn = int(stdin.readline().strip())\n\nfct = [1] * (n+1)\nfor i in range(1, n+1):\n    fct[i] = fct[i-1] * i % MOD\n\nans = reduce(lambda x, y: (x + y) % MOD, [fct[n] * fct[i] * pow(fct[i], MOD-2, MOD) % MOD * pow(n+1-i, n, MOD) for i in range(1, n+1)])\n\nprint(ans)"
 ],
 "1418": [
  "n = int(input())\nprimes = [True] * (n+1)\np = 2\nwhile p**2 <= n:\n    if primes[p]:\n        for i in range(p**2, n+1, p):\n            primes[i] = False\n    p += 1\n\ncolor = [None] * (n+1)\nnum_colors = 0\nfor i in range(2, n+1):\n    if primes[i]:\n        num_colors += 1\n        color[i] = num_colors\n\nfor i in range(2, n+1):\n    if not primes[i]:\n        factors = []\n        tmp = i\n        for d in range(2, i):\n            if d*d > i:\n                break\n            while tmp % d == 0:\n                tmp //= d\n                factors.append(d)\n        if tmp > 1:\n            factors.append(tmp)\n        if len(set(factors)) == 1:\n            color[i] = color[factors[0]]\n        else:\n            used = set(color[d] for d in set(factors))\n            for c in range(1, num_colors+1):\n                if c not in used:\n                    color[i] = c\n                    break\n\nprint(*color[2:])"
 ],
 "1419": [
  "k = int(input())\ntext = input().split()\n\n# function to check if the given width is enough to fit the text with k lines or not\ndef checkWidth(width):\n    lines = 1\n    currWidth = 0\n    for word in text:\n        if len(word) > width:\n            return False\n        if currWidth + len(word) <= width:\n            currWidth += len(word) + 1\n        else:\n            lines += 1\n            currWidth = len(word)\n    return lines <= k\n\n# binary search to find minimal width\nleft = 1\nright = len(''.join(text))\nwhile left <= right:\n    mid = (left + right) // 2\n    if checkWidth(mid):\n        right = mid - 1\n    else:\n        left = mid + 1\n\nprint(left)"
 ],
 "1420": [
  "n, l = map(int, input().split())\nlanterns = list(map(int, input().split()))\nlanterns.sort()\n\nmax_distance = max(lanterns[0], l - lanterns[-1])\n\nfor i in range(n-1):\n    max_distance = max(max_distance, (lanterns[i+1] - lanterns[i])/2)\n\nprint(\"{:.10f}\".format(max_distance))"
 ],
 "1421": [
  "n=int(input()) \nw=list(map(int,input().split())) \nedges=[] \nfor _ in range(n-1): \n    a,b=map(int,input().split()) \n    edges.append([a-1,b-1]) \n    edges.append([b-1,a-1]) \nnexts=[[] for _ in range(n)] \nfor a,b in edges: \n    nexts[a].append(b) \n \ndp=[[0,0] for _ in range(n)] \ndef dfs(v,f):   \n    sm=[0,0] \n    for u in nexts[v]: \n        if u==f:continue  \n        dfs(u,v) \n        dpv=dp[u] \n        l=sm[0]+dpv[0]-w[u] \n        r=max(sm[1]+dpv[0],sm[0]+dpv[1],sm[1]+dpv[1]+w[u]) \n        sm=[l,r] \n    dp[v]=sm \ndfs(0,-1) \nans=max(dp[0]) \nif ans<=0:print(\"Impossible\") \nelse:print(ans)"
 ],
 "1422": [
  "weights = input()\nm = int(input())\nweights_available = []\nfor i in range(10):\n    if weights[i] == '1':\n        weights_available.append(i+1)\n\nif m == 1:\n    print(\"YES\")\n    print(weights_available[0])\n    exit()\n\nif len(weights_available) == 0:\n    print(\"NO\")\n    exit()\n\npossible = False\nweights_on_scales = []\n\nfor i in range(len(weights_available)):\n    weights_on_scales = [weights_available[i]]\n    for j in range(len(weights_available)):\n        if j == i:\n            continue\n        if j % 2 == 0:\n            if weights_on_scales[-1] >= weights_available[j]:\n                continue\n            weights_on_scales.append(weights_available[j])\n        else:\n            if sum(weights_on_scales) <= weights_available[j] or (len(weights_on_scales) > 1 and weights_on_scales[-2] == weights_available[j]):\n                continue\n            weights_on_scales.append(weights_available[j])\n\n        if len(weights_on_scales) == m:\n            possible = True\n            break\n    if possible:\n        break\n\nif possible:\n    print(\"YES\")\n    print(*weights_on_scales)\nelse:\n    print(\"NO\")"
 ],
 "1423": [
  "n, l, r = map(int, input().split())\na = list(map(int, input().split()))\np = list(map(int, input().split()))\n\nnum_to_count = [0] * n\nused_nums = []\navailable_nums = set(range(l, r+1))\n\nfor i, pi in enumerate(p):\n    num_to_count[pi-1] = i\n    if len(used_nums) > num_to_count[pi-1]:\n        print(-1)\n        exit()\n    while len(used_nums) < num_to_count[pi-1]:\n        used_nums.append(l)\n        available_nums.remove(l)\n    if a[i] + len(used_nums) - 1 > r:\n        print(-1)\n        exit()\n    b_i = a[i] + len(used_nums) - 1\n    used_nums.append(b_i)\n    available_nums.remove(b_i)\n\nprint(\" \".join(map(str, used_nums)))"
 ],
 "1424": [
  "n, m, k = map(int, input().split())\nplayers = [int(input()) for _ in range(m+1)]\nfedor = players.pop()\n\nfriends = 0\nfor player in players:\n    diff = bin(player ^ fedor).count('1')\n    if diff <= k:\n        friends += 1\n\nprint(friends)"
 ],
 "1425": [
  "n = int(input())\na = list(map(int, input().split()))\na.sort()\nif a[-1] >= sum(a[:-1]):\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    a = a[::-1]\n    print(*a[1:], a[0])"
 ],
 "1426": [
  "from collections import deque\n\n# Reading input\nN, M = map(int, input().split())\ngraph = [[] for _ in range(N)]\nfor _ in range(M):\n    u, v = map(int, input().split())\n    graph[u-1].append(v-1)\n\n# BFS to find shortest distance\nstart, end = map(int, input().split())\nstart, end = start-1, end-1\ndist = [-1] * N\ndist[start] = 0\nqueue = deque([start])\nwhile queue:\n    node = queue.popleft()\n    for neighbor in graph[node]:\n        if dist[neighbor] == -1:\n            dist[neighbor] = dist[node] + 1\n            queue.append(neighbor)\n\n# Output shortest distance\nprint(dist[end])"
 ],
 "1427": [
  "MOD = 10**9 + 7\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nn = int(input())\na = list(map(int, input().split()))\n\nlcm = a[0]\nfor i in range(1, n):\n    lcm = lcm * a[i] // gcd(lcm, a[i])\n\nans = 0\nfor i in range(n):\n    ans += lcm // a[i]\n\nprint(ans % MOD)"
 ],
 "1428": [
  "from itertools import permutations\nINF = 10 ** 18\n\nn, c = map(int, input().split())\nd = [list(map(int, input().split())) for _ in range(c)]\nc = [list(map(int, input().split())) for _ in range(n)]\n\nans = INF\n\nfor perm in permutations(range(c), 3):\n    cost = 0\n    for i in range(n):\n        for j in range(n):\n            color = c[i][j] - 1 # 0-indexed\n            cost += d[color][perm[(i+j)%3]]\n    ans = min(ans, cost)\n\nprint(ans)"
 ],
 "1429": [
  "n,s=input().split()\nn=int(n)\nans=0\nfor i in range(n):\n    for j in range(i+1,n+1):\n        t=s[i:j]\n        if sorted(t)==['A','C','G','T'] or sorted(t)==['A','A','T','T'] or sorted(t)==['C','C','G','G']:\n            if t==(t[::-1]).translate(str.maketrans('ATCG','TAGC')):\n                ans+=1\nprint(ans)"
 ],
 "1430": [
  "n,k = map(int, input().split())\ns = input()\n\nones = [] # List to keep track of positions with 1's\nlast = '0' # The last character to compare\ncount = 0 # Count of how many consecutive 1's we've encountered so far\nfor i in range(n):\n    if s[i] != last:\n        if last == '1':\n            ones.append(count)\n        count = 1\n        last = s[i]\n    else:\n        count += 1\nif last == '1':\n    ones.append(count)\n\n# We want to try to flip the smallest possible number of ones, but no more than k flips\n# Starting with the leftmost group of one and working our way rightwards:\n# If we flip the current group, we add 2*length to the total number of ones\n# We can then try to merge this group with any subsequent groups of ones that we encounter\n# If we encounter a group that we can't merge with, we flip it and add its length to our total\n# We repeat until we've made K flips or we can't merge any more groups\n\nnum_flips = min(k, len(ones))\nranges = [(0, n-1)]\nfor i in range(num_flips):\n    # Find the shortest group of ones that we can flip\n    length, index = min([(ones[i], i) for i in range(len(ones))])\n    l, r = ranges[index]\n    # Remove the range that we're about to flip from our list\n    del ones[index]\n    del ranges[index]\n    # Add the parts to the left and right of the flipped range to the list\n    if l > 0:\n        ones.insert(0, l)\n        ranges.insert(0, (0, l-1))\n    if r < n-1:\n        ones.append(r-l+1-length)\n        ranges.append((r+1, n-1))\n\n# Calculate the length of the longest sequence of ones\nones.sort(reverse=True)\nmax_len = sum(ones[:num_flips])\nprint(max_len)"
 ],
 "1431": [
  "n = int(input())\na = list(map(int, input().split()))\n\nans = []\nfor i in range(n, 0, -1):\n    if a[i-1] == 1:\n        if sum(ans) % 2 == 0:\n            ans.append(i)\n\nif sum(ans) % 2 == 1:\n    if 1 in ans:\n        ans.remove(1)\n    else:\n        print(-1)\n        exit()\n\nprint(len(ans))\nprint(*ans[::-1])"
 ],
 "1432": [
  "n=int(input())\na=list(map(int,input().split()))\nx=[0]*n\nfor i in range(n//2):\n    x[i*2+1]=(a[i]-sum(x))//2\n    x[i*2]=a[i]-x[i*2+1]\nx[-1]=(a[-1]-sum(x))//2\nprint(*[2*i for i in x])"
 ],
 "1433": [
  "n, m = map(int, input().split())\ngrid = [list(map(int, input().split())) for _ in range(n)]\n\n# Count good positions for left direction\ncnt = 0\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == 0:\n            if any(grid[i][k] for k in range(j+1, m)):\n                cnt += 1\nfor j in range(m):\n    for i in range(n):\n        if grid[i][j] == 0:\n            if any(grid[k][j] for k in range(i+1, n)):\n                cnt += 1\n\n# Count good positions for right direction\nfor i in range(n):\n    for j in range(m-1, -1, -1):\n        if grid[i][j] == 0:\n            if any(grid[i][k] for k in range(j)):\n                cnt += 1\nfor j in range(m-1, -1, -1):\n    for i in range(n):\n        if grid[i][j] == 0:\n            if any(grid[k][j] for k in range(i)):\n                cnt += 1\n\nprint(cnt)"
 ],
 "1434": [
  "n = int(input())\ndegrees = []\nxor_sums = []\n\nfor i in range(n):\n    degree, xor_sum = map(int, input().split())\n    degrees.append(degree)\n    xor_sums.append(xor_sum)\n\nnum_edges = sum(degrees) // 2\nprint(num_edges)\n\nfor v in range(n):\n    while degrees[v] > 0:\n        for u in range(n):\n            if degrees[u] > 0 and xor_sums[v] ^ xor_sums[u] == degrees[v] - 1:\n                print(v, u)\n                degrees[v] -= 1\n                degrees[u] -= 1\n                xor_sums[v] ^= u\n                xor_sums[u] ^= v\n                break"
 ],
 "1435": [
  "s = input().strip()\nans = 0\nn = len(s)\ni = 0\nwhile i < n-1:\n    if s[i] == '9':\n        i += 1\n    elif ord(s[i])+ord(s[i+1])-2*ord('0') == 9:\n        ans += 1\n        j = i+2\n        while j<n and s[j]!='9' and ord(s[j])+ord(s[j-1])-2*ord('0')==9:\n            j += 1\n        a = j-i-1\n        ans += (a+1)*a//2\n        i = j\n    else:\n        i += 1\nprint(ans+1 if s[-1]=='9' else ans)"
 ],
 "1436": [
  "n = int(input())\nevents = list(map(int, input().split()))\n\npolice = 0\nuntreated = 0\n\nfor event in events:\n    if event == -1:\n        if police == 0:\n            untreated += 1\n        else:\n            police -= 1\n    else:\n        police += event\n\nprint(untreated)"
 ],
 "1437": [
  "MOD = 10**9 + 7\nbase64_integers = {chr(i): i-48 if i <= 57 else i-55 if i <= 90 else i-61 if i <= 122 else 62 if i == 45 else 63 for i in range(128)}\ns = input()\nn = len(s)\ntarget = sum(base64_integers[c] * (64**(n-i-1)) for i, c in enumerate(s)) % MOD\n\ncount = [0]*64\nfor i in range(64):\n    for j in range(64):\n        if (i & j) == target:\n            count[i] += 1\nresult = 0\nfor i in range(64):\n    for j in range(64):\n        if (i & j) == target:\n            result += count[i] * count[j]\n            result %= MOD\nprint(result)"
 ],
 "1438": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nlo, hi = 0, 10**9+1\nwhile hi-lo > 1:\n    mid = (lo+hi)//2\n    cnt = 0\n    for i in range(n):\n        need = mid*a[i]\n        if need > b[i]:\n            cnt += need-b[i]\n        if cnt > k:\n            break\n    if cnt <= k:\n        lo = mid\n    else:\n        hi = mid\n\nprint(lo)"
 ],
 "1439": [
  "n, m = map(int, input().split())\na = list(map(int, input().split()))\nprefix_sum = [0]\nfor num in a:\n    prefix_sum.append((prefix_sum[-1] + num) % m)\nif len(set(prefix_sum)) == 1:\n    print(\"YES\")\nelse:\n    print(\"NO\")"
 ],
 "1440": [
  "n = int(input())\nsticks = list(map(int, input().split()))\n\ntriangles = 0\n\n# Check if we have enough sticks of each length to form a triangle\nfor i in range(1, n):\n    min_sticks = min(sticks[i], sticks[i-1])\n    triangles += min_sticks\n    sticks[i] -= min_sticks\n    sticks[i-1] -= min_sticks\n\n# Check if we have enough sticks of length n-1 to form additional triangles\nfor i in range(n-2):\n    min_sticks = min(sticks[i], sticks[i+1])\n    triangles += min_sticks // 2\n    sticks[i] -= min_sticks\n    sticks[i+1] -= min_sticks\n\nprint(triangles)"
 ],
 "1441": [
  "mod = 1000000007\nn = int(input())\na = list(map(int,input().split()))\n\nf = [1] * (n+1)\nfor i in range(2, n+1):\n    f[i] = (f[i-1] * i) % mod\n\nans = 1\n\nn1, n2 = 0, 0\nfor i in range(1, n+1):\n    if a[i-1] == 1:\n        n1 += 1\n    else:\n        n2 += 1\n\nif n2 == 0:\n    ans = f[n1]\nelse:\n    ans2 = 1\n    for i in range(n1+1, n+1):\n        ans2 = (ans2 * i) % mod\n\n    c = 1\n    for i in range(1, n2+1):\n        c = (c * i) % mod\n\n    c = (c * f[n2-1]) % mod\n\n    ans2 = (ans2 * c) % mod\n    ans = ans2\n\nprint(ans)"
 ],
 "1442": [
  "n, s = map(int, input().split())\n\nbuy_orders = {}  # dictionary with price as key and volume as value \nsell_orders = {}  # dictionary with price as key and volume as value\n\nfor i in range(n):\n    d, p, q = input().split()\n    p, q = int(p), int(q)\n    if d == 'B':\n        if p in buy_orders:\n            buy_orders[p] += q\n        else:\n            buy_orders[p] = q\n    else:\n        if p in sell_orders:\n            sell_orders[p] += q\n        else:\n            sell_orders[p] = q\n\nbest_buy_orders = sorted(buy_orders.items(), reverse=True)[:s]\nbest_sell_orders = sorted(sell_orders.items(), reverse=False)[:s]\n\nfor order in best_sell_orders:\n    print(\"S\", order[0], order[1])\n    \nfor order in best_buy_orders:\n    print(\"B\", order[0], order[1])"
 ],
 "1443": [
  "n = int(input())\nsegments = list(map(int, input().split()))\nterrain = input()\n\ntime = 0\nstamina = 0\n\nfor i in range(n):\n    if terrain[i] == 'G':\n        # walking on grass\n        time += segments[i] * 5\n        stamina += segments[i]\n    elif terrain[i] == 'W':\n        # swimming in water\n        time += segments[i] * 3\n        stamina += segments[i]\n    else:\n        # flying over lava\n        if i == n-1 or terrain[i+1] == 'L':\n            # can fly over the whole lava segment\n            time += segments[i]\n            stamina -= segments[i]\n        else:\n            # fly as far as possible, then swim and fly again\n            j = i + 1\n            while j < n-1 and terrain[j] != 'L' and stamina >= j-i:\n                j += 1\n            dist = sum(segments[i:j])\n            if stamina >= dist:\n                # fly over the whole segment\n                time += dist\n                stamina -= dist\n            else:\n                # fly as far as possible, then swim and fly again\n                d = stamina - (j-i-1)\n                time += (dist-d) + (d*3)\n                stamina = 0\n        \nprint(time)"
 ],
 "1444": [
  "n = int(input())\nx = list(map(int, input().split()))\nk = int(input())\n\ndistances = []\nfor i in range(1, n):\n  distances.append((x[i] - x[i-1], i))\ndistances.sort()\nchosen_stations = [x[0], x[n-1]]\nfor _ in range(k-2):\n  _, index = distances.pop(0)\n  chosen_stations.append(x[index])\nchosen_stations.sort()\nprint(' '.join(str(x.index(station)+1) for station in chosen_stations))"
 ],
 "1445": [
  "n = int(input())\nlst = list(map(int, input().split()))\nfor i in range(n // 2):\n    if i % 2 == 0:\n        lst[i], lst[n - i - 1] = lst[n - i - 1], lst[i]\nprint(*lst)"
 ],
 "1446": [
  "n, m, k = map(int, input().split())\nc = list(map(int, input().split()))\n\n# Calculate bounds of bacteria of each type\nbounds = [(sum(c[:i])+1, sum(c[:i+1])) for i in range(k)]\n\n# Initialize adjacency matrix\nd = [[float('inf') if i != j else 0 for j in range(k)] for i in range(k)]\n\n# Build adjacency matrix\nfor i in range(m):\n    u, v, x = map(int, input().split())\n    u_type, v_type = None, None\n    for j in range(k):\n        if u in range(bounds[j][0], bounds[j][1]+1):\n            u_type = j\n        if v in range(bounds[j][0], bounds[j][1]+1):\n            v_type = j\n    if u_type is None or v_type is None:\n        continue\n    d[u_type][v_type] = min(d[u_type][v_type], x)\n    d[v_type][u_type] = d[u_type][v_type]\n\n# Perform Floyd-Warshall algorithm\nfor p in range(k):\n    for i in range(k):\n        for j in range(k):\n            if d[i][j] > d[i][p] + d[p][j]:\n                d[i][j] = d[i][p] + d[p][j]\n\n# Check if type-distribution is correct\nfor i in range(k):\n    for j in range(bounds[i][0], bounds[i][1]):\n        if d[i][j-bounds[i][0]] == float('inf'):\n            print('No')\n            exit()\n\n# Output result\nprint('Yes')\nfor i in range(k):\n    print(' '.join(str(d[i][j]) if d[i][j] != float('inf') else '-1' for j in range(k)))"
 ],
 "1447": [
  "from math import comb\n\nn, m = map(int, input().split())\n\nsame_card_prob = 1/m\ndifferent_cards_prob = 1 - same_card_prob\n\nif n == 1:\n    print(1)\nelse:\n    same_card_count = comb(m, 2)\n    different_card_count = comb(n*m, 2) - same_card_count\n    \n    same_card_success_prob = 1\n    different_card_success_prob = (n-1)/(2*n-2)\n    \n    total_prob = same_card_prob * same_card_success_prob * same_card_count + \\\n                 different_cards_prob * different_card_success_prob * different_card_count\n    \n    print(total_prob)"
 ],
 "1448": [
  "n, d = map(int, input().split())\nm = int(input())\n\nfor _ in range(m):\n    x, y = map(int, input().split())\n    if y-d <= x <= y+d and y+d <= n-x <= n-d+y:\n        print(\"YES\")\n    else:\n        print(\"NO\")"
 ],
 "1449": [
  "for _ in range(int(input())):\n    n,k = map(int,input().split())\n    a = list(map(int,input().split()))\n    if a[n-1]>k:\n        print(-1)\n    else:\n        m = [0]*n\n        for i in range(n):\n            j = 0\n            while j<=a[i]-1:\n                if m[i-j]==k:\n                    break\n                m[i-j]+=1\n                j+=1\n            if j<=a[i]-1:\n                break\n        if i<n-1:\n            print(-1)\n        else:\n            print(sum(m)//n)"
 ],
 "1450": [
  "s = input()\nzeros, ones, twos = s.count('0'), s.count('1'), s.count('2')\nprint('0'*zeros + '1'*ones + '2'*twos)"
 ],
 "1451": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\ndef num_lucky(num):\n    lucky_cnt = 0\n    while num > 0:\n        if num % 10 in [4, 7]:\n            lucky_cnt += 1\n        num //= 10\n    return lucky_cnt\n\ncount = 0\nfor num in a:\n    if num_lucky(num) <= k:\n        count += 1\nprint(count)"
 ],
 "1452": [
  "MOD = 10**9 + 7\nh, w = map(int, input().split())\nr = list(map(int, input().split()))\nc = list(map(int, input().split()))\n\n# Create a matrix with \"?\" in all cells\ngrid = [[\"?\" for _ in range(w)] for _ in range(h)]\n\n# Fill the cells horizontally based on r values\nfor i in range(h):\n    for j in range(r[i]):\n        grid[i][j] = \"X\"\n\n# Fill the cells vertically based on c values\nfor j in range(w):\n    for i in range(c[j]):\n        if grid[i][j] == \"X\":\n            continue\n        elif grid[i][j] == \"O\":\n            print(0)\n            exit()\n        else:\n            grid[i][j] = \"O\"\n\n# Count the number of empty cells and filled cells in the grid\nempty_cells = sum(row.count(\"?\") for row in grid)\nfilled_cells = h * w - empty_cells\n\n# Calculate the number of ways to fill the empty cells with X's and O's\nans = pow(2, empty_cells, MOD)\n\n# If there are no empty cells, check if the grid matches the given r and c values\nif empty_cells == 0:\n    for i in range(h):\n        if r[i] != grid[i].count(\"X\"):\n            print(0)\n            exit()\n    for j in range(w):\n        if c[j] != sum(grid[i][j] == \"X\" for i in range(h)):\n            print(0)\n            exit()\n\n# Otherwise, subtract the number of invalid grid configurations from the total number of configurations\nelse:\n    # Check each row for invalid configurations\n    for i in range(h):\n        if \"?\" not in grid[i]:\n            if r[i] != grid[i].count(\"X\"):\n                ans = 0\n                break\n        else:\n            if r[i] < grid[i].count(\"X\") or r[i] > w - (empty_cells - grid[i].count(\"?\")):\n                ans = 0\n                break\n\n    # Check each column for invalid configurations\n    for j in range(w):\n        col = [grid[i][j] for i in range(h)]\n        if \"?\" not in col:\n            if c[j] != col.count(\"X\"):\n                ans = 0\n                break\n        else:\n            if c[j] < col.count(\"X\") or c[j] > h - (empty_cells - col.count(\"?\")):\n                ans = 0\n                break\n\nprint(ans % MOD)"
 ],
 "1453": [
  "n, m = map(int, input().split())\na = list(map(int, input().split()))\n\na.sort() # sorting the sweets by sugar concentration\n\nprefix_sum = [0] * (n + 1) # prefix_sum[i] = sum of first i sweets\n\nfor i in range(1, n + 1):\n    prefix_sum[i] = prefix_sum[i - 1] + a[i - 1]\n\nans = [] # list to store answers for each value of k\n\nfor k in range(1, n + 1):\n    # calculate the minimum total sugar penalty for k sweets using prefix sums\n    min_penalty = prefix_sum[k]\n    for i in range(k, n, m):\n        # subtract the penalty for skipping the m least sugary sweets\n        min_penalty -= (i // m) * (a[i - m])\n        # add the penalty for eating the next k sweets\n        min_penalty += prefix_sum[min(n, i + k)] - prefix_sum[i]\n    ans.append(min_penalty)\n\nprint(*ans)"
 ],
 "1454": [
  "n,m=map(int,input().split())\na=[]\nfor i in range(n):\n    a.append(list(map(int,input().split())))\nans=0\nfor i in range(1,n-1):\n    for j in range(1,m-1):\n        if a[i][j]==0:\n            continue\n        if a[i-1][j]>=a[i][j] or a[i][j-1]>=a[i][j]:\n            continue\n        a[i][j]=max(a[i-1][j],a[i][j-1])+1\n        if a[i+1][j]<=a[i][j] or a[i][j+1]<=a[i][j]:\n            print(-1)\n            exit()\n        ans+=a[i][j]\nprint(ans)"
 ],
 "1455": [
  "n = int(input())\nm = (n+3)//2\nprint(m)\n\nfor i in range(n):\n    if i%2 == 0:\n        row = 1+i//2\n        for col in range(1,n+1,2):\n            if col <= m:\n                print(row, col)\n            else:\n                print(row-1, col)\n    else:\n        row = m+i//2\n        for col in range(2,n+1,2):\n            if col <= m:\n                print(row, col)\n            else:\n                print(row-1, col)"
 ],
 "1456": [
  "n = int(input())\nboard = [input() for i in range(n)]\nmoves = set()\nfor i in range(n):\n    for j in range(n):\n        if board[i][j] == \"o\":\n            for a in range(-n+1, n):\n                b = i + j - a\n                if 0 <= b < n and board[b][a] != \"o\":\n                    moves.add((a-j, b-i))\nif not moves:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    out = [[\".\" for j in range(2*n-1)] for i in range(2*n-1)]\n    out[n-1][n-1] = \"o\"\n    for m in moves:\n        out[m[1]+n-1][m[0]+n-1] = \"x\"\n    for r in out:\n        print(\"\".join(r))"
 ],
 "1457": [
  "AI_name = input()\nphone_name = input()\n\ncount = AI_name.count(phone_name)\n\nif count == 0:\n    print(0)\nelif count == 1:\n    if len(phone_name) == 1:\n        print(1)\n    else:\n        for i in range(len(phone_name)-1):\n            if phone_name[i:i+2] in AI_name:\n                print(1)\n                break\n        else:\n            print(2)\nelse:\n    print(2)"
 ],
 "1458": [
  "n = int(input())  # reading length of string\ns = input()  # reading the string\n\nfor i in range(n-1):\n    if s[i] > s[i+1]:  # checking if there is a substring which can be reversed to get a lexocographically smaller string\n        print(\"YES\")\n        print(i+1, i+2)  # printing the indices of the substring to be reversed\n        break\nelse:\n    print(\"NO\")  # if no such substring exists"
 ],
 "1459": [
  "n = int(input())\ndistances = list(map(int, input().split()))\ns, t = map(int, input().split())\n\nif s > t:\n    s, t = t, s # swap so that s is always less than t\n\nclockwise_path = sum(distances[s-1:t-1])\ncounterclockwise_path = sum(distances[t-1:]) + sum(distances[:s-1])\n\nprint(min(clockwise_path, counterclockwise_path))"
 ],
 "1460": [
  "n = int(input())\n\nif n==1:\n    print(2)\n    print(0,0)\n    print(1,0)\nelse:\n    print(n*4)\n    for i in range(n):\n        print(i*2,0)\n        print(i*2+1,0)\n        print(i*2,i*2+1)\n        print(i*2+1,i*2+1)"
 ],
 "1461": [
  "n, k = map(int, input().split())\nf = list(map(int, input().split()))\nw = list(map(int, input().split()))\n\ns = [-1] * n  # initialize s with -1 for each vertex\nm = [-1] * n  # initialize m with -1 for each vertex\nvisited = [False] * n  # to keep track of visited vertices\n\ndef dfs(v, d):\n    if visited[v]:\n        return  # if vertex is already visited, return\n    visited[v] = True  # mark the vertex as visited\n    if d == k:  # if we have reached the required path length\n        s[v] = 0\n        m[v] = w[v]\n    else:\n        dfs(f[v], d+1)  # explore the next vertex in the path\n        s[v] = w[v] + s[f[v]]  # update the sum of weights\n        m[v] = min(w[v], m[f[v]])  # update the minimum weight\n\nfor i in range(n):\n    dfs(i, 1)  # start dfs from each vertex\n\nfor i in range(n):\n    print(s[i], m[i])  # print the result for each vertex"
 ],
 "1462": [
  "n, k = map(int, input().split())\ncards = input()\ncoins = [0] * 26\n\nfor c in cards:\n    coins[ord(c) - ord('A')] += 1\n\ncoins.sort(reverse=True)\nans = 0\n\nfor i in range(26):\n    if k >= coins[i]:\n        ans += coins[i] ** 2\n        k -= coins[i]\n    else:\n        ans += k ** 2\n        break\n\nprint(ans)"
 ],
 "1463": [
  "n = int(input())\n\nlst = []\nfor i in range(n):\n    lst.append(list(map(int, input().split())))\n\nfor i in range(n):\n    for j in range(n):\n        if lst[i][j] != 1:\n            flag = False\n            for s in range(n):\n                for t in range(n):\n                    if lst[i][j] == lst[i][s] + lst[t][j]:\n                        flag = True\n                        break\n                if flag:\n                    break\n            if not flag:\n                print(\"No\")\n                exit()\n\nprint(\"Yes\")"
 ],
 "1464": [
  "n = int(input())\ntitles = [input() for i in range(n)]\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\nfor i in range(1, 21):\n    for s in alphabet:\n        flag = True\n        for t in titles:\n            if s*i in t:\n                flag = False\n                break\n        if flag:\n            print(s*i)\n            exit()"
 ],
 "1465": [
  "n, k = map(int, input().split())\ns = input()\n\nleft = []\nright = []\n\nfor i, c in enumerate(s):\n    if c == 'L':\n        left.append(i+1)\n    else:\n        right.append(i+1)\n\nans = []\nfor i in range(k):\n    if len(left) == 0 or len(right) == 0:\n        print(-1)\n        exit()\n\n    pairs = min(len(left), len(right))\n    cur_ans = []\n    for j in range(pairs):\n        cur_ans.append(left.pop())\n        cur_ans.append(right.pop())\n\n    ans.append(cur_ans)\n\nif len(left) > 0:\n    ans.append(left[::-1])\nelif len(right) > 0:\n    ans.append(right[::-1])\n\nfor cur_ans in ans:\n    print(len(cur_ans), end=' ')\n    print(*cur_ans)"
 ],
 "1466": [
  "import heapq\n\nn, m, k = map(int, input().split())\n\ngraph = [[] for _ in range(n)]\nedges = []\nfor i in range(m):\n    x, y, w = map(int, input().split())\n    x -= 1\n    y -= 1\n    graph[x].append((y, w, i))\n    graph[y].append((x, w, i))\n    edges.append((x, y, w, i))\n\nINF = int(1e18)\nd = [INF] * n\nd[0] = 0\nq = [(0, 0)]\nwhile q:\n    dist, v = heapq.heappop(q)\n    if dist > d[v]:\n        continue\n    for u, w, _ in graph[v]:\n        if d[v] + w < d[u]:\n            d[u] = d[v] + w\n            heapq.heappush(q, (d[u], u))\n\ngood = [False] * n\nfor i in range(n):\n    if d[i] == INF:\n        continue\n    for j, _, _ in graph[i]:\n        if d[j] == d[i] - w:\n            good[j] = True\n\nedges.sort(key=lambda x: x[2])\n\nans_edges = []\nnum_good = [0] * (m + 1)\nfor x, y, w, i in edges:\n    if not good[x] or not good[y]:\n        num_good[i+1] = num_good[i]\n        continue\n    ans_edges.append(i+1)\n    num_good[i+1] = num_good[i] + 1\n\nprint(min(num_good[m], k))\nprint(*ans_edges[:min(num_good[m], k)])"
 ],
 "1467": [
  "n = int(input())\na = list(map(int,input().split()))\n\nans = 0\nleft = 0\nxor_all = 0\n\nfor i in range(n):\n    xor_all ^= a[i]\n    if xor_all == 0 and i - left > 0:\n        ans += 1\n        left = i\n    elif i == n - 1 and left == 0:\n        ans = 1\n    elif xor_all == 0:\n        xor_all = a[i]\n        ans += 1\n        left = i\n\nif ans == 0:\n    print(-1)\nelse:\n    print(ans)"
 ],
 "1468": [
  "n = int(input())\nhashtags = [input().rstrip() for _ in range(n)]\nshortened = []\nfor hashtag in hashtags:\n    idx = hashtag.index('#') + 1\n    shortened_hashtag = hashtag[:idx]\n    shortened.append(shortened_hashtag)\nshortened.sort()\nfor i in range(n):\n    print(shortened[i])"
 ],
 "1469": [
  "L = int(input())\nx = 1\nh = 0\nedges = []\nwhile L > 1:\n    L //= 2\n    edges.append((x, x+1, h))\n    edges.append((x, x+1, 2**(h-1)))\n    x += 1 << h\n    h += 1\nif L == 1:\n    edges.append((1, x, h))\n\nN = max([max(e[:2]) for e in edges])\nM = len(edges)\nprint(N, M)\nfor e in edges:\n    print(*e)"
 ],
 "1470": [
  "x = int(input())\nans = (x//11)*2\nif x%11==0:\n    pass\nelif x%11<=6:\n    ans += 1\nelse:\n    ans += 2\nprint(ans)"
 ],
 "1471": [
  "from collections import deque\n\nn = int(input())\n\ngraph = [[] for _ in range(n+1)]\nfor i in range(n-1):\n    u, v, w = map(int, input().split())\n    graph[u].append((v, w))\n    graph[v].append((u, w))\n\ncolor = [-1]*(n+1)\ncolor[1] = 0\n\nq = deque()\nq.append(1)\nwhile q:\n    u = q.popleft()\n    for v, w in graph[u]:\n        if color[v] == -1:\n            if w % 2 == 0:\n                color[v] = color[u]\n            else:\n                color[v] = 1 - color[u]\n            q.append(v)\n\nfor i in range(1, n+1):\n    print(color[i])"
 ],
 "1472": [
  "from collections import deque\n\nN, X, Y = map(int, input().split())\n\nans = [0] * N\n\nfor i in range(1, N):\n    for j in range(i + 1, N + 1):\n        dist = min(j - i, abs(X - i) + 1 + abs(Y - j), abs(Y - i) + 1 + abs(X - j))\n        ans[dist] += 1\n\nfor k in range(1, N):\n    print(ans[k])"
 ],
 "1473": [
  "n = int(input())\nstudents = {}\nfirst_student = None\n\nfor i in range(n):\n    a, b = map(int, input().split())\n    students[a] = b\n\nfor i in range(1, n+1):\n    if i not in students.values():\n        first_student = i\n        break\n\nresult = []\nwhile first_student:\n    result.append(first_student)\n    first_student = students[first_student]\n\nprint(*result)"
 ],
 "1474": [
  "MOD = 10**9 + 7\n\nn = int(input())\nheights = list(map(int, input().split()))\n\ndp = [0] * (n + 1)\nleft = [0] * (n + 1)\nright = [0] * (n + 1)\n\nfor i in range(1, n + 1):\n    left[i] = i - 1\n    while left[i] > 0 and heights[left[i]] >= heights[i]:\n        left[i] = left[left[i]]\n\nfor i in range(n, 0, -1):\n    right[i] = i + 1\n    while right[i] <= n and heights[right[i]] >= heights[i]:\n        right[i] = right[right[i]]\n\nfor i in range(1, n + 1):\n    length = right[i] - left[i] - 1\n    dp[length] += heights[i] - max(heights[left[i]], heights[right[i]])\n    dp[length] %= MOD\n\nfor i in range(n - 1, 0, -1):\n    dp[i] += dp[i + 1]\n    dp[i] %= MOD\n\nresult = 0\nfor i in range(1, n + 1):\n    result += dp[i]\n    result %= MOD\n\nprint(result)"
 ],
 "1475": [
  "n,b,k,x=map(int,input().split())\na=list(map(int,input().split()))\ndp=[0]*x\nfor i in range(n):\n    dp[a[i]%x]+=1\nfor i in range(1,b):\n    new_dp=[0]*x\n    for j in range(x):\n        for k in range(n):\n            new_dp[(j*10+a[k])%x]+=dp[j]\n    dp=new_dp\nprint(dp[k])"
 ],
 "1476": [
  "n = int(input())\nif n == 1:\n    print(1)\n    print(1)\nelif n == 2:\n    print(1)\n    print(1)\nelse:\n    # construct the first part of the sequence with even numbers\n    even_nums = list(range(2, n+1, 2))\n    # construct the second part of the sequence with odd numbers\n    odd_nums = list(range(1, n+1, 2))\n    # combine the two sequences and print\n    print(len(even_nums + odd_nums))\n    print(*(even_nums + odd_nums))"
 ],
 "1477": [
  "n, m = map(int, input().split())\ne = list(map(int, input().split()))\nadj = [[] for _ in range(n)]\nindegree = [0] * n\nfor _ in range(m):\n    u, v = map(int, input().split())\n    adj[v].append(u)\n    indegree[u] += 1\n\nq1 = []\nq2 = []\nfor i in range(n):\n    if e[i] == 1 and indegree[i] == 0:\n        q1.append(i)\n    elif e[i] == 0 and indegree[i] == 0:\n        q2.append(i)\n\nans = 0\nwhile q1 or q2:\n    if q1:\n        ans += 1\n        temp = []\n        for i in q1:\n            for j in adj[i]:\n                indegree[j] -= 1\n                if indegree[j] == 0:\n                    temp.append(j)\n        q1 = temp\n    else:\n        temp = []\n        for i in q2:\n            for j in adj[i]:\n                indegree[j] -= 1\n                if indegree[j] == 0:\n                    if e[j] == 0:\n                        q2.append(j)\n                    else:\n                        temp.append(j)\n        q2 = temp\nprint(ans) "
 ],
 "1478": [
  "comments = input().split(',')\ncomment_tree = {}\ndepth = {} \nmax_depth = 0\nfor i in range(0, len(comments), 2):\n    comment = comments[i]\n    count = int(comments[i+1])\n    depth[comment] = -1\n    if comment not in comment_tree:\n        comment_tree[comment] = []\n    if count:\n        children = comments[i+2:i+2+count]\n        comment_tree[comment].extend(children)\nfor comment in comment_tree:\n    if comment not in depth:\n        stack = [(comment, 1)]\n        while stack:\n            curr_comment, curr_depth = stack.pop()\n            depth[curr_comment] = curr_depth\n            max_depth = max(max_depth, curr_depth)\n            for child in comment_tree[curr_comment]:\n                stack.append((child, curr_depth+1))\nprint(max_depth)\nfor d in range(1, max_depth+1):\n    print(' '.join([comment for comment in depth if depth[comment] == d]))"
 ],
 "1479": [
  "n, m, k = map(int, input().split())\npark = [input() for _ in range(n)]\nspiders = [[0]*m for _ in range(n)]  # 0 means no spider, 1 means spider at current cell, 2 means spider will be at current cell soon\nfor i in range(n):\n    for j in range(m):\n        c = park[i][j]\n        if c != \".\":\n            direction = {\"L\": (0, -1), \"R\": (0, 1), \"U\": (-1, 0), \"D\": (1, 0)}[c]\n            x, y = i + direction[0], j + direction[1]\n            if 0 <= x < n and 0 <= y < m and park[x][y] == \".\":\n                spiders[i][j] = 1\n                spiders[x][y] = 2\nfor j in range(m):\n    cnt = 0\n    for i in range(n):\n        if i > 0 and park[i-1][j] != \".\":\n            cnt += 1\n        if spiders[i][j] == 1 or (spiders[i][j] == 2 and i >= n-1):\n            cnt += 1 \n        if spiders[i][j] == 2:\n            spiders[i][j] = 1\n            spiders[i+1][j] = 2\n    print(cnt, end=\" \")"
 ],
 "1480": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\ncircle = list(range(1, n+1))\nleader = 0\n\nfor i in range(k):\n    count = a[i] % len(circle)\n    if count == 0:\n        count = len(circle)\n    leader = (leader + count - 1) % len(circle)\n    print(circle.pop(leader), end=' ')\nprint()"
 ],
 "1481": [
  "n = int(input())\nboard = [input() for _ in range(n)]\n\nfor i in range(n):\n    for j in range(n):\n        count = 0\n        if i > 0 and board[i-1][j] == 'o': # up\n            count += 1\n        if i < n-1 and board[i+1][j] == 'o': # down\n            count += 1\n        if j > 0 and board[i][j-1] == 'o': # left\n            count += 1\n        if j < n-1 and board[i][j+1] == 'o': # right\n            count += 1\n        if count % 2 == 1: # if there are odd number of adjacent 'o's\n            print(\"NO\")\n            exit()\nprint(\"YES\")"
 ],
 "1482": [
  "n, k = map(int, input().split())\na = list(map(int, input().split()))\n\nb = []\nfor i in range(1, n * k + 1):\n    if i not in a:\n        b.append(i)\n\nans = []\nfor i in range(k):\n    temp = b[:n-1]\n    temp.append(a[i])\n    temp.sort()\n    ans.append(temp)\n    b = [x for x in b if x not in temp]\n\nfor i in ans:\n    print(*i)"
 ],
 "1483": [
  "n=int(input())\np=list(map(int, input().split()))\nvisited=[False for i in range(n)]\nfor student in range(n):\n    temp=student\n    visited[temp]=True\n    while(True):\n        temp=p[temp]-1\n        if(visited[temp]):\n            print(temp+1,end=' ')\n            break\n        visited[temp]=True"
 ],
 "1484": [
  "MOD = 998244353\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\ndp = [[0, 0] for _ in range(n+1)]\ndp[0][0] = 1\n\nfor i in range(1, n+1):\n    if a[i-1] != -1:\n        if i > 1 and a[i-1] == a[i-2]:\n            dp[i][0] = dp[i-1][1]\n        else:\n            dp[i][0] = dp[i-1][1] + dp[i-1][0]\n    else:\n        dp[i][0] = 2 * dp[i-1][1] + dp[i-1][0]\n\n    # calculating dp[i][1]\n    l = i - 1\n    r = i - 1\n    while l > 0:\n        if a[l-1] != -1 and a[i-1] != -1 and a[l-1] != a[i-1]:\n            break\n        l -= 1\n    while r > l:\n        if a[r-1] != -1 and a[i-1] != -1 and a[r-1] != a[i-1]:\n            break\n        r -= 1\n    odd_sz = (i - r + l - 1) % 2 == 1\n    if odd_sz and l < i - 1 and r > 1 and a[l-1] == a[r-1]:\n        dp[i][1] = pow(k, i - (r-l+1), MOD) - dp[l][0] - dp[l][1]\n    else:\n        dp[i][1] = 0\n\n    dp[i][1] %= MOD\n    dp[i][0] %= MOD\n\nans = (dp[n][0] + dp[n][1]) % MOD\nprint(ans)"
 ],
 "1485": [
  "from math import gcd\nn, m = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\nd = [a[i+1]-a[i] for i in range(n-1)]\nlcm = 1\nfor x in d:\n    lcm = x*lcm//gcd(x, lcm)\nans = m//lcm + 1 - (a[0]-1)//lcm - (m-a[n-1])//lcm\nfor i in range(n-1):\n    diff = a[i+1]-a[i]\n    lcm_diff = diff*lcm//gcd(lcm, diff)\n    ans -= (lcm_diff//lcm)*(m//lcm_diff)\nprint(ans)"
 ],
 "1486": [
  "n = int(input())\nx = list(map(int, input().split()))\n\nfor i in range(n):\n    if i == 0:\n        print(x[1] - x[0], x[-1] - x[0])\n    elif i == n - 1:\n        print(x[-1] - x[-2], x[-1] - x[0])\n    else:\n        min_cost = min(x[i] - x[i-1], x[i+1] - x[i])\n        max_cost = max(x[i] - x[0], x[-1] - x[i])\n        print(min_cost, max_cost)"
 ],
 "1487": [
  "s = input()\nt = input()\n\nif s.count('1') + t.count('1') == len(s):\n    print(s)\nelif s.count('1') == t.count('1'):\n    print(s.replace('0', '1'))\nelse:\n    print(\"impossible\")"
 ],
 "1488": [
  "from itertools import permutations\n\nn = input()\ndestinations = list(map(int, input().split()))\n\nroutes = list(permutations(destinations))\n\ntotal_distance = 0\nfor route in routes:\n    distance = 0\n    for i in range(n-1):\n        distance += abs(route[i] - route[i+1])\n    total_distance += distance\n\ngcd_ = math.gcd(total_distance, n-1)\nprint(total_distance//gcd_, (n-1)//gcd_)"
 ],
 "1489": [
  "MOD = 10**9 + 7\n\nclass DSU:\n    def __init__(self, n):\n        self.p = list(range(n + 1))\n        self.r = [0] * (n + 1)\n        \n    def find(self, x):\n        while self.p[x] != x:\n            self.p[x] = self.p[self.p[x]]\n            x = self.p[x]\n        return x\n    \n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px != py:\n            if self.r[px] > self.r[py]:\n                px, py = py, px\n            self.p[px] = py\n            if self.r[px] == self.r[py]:\n                self.r[py] += 1\n\nn = int(input())\nxs = []\nys = []\nfor _ in range(n):\n    x, y = map(int, input().split())\n    xs.append(x)\n    ys.append(y)\nxs.sort()\nys.sort()\nmx = xs[-1] - xs[0]\nmy = ys[-1] - ys[0]\nif mx > my:\n    dsu = DSU(n)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if xs[i] == xs[j]:\n                dsu.union(i, j)\n    ans = pow(2, dsu.p.count(i) for i in range(n), MOD)\nelse:\n    dsu = DSU(n)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if ys[i] == ys[j]:\n                dsu.union(i, j)\n    ans = pow(2, dsu.p.count(i) for i in range(n), MOD)\nprint(ans)"
 ],
 "1490": [
  "n, m = map(int, input().split())\na = set(map(int, input().split()))\n\nans = []\nfor i in range(1, n+m+1):\n    if i not in a:\n        if m >= i:\n            ans.append(i)\n            m -= i\n        else:\n            break\n            \nprint(len(ans))\nprint(*ans)"
 ],
 "1491": [
  "n = int(input())\ncandies = list(map(int, input().split()))\n\nsquares = 0\nnot_squares = 0\nfor c in candies:\n    if int(c ** 0.5) ** 2 == c:\n        squares += 1\n    else:\n        not_squares += 1\n\nif squares == not_squares:\n    print(0)\nelif squares < not_squares:\n    can_add_square = not_squares - squares\n    ans = 0\n    for c in candies:\n        if int(c ** 0.5) ** 2 == c:\n            if can_add_square > 0:\n                can_add_square -= 1\n            else:\n                ans += 1\n    print(ans)\nelse:\n    can_remove_square = squares - not_squares\n    ans = 0\n    for c in candies:\n        if int(c ** 0.5) ** 2 != c:\n            if can_remove_square > 0:\n                can_remove_square -= 1\n            else:\n                ans += 1\n    print(ans)"
 ],
 "1492": [
  "from collections import deque\n\nn, m = map(int, input().split())\nforest = [input() for _ in range(n)]\n\ndef bfs(mid):\n    visited = [[False]*m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if forest[i][j]==\"X\":\n                visited[i][j]=True\n                q.append((i,j,0))\n    while q:\n        x, y, time = q.popleft()\n        if time>mid:\n            return False\n        for dx in [-1,0,1]:\n            for dy in [-1,0,1]:\n                if dx==0 and dy==0:\n                    continue\n                nx, ny = x+dx, y+dy\n                if 0<=nx<n and 0<=ny<m and not visited[nx][ny] and forest[nx][ny]==\".\":\n                    visited[nx][ny]=True\n                    q.append((nx,ny,time+1))\n    return True\n\ndef forest_on_fire(mid):\n    q = deque()\n    flag = bfs(mid)\n    if flag:\n        for i in range(n):\n            cur_row = \"\"\n            for j in range(m):\n                if visited[i][j]:\n                    cur_row += \"X\"\n                else:\n                    cur_row += \".\"\n            res.append(cur_row)\n    return flag\n\nleft, right = 0, n+m\nans = 0\nwhile left<=right:\n    mid = (left+right)//2\n    q = deque()\n    res = []\n    if forest_on_fire(mid):\n        left = mid+1\n        ans = mid\n    else:\n        right = mid-1\n\nprint(ans)\nfor row in res:\n    print(row)"
 ],
 "1493": [
  "n, m = map(int, input().split())\nboard = [input() for i in range(n)]\nfor i in range(n):\n    for j in range(m):\n        if board[i][j] == \".\": \n            print(\"B\" if (i+j)%2==0 else \"W\", end=\"\")\n        else:\n            print(\"-\", end=\"\")\n    print(\"\")"
 ],
 "1494": [
  "s = input()\np = input()\n\nn = len(s)\nm = len(p)\n\ndp = [[0] * (n+1) for _ in range(n+1)]\n\nfor i in range(n+1):\n    for j in range(i):\n        dp[i][j] = -1\n\nfor i in range(n):\n    for j in range(i+1):\n        if j < m and s[i] == p[j]:\n            dp[i+1][j+1] = max(dp[i+1][j+1], dp[i][j]+1)\n        dp[i+1][j] = max(dp[i+1][j], dp[i][j])\n        if j == dp[i][j]:\n            for k in range(i+1, n+1):\n                dp[k][j+1] = max(dp[k][j+1], dp[i][j] + (k-i-m))\n\nans = [0] * (n+1)\nfor i in range(1,n+1):\n    for j in range(i+1):\n        ans[i] = max(ans[i], dp[i][j])\n\nfor i in range(n):\n    print(ans[i]-ans[i+1]+m, end=\" \")\nprint(ans[n]-ans[n+1]+m)"
 ],
 "1495": [
  "n = int(input())\na = list(map(int, input().split()))\ntotal_operations = 0\n\nwhile all(x == a[0] for x in a) == False:\n    max_a = max(a)\n    min_a = min(a)\n    if max_a % 2 == 0 and max_a == min_a * 2:\n        for i in range(n):\n            if a[i] == max_a:\n                a[i] = int(max_a / 2)\n                total_operations += 1\n                break\n    else:\n        for i in range(n):\n            if a[i] == max_a:\n                a[i] = max_a - min_a\n                total_operations += 1\n                break\n\nprint(total_operations)"
 ],
 "1496": [
  "n, m, k, s = map(int, input().split())\nusd = list(map(int, input().split()))\ngbp = list(map(int, input().split()))\ngadgets = []\nfor i in range(m):\n    t, c = map(int, input().split())\n    gadgets.append((i + 1, t, c))\n\ngadgets.sort(key=lambda x: x[2])\n\nok, ng = n, -1\nwhile abs(ok - ng) > 1:\n    mid = (ok + ng) // 2\n    days = []\n    for i in range(n):\n        if i < mid:\n            days.append((i, \"USD\", usd[i]))\n        else:\n            days.append((i, \"GBP\", gbp[i]))\n    days.sort(key=lambda x: x[2])\n    bought_gadgets = []\n    cost = 0\n    for day in days:\n        if day[1] == \"USD\":\n            max_buy = min(len(gadgets), k - len(bought_gadgets))\n            for j in range(max_buy):\n                if gadgets[j][1] == 1:\n                    bought_gadgets.append((day[0], gadgets[j][0]))\n                    cost += gadgets[j][2]\n        else:\n            max_buy = min(len(gadgets), k - len(bought_gadgets))\n            for j in range(max_buy):\n                if gadgets[j][1] == 2:\n                    bought_gadgets.append((day[0], gadgets[j][0]))\n                    cost += gadgets[j][2]\n    if len(bought_gadgets) >= k and cost <= s:\n        ok = mid\n    else:\n        ng = mid\n\nif ok == n:\n    print(-1)\nelse:\n    days = []\n    for i in range(n):\n        if i < ok:\n            days.append((i, \"USD\", usd[i]))\n        else:\n            days.append((i, \"GBP\", gbp[i]))\n    days.sort(key=lambda x: x[2])\n    bought_gadgets = []\n    cost = 0\n    for day in days:\n        if day[1] == \"USD\":\n            max_buy = min(len(gadgets), k - len(bought_gadgets))\n            for j in range(max_buy):\n                if gadgets[j][1] == 1:\n                    bought_gadgets.append((day[0] + 1, gadgets[j][0]))\n                    cost += gadgets[j][2]\n        else:\n            max_buy = min(len(gadgets), k - len(bought_gadgets))\n            for j in range(max_buy):\n                if gadgets[j][1] == 2:\n                    bought_gadgets.append((day[0] + 1, gadgets[j][0]))\n                    cost += gadgets[j][2]\n    print(ok + 1)\n    for bought_gadget in bought_gadgets:\n        print(\"{} {}\".format(*bought_gadget))"
 ],
 "1497": [
  "n = int(input())\nroom = [input() for _ in range(n)]\n\nmax_clean_rows = 0\nfor i in range(2**n):\n    clean_rows = set(range(n))\n    for j in range(n):\n        if (i >> j) & 1:\n            for k in range(n):\n                room[k] = room[k][:j] + ('1' if room[k][j] == '0' else '0') + room[k][j+1:]\n    for row in range(n):\n        if '0' in room[row]:\n            clean_rows.discard(row)\n    max_clean_rows = max(max_clean_rows, len(clean_rows))\n    for j in range(n):\n        if (i >> j) & 1:\n            for k in range(n):\n                room[k] = room[k][:j] + ('1' if room[k][j] == '0' else '0') + room[k][j+1:]\nprint(max_clean_rows)"
 ],
 "1498": [
  "n, q = map(int, input().split())\n\nservers = [0] * n\n\nfor i in range(q):\n    t, k, d = map(int, input().split())\n    available_servers = []\n    for j in range(n):\n        if servers[j] < t:\n            available_servers.append(j)\n    if len(available_servers) < k:\n        print(-1)\n    else:\n        task_servers = available_servers[:k]\n        task_sum = sum(task_servers) + (k * t)\n        print(task_sum)\n        for j in task_servers:\n            servers[j] = t + d"
 ],
 "1499": [
  "n,m = map(int, input().split())\n\nfor i in range(1,n+1):\n    for j in range(m):\n        if j % n == i-1 or j % n == n+i-1:\n            print(j+1,end=\" \")"
 ]
}