{
 "0": "```python\ns = input()\nopen_bracket_idx = s.find('[')\n\tclose_bracket_idx = s.find(']')\n\tcolon1_idx = s.find(':')\n\tcolon2_idx = s.rfind(':')\n\tif open_bracket_idx == -1 or close_bracket_idx == -1 or colon1_idx == -1 or colon2_idx == -1 or colon2_idx <= colon1_idx:\n\t    print(-1)\n\telse:\n\t    max_len = s.count('|', colon1_idx+1, colon2_idx)\n\t    print(max_len+4)\n```",
 "1": "```python\nn = input()\ns = sum(map(int, str(n)))\nmax_sum = 0\nfor i in range(max(1, int(n)-100), int(n)+1):\n    temp_sum = sum(map(int, str(i)))\n    if temp_sum > max_sum:\n        max_sum = temp_sum\n        ans = i\nprint(ans)\n```",
 "2": "n = int(input())\nwhile True:\n    n += 1\n    if str(n).count('0') + str(n).count('1') == len(str(n)):\n        print(n - int(input()))\n        break",
 "3": "```python\nn, q = map(int, input().split())\npainters = []\nfor _ in range(q):\n    l, r = map(int, input().split())\n    painters.append((l, r))\n    \nmax_painted = 0\nfor i in range(q):\n    for j in range(i+1, q):\n        painted_sections = set(range(painters[i][0], painters[i][1]+1)) | set(range(painters[j][0], painters[j][1]+1))\n        max_painted = max(max_painted, len(painted_sections))\n        \nprint(max_painted)\n```",
 "4": "```python\nx = int(input())\nhh, mm = map(int, input().split())\ncount = 0\nwhile True:\n    if '7' in str(hh) or '7' in str(mm):\n        break\n    mm -= x\n    if mm < 0:\n        mm += 60\n        hh = (hh - 1) % 24\n    count += 1\nprint(count)\n```",
 "5": "```python\nn, pos, l, r = [int(x) for x in input().split()]\n\nif l == 1 and r == n:\n    print(0)\nelif l == 1:\n    print(abs(pos - r) + 1)\nelif r == n:\n    print(abs(pos - l) + 1)\nelse:\n    print(min(abs(pos - l), abs(pos - r)) + r - l + 2 + min(abs(pos - l), abs(pos - r)))\n```",
 "6": "```python\nimport heapq\n\ndef solve():\n    n, x = map(int, input().split())\n    delta_head = []\n    for _ in range(n):\n        d, h = map(int, input().split())\n        delta_head.append((d, h))\n    \n    # sort the attacks in decreasing order\n    delta_head.sort(key=lambda x:x[0], reverse=True)\n    \n    # we use a max-heap to store the extra heads added by each attack\n    extra_heads = []\n    num_attacks = 0\n    remaining_heads = x\n    \n    while remaining_heads > 0:\n        if not extra_heads or extra_heads[0] < remaining_heads:\n            # if no attack adds enough extra heads to defeat the remaining heads,\n            # we cannot defeat the monster\n            if not delta_head or delta_head[0][0] < remaining_heads:\n                return -1\n            num_attacks += 1\n            remaining_heads -= delta_head[0][0]\n            heapq.heappush(extra_heads, delta_head[0][1])\n            delta_head.pop(0)\n        else:\n            remaining_heads -= extra_heads[0]\n            heapq.heappop(extra_heads)\n            num_attacks += 1\n            \n    return num_attacks\n\nt = int(input())\nfor _ in range(t):\n    print(solve())\n```",
 "7": "```python\nn, m = map(int, input().split())\n\nlo = 1\nhi = int(2e9)\n\nwhile lo != hi:\n    mid = (lo + hi) // 2\n    grains = (mid * (mid + 1)) // 2\n    if grains > n + ((mid * (mid - 1)) // 2) * m:\n        hi = mid\n    else:\n        lo = mid + 1\n\nprint(lo)\n```",
 "8": "```python\nfrom collections import Counter\n\ntiles = input().split()\n\nsuits = []\nnumbers = []\n\nfor tile in tiles:\n    suits.append(tile[1])\n    numbers.append(int(tile[0]))\n\nsuits_count = Counter(suits)\nnumbers_count = Counter(numbers)\n\n# Check for a koutsu\nfor count in numbers_count.values():\n    if count > 2:\n        print(0)\n        exit()\n\n# Check for a shuntsu\nfor suit_count in suits_count.values():\n    for i in range(1, 8):\n        if suit_count < 3 and all([(i + j) in numbers_count for j in range(3)]):\n            print(0)\n            exit()\n\n# Check for two shuntsu\nfor suit_count in suits_count.values():\n    for i in range(1, 8):\n        if suit_count < 2 and all([(i + j) in numbers_count for j in range(3)]) and all([((i + j) in numbers_count and numbers_count[i + j] > (i == 1 or i + 2 == 8 or i + 2 == 9)) or (i + j) not in numbers_count for j in range(-1, 4)]):\n            print(1)\n            exit()\n\nprint(2)\n```",
 "9": "```python\nd = int(input())\nn, m = map(int, input().split())\nsofas = []\nfor i in range(d):\n    x1, y1, x2, y2 = map(int, input().split())\n    sofas.append((x1, y1, x2, y2, i+1))\ncnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n\ndef check(idx):\n    sl, sr, st, sb = 0, 0, 0, 0\n    x1, y1, x2, y2, _ = sofas[idx]\n    for i in range(d):\n        if i == idx:\n            continue\n        xx1, yy1, xx2, yy2, _ = sofas[i]\n        if xx1 < x1 and y1 <= yy1 <= y2:\n            sl += 1\n        if xx2 > x2 and y1 <= yy1 <= y2:\n            sr += 1\n        if yy1 < y1 and x1 <= xx1 <= x2:\n            st += 1\n        if yy2 > y2 and x1 <= xx1 <= x2:\n            sb += 1\n    return sl == cnt_l and sr == cnt_r and st == cnt_t and sb == cnt_b\n\nfor i in range(d):\n    if check(i):\n        print(sofas[i][4])\n        break\nelse:\n    print(-1)\n```"
}